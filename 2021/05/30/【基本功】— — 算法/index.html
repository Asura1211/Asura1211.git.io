<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【基本功】— — 算法 | 青山の博客</title><meta name="keywords" content="算法"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="排序具体见十大经典排序算法（动图演示）   稳定性？稳定性定义： 排序前后两个相等的数相对位置不变，则算法稳定。 常见的稳定排序算法有：  冒泡排序（Bubble Sort） — O(n²) 插入排序（Insertion Sort）— O(n²) 归并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间 计数排序 (Counting Sort) — O(n+k); 需要">
<meta property="og:type" content="article">
<meta property="og:title" content="【基本功】— — 算法">
<meta property="og:url" content="https://asura1211.github.io/2021/05/30/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="排序具体见十大经典排序算法（动图演示）   稳定性？稳定性定义： 排序前后两个相等的数相对位置不变，则算法稳定。 常见的稳定排序算法有：  冒泡排序（Bubble Sort） — O(n²) 插入排序（Insertion Sort）— O(n²) 归并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间 计数排序 (Counting Sort) — O(n+k); 需要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/07/xyGvCbmdgHPf1E8.jpg">
<meta property="article:published_time" content="2021-05-30T08:58:31.000Z">
<meta property="article:modified_time" content="2021-12-01T05:50:06.733Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/07/xyGvCbmdgHPf1E8.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/05/30/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E7%AE%97%E6%B3%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【基本功】— — 算法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-01 13:50:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/07/xyGvCbmdgHPf1E8.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【基本功】— — 算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-30T08:58:31.000Z" title="发表于 2021-05-30 16:58:31">2021-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-01T05:50:06.733Z" title="更新于 2021-12-01 13:50:06">2021-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【基本功】— — 算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://i.loli.net/2021/10/14/twAFeGEk9KUnRih.png" alt="算法脑图副本.png"></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>具体见<a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/p/7674659.html">十大经典排序算法（动图演示）</a></p>
<p><img src="https://i.loli.net/2021/09/06/sucGyXieoSvHBrI.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2021/09/06/wZMKBa1Jol7CDbr.png" alt="image.png"></p>
<h2 id="稳定性？"><a href="#稳定性？" class="headerlink" title="稳定性？"></a>稳定性？</h2><p><strong>稳定性定义：</strong></p>
<p>排序前后两个相等的数相对位置不变，则算法稳定。</p>
<p>常见的<strong>稳定排序算法</strong>有：</p>
<ul>
<li>冒泡排序（Bubble Sort） — O(n²)</li>
<li>插入排序（Insertion Sort）— O(n²)</li>
<li>归并排序（Merge Sort）— O(nlogn); 需要 O(n) 额外空间</li>
<li>计数排序 (Counting Sort) — O(n+k); 需要 O(n+k) 额外空间</li>
<li>桶排序（Bucket Sort）— O(n+k); 需要 O(k) 额外空间</li>
<li>基数排序（Radix sort）— O(n*k); 需要 O(n) 额外空间</li>
</ul>
<p>常见的<strong>不稳定排序算法</strong>有：</p>
<ul>
<li>选择排序（Selection Sort）— O(n²)</li>
<li>希尔排序（Shell Sort）— O(nlogn)</li>
<li>堆排序（Heapsort）— O(nlogn)</li>
<li>快速排序（Quicksort）— O(nlogn) </li>
</ul>
<h2 id="初级排序-——-O-n-2"><a href="#初级排序-——-O-n-2" class="headerlink" title="初级排序 —— O(n^2)"></a>初级排序 —— O(n^2)</h2><ol>
<li><p>选择排序：每次排序取一个最大或最小的数字放到前面的有序序列中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;    </span><br><span class="line">        minIndex = j;                </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>插入排序：将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> target = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[target] &lt; array[j]) &#123;</span><br><span class="line">                [array[target], array[j]] = [array[j], array[target]];</span><br><span class="line">                target = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="built_in">Array</span>.prototype.insertionSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = <span class="built_in">this</span>.length;</span><br><span class="line">    <span class="keyword">let</span> target;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        target = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>[target] &lt; <span class="built_in">this</span>[j]) &#123;</span><br><span class="line">                [<span class="built_in">this</span>[target], <span class="built_in">this</span>[j]] = [<span class="built_in">this</span>[j], <span class="built_in">this</span>[target]];</span><br><span class="line">                target = j;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>冒泡排序：循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;      </span><br><span class="line">        [arr[j], arr[j + <span class="number">1</span>]] = [arr[j + <span class="number">1</span>], arr[j]];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="高级排序-——-O-N-LogN"><a href="#高级排序-——-O-N-LogN" class="headerlink" title="高级排序 —— O(N*LogN)"></a>高级排序 —— O(N*LogN)</h2><ol>
<li><p>快速排序：选择一个目标值，比目标值小的放左边，比目标值大的放右边；目标值的位置已排好，将左右两侧再进行快排。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = arr[arr.length &gt;&gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; mid) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; mid) &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat(mid, quickSort(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>归并排序：将大序列二分成小序列，将小序列（归并）排序后，再将排序后的小序列归并成大序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> mid = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">const</span> front = array.slice(<span class="number">0</span>, mid);</span><br><span class="line">    <span class="keyword">const</span> end = array.slice(mid);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(front), mergeSort(end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">front, end</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> temp = [];</span><br><span class="line">    <span class="keyword">while</span> (front.length &amp;&amp; end.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (front[<span class="number">0</span>] &lt; end[<span class="number">0</span>]) &#123;</span><br><span class="line">            temp.push(front.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp.push(end.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (front.length) &#123;</span><br><span class="line">        temp.push(front.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (end.length) &#123;</span><br><span class="line">        temp.push(end.shift());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.mergeSort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">front, end</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = [];</span><br><span class="line">        <span class="keyword">while</span> (front.length &amp;&amp; end.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (front[<span class="number">0</span>] &lt;= end[<span class="number">0</span>]) &#123;</span><br><span class="line">                result.push(front.shift());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.push(end.shift());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (front.length) result.push(front.shift());</span><br><span class="line">        <span class="keyword">while</span> (end.length) result.push(end.shift());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> len = arr.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">let</span> front = arr.slice(<span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">let</span> end = arr.slice(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(<span class="built_in">arguments</span>.callee(front), <span class="built_in">arguments</span>.callee(end));</span><br><span class="line">    &#125;)(<span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>归并和快排具有相似性，但步骤顺序相反：</strong></p>
<p>归并：先排序左右子数组，然后合并两个有序子数组</p>
<p>快排：先调配出左右子数组，然后对于左右子数组进行排序</p>
</li>
<li><p>堆排序：创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    creatHeap(array);</span><br><span class="line">    <span class="comment">// 交换第一个和最后一个元素，然后重新调整大顶堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        [array[i], array[<span class="number">0</span>]] = [array[<span class="number">0</span>], array[i]];</span><br><span class="line">        adjust(array, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建大顶堆，从第一个非叶子节点开始，进行下沉操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">creatHeap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = array.length;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">parseInt</span>(len / <span class="number">2</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        adjust(array, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将第target个元素进行下沉，孩子节点有比他大的就下沉</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjust</span>(<span class="params">array, target, len</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span> * target + <span class="number">1</span>; i &lt; len; i = <span class="number">2</span> * i + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到孩子节点中最大的</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; len &amp;&amp; array[i + <span class="number">1</span>] &gt; array[i]) &#123;</span><br><span class="line">            i = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下沉</span></span><br><span class="line">        <span class="keyword">if</span> (array[i] &gt; array[target]) &#123;</span><br><span class="line">            [array[i], array[target]] = [array[target], array[i]];</span><br><span class="line">            target = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="特殊排序-——-O-n"><a href="#特殊排序-——-O-n" class="headerlink" title="特殊排序 —— O(n)"></a>特殊排序 —— O(n)</h2><ol>
<li>计数排序(Counting Sort)：计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存<br>储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。</li>
<li>桶排序(Bucket Sort)：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排)。</li>
<li>基数排序(Radix Sort)：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。</li>
</ol>
<h2 id="LeetCode1122——数组的相对排序（☆）"><a href="#LeetCode1122——数组的相对排序（☆）" class="headerlink" title="LeetCode1122——数组的相对排序（☆）"></a>LeetCode1122——数组的相对排序（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/relative-sort-array/">跳转地址</a></p>
<h3 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>感觉这道题难度不止 easy ，一开始是想先对 arr1 排序，然后遍历 arr2 ，如果 arr1 没有就 shift 再 push。但是很麻烦。</p>
<h3 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> relativeSortArray = <span class="function"><span class="keyword">function</span> (<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//sort(a,b) 正常a,b中谁小排到前面</span></span><br><span class="line">  <span class="keyword">return</span> arr1.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a1 = arr2.indexOf(a);</span><br><span class="line">    <span class="keyword">let</span> b1 = arr2.indexOf(b);</span><br><span class="line">    <span class="keyword">if</span>(a1 == -<span class="number">1</span> &amp;&amp; b1 == -<span class="number">1</span>)&#123;<span class="comment">//如果a和b都不在arr2中，正常的大小升序</span></span><br><span class="line">      <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a1 == -<span class="number">1</span>)&#123; <span class="comment">//如果a不在arr2中，a-b=1说明a&gt;b，a就得排在后面</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(b1 == -<span class="number">1</span>)&#123; <span class="comment">//如果b不在arr2中，a-b=-1说明b&gt;a，b就得排在后面</span></span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果都在arr2中，就看他们谁先出现在arr2中，如果a在前面，那么a1就小于b1,return 就是小于0的，所以a在前面</span></span><br><span class="line">      <span class="keyword">return</span> a1-b1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode242——有效的字母异位词（☆）"><a href="#LeetCode242——有效的字母异位词（☆）" class="headerlink" title="LeetCode242——有效的字母异位词（☆）"></a>LeetCode242——有效的字母异位词（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">跳转地址</a></p>
<h3 id="自己的代码-1"><a href="#自己的代码-1" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 可以这样写 map[s[i]] = (map[s[i]] || 0) + 1;</span></span><br><span class="line">        map[s[i]] ? map[s[i]]++ : map[s[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[t[i]]) map[t[i]]--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，其实这就是计数排序了。</p>
<h2 id="LeetCode493——翻转对（☆☆☆）"><a href="#LeetCode493——翻转对（☆☆☆）" class="headerlink" title="LeetCode493——翻转对（☆☆☆）"></a>LeetCode493——翻转对（☆☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-pairs/">跳转地址</a></p>
<h3 id="自己的代码-2"><a href="#自己的代码-2" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">2</span> * nums[j]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>毫无疑问超时了。</p>
<h3 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p><strong>合并排序：</strong>但是用到 shift，导致数组很大时过不了测试，<a target="_blank" rel="noopener" href="http://stlighter.github.io/2016/06/08/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E4%B8%8A%E7%9A%84%E7%96%91%E6%83%91/">具体原因</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numReversePairs = <span class="number">0</span>; </span><br><span class="line">    mergeSort(nums);</span><br><span class="line">    <span class="keyword">return</span> numReversePairs;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">            left = nums.slice(<span class="number">0</span>, middle),</span><br><span class="line">            right = nums.slice(middle);</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> rightIndex = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span>(leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (left[leftIndex] &gt; <span class="number">2</span> * right[rightIndex]) &#123;</span><br><span class="line">          <span class="comment">// 因为 left 此时已经升序，所以(left.length - leftIndex)里的所有数都比 right[rightIndex] 大。</span></span><br><span class="line">          numReversePairs += (left.length - leftIndex);</span><br><span class="line">          rightIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;    </span><br><span class="line">      <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">          result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此在合并时，可以用下面代码代替：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">leftIndex = <span class="number">0</span>;</span><br><span class="line">   rightIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">     <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">       nums_sorted.push(left[leftIndex++]);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       nums_sorted.push(right[rightIndex++]);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="分治-amp-回溯"><a href="#分治-amp-回溯" class="headerlink" title="分治&amp;回溯"></a>分治&amp;回溯</h1><p>分治模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide_conquer</span>(<span class="params">problem, param1, param2, ...</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// recursion terminator</span></span><br><span class="line">    <span class="keyword">if</span> (problem is None) &#123;</span><br><span class="line">        print_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prepare data (拆分子问题)</span></span><br><span class="line">    data = prepare_data(problem);</span><br><span class="line">    subproblems = split_problem(problem, data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// conquer subproblems (drill down)</span></span><br><span class="line">    subresult1 = divide_conquer(subproblems[<span class="number">0</span>], p1, ...);</span><br><span class="line">    subresult2 = divide_conquer(subproblems[<span class="number">1</span>], p2, ...);</span><br><span class="line">    subresult3 = divide_conquer(subproblems[<span class="number">2</span>], p3, ...);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process and generate the final result </span></span><br><span class="line">    result = process_result(subresult1, subresult2, subresult3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// revert the current level states(回复当前层状态)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回溯模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backtrack</span> (<span class="params">path, list</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (满足条件) &#123;</span><br><span class="line">        result.push(path);</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> () &#123;</span><br><span class="line">        <span class="comment">// 做选择(前序遍历)</span></span><br><span class="line">        backtrack (path, list)</span><br><span class="line">        <span class="comment">// 撤销选择(后续遍历)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode50——Pow-x-n-（☆☆）"><a href="#LeetCode50——Pow-x-n-（☆☆）" class="headerlink" title="LeetCode50——Pow(x, n)（☆☆）"></a>LeetCode50——Pow(x, n)（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/powx-n/">跳转地址</a></p>
<h3 id="自己的代码-3"><a href="#自己的代码-3" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span> (<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">1</span>;</span><br><span class="line">    x = n &gt; <span class="number">0</span> ? x : <span class="number">1</span> / x;</span><br><span class="line">    n = n &gt; <span class="number">0</span> ? n : -n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res *= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没过。时间复杂度O(N)，但是已经超过运行时间了。</p>
<h3 id="思路-amp-题解-2"><a href="#思路-amp-题解-2" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>分治：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myPow = <span class="function"><span class="keyword">function</span> (<span class="params">x, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> pow = <span class="built_in">Math</span>.abs(n);</span><br><span class="line">    <span class="comment">// 使用分治：n是奇数，x的n次方等于 x*x的n-1次方(转化为偶数)；n是偶数 等于（x*x）的n/2次方</span></span><br><span class="line">    <span class="keyword">let</span> result = pow % <span class="number">2</span> === <span class="number">0</span> ? myPow(x * x, pow / <span class="number">2</span>) : x * myPow(x * x, (pow - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">0</span> ? <span class="number">1</span> / result : result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode78——子集（☆☆）"><a href="#LeetCode78——子集（☆☆）" class="headerlink" title="LeetCode78——子集（☆☆）"></a>LeetCode78——子集（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subsets/">跳转地址</a></p>
<h3 id="自己的代码-4"><a href="#自己的代码-4" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [[]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> subset <span class="keyword">in</span> res) &#123;</span><br><span class="line">            arr.push(subset + [num]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没过。感觉还是少用 for in 吧</p>
<h3 id="思路1-amp-题解"><a href="#思路1-amp-题解" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>迭代：依次把每个元素插入到之前的集合中生成新的结果集合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [[]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> arr = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; res.length; j++) &#123;</span><br><span class="line">            arr.push([...res[j], nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 更优写法 forEach</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res = [[]]</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">		res.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">			res.push([...item, nums[i]])</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>空间复杂度: O(n*2^n)</li>
</ul>
<h3 id="思路2-amp-题解（good）"><a href="#思路2-amp-题解（good）" class="headerlink" title="思路2&amp;题解（good）"></a>思路2&amp;题解（good）</h3><p>分治：（+回溯）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res = []</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">index, curr</span>) </span>&#123;</span><br><span class="line">		res.push(curr)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt; nums.length; i++) &#123;</span><br><span class="line">			backtrack(i + <span class="number">1</span>, [...curr, nums[i]])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(<span class="number">0</span>, [])</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深度先遍历第一个数，再往后推。</p>
<h2 id="LeetCode77——组合（☆☆）"><a href="#LeetCode77——组合（☆☆）" class="headerlink" title="LeetCode77——组合（☆☆）"></a>LeetCode77——组合（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">跳转地址</a></p>
<h3 id="自己的代码-5"><a href="#自己的代码-5" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> combine = <span class="function"><span class="keyword">function</span>(<span class="params">n, k</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> res = []</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">backtrack</span>(<span class="params">index, curr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (curr.length === k) &#123;</span><br><span class="line">            res.push(curr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= n; i++) &#123;</span><br><span class="line">			backtrack(i + <span class="number">1</span>, [...curr, i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	backtrack(<span class="number">1</span>, [])</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AC，对照78思路，勉强能做，但是重新开始就不一定。</p>
<h2 id="LeetCode17——电话号码的字母组合（☆☆）"><a href="#LeetCode17——电话号码的字母组合（☆☆）" class="headerlink" title="LeetCode17——电话号码的字母组合（☆☆）"></a>LeetCode17——电话号码的字母组合（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">跳转地址</a></p>
<h3 id="自己的代码-6"><a href="#自己的代码-6" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> letterCombinations = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits === <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接 const map = &#123;2: &#x27;abc&#x27;, 3: &#x27;def&#x27;...&#125;</span></span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), res = [];</span><br><span class="line">	map.set(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	map.set(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">	map.set(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">	map.set(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">	map.set(<span class="string">&quot;6&quot;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">	map.set(<span class="string">&quot;7&quot;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">	map.set(<span class="string">&quot;8&quot;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">	map.set(<span class="string">&quot;9&quot;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">	<span class="comment">// s为每一次回溯的字符串，level为个数</span></span><br><span class="line">	<span class="keyword">const</span> search = <span class="function"><span class="keyword">function</span> (<span class="params">s, level</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 1.终止条件 terminator</span></span><br><span class="line">		<span class="keyword">if</span> (level === digits.length) &#123;</span><br><span class="line">			res.push(s);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 2.单层递归逻辑 process</span></span><br><span class="line">		<span class="keyword">let</span> letter = map.get(digits[level]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; letter.length; i++)&#123;</span><br><span class="line">			<span class="comment">// drill down</span></span><br><span class="line">			search(s + letter[i], level + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	search(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC</p>
<h2 id="LeetCode46——全排列（☆☆）"><a href="#LeetCode46——全排列（☆☆）" class="headerlink" title="LeetCode46——全排列（☆☆）"></a>LeetCode46——全排列（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/">跳转地址</a></p>
<h3 id="自己的代码-7"><a href="#自己的代码-7" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">back</span>(<span class="params">index, arr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">            res.push(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意此时back应该为index+1，若为i+1，则不是全排列</span></span><br><span class="line">            <span class="keyword">if</span> (arr.indexOf(nums[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">                back(index + <span class="number">1</span>, [...arr, nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    back(<span class="number">0</span>, []);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC。但这样的方法解不了47</p>
<h2 id="LeetCode47——全排列Ⅱ（☆☆）"><a href="#LeetCode47——全排列Ⅱ（☆☆）" class="headerlink" title="LeetCode47——全排列Ⅱ（☆☆）"></a>LeetCode47——全排列Ⅱ（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">跳转地址</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> permuteUnique = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [], remain = [], set = <span class="keyword">new</span> <span class="built_in">Set</span>(nums);</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">num</span> =&gt;</span> remain[num] ? remain[num]++ : remain[num] = <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">depth, cur</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == nums.length) &#123;</span><br><span class="line">            res.push(cur.slice());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remain[num]) &#123;</span><br><span class="line">                cur.push(num);</span><br><span class="line">                remain[num]--;</span><br><span class="line">                <span class="comment">// move to the next depth</span></span><br><span class="line">                dfs(depth + <span class="number">1</span>, cur);</span><br><span class="line">                <span class="comment">// backtrack to previous state</span></span><br><span class="line">                cur.pop();</span><br><span class="line">                remain[num]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dfs(<span class="number">0</span>, []);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指Offer51——数组中的逆序对（☆☆☆）"><a href="#剑指Offer51——数组中的逆序对（☆☆☆）" class="headerlink" title="剑指Offer51——数组中的逆序对（☆☆☆）"></a>剑指Offer51——数组中的逆序对（☆☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">跳转地址</a></p>
<p>好难啊。</p>
<h1 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h1><h2 id="LeetCode51——N皇后（☆☆☆）todo！"><a href="#LeetCode51——N皇后（☆☆☆）todo！" class="headerlink" title="LeetCode51——N皇后（☆☆☆）todo！"></a>LeetCode51——N皇后（☆☆☆）todo！</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">跳转地址</a></p>
<p>看视频！还有位运算的解法。</p>
<h2 id="LeetCode37——解数独（☆☆☆）todo！"><a href="#LeetCode37——解数独（☆☆☆）todo！" class="headerlink" title="LeetCode37——解数独（☆☆☆）todo！"></a>LeetCode37——解数独（☆☆☆）todo！</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sudoku-solver/#/description">跳转地址</a></p>
<p>14课2</p>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>二分查找的前提：</strong></p>
<ul>
<li>目标函数单调性( 单调递增或者递减)</li>
<li>存在上下界</li>
<li>能够通过索引访问</li>
</ul>
<h2 id="LeetCode69——x-的平方根（☆）"><a href="#LeetCode69——x-的平方根（☆）" class="headerlink" title="LeetCode69——x 的平方根（☆）"></a>LeetCode69——x 的平方根（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sqrtx/">跳转地址</a></p>
<h3 id="自己的代码-8"><a href="#自己的代码-8" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">0</span> || x === <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; x; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i * i &gt;= x) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i * i &gt; x)&#123;</span><br><span class="line">                <span class="keyword">return</span> i-<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，但没有想到二分，这是O（n）的复杂度。</p>
<h3 id="思路1-amp-题解-1"><a href="#思路1-amp-题解-1" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>二分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="number">0</span> || x === <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">1</span>, right = x;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="built_in">parseInt</span>((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt; x) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解"><a href="#思路2-amp-题解" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>牛顿迭代法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySqrt = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    r = x;</span><br><span class="line">    <span class="keyword">while</span> (r * r &gt; x) &#123;</span><br><span class="line">        r = ((r + x / r) / <span class="number">2</span>) | <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode33——搜索旋转排序数组（☆☆）"><a href="#LeetCode33——搜索旋转排序数组（☆☆）" class="headerlink" title="LeetCode33——搜索旋转排序数组（☆☆）"></a>LeetCode33——搜索旋转排序数组（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">跳转地址</a></p>
<h3 id="自己的代码-9"><a href="#自己的代码-9" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 左边升序</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid] &amp;&amp; (target &gt; nums[mid] || target &lt; nums[<span class="number">0</span>])) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[mid] &amp;&amp; (target &gt; nums[mid] &amp;&amp; target &lt; nums[<span class="number">0</span>])) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] === target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，但是调试了很久才写出来。二分的思路有变化，需要多考虑一些情况。<strong>同时需注意</strong>可以先判断 nums 数组有零个或者一个元素的情况。</p>
<h2 id="LeetCode74——搜索二维矩阵（☆☆）"><a href="#LeetCode74——搜索二维矩阵（☆☆）" class="headerlink" title="LeetCode74——搜索二维矩阵（☆☆）"></a>LeetCode74——搜索二维矩阵（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-a-2d-matrix/">跳转地址</a></p>
<h3 id="自己的代码-10"><a href="#自己的代码-10" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> searchMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> a <span class="keyword">of</span> matrix) &#123;</span><br><span class="line">        arr.push(...a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = arr.length;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[right] === target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，很简单的想法，变成升序的数组后二分查找。复杂度O（n）。</p>
<h3 id="思路-amp-题解-3"><a href="#思路-amp-题解-3" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">searchMatrix</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!matrix.length || !matrix[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> col = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (col &gt;= <span class="number">0</span> &amp;&amp; row &lt;= matrix.length - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[row][col] === target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &gt; target) col--;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (matrix[row][col] &lt; target) row++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>好像这样更精简些。</p>
<h2 id="LeetCode153——寻找旋转排序数组中的最小值（☆☆）"><a href="#LeetCode153——寻找旋转排序数组中的最小值（☆☆）" class="headerlink" title="LeetCode153——寻找旋转排序数组中的最小值（☆☆）"></a>LeetCode153——寻找旋转排序数组中的最小值（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">跳转地址</a></p>
<h3 id="自己的代码-11"><a href="#自己的代码-11" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[nums.length - <span class="number">1</span>] &lt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">      nums.unshift(nums[nums.length - <span class="number">1</span>]);</span><br><span class="line">      nums.pop(nums[nums.length - <span class="number">1</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看了题解后发现这就是传说中的“暴破”法，时间复杂度为O（n）</p>
<h3 id="思路-amp-题解-4"><a href="#思路-amp-题解-4" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>二分法：首先，创建两个指针 left, right 分别指向 numbers 首尾数字，然后计算出两指针之间的中间索引值 middle，然后我们会遇到以下三种情况：</p>
<ol>
<li>middle &gt; right ：代表最小值一定在 middle 右侧，所以 left 移到 middle+1 的位置。</li>
<li>middle&lt; right：代表最小值一定在 middle 左侧或者就是 middle，所以 right 移到 middle 的位置。</li>
<li>middle 既不大于 left 指针的值，也不小于 right 指针的值，代表着 middle 可能等于 left 指针的值，或者 right 指针的值，我们这时候只能让 right 指针递减，来一个一个找最小值了。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">Math</span>.floor((left + right) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[right]) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴破【不推荐】</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：时间复杂度为 O(logn)，其中 n 是数组 nums 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 O(logn)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
<h1 id="BFS、DFS"><a href="#BFS、DFS" class="headerlink" title="BFS、DFS"></a>BFS、DFS</h1><h2 id="DFS代码——递归写法模板"><a href="#DFS代码——递归写法模板" class="headerlink" title="DFS代码——递归写法模板"></a>DFS代码——递归写法模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">visited = <span class="built_in">set</span>();</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">node, visited</span>):</span></span><br><span class="line">  <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">    <span class="comment"># terminator already visited</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">  visited.add(node);</span><br><span class="line">  <span class="comment"># process current node here</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> next_node <span class="keyword">in</span> node.children():</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> next_node <span class="keyword">in</span> visited:</span><br><span class="line">      dfs(next_node,visited)</span><br></pre></td></tr></table></figure>

<h2 id="DFS代码——非递归写法模板"><a href="#DFS代码——非递归写法模板" class="headerlink" title="DFS代码——非递归写法模板"></a>DFS代码——非递归写法模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, tree</span>):</span></span><br><span class="line">  <span class="keyword">if</span> tree.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line">  visited, stack = [], [tree.root]  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> stack:</span><br><span class="line">    node = stack.pop()</span><br><span class="line">    visited.add(node)</span><br><span class="line">    </span><br><span class="line">    process(node)</span><br><span class="line">    nodes=generate_related_nodes(node)</span><br><span class="line">    stack.push(nodes)</span><br></pre></td></tr></table></figure>

<h2 id="BFS代码——模板"><a href="#BFS代码——模板" class="headerlink" title="BFS代码——模板"></a>BFS代码——模板</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">graph, start,end</span>):</span></span><br><span class="line">  queue = []</span><br><span class="line">  queue.append([start])</span><br><span class="line">  visited.add(start)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> queue:</span><br><span class="line">    node = queue.pop()</span><br><span class="line">    visited.add(node)</span><br><span class="line">    </span><br><span class="line">    process(node)</span><br><span class="line">    nodes=generate_related_nodes(node)</span><br><span class="line">    queue.push(nodes)</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode200——岛屿数量（☆☆）"><a href="#LeetCode200——岛屿数量（☆☆）" class="headerlink" title="LeetCode200——岛屿数量（☆☆）"></a>LeetCode200——岛屿数量（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">跳转地址</a></p>
<h3 id="思路-amp-题解-5"><a href="#思路-amp-题解-5" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>沉岛思想：遇到岛屿时，岛屿数量+1； 且将相邻所有陆地变为0，直至遍历完整个网格。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numIslands = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> islands = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> dfs = <span class="function"><span class="keyword">function</span> (<span class="params">i, j</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] === <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        dfs(i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(i, j + <span class="number">1</span>);</span><br><span class="line">        dfs(i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(i, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; grid[i].length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] === <span class="string">&#x27;0&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(i, j);</span><br><span class="line">            islands++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> islands;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Two-ended-BFS"><a href="#Two-ended-BFS" class="headerlink" title="Two-ended BFS"></a>Two-ended BFS</h1><h2 id="LeetCode127——单词接龙（☆☆☆）"><a href="#LeetCode127——单词接龙（☆☆☆）" class="headerlink" title="LeetCode127——单词接龙（☆☆☆）"></a>LeetCode127——单词接龙（☆☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/word-ladder/">跳转地址</a></p>
<p>（其实挺好想的，为什么最开始写的时候想不出呢）</p>
<h3 id="思路1-amp-题解-2"><a href="#思路1-amp-题解-2" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>BFS代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ladderLength = <span class="function"><span class="keyword">function</span>(<span class="params">beginWord, endWord, wordList</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 换成哈希表，更快捷的查找单词是否存在。List——O(n);HashSet——O(1)</span></span><br><span class="line">  <span class="keyword">let</span> wordSet = <span class="keyword">new</span> <span class="built_in">Set</span>(wordList);</span><br><span class="line">  <span class="keyword">let</span> queue = [];</span><br><span class="line">  queue.push([beginWord, <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> [word, level] = queue.shift();</span><br><span class="line">    <span class="keyword">if</span> (word === endWord) &#123;</span><br><span class="line">      <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">97</span>; c &lt;= <span class="number">122</span>; c++)&#123;</span><br><span class="line">        <span class="keyword">let</span> newWord = word.slice(<span class="number">0</span>, i) + <span class="built_in">String</span>.fromCharCode(c) + word.slice(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.has(newWord)) &#123;</span><br><span class="line">          queue.push([newWord, level + <span class="number">1</span>]);</span><br><span class="line">          <span class="comment">// 避免该词重复入列</span></span><br><span class="line">          wordSet.delete(newWord);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-1"><a href="#思路2-amp-题解-1" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>双端BFS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ladderLength = <span class="function"><span class="keyword">function</span>(<span class="params">beginWord, endWord, wordList</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> wordListSet = <span class="keyword">new</span> <span class="built_in">Set</span>(wordList);</span><br><span class="line">  <span class="keyword">if</span>(!wordListSet.has(endWord))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> beginSet = <span class="keyword">new</span> <span class="built_in">Set</span>(), endSet = <span class="keyword">new</span> <span class="built_in">Set</span>(), level=<span class="number">1</span>;</span><br><span class="line">  beginSet.add(beginWord);</span><br><span class="line">  endSet.add(endWord);</span><br><span class="line">  <span class="comment">// BFS starts here</span></span><br><span class="line">  <span class="keyword">while</span> (beginSet.size) &#123;</span><br><span class="line">    <span class="comment">// new_beginSet 存放扩散出来的点</span></span><br><span class="line">    <span class="keyword">let</span> new_beginSet = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> word <span class="keyword">of</span> beginSet) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; word.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> c = <span class="number">97</span>; c &lt;= <span class="number">122</span>; c++)&#123;</span><br><span class="line">          <span class="keyword">let</span> newWord = word.slice(<span class="number">0</span>, i) + <span class="built_in">String</span>.fromCharCode(c) + word.slice(i + <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">if</span> (endSet.has(newWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> level + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (wordListSet.has(newWord)) &#123;</span><br><span class="line">            new_beginSet.add(newWord);</span><br><span class="line">            wordListSet.delete(newWord);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    beginSet = new_beginSet;</span><br><span class="line">    level++;</span><br><span class="line">    <span class="comment">// 保证 beginSet 是最小的，对最小的进行扩散</span></span><br><span class="line">    <span class="keyword">if</span> (beginSet.size &gt; endSet.size) &#123;</span><br><span class="line">      [beginSet, endSet] = [endSet, beginSet];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recur</span>(<span class="params">level, param</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// terminator</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; MAX_LEVEL) &#123;</span><br><span class="line">        <span class="comment">// process result</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process current logic</span></span><br><span class="line">    process(level, param);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// drill down</span></span><br><span class="line">    recur(level + <span class="number">1</span>, newParam);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore current status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>“Simplifying a complicated problem by breaking it down into simpler sub-problems”</p>
<p><strong>分治 + 最优子结构</strong></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>动态规划和递归或者分治没有根本上的区别（关键看有无最优的子结构）</p>
<ul>
<li>共性：找到<strong>重复子问题</strong></li>
<li>差异性：最优子结构、中途可以<strong>淘汰次优解</strong></li>
</ul>
<h2 id="LeetCode509——斐波那契数（☆）"><a href="#LeetCode509——斐波那契数（☆）" class="headerlink" title="LeetCode509——斐波那契数（☆）"></a>LeetCode509——斐波那契数（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/fibonacci-number/">跳转地址</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? n : fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是这是傻递归，时间复杂度O（2^n）。</p>
<h3 id="思路1-amp-题解-3"><a href="#思路1-amp-题解-3" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>Memorization 记忆化搜索，即将过程结果存在数组中。（自顶向上）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span> (<span class="params">n, memo = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!memo[n]) &#123;</span><br><span class="line">        memo[n] = fib(n - <span class="number">1</span>, memo) + fib(n - <span class="number">2</span>, memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-2"><a href="#思路2-amp-题解-2" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>自底向上递推：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = [];</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>, a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + a[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode62——不同路径（☆）"><a href="#LeetCode62——不同路径（☆）" class="headerlink" title="LeetCode62——不同路径（☆）"></a>LeetCode62——不同路径（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths/">跳转地址</a></p>
<h3 id="自己的代码-12"><a href="#自己的代码-12" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span>(<span class="params">m, n, arr=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m === <span class="number">1</span> || n === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!arr[m][n]) &#123;</span><br><span class="line">        arr[m][n] = uniquePaths(m - <span class="number">1</span>, n, arr) + uniquePaths(m, n - <span class="number">1</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC。二维数组应该不能这样写。</p>
<h3 id="思路1-amp-题解-4"><a href="#思路1-amp-题解-4" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> memo = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; memo.length; i++)&#123;</span><br><span class="line">        memo[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> helper(m, n, <span class="number">1</span>, <span class="number">1</span>, memo);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> helper = <span class="function"><span class="keyword">function</span> (<span class="params">m, n, row, col, memo</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (row === m &amp;&amp; col === n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (row &gt; m || col &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (memo[row][col] === -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> rightPath = helper(m, n, row, col + <span class="number">1</span>, memo);</span><br><span class="line">        <span class="keyword">let</span> downPath = helper(m, n, row + <span class="number">1</span>, col, memo);</span><br><span class="line">        memo[row][col] = rightPath + downPath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[row][col];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-3"><a href="#思路2-amp-题解-3" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>动态规划：自底向上递推，左上方路径数＝右+下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uniquePaths = <span class="function">(<span class="params">m, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++) &#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[m][n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> row = m - <span class="number">1</span>; row &gt; <span class="number">0</span>; row--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> col = n - <span class="number">1</span>; col &gt; <span class="number">0</span>; col--)&#123;</span><br><span class="line">            dp[row][col] = dp[row + <span class="number">1</span>][col] + dp[row][col + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>方法二：从左上到右下：(这样方便多了、、)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uniquePaths = <span class="function">(<span class="params">m, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dp 数组初始化</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路3-amp-题解"><a href="#思路3-amp-题解" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uniquePaths = <span class="function">(<span class="params">m, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// dp 数组初始化</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只用一位数组存储结果，更加节省空间。</p>
<h2 id="LeetCode63——不同路径II（☆）"><a href="#LeetCode63——不同路径II（☆）" class="headerlink" title="LeetCode63——不同路径II（☆）"></a>LeetCode63——不同路径II（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths-ii/">跳转地址</a></p>
<h3 id="自己的代码-13"><a href="#自己的代码-13" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span>(<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid[m - <span class="number">1</span>][n - <span class="number">1</span>] === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][n - <span class="number">1</span>] === <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[m - <span class="number">1</span>][i] === <span class="number">0</span>) &#123;</span><br><span class="line">            dp[m - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> row = m-<span class="number">2</span>; row &gt;= <span class="number">0</span>; row--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> col = n-<span class="number">2</span>; col &gt;= <span class="number">0</span>; col--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[row][col] === <span class="number">1</span>) &#123;</span><br><span class="line">                dp[row][col] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[row][col] = dp[row + <span class="number">1</span>][col] + dp[row][col + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC，头疼，调试了一个多小时也没弄出来。思路是从右下往左上递归。</p>
<h3 id="思路1-amp-题解-5"><a href="#思路1-amp-题解-5" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>这是从左上开始往右下递归：（这样就不用考虑 dp 数组与 obstacleGrid 数组的大小关系，比从右下开始递归方便多了）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span>(<span class="params">obstacleGrid</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// dp 数组初始化为0</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化两条边，遇到障碍物则为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m &amp;&amp; obstacleGrid[i][<span class="number">0</span>] === <span class="number">0</span>; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n &amp;&amp; obstacleGrid[<span class="number">0</span>][j] === <span class="number">0</span>; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从左往右、从上到下遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 遇到障碍，不执行当前操作，直接进入下一循环</span></span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-4"><a href="#思路2-amp-题解-4" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>一维数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePathsWithObstacles = <span class="function"><span class="keyword">function</span>(<span class="params">obstacleGrid</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = obstacleGrid.length, n = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// dp 数组初始化</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] === <span class="number">1</span>) &#123;</span><br><span class="line">                dp[j] = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// j &gt; 0 很关键</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode300——最长递增子序列（☆☆）"><a href="#LeetCode300——最长递增子序列（☆☆）" class="headerlink" title="LeetCode300——最长递增子序列（☆☆）"></a>LeetCode300——最长递增子序列（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">跳转地址</a></p>
<h3 id="自己的代码-14"><a href="#自己的代码-14" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> len = nums.length;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode1143——最长公共子序列（☆☆）"><a href="#LeetCode1143——最长公共子序列（☆☆）" class="headerlink" title="LeetCode1143——最长公共子序列（☆☆）"></a>LeetCode1143——最长公共子序列（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">跳转地址</a></p>
<h3 id="思路-amp-题解-6"><a href="#思路-amp-题解-6" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="function"><span class="keyword">function</span>(<span class="params">text1, text2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!text1 || !text2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> m = text1.length, n = text2.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; dp.length; i++)&#123;</span><br><span class="line">        dp[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/26/k85qZCWGbFUlzAf.png" alt="image.png"></p>
<p>要学会把这道题目变成二维数组的 dp 问题。</p>
<h2 id="LeetCode1143——三角形最小路径和（☆☆）"><a href="#LeetCode1143——三角形最小路径和（☆☆）" class="headerlink" title="LeetCode1143——三角形最小路径和（☆☆）"></a>LeetCode1143——三角形最小路径和（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/triangle/">跳转地址</a></p>
<h3 id="思路1-amp-题解-6"><a href="#思路1-amp-题解-6" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>DP:</p>
<ul>
<li>重复性（分治） <code>problem(i, j) = min(sub(i+1, j), sub(i+1, j+1)) + a[i, j]</code></li>
<li>定义状态方程 <code>f[i, j]</code></li>
<li>DP方程 <code>f[i, j] = min(f[i+1, j], f[i+1, j+1]) + a[i, j]</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumTotal = <span class="function"><span class="keyword">function</span>(<span class="params">triangle</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 直接将 triangle 存在 dp 中</span></span><br><span class="line">    <span class="keyword">let</span> dp = triangle;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = dp.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; dp[i].length; j++)&#123;</span><br><span class="line">            dp[i][j] += <span class="built_in">Math</span>.min(dp[i + <span class="number">1</span>][j], dp[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实甚至可以不设 dp 直接返回 triangle[0][0]。</p>
<h3 id="思路2-amp-题解-5"><a href="#思路2-amp-题解-5" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumTotal = <span class="function"><span class="keyword">function</span> (<span class="params">triangle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = triangle[triangle.length-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = triangle.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; triangle[i].length; j++)&#123;</span><br><span class="line">            res[j] = <span class="built_in">Math</span>.min(res[j], res[j + <span class="number">1</span>]) + triangle[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode53——最大子序和（☆）"><a href="#LeetCode53——最大子序和（☆）" class="headerlink" title="LeetCode53——最大子序和（☆）"></a>LeetCode53——最大子序和（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">跳转地址</a></p>
<p>自己做只会暴力求解。。</p>
<h3 id="思路-amp-题解-7"><a href="#思路-amp-题解-7" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li>DP[i]表示 nums 中以 nums[i] 结尾的最大子序和，取决于 DP[i - 1] + nums[i] &gt; nums[i] ,如果 nums[i] 大，则从 nums[i] 开始单独成一段，否则与之前的连成一段。</li>
<li>所以可得 DP 方程 <code>dp[i] = Math.max(nums[i], dp[i - 1] + nums[i])</code> 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxSubArray</span>(<span class="params">nums: number[]</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dp = [...nums];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 要么自成一段，要么和前面子数组合并</span></span><br><span class="line">        dp[i] = <span class="built_in">Math</span>.max(nums[i], dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发现DP[i]其实只与DP[i - 1]有关（只用到了一个变量），所以可以用一个变量 pre 来替代 DP[i - 1]，从而让空间复杂度降低到 O(1)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, dp = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        pre = <span class="built_in">Math</span>.max(pre + nums[i], nums[i]);</span><br><span class="line">        dp = <span class="built_in">Math</span>.max(dp, pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode152——乘积最大子序列（☆☆）"><a href="#LeetCode152——乘积最大子序列（☆☆）" class="headerlink" title="LeetCode152——乘积最大子序列（☆☆）"></a>LeetCode152——乘积最大子序列（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-product-subarray/submissions/">跳转地址</a></p>
<p>自己写 DP 还是没有任何思路。</p>
<h3 id="思路-amp-题解-8"><a href="#思路-amp-题解-8" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProduct = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prevMax = nums[<span class="number">0</span>], prevMin = nums[<span class="number">0</span>], result = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        curMax = <span class="built_in">Math</span>.max(nums[i] * prevMax, nums[i], nums[i] * prevMin);</span><br><span class="line">        <span class="comment">// 考虑负数情况，要算出最小值 因为最小值* 负数 可能就是变为最大值</span></span><br><span class="line">        curMin = <span class="built_in">Math</span>.min(nums[i] * prevMin, nums[i], nums[i] * prevMax);</span><br><span class="line">        prevMax = curMax</span><br><span class="line">        prevMin = curMin</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">Math</span>.max(curMax, result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode198——打家劫舍（☆☆）"><a href="#LeetCode198——打家劫舍（☆☆）" class="headerlink" title="LeetCode198——打家劫舍（☆☆）"></a>LeetCode198——打家劫舍（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">跳转地址</a></p>
<h3 id="思路1-amp-题解-7"><a href="#思路1-amp-题解-7" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ul>
<li>首先考虑能否用一位数组 DP ，但是显然不能存储”偷”或者”没偷”的状态，所以使用二维数组。</li>
<li>a[i] 表示到 i 天为止<strong>能偷</strong>的最大值。</li>
<li>DP 方程：<code>a[i][0] = Math.max(a[i - 1][0], a[i - 1][1]); a[i][1] = a[i - 1][0] + nums[i];</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 0 不偷 1偷</span></span><br><span class="line">  a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>, a[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    a[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(a[i - <span class="number">1</span>][<span class="number">0</span>], a[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    a[i][<span class="number">1</span>] = a[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(a[n - <span class="number">1</span>][<span class="number">0</span>], a[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-6"><a href="#思路2-amp-题解-6" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><ul>
<li>用 a[i] 表示到 i 天为止<strong>已经偷到</strong>的最大现金。</li>
<li>DP 方程：<code>a[i] = Math.max(a[i - 1], a[i - 2] + nums[i]);</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length, a = <span class="keyword">new</span> <span class="built_in">Array</span>(n);</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">  a[<span class="number">0</span>] = nums[<span class="number">0</span>], a[<span class="number">1</span>] = <span class="built_in">Math</span>.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> res = <span class="built_in">Math</span>.max(a[<span class="number">0</span>], a[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">    a[i] = <span class="built_in">Math</span>.max(a[i - <span class="number">1</span>], a[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>改进成 O（1）的空间复杂度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prevMax = <span class="number">0</span>, curMax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = curMax;</span><br><span class="line">        curMax = <span class="built_in">Math</span>.max(prevMax + n, curMax);</span><br><span class="line">        prevMax = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(curMax, prevMax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode219——打家劫舍-II（☆☆）"><a href="#LeetCode219——打家劫舍-II（☆☆）" class="headerlink" title="LeetCode219——打家劫舍 II（☆☆）"></a>LeetCode219——打家劫舍 II（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">跳转地址</a></p>
<h3 id="思路-amp-题解-9"><a href="#思路-amp-题解-9" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP 方程还是没变，只是多设置了一个 dp 数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> nums[<span class="number">0</span>] || <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dp1 = [nums[<span class="number">0</span>], <span class="built_in">Math</span>.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])];</span><br><span class="line">  <span class="keyword">const</span> dp2 = [<span class="number">0</span>, nums[<span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp1[i] = i === n - <span class="number">1</span> ? dp1[i - <span class="number">1</span>] : <span class="built_in">Math</span>.max(nums[i] + dp1[i - <span class="number">2</span>], dp1[i - <span class="number">1</span>]);</span><br><span class="line">    dp2[i] = <span class="built_in">Math</span>.max(nums[i] + dp2[i - <span class="number">2</span>], dp2[i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max(dp1[n - <span class="number">1</span>], dp2[n - <span class="number">1</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="动态规划——买卖股票"><a href="#动态规划——买卖股票" class="headerlink" title="动态规划——买卖股票"></a>动态规划——买卖股票</h2><p>共有三个状态：</p>
<ul>
<li>第 i 天</li>
<li>交易次数 k</li>
<li>是否持有股票 （0 不持有，1 持有）</li>
</ul>
<p>故可以用 <code>dp[i][k][s]</code> 表示 DP 状态数组，且<code>dp[n-1][k][0]</code>是最后一天允许的最大交易次数的最大利润。</p>
<p>DP方程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 今天不持有股票。最大利润为昨天不持有股票的利润，或者今天卖出昨天股票的利润。</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = Max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line"><span class="comment">// 今天持有股票。最大利润为昨天持有股票的利润</span></span><br><span class="line">dp[i][k][<span class="number">1</span>] = Max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p>初始数组：</p>
<ul>
<li><code>dp[-1][k][0] = 0</code>  因为一天从 0 开始，这里 i 是 -1</li>
<li><code>dp[-1][k][1] = -Infinity</code>  因为在第一天之前不能持有任何股票</li>
<li><code>dp[i][0][0] = 0</code>  因为 k = 0。不会有任何交易，所以利润为零</li>
<li><code>dp[i][0][1] = -Infinity</code>  因为k = 0。不能在不开始交易的情况下持有任何股票</li>
</ul>
<h2 id="LeetCode122——买卖股票的最佳时机（☆）"><a href="#LeetCode122——买卖股票的最佳时机（☆）" class="headerlink" title="LeetCode122——买卖股票的最佳时机（☆）"></a>LeetCode122——买卖股票的最佳时机（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/#/description">跳转地址</a></p>
<h3 id="自己的代码-15"><a href="#自己的代码-15" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> minPrice = prices[<span class="number">0</span>], profit = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">      minPrice = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prices[i] - minPrice &gt; profit) &#123;</span><br><span class="line">      profit = prices[i] - minPrice;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> profit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路1-amp-题解-8"><a href="#思路1-amp-题解-8" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min = <span class="built_in">Number</span>.MAX_SAFE_INTEGER; </span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        min = <span class="built_in">Math</span>.min(min, prices[i]);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, prices[i] - min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-7"><a href="#思路2-amp-题解-7" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>重点看动态规划：即 k=1 。 当 k 为 1 时，k 的存在不会以任何方式改变数组状态，因此我们可以忽略它。</p>
<p>DP 方程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], <span class="number">0</span> - prices[i])</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = prices.length;</span><br><span class="line">  <span class="keyword">let</span> dp = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    dp[i] = [];</span><br><span class="line">    <span class="keyword">if</span>(i === <span class="number">0</span>)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">      dp[i][<span class="number">1</span>] = -prices[i];</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],  -prices[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>降低空间复杂度：不构造 DP 矩阵，从而将空间复杂度降低到 O(1)，因为新状态仅与相邻状态相关。（状态存储在单个变量中）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_i10 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_i11 = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;prices.length;i++)&#123;</span><br><span class="line">    d_i10 = <span class="built_in">Math</span>.max(d_i10, d_i11 + prices[i]);</span><br><span class="line">    d_i11 = <span class="built_in">Math</span>.max(d_i11, <span class="number">0</span> - prices[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_i10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode122——买卖股票的最佳时机-II（☆）"><a href="#LeetCode122——买卖股票的最佳时机-II（☆）" class="headerlink" title="LeetCode122——买卖股票的最佳时机 II（☆）"></a>LeetCode122——买卖股票的最佳时机 II（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">跳转地址</a></p>
<h3 id="自己的代码-16"><a href="#自己的代码-16" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>没写出来，有很多种情况。除了案例给的，还有[1,3,2,4,5]这种。不可能用分类讨论来做吧？</p>
<h3 id="思路1-amp-题解-9"><a href="#思路1-amp-题解-9" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>动态规划= （<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/mai-mai-gu-piao-de-zui-jia-shi-ji-ii-by-leetcode-s/">占个坑</a>，以后再看吧）</p>
<p>接上：即 k = +Infinity。同样可以忽略 k 。DP 方程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_ik0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_ik1 = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    d_ik0 = <span class="built_in">Math</span>.max(d_ik0 , d_ik1 + prices[i]);</span><br><span class="line">    d_ik1 = <span class="built_in">Math</span>.max(d_ik1, d_ik0 - prices[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_ik0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-8"><a href="#思路2-amp-题解-8" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>贪心：<strong>当天可以卖了之后，又买一股！</strong>假设，如果今天我买了，明天是否赚？（只要是能赚钱，就统统头天买，今天买！）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>, len = prices.length; i &lt; len; i++)&#123;</span><br><span class="line">        ans += <span class="built_in">Math</span>.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：O(n)，其中 nn 为数组的长度。我们只需要遍历一次数组即可。</p>
</li>
<li><p>空间复杂度：O(1)。只需要常数空间存放若干变量。</p>
</li>
</ul>
<h3 id="LeetCode123——买卖股票的最佳时机-III（☆☆☆）"><a href="#LeetCode123——买卖股票的最佳时机-III（☆☆☆）" class="headerlink" title="LeetCode123——买卖股票的最佳时机 III（☆☆☆）"></a>LeetCode123——买卖股票的最佳时机 III（☆☆☆）</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">跳转地址</a></p>
<h3 id="思路-amp-题解-10"><a href="#思路-amp-题解-10" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP k = 2，需要穷尽 k 的值，与第一笔交易一起保存第二笔交易的状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">2</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">2</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">2</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>], -prices[i])</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_i20 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_i21 = -<span class="literal">Infinity</span>; </span><br><span class="line">  <span class="keyword">let</span> d_i10 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_i11 = -<span class="literal">Infinity</span>; </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">    d_i10 = <span class="built_in">Math</span>.max(d_i10, d_i11 + prices[i]);</span><br><span class="line">    d_i11 = <span class="built_in">Math</span>.max(d_i11,  <span class="number">0</span> - prices[i]);</span><br><span class="line">    d_i20 = <span class="built_in">Math</span>.max(d_i20, d_i21 + prices[i]);</span><br><span class="line">    d_i21 = <span class="built_in">Math</span>.max(d_i21, d_i10 - prices[i]);</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_i20</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode188——买卖股票的最佳时机-IV（☆☆☆）-too-hard"><a href="#LeetCode188——买卖股票的最佳时机-IV（☆☆☆）-too-hard" class="headerlink" title="LeetCode188——买卖股票的最佳时机 IV（☆☆☆）(too hard)"></a>LeetCode188——买卖股票的最佳时机 IV（☆☆☆）(too hard)</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">跳转地址</a></p>
<h3 id="思路-amp-题解-11"><a href="#思路-amp-题解-11" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP：k 为正整数。交易包括买卖，至少需要 2 天。因此有效限制 k 不应超过 n/2（n 为天数）。如果超过，则没有约束效应使 k 等于 +Infinity。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">k, prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// When k becomes so much larger than the number of prices we can make transactions whenever.</span></span><br><span class="line">    <span class="keyword">if</span>(k &gt; (prices.length / <span class="number">2</span>) )&#123;</span><br><span class="line">      <span class="keyword">let</span> d_ik0 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> d_ik1 =  -<span class="literal">Infinity</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>; i&lt;prices.length;i++)&#123;</span><br><span class="line">        d_ik0 = <span class="built_in">Math</span>.max(d_ik0, d_ik1 + prices[i]);</span><br><span class="line">        d_ik1 = <span class="built_in">Math</span>.max(d_ik1, d_ik0 - prices[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> d_ik0</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> dp = [];</span><br><span class="line">        <span class="keyword">let</span> size = prices.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;size; i++)&#123;</span><br><span class="line">          dp[i] = [];</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>; j&lt;=k; j++)&#123;</span><br><span class="line">            dp[i][j] = []</span><br><span class="line">            <span class="keyword">if</span>(i-<span class="number">1</span> === -<span class="number">1</span> || j-<span class="number">1</span> === -<span class="number">1</span>)&#123;</span><br><span class="line">              dp[i][j][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">              dp[i][j][<span class="number">1</span>] = -prices[i];</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][j][<span class="number">0</span>] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][j][<span class="number">0</span>], dp[i-<span class="number">1</span>][j][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][j][<span class="number">1</span>] = <span class="built_in">Math</span>.max(dp[i-<span class="number">1</span>][j][<span class="number">1</span>], dp[i-<span class="number">1</span>][j-<span class="number">1</span>][<span class="number">0</span>] - prices[i])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> dp[size-<span class="number">1</span>][k][<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode188——最佳买卖股票时机含冷冻期（☆☆）"><a href="#LeetCode188——最佳买卖股票时机含冷冻期（☆☆）" class="headerlink" title="LeetCode188——最佳买卖股票时机含冷冻期（☆☆）"></a>LeetCode188——最佳买卖股票时机含冷冻期（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">跳转地址</a></p>
<h3 id="思路-amp-题解-12"><a href="#思路-amp-题解-12" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP：<strong>k = +Infinity 且有冷却时间</strong>，所以必须在卖出股票后等待一天才能继续交易。我们可以将状态转移方程写为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_ik0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_ik1 = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="keyword">let</span> d_ik0_pre = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> d_ik0_old = d_ik0; </span><br><span class="line">    d_ik0 = <span class="built_in">Math</span>.max(d_ik0 , d_ik1 + prices[i]);</span><br><span class="line">    d_ik1 = <span class="built_in">Math</span>.max(d_ik1, d_ik0_pre - prices[i]);</span><br><span class="line">    d_ik0_pre = d_ik0_old;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_ik0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode188——买卖股票的最佳时机含手续费（☆☆）"><a href="#LeetCode188——买卖股票的最佳时机含手续费（☆☆）" class="headerlink" title="LeetCode188——买卖股票的最佳时机含手续费（☆☆）"></a>LeetCode188——买卖股票的最佳时机含手续费（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">跳转地址</a></p>
<h3 id="思路-amp-题解-13"><a href="#思路-amp-题解-13" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>DP：<strong>k = +Infinity 含有交易费</strong>。第 i 天买入或卖出股票后的利润应该减去这个金额，因此新的 DP 方程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i])</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i] - fee)</span><br><span class="line"><span class="comment">//or</span></span><br><span class="line">dp[i][k][<span class="number">0</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">0</span>], dp[i-<span class="number">1</span>][k][<span class="number">1</span>] + prices[i] - fee)</span><br><span class="line">dp[i][k][<span class="number">1</span>] = max(dp[i-<span class="number">1</span>][k][<span class="number">1</span>], dp[i-<span class="number">1</span>][k][<span class="number">0</span>] - prices[i])</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices, fee</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> d_ik0 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> d_ik1 = -<span class="literal">Infinity</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">    d_ik0 = <span class="built_in">Math</span>.max(d_ik0 , d_ik1 + prices[i]);</span><br><span class="line">    d_ik1 = <span class="built_in">Math</span>.max(d_ik1, d_ik0 - prices[i] - fee);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_ik0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。</p>
<p>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</p>
<p>贪心法可以解决一些最优化问题， 如：求图中的最小生成树、求哈夫曼编码等。然而对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案。</p>
<h2 id="LeetCode322——零钱兑换（☆☆）"><a href="#LeetCode322——零钱兑换（☆☆）" class="headerlink" title="LeetCode322——零钱兑换（☆☆）"></a>LeetCode322——零钱兑换（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/coin-change/">跳转地址</a></p>
<h3 id="自己的代码-17"><a href="#自己的代码-17" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    coins = coins.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">parseInt</span>(amount / coins[<span class="number">0</span>]) !== <span class="number">0</span>) &#123;</span><br><span class="line">            amount = amount - coins[<span class="number">0</span>];</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        coins.shift();</span><br><span class="line">        <span class="comment">// 注意！判断coins是否为[]时，不能用 === ，也不能！，因为数组是对象。</span></span><br><span class="line">        <span class="keyword">if</span> (coins.length === <span class="number">0</span> &amp;&amp; amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC，感觉思路就是这样，没什么问题。但是几个极限测试点没有过。</p>
<h3 id="思路1-amp-题解-10"><a href="#思路1-amp-题解-10" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>DFS+贪心:（暂时没看懂）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> coinChange = <span class="function">(<span class="params">coins, amount</span>) =&gt;</span> &#123;</span><br><span class="line">    coins.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b - a);</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">Infinity</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">const</span> find = <span class="function">(<span class="params">k, amount, count</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> coin = coins[k];</span><br><span class="line">      <span class="keyword">if</span> (k === coins.length - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (amount % coin === <span class="number">0</span>) &#123;</span><br><span class="line">          res = <span class="built_in">Math</span>.min(res, count + ~~(amount / coin));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = ~~(amount / coin); i &gt;= <span class="number">0</span> &amp;&amp; count + i &lt; res; i--) &#123; </span><br><span class="line">          find(k + <span class="number">1</span>, amount - coin * i, count + i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    find(<span class="number">0</span>, amount, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res === <span class="literal">Infinity</span> ? -<span class="number">1</span> : res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-9"><a href="#思路2-amp-题解-9" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>DP：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(amount + <span class="number">1</span>).fill(<span class="literal">Infinity</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= amount; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> coin <span class="keyword">of</span> coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] === <span class="literal">Infinity</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode55——跳跃游戏（☆☆）"><a href="#LeetCode55——跳跃游戏（☆☆）" class="headerlink" title="LeetCode55——跳跃游戏（☆☆）"></a>LeetCode55——跳跃游戏（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">跳转地址</a></p>
<h3 id="自己的代码-18"><a href="#自己的代码-18" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> length = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="literal">false</span>);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= nums[i]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &lt; length) &#123;</span><br><span class="line">                arr[i + j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!arr[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC，永远存在小错误，头都大了。思路是将数组变成 true / false ，如果数组中存在 false 则返回 false。</p>
<h3 id="思路1-amp-题解-11"><a href="#思路1-amp-题解-11" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>贪心算法，从后往前贪。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> endReachable = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + i &gt;= endReachable) &#123;</span><br><span class="line">            endReachable = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> endReachable === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="keyword">var</span> canJump = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; i) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        max = <span class="built_in">Math</span>.max(i+nums[i], max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode45——跳跃游戏II（☆☆）"><a href="#LeetCode45——跳跃游戏II（☆☆）" class="headerlink" title="LeetCode45——跳跃游戏II（☆☆）"></a>LeetCode45——跳跃游戏II（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game-ii/">跳转地址</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jump = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> end = <span class="number">0</span>; <span class="comment">// 当前跳跃所能到达的边界</span></span><br><span class="line">    <span class="keyword">let</span> steps = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>; <span class="comment">// 当前跳跃所有位置可达的最大距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123; <span class="comment">// 最后一个位置不需要遍历，因为在此之前max肯定大于等于该位置的索引</span></span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, i + nums[i]); <span class="comment">// 更新当前跳跃中i位置可达的最大距离</span></span><br><span class="line">        <span class="keyword">if</span> (i === end) &#123; <span class="comment">// 已经到达边界，必须跳一下</span></span><br><span class="line">            end = max; <span class="comment">// 更新新的边界</span></span><br><span class="line">            steps++; <span class="comment">// 必须跳一下</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="字典树（Trie-树）与并查集"><a href="#字典树（Trie-树）与并查集" class="headerlink" title="字典树（Trie 树）与并查集"></a>字典树（Trie 树）与并查集</h1><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><ul>
<li>结点本身不存完整单词;</li>
<li>从根结点到某一结点，路径上经过的字符连接起来，为该结点对应的字符串;</li>
<li>每个结点的所有子结点路径代表的字符都不相同。 </li>
</ul>
<p><strong>结点的内部实现：</strong></p>
<p><img src="https://i.loli.net/2021/09/03/ZFHKTMRDui6WbQX.png" alt="image.png"></p>
<h2 id="LeetCode116——朋友圈（☆☆）"><a href="#LeetCode116——朋友圈（☆☆）" class="headerlink" title="LeetCode116——朋友圈（☆☆）"></a>LeetCode116——朋友圈（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bLyHh0/">跳转地址</a></p>
<p>DFS 解法同 LC200 岛屿数量。</p>
<h3 id="思路-amp-题解-14"><a href="#思路-amp-题解-14" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p><strong>Union Find，并查集：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findCircleNum = <span class="function"><span class="keyword">function</span>(<span class="params">M</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> dsu = <span class="keyword">new</span> DSU(M.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; M.length; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; M[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(M[row][col] === <span class="number">1</span>) &#123;</span><br><span class="line">                dsu.union(row, col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>(M.map(<span class="function">(<span class="params">m, i</span>) =&gt;</span> dsu.find(i))).size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">N</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent = [...new <span class="built_in">Array</span>(N).keys()];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">find</span>(<span class="params">x</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.parent[x] !== x) &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent[x] = <span class="built_in">this</span>.find(<span class="built_in">this</span>.parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">union</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.parent[<span class="built_in">this</span>.find(x)] = <span class="built_in">this</span>.find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="A-search（启发式搜索）"><a href="#A-search（启发式搜索）" class="headerlink" title="A* search（启发式搜索）"></a>A* search（启发式搜索）</h1><h2 id="模板："><a href="#模板：" class="headerlink" title="模板："></a>模板：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def bfs(graph, start,end):</span><br><span class="line">  queue = []</span><br><span class="line">  queue.append([start])</span><br><span class="line">  visited.add(start)</span><br><span class="line"></span><br><span class="line">  while queue:</span><br><span class="line">    node = queue.pop()</span><br><span class="line">    visited.add(node)</span><br><span class="line">    </span><br><span class="line">    process(node)</span><br><span class="line">    nodes=generate_related_nodes(node)</span><br><span class="line">    queue.push(nodes)</span><br></pre></td></tr></table></figure>

<h2 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h2><p>启发式函数: h(n), 它用来评价哪些结点最有希望的是个我们要找的结点，h(n) 会返回一个非负实数，也可以认为是从结点n的目标结点路径的估计成本。</p>
<p>启发式函数是一种告知搜索方向的方法。它提供了-种明智的方法来猜测哪个邻居结点会导向一个目标。</p>
<h2 id="LeetCode1091——二进制矩阵中的最短路径（☆☆）"><a href="#LeetCode1091——二进制矩阵中的最短路径（☆☆）" class="headerlink" title="LeetCode1091——二进制矩阵中的最短路径（☆☆）"></a>LeetCode1091——二进制矩阵中的最短路径（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/">跳转地址</a></p>
<h3 id="思路-amp-题解-15"><a href="#思路-amp-题解-15" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>BFS:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shortestPathBinaryMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> n = grid.length;</span><br><span class="line">  <span class="keyword">if</span> (grid[<span class="number">0</span>][<span class="number">0</span>] || grid[n - <span class="number">1</span>][n - <span class="number">1</span>]) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">  <span class="keyword">const</span> queue = [];</span><br><span class="line">  queue.push([<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> directions = [[-<span class="number">1</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, j, d] <span class="keyword">of</span> queue) &#123;</span><br><span class="line">    <span class="comment">// 已经走到右下角</span></span><br><span class="line">    <span class="keyword">if</span> (i === n - <span class="number">1</span> &amp;&amp; j === n - <span class="number">1</span>) <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> [x, y] <span class="keyword">of</span> directions)&#123;</span><br><span class="line">      <span class="keyword">const</span> newI = i + x, newJ = j + y;</span><br><span class="line">      <span class="keyword">if</span>(<span class="number">0</span> &lt;= newI &amp;&amp; newI &lt; n &amp;&amp; <span class="number">0</span> &lt;= newJ &amp;&amp; newJ &lt; n &amp;&amp; !grid[newI][newJ])&#123;</span><br><span class="line">        queue.push([newI, newJ, d + <span class="number">1</span>]);</span><br><span class="line">        grid[newI][newJ] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>启发式搜索好难（todo。。）</p>
<h1 id="AVL和红黑树"><a href="#AVL和红黑树" class="headerlink" title="AVL和红黑树"></a>AVL和红黑树</h1><p><img src="https://i.loli.net/2021/09/05/bFCEj642c9YBhuD.png" alt="image.png"></p>
<h2 id="AVL-总结"><a href="#AVL-总结" class="headerlink" title="AVL 总结"></a>AVL 总结</h2><ol>
<li>平衡二叉搜索树</li>
<li>每个结点存balance factor= {-1, 0, 1}</li>
<li>四种旋转操作</li>
</ol>
<p>不足：结点需要存储额外信息、且调整次数频繁</p>
<h2 id="Red-black-Tree"><a href="#Red-black-Tree" class="headerlink" title="Red-black Tree"></a>Red-black Tree</h2><p>红黑树是一种<strong>近似平衡</strong>的二叉搜索树(Binary SearchTree) ，它能够确保任何一个结点的左右子树的<strong>高度差小于两倍</strong>。具体来说，红黑树是满足如下条件的二叉搜索树：</p>
<ul>
<li>每个结点要么是红色，要么是黑色</li>
<li>根结点是黑色</li>
<li>每个叶结点（NIL结点， 空结点）是黑色的。</li>
<li>.不能有相邻接的两个红色结点</li>
<li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</li>
</ul>
<h2 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h2><ul>
<li>AVLtrees provide <strong>faster lookups</strong> than Red Black Trees because they are <strong>more strictly balanced</strong>.</li>
<li>Red Black Trees provide <strong>faster insertion and removal</strong> operations than AVL trees as fewer rotations are done due to relatively relaxed balancing.</li>
<li>AVLtrees store balance <strong>factors or heights</strong> with eachnode, thus requires storage for an integer per nodewhereas Red Black Tree requires only 1 bit of information per node.</li>
<li>Red Black Trees are used in most of the <strong>language libraries like map, multimap, multisetin C++</strong> whereas AVL trees are used in <strong>databases</strong> where faster retrievals are required.</li>
</ul>
<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="指定位置的位运算"><a href="#指定位置的位运算" class="headerlink" title="指定位置的位运算"></a>指定位置的位运算</h2><ol>
<li>将 x 最右边的 n 位清零： <code>x &amp; (~0 &lt;&lt; n)</code> （~0 &lt;&lt; n 表示全1后面有 n 个0，再和 x 相与）</li>
<li>获取 x 的第 n 位值（0 或者 1）：<code>(x &gt;&gt; n) &amp; 1</code> （x &gt;&gt; n 表示 x 的第 n 位变成最后一位）</li>
<li>获取 x 的第 n 位的幂值： <code>x &amp; (1 &lt;&lt; (n-1))</code></li>
<li>仅将第 n 位置为1： <code>x | (1 &lt;&lt; n)</code></li>
<li>仅将第 n 位置为0：<code>x &amp; (~(1 &lt;&lt; n))</code></li>
<li>将 x 最高位至第 n 位（含）清零：<code>x &amp; ((1 &lt;&lt; n)-1)</code></li>
<li>将第 n 位至第 0 位（含）清零： <code>x &amp; (~((1 &lt;&lt; (n+1))-1))</code></li>
</ol>
<h2 id="实战位运算要点"><a href="#实战位运算要点" class="headerlink" title="实战位运算要点"></a>实战位运算要点</h2><ul>
<li><strong>判断奇偶：（建议以后都用位运算）</strong><br><code>x % 2 == 1 —&gt; (x &amp; 1) == 1</code><br><code>x % 2 == 0 —&gt; (x &amp; 1) == 0</code></li>
<li><code>x &gt;&gt; 1 —&gt; x/ 2</code><br>即：x=x/ 2; —&gt; x=x &gt;&gt; 1;<br>mid =(left +right)/2;—&gt; mid =(left + right) &gt;&gt; 1;</li>
<li><strong>清零最低位的1：（高频）</strong><code>X = X &amp;(X-1)</code> </li>
<li><strong>得到最低位的1：</strong><code>X &amp; -X</code></li>
<li><strong>得到0 ：</strong><code>X &amp; ~X</code> </li>
</ul>
<h2 id="LeetCode191——位1的个数（☆）"><a href="#LeetCode191——位1的个数（☆）" class="headerlink" title="LeetCode191——位1的个数（☆）"></a>LeetCode191——位1的个数（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/">跳转地址</a></p>
<ol>
<li>for loop：0 —&gt; 32 循环判断 “1”。</li>
<li>%2，/2 （32次）</li>
<li>&amp;1，x = x &gt;&gt; 1（32次）</li>
<li>while(x) { count++; x = x &amp; (x - 1);}（最佳）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hammingWeight = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line">    n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode190——颠倒二进制位（☆）"><a href="#LeetCode190——颠倒二进制位（☆）" class="headerlink" title="LeetCode190——颠倒二进制位（☆）"></a>LeetCode190——颠倒二进制位（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-bits/">跳转地址</a></p>
<p>int —&gt; string —&gt; reverse —&gt; int 但是这样效率极低。</p>
<h3 id="思路1-amp-题解-12"><a href="#思路1-amp-题解-12" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>位运算：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBits = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    res = (res &lt;&lt; <span class="number">1</span>) + (n &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// n = n &gt;&gt; 1; </span></span><br><span class="line">    n = n &gt;&gt;&gt; <span class="number">1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-10"><a href="#思路2-amp-题解-10" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>不用无符号位移：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseBits = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>, count = <span class="number">32</span>;</span><br><span class="line">  <span class="keyword">while</span> (count--) &#123;</span><br><span class="line">    result *= <span class="number">2</span>;</span><br><span class="line">    result += n &amp; <span class="number">1</span>;</span><br><span class="line">    n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode338——比特位计数（☆）"><a href="#LeetCode338——比特位计数（☆）" class="headerlink" title="LeetCode338——比特位计数（☆）"></a>LeetCode338——比特位计数（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/counting-bits/">跳转地址</a></p>
<h3 id="自己的代码-19"><a href="#自己的代码-19" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, x = i;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(count);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路-amp-题解-16"><a href="#思路-amp-题解-16" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p><strong>动态规划+位运算：</strong>对于任一数 i，它二进制数中 1 的个数 = i 右移一位 的 1 的个数 + i 末位 1 的个数</p>
<p>用 dp[i] 表示 i 对应二进制数中 1 的个数，即 dp[i] = dp[i &gt;&gt; 1] + (i &amp; 1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countBits = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="built_in">Array</span>(num+<span class="number">1</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span> ;i&lt; num+<span class="number">1</span>;i++)&#123;</span><br><span class="line">    dp[i] = dp[i&gt;&gt;<span class="number">1</span>] + (i &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><h2 id="Bloom-Filter-Vs-Hash-Table"><a href="#Bloom-Filter-Vs-Hash-Table" class="headerlink" title="Bloom Filter Vs Hash Table"></a>Bloom Filter Vs Hash Table</h2><p>一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p>
<p><strong>优点：</strong>空间效率和查询时间都远远超过般的算法</p>
<p><strong>缺点：</strong>有一定的误识别率和删除困难。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/05/30/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E7%AE%97%E6%B3%95/">https://asura1211.github.io/2021/05/30/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/07/xyGvCbmdgHPf1E8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/05/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"><img class="prev-cover" src="https://i.loli.net/2021/06/07/xyGvCbmdgHPf1E8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">我的第一篇博客文章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Asura1211"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">稳定性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F-%E2%80%94%E2%80%94-O-n-2"><span class="toc-number">1.2.</span> <span class="toc-text">初级排序 —— O(n^2)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%8E%92%E5%BA%8F-%E2%80%94%E2%80%94-O-N-LogN"><span class="toc-number">1.3.</span> <span class="toc-text">高级排序 —— O(N*LogN)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%8E%92%E5%BA%8F-%E2%80%94%E2%80%94-O-n"><span class="toc-number">1.4.</span> <span class="toc-text">特殊排序 —— O(n)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode1122%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">LeetCode1122——数组的相对排序（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">1.5.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode242%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">LeetCode242——有效的字母异位词（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode493%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E5%AF%B9%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">LeetCode493——翻转对（☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.7.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">1.7.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%B2%BB-amp-%E5%9B%9E%E6%BA%AF"><span class="toc-number">2.</span> <span class="toc-text">分治&amp;回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode50%E2%80%94%E2%80%94Pow-x-n-%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">LeetCode50——Pow(x, n)（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.1.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode78%E2%80%94%E2%80%94%E5%AD%90%E9%9B%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">LeetCode78——子集（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-4"><span class="toc-number">2.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3%EF%BC%88good%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">思路2&amp;题解（good）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode77%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">LeetCode77——组合（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-5"><span class="toc-number">2.3.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode17%E2%80%94%E2%80%94%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">LeetCode17——电话号码的字母组合（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-6"><span class="toc-number">2.4.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode46%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">LeetCode46——全排列（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-7"><span class="toc-number">2.5.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode47%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">LeetCode47——全排列Ⅱ（☆☆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer51%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">剑指Offer51——数组中的逆序对（☆☆☆）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%AA%E6%9E%9D"><span class="toc-number">3.</span> <span class="toc-text">剪枝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode51%E2%80%94%E2%80%94N%E7%9A%87%E5%90%8E%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89todo%EF%BC%81"><span class="toc-number">3.1.</span> <span class="toc-text">LeetCode51——N皇后（☆☆☆）todo！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode37%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89todo%EF%BC%81"><span class="toc-number">3.2.</span> <span class="toc-text">LeetCode37——解数独（☆☆☆）todo！</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">4.</span> <span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode69%E2%80%94%E2%80%94x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">LeetCode69——x 的平方根（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-8"><span class="toc-number">4.1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">4.1.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">4.1.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode33%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">LeetCode33——搜索旋转排序数组（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-9"><span class="toc-number">4.2.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode74%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">LeetCode74——搜索二维矩阵（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-10"><span class="toc-number">4.3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">4.3.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode153%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">LeetCode153——寻找旋转排序数组中的最小值（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-11"><span class="toc-number">4.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">4.4.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">4.4.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BFS%E3%80%81DFS"><span class="toc-number">5.</span> <span class="toc-text">BFS、DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.1.</span> <span class="toc-text">DFS代码——递归写法模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFS%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E9%9D%9E%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.2.</span> <span class="toc-text">DFS代码——非递归写法模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BFS%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.3.</span> <span class="toc-text">BFS代码——模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode200%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">LeetCode200——岛屿数量（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">5.4.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Two-ended-BFS"><span class="toc-number">6.</span> <span class="toc-text">Two-ended BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode127%E2%80%94%E2%80%94%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">LeetCode127——单词接龙（☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">6.1.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">6.1.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">7.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-Dynamic-Programming"><span class="toc-number">8.</span> <span class="toc-text">动态规划 Dynamic Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">8.2.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode509%E2%80%94%E2%80%94%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">LeetCode509——斐波那契数（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">8.3.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">8.3.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode62%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">LeetCode62——不同路径（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-12"><span class="toc-number">8.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">8.4.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">8.4.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">8.4.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode63%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">8.5.</span> <span class="toc-text">LeetCode63——不同路径II（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-13"><span class="toc-number">8.5.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">8.5.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">8.5.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode300%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.6.</span> <span class="toc-text">LeetCode300——最长递增子序列（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-14"><span class="toc-number">8.6.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode1143%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.7.</span> <span class="toc-text">LeetCode1143——最长公共子序列（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">8.7.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode1143%E2%80%94%E2%80%94%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.8.</span> <span class="toc-text">LeetCode1143——三角形最小路径和（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">8.8.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">8.8.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode53%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">8.9.</span> <span class="toc-text">LeetCode53——最大子序和（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">8.9.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode152%E2%80%94%E2%80%94%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.10.</span> <span class="toc-text">LeetCode152——乘积最大子序列（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">8.10.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode198%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.11.</span> <span class="toc-text">LeetCode198——打家劫舍（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">8.11.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">8.11.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode219%E2%80%94%E2%80%94%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.12.</span> <span class="toc-text">LeetCode219——打家劫舍 II（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">8.12.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8"><span class="toc-number">8.13.</span> <span class="toc-text">动态规划——买卖股票</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode122%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">8.14.</span> <span class="toc-text">LeetCode122——买卖股票的最佳时机（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-15"><span class="toc-number">8.14.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">8.14.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">8.14.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode122%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">8.15.</span> <span class="toc-text">LeetCode122——买卖股票的最佳时机 II（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-16"><span class="toc-number">8.15.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">8.15.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">8.15.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">8.15.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LeetCode123%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.15.5.</span> <span class="toc-text">LeetCode123——买卖股票的最佳时机 III（☆☆☆）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">8.15.6.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode188%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89-too-hard"><span class="toc-number">8.16.</span> <span class="toc-text">LeetCode188——买卖股票的最佳时机 IV（☆☆☆）(too hard)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-11"><span class="toc-number">8.16.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode188%E2%80%94%E2%80%94%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.17.</span> <span class="toc-text">LeetCode188——最佳买卖股票时机含冷冻期（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-12"><span class="toc-number">8.17.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode188%E2%80%94%E2%80%94%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.18.</span> <span class="toc-text">LeetCode188——买卖股票的最佳时机含手续费（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-13"><span class="toc-number">8.18.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode322%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">LeetCode322——零钱兑换（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-17"><span class="toc-number">9.1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">9.1.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">9.1.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode55%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">LeetCode55——跳跃游戏（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-18"><span class="toc-number">9.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-11"><span class="toc-number">9.2.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode45%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">LeetCode45——跳跃游戏II（☆☆）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%88Trie-%E6%A0%91%EF%BC%89%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">10.</span> <span class="toc-text">字典树（Trie 树）与并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%A7%E8%B4%A8"><span class="toc-number">10.1.</span> <span class="toc-text">基本性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode116%E2%80%94%E2%80%94%E6%9C%8B%E5%8F%8B%E5%9C%88%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">10.2.</span> <span class="toc-text">LeetCode116——朋友圈（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-14"><span class="toc-number">10.2.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#A-search%EF%BC%88%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">A* search（启发式搜索）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%EF%BC%9A"><span class="toc-number">11.1.</span> <span class="toc-text">模板：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%B0%E4%BB%B7%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">估价函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode1091%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">LeetCode1091——二进制矩阵中的最短路径（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-15"><span class="toc-number">11.3.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AVL%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">12.</span> <span class="toc-text">AVL和红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL-%E6%80%BB%E7%BB%93"><span class="toc-number">12.1.</span> <span class="toc-text">AVL 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Red-black-Tree"><span class="toc-number">12.2.</span> <span class="toc-text">Red-black Tree</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-1"><span class="toc-number">12.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">13.</span> <span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">13.1.</span> <span class="toc-text">指定位置的位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A6%81%E7%82%B9"><span class="toc-number">13.2.</span> <span class="toc-text">实战位运算要点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode191%E2%80%94%E2%80%94%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">13.3.</span> <span class="toc-text">LeetCode191——位1的个数（☆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode190%E2%80%94%E2%80%94%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">13.4.</span> <span class="toc-text">LeetCode190——颠倒二进制位（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-12"><span class="toc-number">13.4.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">13.4.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode338%E2%80%94%E2%80%94%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">13.5.</span> <span class="toc-text">LeetCode338——比特位计数（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-19"><span class="toc-number">13.5.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-16"><span class="toc-number">13.5.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bloom-Filter-Vs-Hash-Table"><span class="toc-number">14.1.</span> <span class="toc-text">Bloom Filter Vs Hash Table</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家社区商城"/></a><div class="content"><a class="title" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城">【项目复盘】— — 贤得家社区商城</a><time datetime="2021-10-31T15:01:17.000Z" title="发表于 2021-10-31 23:01:17">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/11/26/c8CoiAjKTyGNS4a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇"><img src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 前端综合篇"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇">【面试准备】— — 前端综合篇</a><time datetime="2021-10-11T12:53:49.000Z" title="发表于 2021-10-11 20:53:49">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" title="【学习笔记】— — 字节青训营"><img src="https://i.loli.net/2021/11/20/6kUmfsBR2yEIqnD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【学习笔记】— — 字节青训营"/></a><div class="content"><a class="title" href="/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" title="【学习笔记】— — 字节青训营">【学习笔记】— — 字节青训营</a><time datetime="2021-08-14T15:04:54.000Z" title="发表于 2021-08-14 23:04:54">2021-08-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>