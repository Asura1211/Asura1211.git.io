<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【数据结构】— — 数组、字符串和链表 | 青山の博客</title><meta name="keywords" content="数组"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是根据极客时间王争老师的《数据结构与算法之美》作的笔记，后续将补充LeetCode的题目和刷题过程，部分题解参考awesome-coding-js。（侵权删） 数组部分数组定义数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 第一是线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和">
<meta property="og:type" content="article">
<meta property="og:title" content="【数据结构】— — 数组、字符串和链表">
<meta property="og:url" content="https://asura1211.github.io/2021/06/09/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E9%93%BE%E8%A1%A8/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是根据极客时间王争老师的《数据结构与算法之美》作的笔记，后续将补充LeetCode的题目和刷题过程，部分题解参考awesome-coding-js。（侵权删） 数组部分数组定义数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。 第一是线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg">
<meta property="article:published_time" content="2021-06-09T22:05:49.000Z">
<meta property="article:modified_time" content="2021-10-31T10:51:44.520Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="数组">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/06/09/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E9%93%BE%E8%A1%A8/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【数据结构】— — 数组、字符串和链表',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-31 18:51:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【数据结构】— — 数组、字符串和链表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-09T22:05:49.000Z" title="发表于 2021-06-10 06:05:49">2021-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-31T10:51:44.520Z" title="更新于 2021-10-31 18:51:44">2021-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>60分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【数据结构】— — 数组、字符串和链表"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://i.loli.net/2021/10/14/FhG1sJ8bnKCSRXP.png" alt="数据结构副本.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是根据极客时间王争老师的<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100017301">《数据结构与算法之美》</a>作的笔记，后续将补充LeetCode的题目和刷题过程，部分题解参考<a target="_blank" rel="noopener" href="http://www.conardli.top/docs/">awesome-coding-js</a>。（侵权删）</p>
<h1 id="数组部分"><a href="#数组部分" class="headerlink" title="数组部分"></a>数组部分</h1><h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><p>数组（Array）是一种<strong>线性表</strong>数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>
<p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p>
<p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>
<h3 id="数组是如何实现根据下标随机访问数组元素？"><a href="#数组是如何实现根据下标随机访问数组元素？" class="headerlink" title="数组是如何实现根据下标随机访问数组元素？"></a><strong>数组是如何实现根据下标随机访问数组元素？</strong></h3><p><code>a[i]_address = base_address + i * data_type_size</code></p>
<ul>
<li>数组适合查找，查找时间复杂度为O(logn)(排好序的数组，二分查找)</li>
<li>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</li>
</ul>
<h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a><strong>插入</strong>操作</h4><p>假设数组的长度为 n，如果将一个数据插入到数组中的第 k 个位置。我们需将第 k～n 这部分的元素都顺序地往后挪一位。</p>
<p>如果在数组的末尾插入元素，那就不需要移动数据，时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。 因为每个位置插入元素的概率一样，所以平均时间复杂度为 (1+2+…n)/n=O(n)。</p>
<p><strong>还有一个简单的办法</strong>:直接将第 k 位的数据移到数组元素的最后，把新的元素直接放入第 k 个位置，这样时间复杂度就会降为 O(1)。</p>
<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><strong>删除操作</strong></h4><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p>
<p><strong>提高效率的方法：</strong>为了避免剩余数据多次搬移，我们可以先记录已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<h3 id="数组的访问越界问题"><a href="#数组的访问越界问题" class="headerlink" title="数组的访问越界问题"></a>数组的访问越界问题</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++)&#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”。</p>
<p>因为在 C 语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的。a[3] 被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</p>
<h3 id="为什么大多数编程语言中，数组从-0-开始编号呢？"><a href="#为什么大多数编程语言中，数组从-0-开始编号呢？" class="headerlink" title="为什么大多数编程语言中，数组从 0 开始编号呢？"></a><strong>为什么大多数编程语言中，数组从 0 开始编号呢？</strong></h3><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：<code>a[k]_address = base_address + k * type_size</code>。但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：<code>a[k]_address = base_address + (k-1)*type_size</code>。对于 CPU 来说，<strong>多了一次减法指令</strong>。</p>
<h2 id="LeetCode724——寻找数组的中心索引（☆）"><a href="#LeetCode724——寻找数组的中心索引（☆）" class="headerlink" title="LeetCode724——寻找数组的中心索引（☆）"></a>LeetCode724——寻找数组的中心索引（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-pivot-index/">跳转地址</a></p>
<h3 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">var</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            sum1+=nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = index+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum2+=nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum1 == sum2) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只想到用循环将前后sum求出来，然后判断。。</p>
<h3 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a><strong>思路</strong>&amp;题解</h3><p>记数组的全部元素之和为 total，当遍历到第 i 个元素时，设其左侧元素之和为 sum，则其右侧元素之和为 total-num_si-sum。左右侧元素相等即为 sum=total-num_si-sum。即 2* sum+num_si=total。</p>
<p>当中心索引左侧或右侧没有元素时，即为零个项相加，这在数学上称作「空和」（empty sum）。在程序设计中我们约定「空和是零」。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> total = nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] === total) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul>
<li>时间复杂度：O(n)，其中 n为数组的长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h2 id="LeetCode56——合并区间（☆☆）（高频）"><a href="#LeetCode56——合并区间（☆☆）（高频）" class="headerlink" title="LeetCode56——合并区间（☆☆）（高频）"></a>LeetCode56——合并区间（☆☆）（高频）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">跳转地址</a></p>
<h3 id="自己的代码-1"><a href="#自己的代码-1" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt; intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            arr.push(intervals[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push([intervals[i][<span class="number">0</span>],intervals[i+<span class="number">1</span>][<span class="number">1</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC，只会对传入的数组进行判断，如果能考虑到思路1那样，对merge的数组进行边界判断就好了。</p>
<h3 id="思路1-amp-题解"><a href="#思路1-amp-题解" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>使用排序,按照区间的左端点进行排序，那么在排完序的列表中，可以合并的区间一定是连续的。使用数组res存储最终的答案。</p>
<p>首先，将列表中的区间按照左端点升序排列，然后我们将第一个区间加入 merged 数组,并按照顺序依次考虑之后的每个区间。</p>
<p>如果当前区间的左端点在数组 merged中最后一个区间的右端点之后，那么他们不会重合，我们可以直接将这个区间加入数组 merged的末尾。</p>
<p>否则,它们重合，我们需要用当前区间的右端点更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果传递进来的数组长度为0 返回一个空数组</span></span><br><span class="line">    <span class="keyword">if</span> (intervals.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res = []</span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a[<span class="number">0</span>]-b[<span class="number">0</span>])</span><br><span class="line">    res.push(intervals[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 从原数组的第一个元素进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前区间的左端点 大于 merge数组最后一个元素的右端点</span></span><br><span class="line">      <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; res[res.length - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 说明这个数组可以直接放进merge数组中</span></span><br><span class="line">        res.push(intervals[i])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明有区间有交集 当前区间的左端点小于等于最后一个元素的右端点</span></span><br><span class="line">        <span class="comment">// 如果当前区间的右端点 大于 merge 最后一个右端点</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; res[res.length - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="comment">// 更新右端点为最大值</span></span><br><span class="line">          res[res.length - <span class="number">1</span>][<span class="number">1</span>] = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(nlogn)，其中 n 为区间的数量。除去排序的开销，我们只需要一次线性扫描，所以主要的时间开销是排序的 O(nlogn)。</li>
<li>空间复杂度：O(logn)，其中 n为区间的数量。这里计算的是存储答案之外，使用的额外空间。O(logn) 即为排序所需要的空间复杂度。</li>
</ul>
<h3 id="思路2-amp-题解"><a href="#思路2-amp-题解" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a[<span class="number">0</span>]-b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 注意这里对同一个数组进行了读写操作</span></span><br><span class="line">    <span class="comment">// 存在i+1操作 所以intervals.length-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;intervals.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">          <span class="comment">// 根据规律 说明这个区间可以合并</span></span><br><span class="line">           <span class="keyword">const</span> data = [...intervals[i],...intervals[i+<span class="number">1</span>]]</span><br><span class="line">           <span class="keyword">const</span> item = [<span class="built_in">Math</span>.min(...data), <span class="built_in">Math</span>.max(...data)];</span><br><span class="line">           intervals.splice(i, <span class="number">2</span>, item);</span><br><span class="line">           i--; <span class="comment">// 回退操作 看看新调整的区间可以跟后面的合并不</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要很扎实的js基础。。。真的很难想到</p>
<h3 id="思路3-amp-题解"><a href="#思路3-amp-题解" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!intervals.length) <span class="keyword">return</span> [];</span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> result = [intervals[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [start, end] <span class="keyword">of</span> intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(start &lt;= result[result.length - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">const</span> [startPrev, endPrev] = result.pop();</span><br><span class="line">            result.push([startPrev, <span class="built_in">Math</span>.max(end, endPrev)]);</span><br><span class="line">        &#125; <span class="keyword">else</span> result.push([start, end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode2015——旋转矩阵（☆☆）（同48旋转图像）"><a href="#LeetCode2015——旋转矩阵（☆☆）（同48旋转图像）" class="headerlink" title="LeetCode2015——旋转矩阵（☆☆）（同48旋转图像）"></a>LeetCode2015——旋转矩阵（☆☆）（同48旋转图像）</h2><p>跳转地址</p>
<h3 id="自己的代码-2"><a href="#自己的代码-2" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr=[]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; matrix.length; j++)&#123;</span><br><span class="line">      arr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix.length; j++)&#123;</span><br><span class="line">      arr[j][matrix.length-<span class="number">1</span>-i] = matrix[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><del>感觉没毛病啊？在vscode里能跑出来，可为啥在lc里第一个都过不了呢？</del> </p>
<p>题目说了，不占用额外的内存空间！所以需要<strong>把新的数组复制到原数组</strong>。（然后就过了。。）</p>
<h3 id="思路1-amp-题解-1"><a href="#思路1-amp-题解-1" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> matrix_new = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix_new[j][n - i - <span class="number">1</span>] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[i][j] = matrix_new[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>js初始化二维数组：（太巧妙了，不像我那样双重for循环）</p>
<p><code>new Array(n).fill(0).map(() =&gt; new Array(n).fill(0))</code> </p>
</li>
<li><p>把matrix.length的值提早赋值给n，因为后面需要用到多次。提高效率</p>
</li>
</ul>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：O(N^2)，其中 N 是 matrix 的边长。</p>
</li>
<li><p>空间复杂度：O(N^2)。我们需要使用一个和 matrix 大小相同的辅助数组。</p>
</li>
</ul>
<h3 id="思路2-amp-题解-1"><a href="#思路2-amp-题解-1" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>用翻转操作代替旋转操作（旋转好难，看不懂就先不写了）</p>
<p>为了直观显示，就直接放lc题解中的图片了。</p>
<p><img src="https://i.loli.net/2021/06/13/rod8EOIMj42X3ya.jpg" alt="Snipaste_2021-06-13_11-26-28.jpg"></p>
<p><img src="https://i.loli.net/2021/06/13/VArObSCjZcaifH7.jpg" alt="Snipaste_2021-06-13_11-27-24.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = matrix.length;</span><br><span class="line">    <span class="comment">// 水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor(n / <span class="number">2</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            [matrix[i][j], matrix[n - i - <span class="number">1</span>][j]] = [matrix[n - i - <span class="number">1</span>][j], matrix[i][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>交换数组值时，用到了ES6中的<strong>解构赋值</strong>。（等号的左右两边模式相同，就会将右边的值赋给左边的变量）</p>
<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(N^2)，其中 N 是 matrix 的边长。对于每一次翻转操作，我们都需要枚举矩阵中一半的元素。</li>
<li>空间复杂度：O(1)。为原地翻转得到的原地旋转。</li>
</ul>
<h3 id="思路3-amp-题解-1"><a href="#思路3-amp-题解-1" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>倒叙倒置法：先将矩阵转置，然后将每一行row倒序（reserve）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rotate = <span class="function">(<span class="params">matrix</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n=matrix.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix.forEach(<span class="function"><span class="params">row</span>=&gt;</span> row.reverse())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode2016——零矩阵（☆☆）"><a href="#LeetCode2016——零矩阵（☆☆）" class="headerlink" title="LeetCode2016——零矩阵（☆☆）"></a>LeetCode2016——零矩阵（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zero-matrix-lcci/">跳转地址</a></p>
<h3 id="自己的代码-3"><a href="#自己的代码-3" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = matrix.length</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(matrix))  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j =<span class="number">0</span>; j &lt; matrix[i].length; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; matrix[i].length; a++)&#123;</span><br><span class="line">          arr[i][a]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; n; b++)&#123;</span><br><span class="line">          arr[b][j]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<p>开辟了额外的内存空间，最后需要再赋值回原数组。看题解有不开辟的解法，等以后再看看吧。</p>
<h2 id="LeetCode498——对角线遍历（☆☆）"><a href="#LeetCode498——对角线遍历（☆☆）" class="headerlink" title="LeetCode498——对角线遍历（☆☆）"></a>LeetCode498——对角线遍历（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diagonal-traverse/">跳转地址</a></p>
<h3 id="自己的代码-4"><a href="#自己的代码-4" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>是真不会= =感觉应该分两种情况（一个往右上，一个往左下），先找到几条对角线（2n-1），然后相连？但是每种情况交界（向右向下+1）也不一样。</p>
<h3 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ol>
<li>只有两种移动方向：<br>右上移动 <code>i-=1; j+=1</code><br>左下移动 <code>i+=1; j-=1</code></li>
<li>处理上下左右编辑问题</li>
<li>越界即转弯</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diagonal-traverse/solution/dui-jiao-xian-bian-li-chao-jian-dan-while-jie-fa-b/">代码好长</a>，超过50行真的就不想看了aa.</p>
<h2 id="LeetCode561——数组拆分-I（☆）"><a href="#LeetCode561——数组拆分-I（☆）" class="headerlink" title="LeetCode561——数组拆分 I（☆）"></a>LeetCode561——数组拆分 I（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-partition-i/">跳转地址</a>)</p>
<h3 id="自己的代码-5"><a href="#自己的代码-5" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>好像需要实现全排列？但其实最大总和一定是两个最小一组，两个次小一组。。一直到两个最大一组，但是这怎么用代码实现呢？感觉这不该是一道easy，是我太菜了=</p>
<h3 id="思路-amp-题解-2"><a href="#思路-amp-题解-2" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>排序：<img src="https://i.loli.net/2021/06/16/mbS8nil2HVIaUox.jpg" alt="Snipaste_2021-06-16_21-56-57.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayPairSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        ans += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好吧，实在是太巧妙了。想到排序但是没想到累加偶数项就可以了。。</p>
<h3 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：O(nlogn)，即为对数组 nums 进行排序的时间复杂度。</p>
</li>
<li><p>空间复杂度：O(logn)，即为排序需要使用的栈空间。</p>
</li>
</ul>
<h2 id="LeetCode167——两数之和-II-输入有序数组（☆）"><a href="#LeetCode167——两数之和-II-输入有序数组（☆）" class="headerlink" title="LeetCode167——两数之和 II - 输入有序数组（☆）"></a>LeetCode167——两数之和 II - 输入有序数组（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">跳转地址</a></p>
<h3 id="自己的代码-6"><a href="#自己的代码-6" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">var</span> n,a</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">    n = target - numbers[i];</span><br><span class="line">    a=numbers.indexOf(n)</span><br><span class="line">    <span class="keyword">if</span> (a!=-<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(i+<span class="number">1</span>);</span><br><span class="line">      arr.push(a + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用了indexOf 果然错了。看到题解上有人说“印象深刻，现在还记得，第一看好简单，马上就用 indexOf 写了，然后肯定没通过，泪目。现在看，那时候不仅没注意复杂度的问题，而且逻辑上也有些问题，没有考虑 target 由 numbers 有两个相同是数组成的情况。”</p>
<p>害，涨涨经验把。</p>
<h3 id="思路1-amp-题解-2"><a href="#思路1-amp-题解-2" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ul>
<li>声明一个数组 a 记录每个 numbers 中的元素与 target 直接的差值。</li>
<li>如果：x+y=target，那么 target-x=y，target-y=x</li>
<li>当遍历到满足要求的值直接返回，不然存贮对应的差值到 a 的对应索引位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = numbers.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = target - numbers[i]</span><br><span class="line">    <span class="keyword">if</span> (a[tmp] !== <span class="literal">undefined</span>) <span class="keyword">return</span> [a[tmp] + <span class="number">1</span>, i + <span class="number">1</span>]</span><br><span class="line">    a[numbers[i]] = i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法好巧妙啊=</p>
<h3 id="思路2-amp-题解-2"><a href="#思路2-amp-题解-2" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>强行遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                <span class="keyword">return</span> [i + <span class="number">1</span>, j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路3-amp-题解-2"><a href="#思路3-amp-题解-2" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>双指针：</p>
<ol>
<li>定义left、right</li>
<li>遍历过程若nums[left] + nums[right] &gt; target，太大了，要小一点，则right左移一位</li>
<li>遍历过程若nums[left] + nums[right] &lt; target，太小了，要大一点，则left右移一位</li>
<li>其余的情况就是nums[left] + nums[right] == target，return [left + 1, right + 1]即可</li>
<li>注意题目的index从1开始，所以return时+1即可</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [left + <span class="number">1</span>, right + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode209——长度最小的子数组（☆☆）"><a href="#LeetCode209——长度最小的子数组（☆☆）" class="headerlink" title="LeetCode209——长度最小的子数组（☆☆）"></a>LeetCode209——长度最小的子数组（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">跳转地址</a></p>
<h3 id="自己的代码-7"><a href="#自己的代码-7" class="headerlink" title="自己的代码"></a>自己的代码</h3><p><del>没有头绪= 想的是可以定义一个sum求和函数，然后对nums数组一位、两位进行遍历，但这样很麻烦还实现不了。</del></p>
<p>如果找到一个子数组，如何继续遍历找下一个子数组呢？（从第nums[i]开始？）</p>
<p>没想到思路写着写着就做出来了，虽然用时垫底5%。。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">target, nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> minCount=<span class="number">10000</span></span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b) &lt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">      sum += nums[j];</span><br><span class="line">      <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">        count = j - i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (minCount &gt; count) &#123;</span><br><span class="line">          minCount = count;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minCount</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路-amp-题解-3"><a href="#思路-amp-题解-3" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针+滑动窗口：</p>
<p><img src="https://i.loli.net/2021/06/17/RNI5kP2Cxwp9BJa.jpg" alt="Snipaste_2021-06-17_14-48-02.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">s, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> int_max = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>, sum = <span class="number">0</span>, ans = int_max</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        sum += nums[j]</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            ans = <span class="built_in">Math</span>.min(ans, j - i + <span class="number">1</span>)</span><br><span class="line">            sum -= nums[i++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans === int_max ? <span class="number">0</span> : ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>时间复杂度：O(n),每个指针移动都需要O(n) 的时间,每个元素最多被访问2次</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="LeetCode118——杨辉三角（☆）"><a href="#LeetCode118——杨辉三角（☆）" class="headerlink" title="LeetCode118——杨辉三角（☆）"></a>LeetCode118——杨辉三角（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle/">跳转地址</a></p>
<h3 id="自己的代码-8"><a href="#自己的代码-8" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(numRows)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">    arr[i]=<span class="keyword">new</span> <span class="built_in">Array</span>(i+<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">    arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">      arr[i][j] = arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实不难，毕竟easy题。但是看了答案后发现自己多了很多冗余代码，比如创建二维数组，完全可以先 var arr=[]，然后最后再push的方式创建；还有就是不必第一个和最后一个赋值1，可以用fill(1)的方式。</p>
<h3 id="思路-amp-题解-4"><a href="#思路-amp-题解-4" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span>(<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> row = <span class="keyword">new</span> <span class="built_in">Array</span>(i + <span class="number">1</span>).fill(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; row.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            row[j] = ret[i - <span class="number">1</span>][j - <span class="number">1</span>] + ret[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ret.push(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul>
<li>时间复杂度：O*(*numRows^2)。</li>
<li>空间复杂度：O(1)。不考虑返回值的空间占用。</li>
</ul>
<h2 id="LeetCode557——反转字符串（☆）"><a href="#LeetCode557——反转字符串（☆）" class="headerlink" title="LeetCode557——反转字符串（☆）"></a>LeetCode557——反转字符串（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">跳转地址</a></p>
<h3 id="自己的代码-9"><a href="#自己的代码-9" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">var</span> s1=<span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] !== <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">      arr.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s1=s1+arr.reverse().join(<span class="string">&quot;&quot;</span>)+<span class="string">&quot; &quot;</span>;</span><br><span class="line">      arr=[]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  s1=s1+arr.reverse().join(<span class="string">&quot;&quot;</span>)+<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> s1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>磨磨蹭蹭写了半天才做对，还是api没用精啊。</p>
<h3 id="思路-amp-题解-5"><a href="#思路-amp-题解-5" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li><code>split</code>字符串 转 单词数组</li>
<li><code>map</code>修改每个单词 = 单词 转 数组 <code>reverse</code> 转 单词</li>
<li><code>join</code>单词数组 转 字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27; &#x27;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)).join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以后每做一道题得先想清楚思路了，这道题如果想清楚，先分割成单词，再把每个单词分割成字母，再反转，再连接，很快就行了。</p>
<h2 id="LeetCode283——移动零（☆）"><a href="#LeetCode283——移动零（☆）" class="headerlink" title="LeetCode283——移动零（☆）"></a>LeetCode283——移动零（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">跳转地址</a></p>
<h3 id="自己的代码-10"><a href="#自己的代码-10" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length; i--;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>);</span><br><span class="line">      nums.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不难，主要是优化：每次执行 splice 相当于把 i 后的数都向前移一位，时间复杂度O(n)， for 循环也是O(n)，所以代码时间复杂度为O(n^2)。</p>
<h3 id="思路-amp-题解-6"><a href="#思路-amp-题解-6" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：</p>
<ol>
<li>左指针左边均为非零数；</li>
<li>右指针左边直到左指针处均为零。</li>
<li>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = nums.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">          [nums[left],nums[right]]=[nums[right],nums[left]]</span><br><span class="line">          left++;</span><br><span class="line">      &#125;</span><br><span class="line">      right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 另一种解法</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== <span class="number">0</span>)&#123;</span><br><span class="line">            nums[pos++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)，其中 n 为序列长度。每个位置至多被遍历两次。</li>
<li>空间复杂度：O(1)。只需要常数的空间存放若干变量</li>
</ul>
<h2 id="LeetCode70——爬楼梯（☆）"><a href="#LeetCode70——爬楼梯（☆）" class="headerlink" title="LeetCode70——爬楼梯（☆）"></a>LeetCode70——爬楼梯（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">跳转地址</a></p>
<h3 id="自己的代码-11"><a href="#自己的代码-11" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全不会，没有一点思路。</p>
<h3 id="思路-amp-题解-7"><a href="#思路-amp-题解-7" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>动态规划：（？！）分成多个子问题<strong>（找最近重复子问题）</strong>，爬第 n 阶楼梯的方法数量，等于 2 部分之和：</p>
<ul>
<li>爬上 n-1 阶楼梯的方法数量。因为再爬 1 阶就能到第 n 阶</li>
<li>爬上 n-2 阶楼梯的方法数量。因为再爬 2 阶就能到第 n 阶</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 压缩空间：dp[i] 只与过去的两项：dp[i-1] 和 dp[i-2] 有关，没有必要存下所有计算过的 dp 项。所以用两个变量去存这两个过去的状态就好。</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="number">0</span>, f2 = <span class="number">1</span>, f3;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span> ; i++) &#123;</span><br><span class="line">    f3 = f1 + f2;</span><br><span class="line">    f1 = f2;</span><br><span class="line">    f2 = f3; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O（n）</p>
<h2 id="LeetCode15——三数之和（☆☆-高频老题）"><a href="#LeetCode15——三数之和（☆☆-高频老题）" class="headerlink" title="LeetCode15——三数之和（☆☆ 高频老题）"></a>LeetCode15——三数之和（☆☆ 高频老题）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">跳转地址</a></p>
<h3 id="自己的代码-12"><a href="#自己的代码-12" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num, arr = [], res = [];</span><br><span class="line">  nums = nums.sort();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">      num = <span class="number">0</span> - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">if</span> (nums.indexOf(num) &gt; j) &#123;</span><br><span class="line">        arr.push(nums[i]);</span><br><span class="line">        arr.push(nums[j]);</span><br><span class="line">        arr.push(num);</span><br><span class="line">        res.push(arr);</span><br><span class="line">        arr = [];</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没过，if() 中的逻辑有点懵了，不知道如何去重。</p>
<h3 id="思路1-amp-题解-3"><a href="#思路1-amp-题解-3" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>三重循环（这竟然没想到）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123; </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = j + <span class="number">1</span>; k &lt; nums.length; k++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="number">0</span>) &#123; </span><br><span class="line">          res.push([nums[i], nums[j], nums[k]])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-7"><a href="#复杂度分析-7" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(n^3)，n 为数组长度</li>
</ul>
<h3 id="思路2-amp-题解-3"><a href="#思路2-amp-题解-3" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>首先对数组排序！太重要了。（自己写的时候到最后才想到这一点）</p>
<ul>
<li>排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集。</li>
<li>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环。</li>
<li>如果 nums[i] = nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过。</li>
<li>当 sum = 0 时，nums[L] = nums[L+1] 则会导致结果重复，应该跳过，L++。</li>
<li>当 sum = 0 时，nums[R] = nums[R-1] 则会导致结果重复，应该跳过，R−−。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> length = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (nums === <span class="literal">null</span> || length &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> L = i + <span class="number">1</span>, R = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        ans.push([nums[i], nums[L], nums[R]]);</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] === nums[L + <span class="number">1</span>]) L++;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] === nums[R - <span class="number">1</span>]) R--;</span><br><span class="line">        L++;</span><br><span class="line">        R--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        L++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        R--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-8"><a href="#复杂度分析-8" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(n^2)，n 为数组长度</li>
</ul>
<h3 id="思路3-amp-题解-3"><a href="#思路3-amp-题解-3" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>哈希表（todo）</p>
<h2 id="LeetCode11——盛最多水的容器（☆☆）"><a href="#LeetCode11——盛最多水的容器（☆☆）" class="headerlink" title="LeetCode11——盛最多水的容器（☆☆）"></a>LeetCode11——盛最多水的容器（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">跳转地址</a></p>
<h3 id="自己的代码-13"><a href="#自己的代码-13" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>, len = height.length, sum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">      sum = <span class="built_in">Math</span>.min(height[i], height[j]) * (j - i);</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, sum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>暴破，但是过不了因为时间限制了。（看到题目后只有这一种想法了，不知道如何优化时间复杂度）</p>
<h3 id="思路-amp-题解-8"><a href="#思路-amp-题解-8" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：左右边界 i，j 向中间收敛。<strong>（两根柱子，肯定是双指针）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>, len = height.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; i &lt; j;)&#123;</span><br><span class="line">    <span class="comment">// 每个循环找到两个柱子中最短的, 挪动最短的柱子(这样面积才有可能变大).</span></span><br><span class="line">    <span class="keyword">let</span> minHeight = height[i] &lt; height[j] ? height[i++] : height[j--];</span><br><span class="line">    <span class="keyword">let</span> area = minHeight * (j - i + <span class="number">1</span>);</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, area);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样也能遍历每一种情况，且只是单循环。（自己对双指针是真不了解）</p>
<h3 id="复杂度分享"><a href="#复杂度分享" class="headerlink" title="复杂度分享"></a>复杂度分享</h3><ul>
<li>时间复杂度：O(N)，双指针总计最多遍历整个数组一次。</li>
<li>空间复杂度：O(1)，只需要额外的常数级别的空间。</li>
</ul>
<h2 id="LeetCode189——旋转数组（☆☆）"><a href="#LeetCode189——旋转数组（☆☆）" class="headerlink" title="LeetCode189——旋转数组（☆☆）"></a>LeetCode189——旋转数组（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">跳转地址</a></p>
<h3 id="自己的代码-14"><a href="#自己的代码-14" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">    nums.unshift(nums[len-<span class="number">1</span>])</span><br><span class="line">    nums.pop(len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只能想到pop加unshift这一种方法了，还过不了（超出时间限制）。题目要求最好用三种方法实现=-=我太菜了。</p>
<h3 id="思路1-amp-题解-4"><a href="#思路1-amp-题解-4" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>使用额外的数组：</strong>原来题目要求的空间复杂度O(1)是思考题，害，只能怪自己读题不仔细了。这方法简单（不贴了）。</p>
<h3 id="复杂度分析-9"><a href="#复杂度分析-9" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul>
<li>时间复杂度： O(n)，其中 n 为数组的长度。</li>
<li>空间复杂度： O(n)。</li>
</ul>
<h3 id="思路2-amp-题解-4"><a href="#思路2-amp-题解-4" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>数组翻转：太巧妙了！</p>
<ol>
<li>首先对整个数组实行翻转，这样子原数组中需要翻转的子数组，就会跑到数组最前面。</li>
<li>这时候，从 k<em>k</em> 处分隔数组，左右两数组，各自进行翻转即可。</li>
</ol>
<p><img src="https://i.loli.net/2021/06/19/7lAjQBuiYGXET6d.jpg" alt="Snipaste_2021-06-19_16-25-58.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">nums, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    [nums[start++],nums[end--]]=[nums[end],nums[start]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  k = k % nums;</span><br><span class="line">  reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, k, nums.length-<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>k = k % nums;</code>也很关键，容易遗忘。</p>
<h3 id="复杂度分析-10"><a href="#复杂度分析-10" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：O(n)，其中 nn 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)=O(n)。</p>
</li>
<li><p>空间复杂度：O(1)。</p>
</li>
</ul>
<h3 id="思路3-amp-题解-4"><a href="#思路3-amp-题解-4" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>对于数组nums,向右移动k位移，等价于将原数组第nums.length-k位置到末尾移动到前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    k = k%nums.length</span><br><span class="line">    nums.unshift(...nums.splice(nums.length-k))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原来真的可以一两行代码实现。做的时候也有想到如何把后面一堆统一移动到前面。 <strong>splice</strong> 这个方法一定要掌握啊！</p>
<h2 id="LeetCode217——存在重复元素（☆）"><a href="#LeetCode217——存在重复元素（☆）" class="headerlink" title="LeetCode217——存在重复元素（☆）"></a>LeetCode217——存在重复元素（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/">跳转地址</a></p>
<h3 id="自己的代码-15"><a href="#自己的代码-15" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.indexOf(nums[i])!==i) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>做出来问题不大，但是时间复杂度竟然达到了 O(n^2)！以后写代码一定要注意啊。（indexOf按顺序遍历列表，时间复杂度为O(n)）</p>
<h3 id="思路1-amp-题解-5"><a href="#思路1-amp-题解-5" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>先将数组排序，然后再遍历判断。（为什么做题的时候想不到呢）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-11"><a href="#复杂度分析-11" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：O(NlogN)，其中 NN 为数组的长度。需要对数组进行排序。（时间复杂度太高了！）</p>
</li>
<li><p>空间复杂度：O(logN)，其中 NN 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。</p>
</li>
</ul>
<h3 id="思路2-amp-题解-5"><a href="#思路2-amp-题解-5" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>哈希表:</p>
<ol>
<li>创建一个哈希表，然后从左往右遍历数组。</li>
<li>检测哈希表中是否已存在当前字符，若存在，直接返回结果，若不存在，将当前字符加入哈希表，供后续判断使用即可。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.set(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-12"><a href="#复杂度分析-12" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul>
<li>时间复杂度：O(N)，其中 N 为数组的长度。</li>
<li>空间复杂度：O(N)，其中 N 为数组的长度。</li>
</ul>
<h2 id="LeetCode136——只出现一次的数字（☆）"><a href="#LeetCode136——只出现一次的数字（☆）" class="headerlink" title="LeetCode136——只出现一次的数字（☆）"></a>LeetCode136——只出现一次的数字（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">跳转地址</a></p>
<h3 id="自己的代码-16"><a href="#自己的代码-16" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">    arr[i] +=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>感觉思维永远是小学生思维，什么时候才能写出像标答一样的代码啊。</p>
<h3 id="思路1-amp-题解-6"><a href="#思路1-amp-题解-6" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>排序后比较，老生常谈了。</p>
<h3 id="思路2-amp-题解-6"><a href="#思路2-amp-题解-6" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>利用map Hash映射</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">        map.set(item, map.has(item) ? map.get(item) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">        <span class="keyword">if</span>(val === <span class="number">1</span>) <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>但是这样空间复杂度为O(n)，时间复杂度 O(n)</p>
<h3 id="思路3-amp-题解-5"><a href="#思路3-amp-题解-5" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>异或运算：</p>
<ul>
<li>一个数和 0 做 XOR 运算等于本身：a⊕0 = a</li>
<li>一个数和其本身做 XOR 运算等于 0：a⊕a = 0</li>
<li>XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</li>
<li>将所有数字按照顺序做异或运算，最后剩下的结果即为唯一的数字</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        ans ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span> pre ^ cur);</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-13"><a href="#复杂度分析-13" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h2 id="LeetCode350——两个数组的交集-II（☆）"><a href="#LeetCode350——两个数组的交集-II（☆）" class="headerlink" title="LeetCode350——两个数组的交集 II（☆）"></a>LeetCode350——两个数组的交集 II（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">跳转地址</a></p>
<h3 id="自己的代码-17"><a href="#自己的代码-17" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intersect = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr1 = [],arr2=[],arr=[];</span><br><span class="line">  arr1 = nums1.length &lt; nums2.length ? [...nums1] : [...nums2];</span><br><span class="line">  arr2 = nums1.length &lt; nums2.length ? [...nums2] : [...nums1];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr2.indexOf(arr1[i]) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(arr1[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr  <span class="comment">// [1,2] [1,1]=&gt;[1,1]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发现到现在遇到 <strong>判断数组中的某个值是否存在</strong> 还是只会 indexOf ，而这个api感觉不太有用，比如这里没法判断重复 [1,2] [1,1]=&gt;[1]。</p>
<p>突然发现，自己的第3、4行代码好傻。<code> if (nums1.length &lt; nums2.length) [nums1, nums2] = [nums2, nums1];</code> 这不香吗？</p>
<h3 id="思路-amp-题解-9"><a href="#思路-amp-题解-9" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：先行将数组排序，方便查找，然后正式流程如下：</p>
<ol>
<li>创建一个指针 i 指向 nums1 数组首位，指针 j 指向 nums2 数组首位。</li>
<li>创建一个临时栈，用于存放结果集。</li>
<li>开始比较指针 i 和指针 j 的值大小，若两个值不等，则数字小的指针，往右移一位。</li>
<li>若指针 i 和指针 j 的值相等，则将交集压入栈。</li>
<li>若 nums 或 nums2 有一方遍历结束，代表另一方的剩余值，都是唯一存在，且不会与之产生交集的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intersect = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    nums2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = [];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; nums1.length &amp;&amp; r &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[l] === nums2[r]) &#123;</span><br><span class="line">            ans.push(nums1[l]);</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125; <span class="keyword">else</span> nums1[l] &lt; nums2[r] ? l++ : r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我为什么这么不愿意先排序数组啊。明明一行代码久能搞定的事。</p>
<blockquote>
<p>有一个疑问：<code>nums1.sort((a, b) =&gt; a - b);</code>和<code>nums1.sort()</code>有什么区别呢？为什么改成后面的就过不了？</p>
</blockquote>
<h3 id="思路2-amp-题解-7"><a href="#思路2-amp-题解-7" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>看完网上的，发现自己之前的代码也能实现。O(n^2)暴破：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[];</span><br><span class="line">  <span class="keyword">if</span> (nums1.length &lt; nums2.length) [nums1, nums2] = [nums2, nums1]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums2.indexOf(nums1[i]);</span><br><span class="line">    <span class="keyword">if</span> ( n!== -<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(...nums2.splice(n,<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> arr </span><br></pre></td></tr></table></figure>

<p>之前败在arr的长度问题，其实用splice对nums2进行缩减就完全没问题了。注意需要用…拓展运算符将得到的数组变成字符。</p>
<h3 id="思路3-amp-题解-6"><a href="#思路3-amp-题解-6" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>哈希表：(还没仔细看)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intersect = <span class="function">(<span class="params">nums1, nums2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num1 <span class="keyword">of</span> nums1) &#123; <span class="comment">// 记录nums1各个数字的出现次数</span></span><br><span class="line">    <span class="keyword">if</span> (map[num1]) &#123;</span><br><span class="line">      map[num1]++;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">      map[num1] = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num2 <span class="keyword">of</span> nums2) &#123; <span class="comment">// 遍历nums2，看看有没有数字在nums1出现过</span></span><br><span class="line">    <span class="keyword">const</span> val = map[num2];</span><br><span class="line">    <span class="keyword">if</span> (val &gt; <span class="number">0</span>) &#123;            <span class="comment">// 有出现过</span></span><br><span class="line">      res.push(num2);         <span class="comment">// 推入res数组</span></span><br><span class="line">      map[num2]--;            <span class="comment">// 匹配掉一个，就减一个</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode66——加一（☆）"><a href="#LeetCode66——加一（☆）" class="headerlink" title="LeetCode66——加一（☆）"></a>LeetCode66——加一（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">跳转地址</a></p>
<h3 id="自己的代码-18"><a href="#自己的代码-18" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">parseInt</span>(digits.join(<span class="string">&quot;&quot;</span>))+<span class="number">1</span>+<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    digits[i] = <span class="built_in">parseInt</span>(s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> digits</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没想到看起来这么简单的一道题目，被卡死了。。看到题目第一眼就是直接对数组最后一位+1，但是没考虑到9。然后又想判断是否为9，对前一位+1，但存在个位数，没有index为-1的情况。</p>
<p>然后换了种方法，数组先变字符串再变数字+1，再变字符串，拆分为数组，最后得到数字数组，但是parseInt有最大限制，用Float也不行。</p>
<h3 id="思路-amp-题解-10"><a href="#思路-amp-题解-10" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>总结一下可能会遇到的问题：</p>
<ol>
<li>当前位是否需要进位？</li>
<li>数字长度是否会改变？</li>
</ol>
<p><del>（为啥这么快就能抓住题目精髓啊）</del></p>
<p>流程如下：</p>
<ol>
<li>首先将数字转为数组形式，便于数据处理。</li>
<li>数组末位数字加 11，然后开始倒序遍历数组。</li>
<li>判断当前位数字是否需要进位，做出对应处理。</li>
<li>遍历数组完毕，若还存在进位，则数组首位添加 11 即可。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    digits[digits.length-<span class="number">1</span>] ++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag) digits[i]++;</span><br><span class="line">        flag = digits[i] &gt; <span class="number">9</span>;</span><br><span class="line">        digits[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) digits.unshift(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> digits;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面的方法其实也一样</span></span><br><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        digits[i]++</span><br><span class="line">        digits[i] = digits[i] % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> (digits[i]) <span class="keyword">return</span> digits</span><br><span class="line">    &#125;</span><br><span class="line">    digits.unshift(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode36——有效的数独（☆☆）"><a href="#LeetCode36——有效的数独（☆☆）" class="headerlink" title="LeetCode36——有效的数独（☆☆）"></a>LeetCode36——有效的数独（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku/">跳转地址</a></p>
<h3 id="自己的代码-19"><a href="#自己的代码-19" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全没法做这道题目，这是啥啊？感觉符合规则1、2就已经好麻烦了，不知道怎么下手。</p>
<h3 id="思路1-amp-题解-7"><a href="#思路1-amp-题解-7" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>利用map的has来判断。先把横竖验了，再验块状。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mapRow = <span class="keyword">new</span> <span class="built_in">Map</span>(), mapColumn = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">    mapRow.clear();</span><br><span class="line">    mapColumn.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (mapRow.has(board[i][j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (mapColumn.has(board[j][i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] !== <span class="string">&quot;.&quot;</span>) &#123; mapRow.set(board[i][j], j) &#125;</span><br><span class="line">      <span class="keyword">if</span> (board[j][i] !== <span class="string">&quot;.&quot;</span>) &#123; mapColumn.set(board[j][i], i) &#125; <span class="comment">// set后面的i、j只是值，甚至可以常量</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (m &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">9</span>) &#123;</span><br><span class="line">      map.clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; n + <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = m; j &lt; m + <span class="number">3</span>; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (map.has(board[i][j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(board[i][j]!==<span class="string">&quot;.&quot;</span>)&#123; map.set(board[i][j],i) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      n+=<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    m+=<span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-14"><a href="#复杂度分析-14" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h3 id="思路2-amp-题解-8"><a href="#思路2-amp-题解-8" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>用 Set 更方便些。（注意题目只要求对已有数字进行验证！）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">        col = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">        box = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> _row = board[i][j];</span><br><span class="line">      <span class="keyword">let</span> _col = board[j][i];</span><br><span class="line">      <span class="comment">// 使用 i、j 对3*3的框进行迭代</span></span><br><span class="line">      <span class="keyword">let</span> _box = board[<span class="number">3</span>*<span class="built_in">Math</span>.floor(i/<span class="number">3</span>)+<span class="built_in">Math</span>.floor(j/<span class="number">3</span>)][<span class="number">3</span>*(i%<span class="number">3</span>)+(j%<span class="number">3</span>)]</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (_row != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row.has(_row)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        row.add(_row);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (_col != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col.has(_col)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        col.add(_col);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (_box != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (box.has(_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        box.add(_box);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode88——合并两个有序数组（☆）"><a href="#LeetCode88——合并两个有序数组（☆）" class="headerlink" title="LeetCode88——合并两个有序数组（☆）"></a>LeetCode88——合并两个有序数组（☆）</h2><p>跳转地址</p>
<h3 id="自己的代码-20"><a href="#自己的代码-20" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  nums1.splice(m, n, ...nums2);</span><br><span class="line">  nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>套用 api 还是挺容易实现的。但是时间复杂度为O(nlogn) （n=&gt;m+n）</p>
<h3 id="思路-amp-题解-11"><a href="#思路-amp-题解-11" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>在 nums1 后面不断插入当前最大值，直到 nums2 为空。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> insertPos = m + n - <span class="number">1</span>;</span><br><span class="line">  m--, n--;</span><br><span class="line">  <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    nums1[insertPos--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-15"><a href="#复杂度分析-15" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O（n）</p>
<h2 id="LeetCode22——括号生成（☆☆）"><a href="#LeetCode22——括号生成（☆☆）" class="headerlink" title="LeetCode22——括号生成（☆☆）"></a>LeetCode22——括号生成（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">跳转地址</a></p>
<h3 id="自己的代码-21"><a href="#自己的代码-21" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">left, right, n, str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (left === n &amp;&amp; right === n) &#123;</span><br><span class="line">      res.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.单层逻辑 两个 if 就是剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n) generate(left + <span class="number">1</span>, right, n, str + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) generate(left, right+<span class="number">1</span>, n, str + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  generate(<span class="number">0</span>, <span class="number">0</span>, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，递归实现。</p>
<h2 id="LeetCode169——多数元素（☆）"><a href="#LeetCode169——多数元素（☆）" class="headerlink" title="LeetCode169——多数元素（☆）"></a>LeetCode169——多数元素（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">跳转地址</a></p>
<h3 id="自己的代码-22"><a href="#自己的代码-22" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> map = [];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (map[nums[i]]) &#123;</span><br><span class="line">			map[nums[i]]++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			map[nums[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">in</span> map) &#123;</span><br><span class="line">		<span class="keyword">if</span> (map[c] &gt; nums.length / <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> map[c];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，但是很臃肿</p>
<h3 id="思路1-amp-题解-8"><a href="#思路1-amp-题解-8" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 学习！</span></span><br><span class="line">        obj[nums[i]] = obj[nums[i]] + <span class="number">1</span> || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj[nums[i]] &gt; nums.length / <span class="number">2</span>)  <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完全可以简化如上所示。</p>
<h3 id="思路2-amp-题解-9"><a href="#思路2-amp-题解-9" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>排序。因为大于一半, 所以排序后的中间那个数即是。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  	nums.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a - b)</span><br><span class="line">  	<span class="keyword">return</span> nums[<span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串简介"><a href="#字符串简介" class="headerlink" title="字符串简介"></a>字符串简介</h2><p>1.字符串的基本操作对象通常是<strong>字符串整体或者其子串</strong>。例如，一句话中每个单词就叫做字符串的「子串」</p>
<p>2.字符串操作比其他数据类型更复杂（例如比较、连接操作）</p>
<h2 id="LeetCode14——最长公共前缀（☆）"><a href="#LeetCode14——最长公共前缀（☆）" class="headerlink" title="LeetCode14——最长公共前缀（☆）"></a>LeetCode14——最长公共前缀（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">跳转地址</a></p>
<h3 id="自己的代码-23"><a href="#自己的代码-23" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> n = strs.length;</span><br><span class="line"><span class="keyword">var</span> count </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;strs[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  a = strs[<span class="number">0</span>][i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs[j].indexOf(a) == i) &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count==n-<span class="number">1</span>) &#123;</span><br><span class="line">    str1 = str1 + a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str1 == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真的又臭又长啊。还过不了，硬罗列总会有考虑不到的地方。为什么做题老是想不到用一些<strong>js内置方法</strong>解决呢。（比如这题的substr）</p>
<p>easy题卡了半个多小时哇。。</p>
<h3 id="思路1-amp-题解-9"><a href="#思路1-amp-题解-9" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴力求解：先对数组排序，看最小长度的字符串有没有在其他两个中，没有的话就减少一位。但是复杂度很高。</p>
<h3 id="思路2-amp-题解-10"><a href="#思路2-amp-题解-10" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs === <span class="literal">null</span> || strs.leng === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; strs.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j].charAt(i) !== c) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 或者直接 for of</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] !== strs[<span class="number">0</span>][i]) <span class="keyword">return</span> s.slice(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接用字符串下标的方法按位比较啊！为啥要把字符串的第x位取出来然后和下一个的第x位比较呢？</p>
<p>还有，可以先两两比较，再在下一个循环中两两比较，不用一次性对循环中的所有字符串判断啊。</p>
<h3 id="复杂度分析-16"><a href="#复杂度分析-16" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O(n)，n 为所有字符串的长度之和</li>
</ul>
<h2 id="LeetCode5——最长回文子串（☆☆）"><a href="#LeetCode5——最长回文子串（☆☆）" class="headerlink" title="LeetCode5——最长回文子串（☆☆）"></a>LeetCode5——最长回文子串（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">跳转地址</a></p>
<h3 id="自己的代码-24"><a href="#自己的代码-24" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>这下子是没有一点思路了。。</p>
<h3 id="思路-amp-题解-12"><a href="#思路-amp-题解-12" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>好像是道动态规划的题目，看了一些题解看不懂哇。。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/chao-jian-dan-de-zhong-xin-kuo-san-fa-yi-qini/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/chao-jian-dan-de-zhong-xin-kuo-san-fa-yi-qini/</a> 占个坑以后再看。</p>
<h2 id="LeetCode151——翻转字符串里的单词（☆☆）"><a href="#LeetCode151——翻转字符串里的单词（☆☆）" class="headerlink" title="LeetCode151——翻转字符串里的单词（☆☆）"></a>LeetCode151——翻转字符串里的单词（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">跳转地址</a></p>
<h3 id="自己的代码-25"><a href="#自己的代码-25" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s=s.trim()</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">  <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">  <span class="keyword">var</span> count=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span> ) &#123;</span><br><span class="line">      a.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i + <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      arr[count++]=a.join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      a=[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[count]=a.join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> arr.reverse().join(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果真让自己想，肯定做不出来，因为过程中找了怎么将数组连接字符串，怎么往数组中添加字符等等。甚至还尝试了二维数组，只能说掌握太不好了。</p>
<h3 id="思路1-amp-题解-10"><a href="#思路1-amp-题解-10" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ol>
<li>使用 <code>split</code> 将字符串按空格分割成字符串数组；</li>
<li>使用 <code>reverse</code> 将字符串数组进行反转；</li>
<li>使用 <code>join</code> 方法将字符串数组拼成一个字符串。</li>
</ol>
<p><img src="https://i.loli.net/2021/06/14/ZiC1kM2E9msTIKF.jpg" alt="Snipaste_2021-06-14_15-14-36.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正则</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="regexp">/\s+/</span>).reverse().join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤器</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以用 filter(Boolean)</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v != <span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>？？？这就是计算机的魅力吗？</p>
<h3 id="复杂度分析-17"><a href="#复杂度分析-17" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul>
<li>时间复杂度：O(N)，其中 N 为输入字符串的长度。</li>
<li>空间复杂度：O(N)，用来存储字符串分割之后的结果。</li>
</ul>
<h3 id="思路2-amp-题解-11"><a href="#思路2-amp-题解-11" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>双端队列（不使用 API）</strong>（两端都可以进队的队列）</p>
<ul>
<li>首先去除字符串左右空格</li>
<li>逐个读取字符串中的每个单词，依次放入双端队列的对头</li>
<li>再将队列转换成字符串输出（已空格为分隔符）</li>
</ul>
<p><img src="https://i.loli.net/2021/06/14/25jGUv4EWdwrqnT.jpg" alt="Snipaste_2021-06-14_15-22-42.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    <span class="keyword">let</span> word = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (s.charAt(left) === <span class="string">&#x27; &#x27;</span>) left ++</span><br><span class="line">    <span class="keyword">while</span> (s.charAt(right) === <span class="string">&#x27; &#x27;</span>) right --</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> char = s.charAt(left)</span><br><span class="line">        <span class="keyword">if</span> (char === <span class="string">&#x27; &#x27;</span> &amp;&amp; word) &#123;</span><br><span class="line">            queue.unshift(word)</span><br><span class="line">            word = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char !== <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            word += char</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    queue.unshift(word)</span><br><span class="line">    <span class="keyword">return</span> queue.join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过unshift插入队列头部，其实跟自己写的<code>arr[count]</code>挺像。</p>
<p>通过charAt得到字符串的字符，好像也可以用s[i]。</p>
<h2 id="LeetCode387——字符串中的第一个唯一字符（☆）"><a href="#LeetCode387——字符串中的第一个唯一字符（☆）" class="headerlink" title="LeetCode387——字符串中的第一个唯一字符（☆）"></a>LeetCode387——字符串中的第一个唯一字符（☆）</h2><p>跳转地址</p>
<h3 id="自己的代码-26"><a href="#自己的代码-26" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    map.set(s[i], <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> x=map.get(s[i])</span><br><span class="line">    map.set(s[i],x+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(s[i]) === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然做出来了，但还是google了“如何让map的值自增”，最后得到7、8行结果。三段循环真又臭又长啊。</p>
<h3 id="思路1-amp-题解-11"><a href="#思路1-amp-题解-11" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ol>
<li>遍历两次字符串，第一次构造哈希map， 存入每个字符出现的次数</li>
<li>第二次判断每个字符次数是否等于1，等于1就返回i</li>
<li>遍历结束，返回-1</li>
</ol>
<p>（和自己最初想的基本一致）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.length;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 三目运算符，简洁多了</span></span><br><span class="line">        map[s[i]] = map[s[i]] ? map[s[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[s[i]] === <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-12"><a href="#思路2-amp-题解-12" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>唯一字符 首次出现索引 <code>=</code> 该字符最后出现索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) </span><br><span class="line">        <span class="keyword">if</span> (s.indexOf(s[i]) === s.lastIndexOf(s[i]))</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode125——验证回文串（☆）"><a href="#LeetCode125——验证回文串（☆）" class="headerlink" title="LeetCode125——验证回文串（☆）"></a>LeetCode125——验证回文串（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">跳转地址</a></p>
<h3 id="自己的代码-27"><a href="#自己的代码-27" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.toLowerCase().split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> n = s.length;</span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/[a-z0-9]/</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pattern.test(s[i])) &#123;</span><br><span class="line">      s.splice(i, <span class="number">1</span>);</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  s = s.join(<span class="string">&quot;&quot;</span>).split(<span class="string">&quot; &quot;</span>).join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor(s.length/<span class="number">2</span>); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] !== s[s.length - i - <span class="number">1</span>]) &#123;</span><br><span class="line">      flag=<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太折磨了。。思路很简单，就是先吧字符串变成全小写的字母，然后一头一尾对比。但是遇到了<strong>各种各样的问题</strong>：以<code>&quot;A man, a plan, a canal: Panama&quot; </code>为例：</p>
<ol>
<li>用split(“”)去了空格，但是还剩下，：等特殊字符串。</li>
<li>用正则匹配，折腾了好久因为第一次使用。后来没看见题目说的数字，案例没通过才加了0-9。</li>
<li>，：等特殊字符使用splice()删除，但是删除后原数组长度变化，因此i需要自减。</li>
<li>操作完后的s是一个数组，join(“”)后变成<code>Aman aplan acanal Panama</code>，还是有空格。所以需要split(“ “) 再join(“”) （好麻烦）</li>
<li>然后又犯了个错误，判断不相等时直接return false了，其实应该用flag=false，最后return flag就行。</li>
</ol>
<h3 id="思路1-amp-题解-12"><a href="#思路1-amp-题解-12" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// s.replace(/\W/g, &quot;&quot;) 也可以这样直接匹配非一个单字字符</span></span><br><span class="line">    <span class="keyword">let</span> strArr = s.replace(<span class="regexp">/[^0-9a-zA-Z]/g</span>,<span class="string">&quot;&quot;</span>).toLowerCase().split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> strArr.join(<span class="string">&#x27;&#x27;</span>) == strArr.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>真的佩服。原来可以用^0-9a-zA-Z选定所有其他字符。而且正则可以直接replace，不用new一个pattern再test。（注意：<strong>只有Array才有reverse()方法，String没法调用</strong>）</p>
<h3 id="思路2-amp-题解-13"><a href="#思路2-amp-题解-13" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>双指针：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s = s.replace(<span class="regexp">/[^0-9a-zA-Z]/g</span>,<span class="string">&#x27;&#x27;</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">let</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>感觉就是败在了第一步。把这一串字符变成全小写字母竟然要花这么大力气，哎！</p>
<h2 id="LeetCode8——字符串转换整数-atoi-（☆☆）"><a href="#LeetCode8——字符串转换整数-atoi-（☆☆）" class="headerlink" title="LeetCode8——字符串转换整数 (atoi)（☆☆）"></a>LeetCode8——字符串转换整数 (atoi)（☆☆）</h2><p>跳转地址</p>
<h3 id="自己的代码-28"><a href="#自己的代码-28" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.trim();</span><br><span class="line">  <span class="keyword">let</span> n = s.length,flag=<span class="literal">true</span>,arr=[],num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isNaN</span>(s[<span class="number">0</span>])) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(s[i])) &#123;</span><br><span class="line">      arr.push(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  num = <span class="built_in">Number</span>(arr.join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="comment">//console.log(num &lt; -Math.pow(2, 31))</span></span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">    num=<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span> - <span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">    num=-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag?<span class="built_in">parseInt</span>(arr.join(<span class="string">&quot;&quot;</span>)):-<span class="built_in">parseInt</span>(arr.join(<span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好纳闷。。不难的一道题目定为medium果然有道理。就不明白了，为啥<code>console.log(num &lt; -Math.pow(2, 31)) =&gt; false</code>，而<code>console.log(-91283472332 &lt; -2147483648) =&gt; true</code> 一模一样结果咋不同？</p>
<p>心态崩了呀，明天再整</p>
<h3 id="思路-amp-题解-13"><a href="#思路-amp-题解-13" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>题目即JavaScript中的<code>parseInt()</code>这一API的转换规则，但这样写面试肯定过不了，考验的是基本功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> number = <span class="built_in">parseInt</span>(str, <span class="number">10</span>); <span class="comment">// 10最好写上，未防止str以&quot;0x&quot;或者&quot;0X&quot;开头或者&quot;0&quot;开头。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(number)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) || number &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> number &lt; <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) ? <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) : <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-14"><a href="#思路2-amp-题解-14" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>挺清晰的，以后要多写写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>, sign = <span class="number">1</span>, total = <span class="number">0</span>, length = str.length;</span><br><span class="line">    <span class="comment">// 1.Empty string</span></span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2.Remove Spaces 因为 str 是 immutable 的, 所以使用 trim 会带来额外的空间</span></span><br><span class="line">    <span class="keyword">while</span> (str.charAt(index) === <span class="string">&#x27; &#x27;</span> &amp;&amp; index &lt; length) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.Handle signs</span></span><br><span class="line">    <span class="keyword">if</span> (str.charAt(index) === <span class="string">&#x27;+&#x27;</span> || str.charAt(index) === <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        sign = str.charAt(index) === <span class="string">&#x27;-&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> MAX_SAFE_32_INT = <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> MIN_SAFE_32_INT = -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.Convert number and avoid overflow</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; length &amp;&amp; str[index].match(<span class="regexp">/[0-9]/</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> digit = str.charAt(index) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (digit &lt; <span class="number">0</span> || digit &gt; <span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// check if total will be overflow after 10 times and add digit</span></span><br><span class="line">        <span class="keyword">if</span> (total &gt; <span class="built_in">Math</span>.floor(MAX_SAFE_32_INT / <span class="number">10</span>) ||</span><br><span class="line">        (total === <span class="built_in">Math</span>.floor(MAX_SAFE_32_INT / <span class="number">10</span>) &amp;&amp; digit &gt; MAX_SAFE_32_INT % <span class="number">10</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (sign === <span class="number">1</span>) ? MAX_SAFE_32_INT  : MIN_SAFE_32_INT ;</span><br><span class="line">        &#125;</span><br><span class="line">        total = total * <span class="number">10</span> + digit;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total * sign;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode38——外观数列（☆☆）"><a href="#LeetCode38——外观数列（☆☆）" class="headerlink" title="LeetCode38——外观数列（☆☆）"></a>LeetCode38——外观数列（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say/">跳转地址</a></p>
<h3 id="自己的代码-29"><a href="#自己的代码-29" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>看见递归就没有思路了。。</p>
<h3 id="思路-amp-题解-14"><a href="#思路-amp-题解-14" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递归+正则：</p>
<ul>
<li>/(\d)\1*/g  这个正则表示，全局匹配，匹配一位数字或者匹配相同的多位数字。 (\d)\1匹配两个连续数字字符，因为\1是对(\d)的引用。 *修饰\1，表示可以有0或多个。</li>
<li>对n-1时产生的数组，用 length+值  确定n的数组。比如，[‘21’]=&gt;’2’的length+’2’  +  ‘1’的length+’1’=&gt;’1211’</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countAndSay = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> temp = countAndSay(n-<span class="number">1</span>).match(<span class="regexp">/(\d)\1*/g</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        result += (temp[i].length + <span class="string">&#x27;&#x27;</span> + temp[i].substring(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode58——最后一个单词的长度（☆）"><a href="#LeetCode58——最后一个单词的长度（☆）" class="headerlink" title="LeetCode58——最后一个单词的长度（☆）"></a>LeetCode58——最后一个单词的长度（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/to-lower-case/">跳转地址</a></p>
<h3 id="思路-amp-题解-15"><a href="#思路-amp-题解-15" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="string">&quot; &quot;</span>).pop().length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这类题目一定要熟练运用 api 啦。</p>
<h2 id="LeetCode541——反转字符串-II（☆）"><a href="#LeetCode541——反转字符串-II（☆）" class="headerlink" title="LeetCode541——反转字符串 II（☆）"></a>LeetCode541——反转字符串 II（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string-ii/">跳转地址</a></p>
<p>还是不熟练啊。</p>
<h3 id="思路-amp-题解-16"><a href="#思路-amp-题解-16" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseStr = <span class="function"><span class="keyword">function</span> (<span class="params">s, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">        res += s.slice(i, i + k).split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) + s.slice(i + k, i + <span class="number">2</span> * k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode49——字母异位词分组（☆☆）"><a href="#LeetCode49——字母异位词分组（☆☆）" class="headerlink" title="LeetCode49——字母异位词分组（☆☆）"></a>LeetCode49——字母异位词分组（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">跳转地址</a></p>
<h3 id="自己的代码-30"><a href="#自己的代码-30" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> strs) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = i.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    map[str] ? map[str].push(i) : map[str] = [i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> map) &#123;</span><br><span class="line">    res.push(map[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode438——找到字符串中所有字母异位词（☆☆）"><a href="#LeetCode438——找到字符串中所有字母异位词（☆☆）" class="headerlink" title="LeetCode438——找到字符串中所有字母异位词（☆☆）"></a>LeetCode438——找到字符串中所有字母异位词（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">跳转地址</a></p>
<h3 id="思路1-amp-题解-13"><a href="#思路1-amp-题解-13" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findAnagrams = <span class="function"><span class="keyword">function</span>(<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (p.length &gt; s.length) <span class="keyword">return</span> result;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = p.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(left &lt; s.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = s.substring(left,right);</span><br><span class="line">    <span class="keyword">if</span> ( tmp.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>) === p.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>))&#123;</span><br><span class="line">      result.push(left);</span><br><span class="line">    &#125;</span><br><span class="line">    left++;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然超时，但是其他题解真看不懂诶。。</p>
<h3 id="思路2-amp-题解（to-understand）"><a href="#思路2-amp-题解（to-understand）" class="headerlink" title="思路2&amp;题解（to understand）"></a>思路2&amp;题解（to understand）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> findAnagrams = <span class="function">(<span class="params">s, p</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [], neededChars = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> p) &#123;</span><br><span class="line">        neededChars[char] ? neededChars[char]++ : neededChars[char] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> count = p.length </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (neededChars[s[right]] &gt; <span class="number">0</span>) count--;</span><br><span class="line">        neededChars[s[right]]--;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">0</span>) output.push(left);</span><br><span class="line">        <span class="keyword">if</span> (right - left == p.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (neededChars[s[left]] &gt;= <span class="number">0</span>) count++;</span><br><span class="line">            neededChars[s[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode680——验证回文字符串-Ⅱ（☆）"><a href="#LeetCode680——验证回文字符串-Ⅱ（☆）" class="headerlink" title="LeetCode680——验证回文字符串 Ⅱ（☆）"></a>LeetCode680——验证回文字符串 Ⅱ（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/">跳转地址</a></p>
<p>好难啊。</p>
<h3 id="思路-amp-题解-17"><a href="#思路-amp-题解-17" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> validPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s, flag = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[left] === s[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validPalindrome(s.slice(left, right), <span class="literal">true</span>) || validPalindrome(s.slice(left + <span class="number">1</span>, right + <span class="number">1</span>), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode5——最长回文子串（☆）"><a href="#LeetCode5——最长回文子串（☆）" class="headerlink" title="LeetCode5——最长回文子串（☆）"></a>LeetCode5——最长回文子串（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">跳转地址</a></p>
<h3 id="自己的代码-31"><a href="#自己的代码-31" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = s.length-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">let</span> newStr = s.slice(i, j);</span><br><span class="line">            <span class="keyword">if</span> (newStr.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) === newStr &amp;&amp; count &lt; j - i) &#123;</span><br><span class="line">                count = j - i;</span><br><span class="line">                res = newStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC，超时了。</p>
<h3 id="思路-amp-题解-18"><a href="#思路-amp-题解-18" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><h1 id="链表部分"><a href="#链表部分" class="headerlink" title="链表部分"></a>链表部分</h1><h2 id="LeetCode141——环形链表（☆）"><a href="#LeetCode141——环形链表（☆）" class="headerlink" title="LeetCode141——环形链表（☆）"></a>LeetCode141——环形链表（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">跳转地址</a></p>
<h3 id="自己的代码-32"><a href="#自己的代码-32" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>正常做法就是创建空数组（或set），然后遍历判断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.has(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路1-amp-题解-14"><a href="#思路1-amp-题解-14" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>污链表法</strong>：在 Javascript 里面定义的任何数据结构，其类型都是 object。这意味着，可以给一个对象设定任何属性。我们为每次遍历的节点设定一个标记，如果存在环，那么一定存在某个节点已经设定过标记。否则链表遍历结束其不为环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.flag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head.flag = <span class="literal">true</span>;</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-15"><a href="#思路2-amp-题解-15" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>快慢指针：</strong></p>
<ul>
<li>定义“快指针 fastp”、“慢指针 slowp”，<strong>“快指针”总比“慢指针”快一步</strong>。</li>
<li>进入环形链表，当 fastp === slowp，说明“快指针”追上了“慢指针”。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slowp = head, fastp = head;</span><br><span class="line">    <span class="keyword">while</span> (fastp.next !== <span class="literal">null</span> &amp;&amp; fastp.next.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        slowp = slowp.next;</span><br><span class="line">        fastp = fastp.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slowp === fastp) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode160——相交链表（☆）"><a href="#LeetCode160——相交链表（☆）" class="headerlink" title="LeetCode160——相交链表（☆）"></a>LeetCode160——相交链表（☆）</h2><p>跳转地址</p>
<h3 id="自己的代码-33"><a href="#自己的代码-33" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>没有思路，双指针遍历也不会做。</p>
<h3 id="思路1-amp-题解-15"><a href="#思路1-amp-题解-15" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>哈希集合</strong></p>
<p>首先遍历链表 headA，并将每个节点加入哈希集合（Set）。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p>
<ul>
<li><p>如果当前节点不在哈希集合中，则继续遍历下一个节点；</p>
</li>
<li><p>如果当前节点在哈希集合中，<strong>则后面的节点都在哈希集合中</strong>（应该是不会出现分叉的情况），即从当前节点开始的所有节点都在两个链表的相交部分，因此返回第一个相交节点。</p>
</li>
<li><p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span> (<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">while</span> (headA) &#123;</span><br><span class="line">        visited.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.has(headB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-18"><a href="#复杂度分析-18" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。</p>
<p>空间复杂度：O(m)，其中 m 是链表 headA 的长度。需要使用哈希集合存储链表 headA 中的全部节点。</p>
<h3 id="思路2-amp-题解-16"><a href="#思路2-amp-题解-16" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>双指针</strong>：**”错的人就算走过了对方的路也还是会错过”**</p>
<p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p>
<p>当链表 headA 和 headB 都不为空时，创建两个头指针 pA 和 pB，依次遍历两个链表的每个节点：</p>
<ul>
<li><p>每步操作需要同时更新指针 pA 和 pB。</p>
</li>
<li><p>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p>
</li>
<li><p>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p>
</li>
<li><p>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA === <span class="literal">null</span> || headB === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pA = headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA !== pB) &#123;</span><br><span class="line">        pA = pA === <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB === <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-19"><a href="#复杂度分析-19" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p>
<p>空间复杂度：O(1)。</p>
<h2 id="LeetCode206——反转链表（☆）"><a href="#LeetCode206——反转链表（☆）" class="headerlink" title="LeetCode206——反转链表（☆）"></a>LeetCode206——反转链表（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">跳转地址</a></p>
<h3 id="自己的代码-34"><a href="#自己的代码-34" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">while</span> (head !== <span class="literal">null</span>) &#123;</span><br><span class="line">        arr.unshift(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i].next=arr[i+<span class="number">1</span>].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC。瞎写，没想到这是双向链表题。</p>
<h3 id="思路-amp-题解-19"><a href="#思路-amp-题解-19" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>迭代：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/discuss/1449712/Easy-C%2B%2BJavaPythonJavaScript-Explained%2BAnimated">=&gt;动画</a></p>
<ul>
<li>定义“前指针prev”、“当前指针curr”、“后指针next”</li>
<li>对原始链表每个节点：<ul>
<li>首先将 next 初始化为 curr 之后的节点。即（n=cur-&gt;next）。</li>
<li>然后让 curr-&gt;next 指向 prev（下一个节点指针）。</li>
<li>然后让 prev 现在指向（前面一个节点）cur 节点。</li>
<li>最后将 cur 也向前移动一个节点到 next。</li>
</ul>
</li>
<li><strong>最后返回 prev，即可获得整条反向链表</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>, curr = head, next = head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line">	<span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    	[curr.next, prev, curr] = [prev, curr, curr.next];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-17"><a href="#思路2-amp-题解-17" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function">(<span class="params">cur, prev = <span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cur) <span class="keyword">return</span> prev;</span><br><span class="line">  <span class="keyword">const</span> next = cur.next;</span><br><span class="line">  cur.next = prev;</span><br><span class="line">  <span class="keyword">return</span> reverseList(next, cur);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode21——合并两个有序链表（☆）"><a href="#LeetCode21——合并两个有序链表（☆）" class="headerlink" title="LeetCode21——合并两个有序链表（☆）"></a>LeetCode21——合并两个有序链表（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">跳转地址</a></p>
<h3 id="自己的代码-35"><a href="#自己的代码-35" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。。有太多种情况，难道都用 if 判断吗？（不开辟新的空间前提下）</p>
<h3 id="思路-amp-题解-20"><a href="#思路-amp-题解-20" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递归：</p>
<ul>
<li>返回值：每一层调用都返回排序好的链表头</li>
<li>终止条件：l1 为空或 l2 为空时结束</li>
<li>单层递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l1 === <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span> (l2 === <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">  <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-18"><a href="#思路2-amp-题解-18" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>开辟新空间：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mergedHead = &#123; <span class="attr">val</span> : -<span class="number">1</span>, <span class="attr">next</span> : <span class="literal">null</span> &#125;,</span><br><span class="line">        crt = mergedHead;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &gt; l2.val) &#123;</span><br><span class="line">            crt.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            crt.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        crt = crt.next;</span><br><span class="line">    &#125;</span><br><span class="line">    crt.next = l1 || l2;</span><br><span class="line">    <span class="keyword">return</span> mergedHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode24——两两交换链表中的节点（☆☆）"><a href="#LeetCode24——两两交换链表中的节点（☆☆）" class="headerlink" title="LeetCode24——两两交换链表中的节点（☆☆）"></a>LeetCode24——两两交换链表中的节点（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">跳转地址</a></p>
<h3 id="自己的代码-36"><a href="#自己的代码-36" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head, res = curr.next;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = curr.next;</span><br><span class="line">    curr.next = next.next;</span><br><span class="line">    next.next = curr;</span><br><span class="line">    curr = next.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没过。逻辑上应该没问题啊。</p>
<h3 id="思路1-amp-题解-16"><a href="#思路1-amp-题解-16" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>迭代：</p>
<ul>
<li>设置虚拟头结点 dummy，因为真实头结点要换人，设置了 dummy 后，dummy.next 就能找到头结点。<strong>（想不到）</strong></li>
<li>开启 while 循环，一对结点的交换有三个指针要改变。<img src="https://i.loli.net/2021/08/12/IUrsqcJ4azfjdCW.png" alt="image.png"></li>
<li>指针推进，准备交换下一对结点。</li>
<li>最后返回 dummy.next 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> prev = dummy;</span><br><span class="line">  <span class="keyword">while</span> (head &amp;&amp; head.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = head.next;</span><br><span class="line">    <span class="comment">// 三步完成一对交换</span></span><br><span class="line">    head.next = next.next;</span><br><span class="line">    next.next = head;</span><br><span class="line">    prev.next = next;</span><br><span class="line">	<span class="comment">// 指针更新</span></span><br><span class="line">    prev = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-19"><a href="#思路2-amp-题解-19" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：</p>
<ul>
<li>交换当前两个节点</li>
<li>递归并连接两组节点。将第三个节点作为递归的参数，<strong>上一组尾部连接下一组头部</strong>(递归返回的值)。</li>
<li>终结条件。当节点为 null 或节点的下一个节点为 null 时，无法交换，递归结束。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">var</span> v1 = head, v2 = head.next, v3 = v2.next;</span><br><span class="line">    v2.next = v1;</span><br><span class="line">    v1.next = swapPairs(v3);</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode25——K-个一组翻转链表（☆☆☆）"><a href="#LeetCode25——K-个一组翻转链表（☆☆☆）" class="headerlink" title="LeetCode25——K 个一组翻转链表（☆☆☆）"></a>LeetCode25——K 个一组翻转链表（☆☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">跳转地址</a></p>
<h3 id="自己的代码-37"><a href="#自己的代码-37" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。思路是在翻转链表的基础上传 k ，但是不知道如何在主函数中调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>, curr = head, next = head;</span><br><span class="line">  <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    next = curr.next;</span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路-amp-题解-21"><a href="#思路-amp-题解-21" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>不需要在反转链表中传 k 值。在 reverseKGroup 函数中通过循环找到首尾节点（head、tail 的间隔就是 k 值），再通过递归，上一组的尾节点链接下一组的头结点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseKGroup</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> tail = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">    tail = tail.next;</span><br><span class="line">    <span class="keyword">if</span> (!tail) <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> next = tail.next;</span><br><span class="line">  tail.next = <span class="literal">null</span>;</span><br><span class="line">  reverse(head);</span><br><span class="line">  <span class="comment">// 此时 head 为上一组尾节点，next 为下一组头结点</span></span><br><span class="line">  head.next = reverseKGroup(next, k);</span><br><span class="line">  <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">curr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">var</span> next = curr.next;</span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

































</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/06/09/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E9%93%BE%E8%A1%A8/">https://asura1211.github.io/2021/06/09/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E7%BB%84%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E9%93%BE%E8%A1%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E7%BB%84/">数组</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"><img class="prev-cover" src="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【数据结构】— — 栈和队列</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20pink%E8%80%81%E5%B8%88js%E8%BF%9B%E9%98%B6/"><img class="next-cover" src="https://i.loli.net/2021/06/07/3boUIdzwVjvaMu6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【阅读笔记】— — pink老师js进阶</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%83%A8%E5%88%86"><span class="toc-number">2.</span> <span class="toc-text">数组部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">数组定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%A0%B9%E6%8D%AE%E4%B8%8B%E6%A0%87%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">数组是如何实现根据下标随机访问数组元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E6%95%88%E7%9A%84%E2%80%9C%E6%8F%92%E5%85%A5%E2%80%9D%E5%92%8C%E2%80%9C%E5%88%A0%E9%99%A4%E2%80%9D"><span class="toc-number">2.1.2.</span> <span class="toc-text">低效的“插入”和“删除”</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.3.</span> <span class="toc-text">数组的访问越界问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%A4%9A%E6%95%B0%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%EF%BC%8C%E6%95%B0%E7%BB%84%E4%BB%8E-0-%E5%BC%80%E5%A7%8B%E7%BC%96%E5%8F%B7%E5%91%A2%EF%BC%9F"><span class="toc-number">2.1.4.</span> <span class="toc-text">为什么大多数编程语言中，数组从 0 开始编号呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode724%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">LeetCode724——寻找数组的中心索引（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.2.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode56%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">LeetCode56——合并区间（☆☆）（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.3.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.3.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.3.5.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode2015%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E5%90%8C48%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">LeetCode2015——旋转矩阵（☆☆）（同48旋转图像）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">2.4.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">2.4.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">2.4.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">2.4.5.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">2.4.6.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode2016%E2%80%94%E2%80%94%E9%9B%B6%E7%9F%A9%E9%98%B5%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">LeetCode2016——零矩阵（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.5.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode498%E2%80%94%E2%80%94%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">LeetCode498——对角线遍历（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-4"><span class="toc-number">2.6.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">2.6.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode561%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">LeetCode561——数组拆分 I（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-5"><span class="toc-number">2.7.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.7.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-number">2.7.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode167%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">LeetCode167——两数之和 II - 输入有序数组（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-6"><span class="toc-number">2.8.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.8.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.8.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.8.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode209%E2%80%94%E2%80%94%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">LeetCode209——长度最小的子数组（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-7"><span class="toc-number">2.9.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">2.9.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.9.3.</span> <span class="toc-text">算法复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode118%E2%80%94%E2%80%94%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">LeetCode118——杨辉三角（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-8"><span class="toc-number">2.10.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">2.10.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-5"><span class="toc-number">2.10.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode557%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">LeetCode557——反转字符串（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-9"><span class="toc-number">2.11.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">2.11.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode283%E2%80%94%E2%80%94%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.12.</span> <span class="toc-text">LeetCode283——移动零（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-10"><span class="toc-number">2.12.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">2.12.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode70%E2%80%94%E2%80%94%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.13.</span> <span class="toc-text">LeetCode70——爬楼梯（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-11"><span class="toc-number">2.13.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">2.13.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-6"><span class="toc-number">2.13.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode15%E2%80%94%E2%80%94%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E2%98%86%E2%98%86-%E9%AB%98%E9%A2%91%E8%80%81%E9%A2%98%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">LeetCode15——三数之和（☆☆ 高频老题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-12"><span class="toc-number">2.14.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">2.14.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-7"><span class="toc-number">2.14.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">2.14.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-8"><span class="toc-number">2.14.5.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">2.14.6.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode11%E2%80%94%E2%80%94%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.15.</span> <span class="toc-text">LeetCode11——盛最多水的容器（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-13"><span class="toc-number">2.15.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">2.15.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E4%BA%AB"><span class="toc-number">2.15.3.</span> <span class="toc-text">复杂度分享</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode189%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.16.</span> <span class="toc-text">LeetCode189——旋转数组（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-14"><span class="toc-number">2.16.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">2.16.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-9"><span class="toc-number">2.16.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">2.16.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-10"><span class="toc-number">2.16.5.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">2.16.6.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode217%E2%80%94%E2%80%94%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.17.</span> <span class="toc-text">LeetCode217——存在重复元素（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-15"><span class="toc-number">2.17.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">2.17.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-11"><span class="toc-number">2.17.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">2.17.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-12"><span class="toc-number">2.17.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode136%E2%80%94%E2%80%94%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.18.</span> <span class="toc-text">LeetCode136——只出现一次的数字（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-16"><span class="toc-number">2.18.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">2.18.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">2.18.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">2.18.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-13"><span class="toc-number">2.18.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode350%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.19.</span> <span class="toc-text">LeetCode350——两个数组的交集 II（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-17"><span class="toc-number">2.19.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">2.19.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">2.19.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">2.19.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode66%E2%80%94%E2%80%94%E5%8A%A0%E4%B8%80%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.20.</span> <span class="toc-text">LeetCode66——加一（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-18"><span class="toc-number">2.20.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">2.20.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode36%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.21.</span> <span class="toc-text">LeetCode36——有效的数独（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-19"><span class="toc-number">2.21.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">2.21.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-14"><span class="toc-number">2.21.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">2.21.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode88%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.22.</span> <span class="toc-text">LeetCode88——合并两个有序数组（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-20"><span class="toc-number">2.22.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-11"><span class="toc-number">2.22.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-15"><span class="toc-number">2.22.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode22%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.23.</span> <span class="toc-text">LeetCode22——括号生成（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-21"><span class="toc-number">2.23.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode169%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.24.</span> <span class="toc-text">LeetCode169——多数元素（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-22"><span class="toc-number">2.24.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">2.24.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">2.24.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">字符串简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode14%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">LeetCode14——最长公共前缀（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-23"><span class="toc-number">3.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">3.2.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">3.2.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-16"><span class="toc-number">3.2.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode5%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">LeetCode5——最长回文子串（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-24"><span class="toc-number">3.3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-12"><span class="toc-number">3.3.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode151%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">LeetCode151——翻转字符串里的单词（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-25"><span class="toc-number">3.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">3.4.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-17"><span class="toc-number">3.4.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-11"><span class="toc-number">3.4.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode387%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">LeetCode387——字符串中的第一个唯一字符（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-26"><span class="toc-number">3.5.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-11"><span class="toc-number">3.5.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-12"><span class="toc-number">3.5.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode125%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">LeetCode125——验证回文串（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-27"><span class="toc-number">3.6.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-12"><span class="toc-number">3.6.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-13"><span class="toc-number">3.6.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode8%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi-%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">LeetCode8——字符串转换整数 (atoi)（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-28"><span class="toc-number">3.7.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-13"><span class="toc-number">3.7.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-14"><span class="toc-number">3.7.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode38%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">LeetCode38——外观数列（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-29"><span class="toc-number">3.8.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-14"><span class="toc-number">3.8.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode58%E2%80%94%E2%80%94%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.9.</span> <span class="toc-text">LeetCode58——最后一个单词的长度（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-15"><span class="toc-number">3.9.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode541%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.10.</span> <span class="toc-text">LeetCode541——反转字符串 II（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-16"><span class="toc-number">3.10.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode49%E2%80%94%E2%80%94%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">3.11.</span> <span class="toc-text">LeetCode49——字母异位词分组（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-30"><span class="toc-number">3.11.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode438%E2%80%94%E2%80%94%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">3.12.</span> <span class="toc-text">LeetCode438——找到字符串中所有字母异位词（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-13"><span class="toc-number">3.12.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3%EF%BC%88to-understand%EF%BC%89"><span class="toc-number">3.12.2.</span> <span class="toc-text">思路2&amp;题解（to understand）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode680%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%85%A1%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.13.</span> <span class="toc-text">LeetCode680——验证回文字符串 Ⅱ（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-17"><span class="toc-number">3.13.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode5%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.14.</span> <span class="toc-text">LeetCode5——最长回文子串（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-31"><span class="toc-number">3.14.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-18"><span class="toc-number">3.14.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E9%83%A8%E5%88%86"><span class="toc-number">4.</span> <span class="toc-text">链表部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode141%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">LeetCode141——环形链表（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-32"><span class="toc-number">4.1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-14"><span class="toc-number">4.1.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-15"><span class="toc-number">4.1.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode160%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">LeetCode160——相交链表（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-33"><span class="toc-number">4.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-15"><span class="toc-number">4.2.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-18"><span class="toc-number">4.2.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-16"><span class="toc-number">4.2.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-19"><span class="toc-number">4.2.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode206%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">LeetCode206——反转链表（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-34"><span class="toc-number">4.3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-19"><span class="toc-number">4.3.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-17"><span class="toc-number">4.3.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode21%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">LeetCode21——合并两个有序链表（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-35"><span class="toc-number">4.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-20"><span class="toc-number">4.4.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-18"><span class="toc-number">4.4.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode24%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">LeetCode24——两两交换链表中的节点（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-36"><span class="toc-number">4.5.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-16"><span class="toc-number">4.5.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-19"><span class="toc-number">4.5.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode25%E2%80%94%E2%80%94K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">LeetCode25——K 个一组翻转链表（☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-37"><span class="toc-number">4.6.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-21"><span class="toc-number">4.6.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家社区商城"/></a><div class="content"><a class="title" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城">【项目复盘】— — 贤得家社区商城</a><time datetime="2021-10-31T15:01:17.000Z" title="发表于 2021-10-31 23:01:17">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 常见问题"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题">【面试准备】— — 常见问题</a><time datetime="2021-10-11T14:03:14.000Z" title="发表于 2021-10-11 22:03:14">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 前端综合篇"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇">【面试准备】— — 前端综合篇</a><time datetime="2021-10-11T12:53:49.000Z" title="发表于 2021-10-11 20:53:49">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>