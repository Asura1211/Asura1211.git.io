<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【基本功】— — 数据结构 | 青山の博客</title><meta name="keywords" content="数组"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文记录的是 LeetCode 的题目和自己的刷题过程。 数组低效的“插入”和“删除”插入操作假设数组的长度为 n，如果将一个数据插入到数组中的第 k 个位置。我们需将第 k～n 这部分的元素都顺序地往后挪一位。 如果在数组的末尾插入元素，那就不需要移动数据，时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。 因为每个位置插入">
<meta property="og:type" content="article">
<meta property="og:title" content="【基本功】— — 数据结构">
<meta property="og:url" content="https://asura1211.github.io/2021/06/09/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文记录的是 LeetCode 的题目和自己的刷题过程。 数组低效的“插入”和“删除”插入操作假设数组的长度为 n，如果将一个数据插入到数组中的第 k 个位置。我们需将第 k～n 这部分的元素都顺序地往后挪一位。 如果在数组的末尾插入元素，那就不需要移动数据，时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。 因为每个位置插入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg">
<meta property="article:published_time" content="2021-06-09T22:05:49.000Z">
<meta property="article:modified_time" content="2021-12-07T14:11:45.710Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="数组">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/06/09/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【基本功】— — 数据结构',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-07 22:11:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【基本功】— — 数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-09T22:05:49.000Z" title="发表于 2021-06-10 06:05:49">2021-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-07T14:11:45.710Z" title="更新于 2021-12-07 22:11:45">2021-12-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>96分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【基本功】— — 数据结构"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="https://i.loli.net/2021/10/14/FhG1sJ8bnKCSRXP.png" alt="数据结构副本.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录的是 LeetCode 的题目和自己的刷题过程。</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h2><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a><strong>插入</strong>操作</h3><p>假设数组的长度为 n，如果将一个数据插入到数组中的第 k 个位置。我们需将第 k～n 这部分的元素都顺序地往后挪一位。</p>
<p>如果在数组的末尾插入元素，那就不需要移动数据，时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，最坏时间复杂度是 O(n)。 因为每个位置插入元素的概率一样，所以平均时间复杂度为 (1+2+…n)/n=O(n)。</p>
<p><strong>还有一个简单的办法</strong>:直接将第 k 位的数据移到数组元素的最后，把新的元素直接放入第 k 个位置，这样时间复杂度就会降为 O(1)。</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><strong>删除操作</strong></h3><p>和插入类似，如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。</p>
<p><strong>提高效率的方法：</strong>为了避免剩余数据多次搬移，我们可以先记录已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p>
<h2 id="LeetCode1——两数之和（☆）（★）"><a href="#LeetCode1——两数之和（☆）（★）" class="headerlink" title="LeetCode1——两数之和（☆）（★）"></a>LeetCode1——两数之和（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum/">跳转地址</a></p>
<h3 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;=nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target)&#123;</span><br><span class="line">                <span class="keyword">var</span> result=[]</span><br><span class="line">                result[<span class="number">0</span>]=i</span><br><span class="line">                result[<span class="number">1</span>]=j</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，但时间复杂度O(n^2)</p>
<h3 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>利用 map</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        x = target - nums[i]</span><br><span class="line">        <span class="keyword">if</span>(map.has(x)) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map.get(x),i]</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(nums[i],i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode167——两数之和-II-输入有序数组（☆）"><a href="#LeetCode167——两数之和-II-输入有序数组（☆）" class="headerlink" title="LeetCode167——两数之和 II - 输入有序数组（☆）"></a>LeetCode167——两数之和 II - 输入有序数组（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">跳转地址</a></p>
<h3 id="自己的代码-1"><a href="#自己的代码-1" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">var</span> n,a</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">    n = target - numbers[i];</span><br><span class="line">    a=numbers.indexOf(n)</span><br><span class="line">    <span class="keyword">if</span> (a!=-<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(i+<span class="number">1</span>);</span><br><span class="line">      arr.push(a + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用了indexOf 果然错了。看到题解上有人说“印象深刻，现在还记得，第一看好简单，马上就用 indexOf 写了，然后肯定没通过，泪目。现在看，那时候不仅没注意复杂度的问题，而且逻辑上也有些问题，没有考虑 target 由 numbers 有两个相同是数组成的情况。”</p>
<p>害，涨涨经验把。</p>
<h3 id="思路1-amp-题解"><a href="#思路1-amp-题解" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ul>
<li>声明一个数组 a 记录每个 numbers 中的元素与 target 直接的差值。</li>
<li>如果：x+y=target，那么 target-x=y，target-y=x</li>
<li>当遍历到满足要求的值直接返回，不然存贮对应的差值到 a 的对应索引位置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span> (<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = numbers.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = target - numbers[i]</span><br><span class="line">    <span class="keyword">if</span> (a[tmp] !== <span class="literal">undefined</span>) <span class="keyword">return</span> [a[tmp] + <span class="number">1</span>, i + <span class="number">1</span>]</span><br><span class="line">    a[numbers[i]] = i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法好巧妙啊=</p>
<h3 id="思路2-amp-题解"><a href="#思路2-amp-题解" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>强行遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] === target) &#123;</span><br><span class="line">                <span class="keyword">return</span> [i + <span class="number">1</span>, j + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路3-amp-题解"><a href="#思路3-amp-题解" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>双指针：</p>
<ol>
<li>定义left、right</li>
<li>遍历过程若nums[left] + nums[right] &gt; target，太大了，要小一点，则right左移一位</li>
<li>遍历过程若nums[left] + nums[right] &lt; target，太小了，要大一点，则left右移一位</li>
<li>其余的情况就是nums[left] + nums[right] == target，return [left + 1, right + 1]即可</li>
<li>注意题目的index从1开始，所以return时+1即可</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function">(<span class="params">nums, target</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [left + <span class="number">1</span>, right + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode724——寻找数组的中心索引（☆）"><a href="#LeetCode724——寻找数组的中心索引（☆）" class="headerlink" title="LeetCode724——寻找数组的中心索引（☆）"></a>LeetCode724——寻找数组的中心索引（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-pivot-index/">跳转地址</a></p>
<h3 id="自己的代码-2"><a href="#自己的代码-2" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">var</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; index; i++)&#123;</span><br><span class="line">            sum1+=nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = index+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            sum2+=nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum1 == sum2) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只想到用循环将前后sum求出来，然后判断。。</p>
<h3 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a><strong>思路</strong>&amp;题解</h3><p>记数组的全部元素之和为 total，当遍历到第 i 个元素时，设其左侧元素之和为 sum，则其右侧元素之和为 total-num_si-sum。左右侧元素相等即为 sum=total-num_si-sum。即 2* sum+num_si=total。</p>
<p>当中心索引左侧或右侧没有元素时，即为零个项相加，称作「空和」（0）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> total = nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span> * sum + nums[i] === total) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n为数组的长度。</p>
<h2 id="LeetCode88——合并两个有序数组（☆）（★★★）"><a href="#LeetCode88——合并两个有序数组（☆）（★★★）" class="headerlink" title="LeetCode88——合并两个有序数组（☆）（★★★）"></a>LeetCode88——合并两个有序数组（☆）（★★★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-sorted-array/">跳转地址</a></p>
<h3 id="思路1-amp-题解-1"><a href="#思路1-amp-题解-1" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>API大法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">  nums1.splice(m, n, ...nums2);</span><br><span class="line">  <span class="keyword">return</span> nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O（(m+n)log(m+n)）</p>
<h3 id="思路2-amp-题解-1"><a href="#思路2-amp-题解-1" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>双指针：在 nums1 后面不断插入当前最大值，直到 nums2 为空。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, m, nums2, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> insertPos = m + n - <span class="number">1</span>;</span><br><span class="line">    m--, n--;</span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[insertPos--] = nums1[m] &gt; nums2[n] ? nums1[m--] : nums2[n--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>O（m+n）</p>
<h2 id="LeetCode56——合并区间（☆☆）（高频）"><a href="#LeetCode56——合并区间（☆☆）（高频）" class="headerlink" title="LeetCode56——合并区间（☆☆）（高频）"></a>LeetCode56——合并区间（☆☆）（高频）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals/">跳转地址</a></p>
<h3 id="自己的代码-3"><a href="#自己的代码-3" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt; intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            arr.push(intervals[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.push([intervals[i][<span class="number">0</span>],intervals[i+<span class="number">1</span>][<span class="number">1</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC，只会对传入的数组进行判断，如果能考虑到思路1那样，对merge的数组进行边界判断就好了。</p>
<h3 id="思路1-amp-题解-2"><a href="#思路1-amp-题解-2" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果传递进来的数组长度为0 返回一个空数组</span></span><br><span class="line">    <span class="keyword">if</span> (intervals.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> res = [intervals[<span class="number">0</span>]]</span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a[<span class="number">0</span>]-b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 从原数组的第一个元素进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 如果当前区间的左端点 大于 merge数组最后一个元素的右端点</span></span><br><span class="line">      <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; res[res.length - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 说明这个数组可以直接放进merge数组中</span></span><br><span class="line">        res.push(intervals[i])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明有区间有交集 当前区间的左端点小于等于最后一个元素的右端点</span></span><br><span class="line">        <span class="comment">// 如果当前区间的右端点 大于 merge 最后一个右端点</span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &gt; res[res.length - <span class="number">1</span>][<span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="comment">// 更新右端点为最大值</span></span><br><span class="line">          res[res.length - <span class="number">1</span>][<span class="number">1</span>] = intervals[i][<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)，其中 n 为区间的数量。除去排序的开销，只需要一次线性扫描。</p>
<h3 id="思路2-amp-题解-2"><a href="#思路2-amp-题解-2" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span> (<span class="params">intervals</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">    intervals.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a[<span class="number">0</span>]-b[<span class="number">0</span>])</span><br><span class="line">    <span class="comment">// 注意这里对同一个数组进行了读写操作</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;intervals.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals[i][<span class="number">1</span>]&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">          <span class="comment">// 根据规律 说明这个区间可以合并</span></span><br><span class="line">           <span class="keyword">const</span> data = [...intervals[i],...intervals[i+<span class="number">1</span>]]</span><br><span class="line">           <span class="keyword">const</span> item = [<span class="built_in">Math</span>.min(...data), <span class="built_in">Math</span>.max(...data)];</span><br><span class="line">            <span class="comment">// 在第i位置删除2个，插入新的item</span></span><br><span class="line">           intervals.splice(i, <span class="number">2</span>, item);</span><br><span class="line">           i--; <span class="comment">// 回退操作 看看新调整的区间是否可以跟后面的合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intervals</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要很扎实的js基础。。。真的很难想到</p>
<h2 id="LeetCode2015——旋转矩阵（☆☆）（★★）"><a href="#LeetCode2015——旋转矩阵（☆☆）（★★）" class="headerlink" title="LeetCode2015——旋转矩阵（☆☆）（★★）"></a>LeetCode2015——旋转矩阵（☆☆）（★★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-matrix-lcci/">跳转地址</a></p>
<h3 id="自己的代码-4"><a href="#自己的代码-4" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr=[]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">    arr[i] = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; matrix.length; j++)&#123;</span><br><span class="line">      arr[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; matrix.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix.length; j++)&#123;</span><br><span class="line">      arr[j][matrix.length-<span class="number">1</span>-i] = matrix[i][j]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><del>感觉没毛病啊？在vscode里能跑出来，可为啥在lc里第一个都过不了呢？</del> </p>
<p>题目说了，不占用额外的内存空间！所以需要<strong>把新的数组复制到原数组</strong>。（然后就过了。。）</p>
<h3 id="思路1-amp-题解-3"><a href="#思路1-amp-题解-3" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = matrix.length;</span><br><span class="line">    <span class="keyword">const</span> matrix_new = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix_new[j][n - i - <span class="number">1</span>] = matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            matrix[i][j] = matrix_new[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>js初始化二维数组：（太巧妙了，不像我那样双重for循环）</p>
<p><code>new Array(n).fill(0).map(() =&gt; new Array(n).fill(0))</code> </p>
</li>
<li><p>把matrix.length的值提早赋值给n，因为后面需要用到多次。提高效率</p>
</li>
</ul>
<p>时间复杂度：O(N^2)，其中 N 是 matrix 的边长。</p>
<h3 id="思路2-amp-题解-3"><a href="#思路2-amp-题解-3" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>用翻转操作代替旋转操作（旋转好难，看不懂就先不写了）</p>
<p>为了直观显示，就直接放lc题解中的图片了。</p>
<p><img src="https://i.loli.net/2021/06/13/rod8EOIMj42X3ya.jpg" alt="Snipaste_2021-06-13_11-26-28.jpg"></p>
<p><img src="https://i.loli.net/2021/06/13/VArObSCjZcaifH7.jpg" alt="Snipaste_2021-06-13_11-27-24.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n = matrix.length;</span><br><span class="line">    <span class="comment">// 水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor(n / <span class="number">2</span>); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            [matrix[i][j], matrix[n - i - <span class="number">1</span>][j]] = [matrix[n - i - <span class="number">1</span>][j], matrix[i][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N^2)，其中 N 是 matrix 的边长。对于每一次翻转操作，我们都需要枚举矩阵中一半的元素。</p>
<h3 id="思路3-amp-题解-1"><a href="#思路3-amp-题解-1" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>倒叙倒置法：先将矩阵转置，然后将每一行row倒序（reserve）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> rotate = <span class="function">(<span class="params">matrix</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> n=matrix.length</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            [matrix[i][j],matrix[j][i]] = [matrix[j][i],matrix[i][j]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    matrix.forEach(<span class="function"><span class="params">row</span>=&gt;</span> row.reverse())</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode2016——零矩阵（☆☆）"><a href="#LeetCode2016——零矩阵（☆☆）" class="headerlink" title="LeetCode2016——零矩阵（☆☆）"></a>LeetCode2016——零矩阵（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zero-matrix-lcci/">跳转地址</a></p>
<h3 id="自己的代码-5"><a href="#自己的代码-5" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> n = matrix.length</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(matrix))  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (matrix[i][j] === <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; matrix[i].length; a++)&#123;</span><br><span class="line">          arr[i][a]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> b = <span class="number">0</span>; b &lt; n; b++)&#123;</span><br><span class="line">          arr[b][j]=<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>

<p>AC 开辟了额外的内存空间，最后需要再赋值回原数组。看题解有不开辟的解法，等以后再看看吧。</p>
<h2 id="LeetCode498——对角线遍历（☆☆）（todo）"><a href="#LeetCode498——对角线遍历（☆☆）（todo）" class="headerlink" title="LeetCode498——对角线遍历（☆☆）（todo）"></a>LeetCode498——对角线遍历（☆☆）（todo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diagonal-traverse/">跳转地址</a></p>
<h3 id="自己的代码-6"><a href="#自己的代码-6" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>是真不会= =感觉应该分两种情况（一个往右上，一个往左下），先找到几条对角线（2n-1），然后相连？但是每种情况交界（向右向下+1）也不一样。</p>
<h3 id="思路-amp-题解-2"><a href="#思路-amp-题解-2" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ol>
<li>只有两种移动方向：<br>右上移动 <code>i-=1; j+=1</code><br>左下移动 <code>i+=1; j-=1</code></li>
<li>处理上下左右编辑问题</li>
<li>越界即转弯</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/diagonal-traverse/solution/dui-jiao-xian-bian-li-chao-jian-dan-while-jie-fa-b/">代码好长</a>，超过50行真的就不想看了aa.</p>
<h2 id="LeetCode561——数组拆分-I（☆）"><a href="#LeetCode561——数组拆分-I（☆）" class="headerlink" title="LeetCode561——数组拆分 I（☆）"></a>LeetCode561——数组拆分 I（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/array-partition-i/">跳转地址</a></p>
<h3 id="自己的代码-7"><a href="#自己的代码-7" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>好像需要实现全排列？但其实最大总和一定是两个最小一组，两个次小一组。。一直到两个最大一组，但是这怎么用代码实现呢？感觉这不该是一道easy，是我太菜了=</p>
<h3 id="思路-amp-题解-3"><a href="#思路-amp-题解-3" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>排序：<img src="https://i.loli.net/2021/06/16/mbS8nil2HVIaUox.jpg" alt="Snipaste_2021-06-16_21-56-57.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayPairSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i += <span class="number">2</span>) &#123;</span><br><span class="line">        ans += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好吧，实在是太巧妙了。想到排序但是没想到累加偶数项就可以了。。</p>
<p>时间复杂度：O(nlogn)，即为对数组 nums 进行排序的时间复杂度。</p>
<h2 id="LeetCode209——长度最小的子数组（☆☆）"><a href="#LeetCode209——长度最小的子数组（☆☆）" class="headerlink" title="LeetCode209——长度最小的子数组（☆☆）"></a>LeetCode209——长度最小的子数组（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">跳转地址</a></p>
<h3 id="自己的代码-8"><a href="#自己的代码-8" class="headerlink" title="自己的代码"></a>自己的代码</h3><p><del>没有头绪= 想的是可以定义一个sum求和函数，然后对nums数组一位、两位进行遍历，但这样很麻烦还实现不了。</del></p>
<p>如果找到一个子数组，如何继续遍历找下一个子数组呢？（从第nums[i]开始？）</p>
<p>没想到思路写着写着就做出来了，虽然用时垫底5%。。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">target, nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> minCount=<span class="number">10000</span></span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (nums.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b) &lt; target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; nums.length; j++)&#123;</span><br><span class="line">      sum += nums[j];</span><br><span class="line">      <span class="keyword">if</span> (sum &gt;= target) &#123;</span><br><span class="line">        count = j - i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (minCount &gt; count) &#123;</span><br><span class="line">          minCount = count;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minCount</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路-amp-题解-4"><a href="#思路-amp-题解-4" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针+滑动窗口：</p>
<p><img src="https://i.loli.net/2021/06/17/RNI5kP2Cxwp9BJa.jpg" alt="Snipaste_2021-06-17_14-48-02.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">s, nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> int_max = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, sum = <span class="number">0</span>, ans = int_max</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> right = <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        sum += nums[right]</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= s) &#123;</span><br><span class="line">            ans = <span class="built_in">Math</span>.min(ans, right - left + <span class="number">1</span>)</span><br><span class="line">            sum -= nums[left++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans === int_max ? <span class="number">0</span> : ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n),每个指针移动都需要O(n) 的时间,每个元素最多被访问2次</p>
<h2 id="LeetCode118——杨辉三角（☆）"><a href="#LeetCode118——杨辉三角（☆）" class="headerlink" title="LeetCode118——杨辉三角（☆）"></a>LeetCode118——杨辉三角（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pascals-triangle/">跳转地址</a></p>
<h3 id="自己的代码-9"><a href="#自己的代码-9" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(numRows)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">    arr[i]=<span class="keyword">new</span> <span class="built_in">Array</span>(i+<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++)&#123;</span><br><span class="line">    arr[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">      arr[i][j] = arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i][i] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其实不难，毕竟easy题。但是看了答案后发现自己多了很多冗余代码，比如创建二维数组，完全可以先 var arr=[]，然后最后再push的方式创建；还有就是不必第一个和最后一个赋值1，可以用fill(1)的方式。</p>
<h3 id="思路-amp-题解-5"><a href="#思路-amp-题解-5" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span>(<span class="params">numRows</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ret = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> row = <span class="keyword">new</span> <span class="built_in">Array</span>(i + <span class="number">1</span>).fill(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; row.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            row[j] = ret[i - <span class="number">1</span>][j - <span class="number">1</span>] + ret[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        ret.push(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O*(*numRows^2)。</p>
<h2 id="LeetCode557——反转字符串（☆）"><a href="#LeetCode557——反转字符串（☆）" class="headerlink" title="LeetCode557——反转字符串（☆）"></a>LeetCode557——反转字符串（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">跳转地址</a></p>
<h3 id="自己的代码-10"><a href="#自己的代码-10" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">var</span> s1=<span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] !== <span class="string">&quot; &quot;</span>) &#123;</span><br><span class="line">      arr.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s1=s1+arr.reverse().join(<span class="string">&quot;&quot;</span>)+<span class="string">&quot; &quot;</span>;</span><br><span class="line">      arr=[]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  s1=s1+arr.reverse().join(<span class="string">&quot;&quot;</span>)+<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> s1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC， 磨磨蹭蹭写了半天才做对，还是api没用精啊。</p>
<h3 id="思路-amp-题解-6"><a href="#思路-amp-题解-6" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><ul>
<li><code>split</code>字符串 转 单词数组</li>
<li><code>map</code>修改每个单词 = 单词 转 数组 <code>reverse</code> 转 单词</li>
<li><code>join</code>单词数组 转 字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27; &#x27;</span>).map(<span class="function"><span class="params">x</span> =&gt;</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)).join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以后每做一道题得先想清楚思路了，这道题如果想清楚，先分割成单词，再把每个单词分割成字母，再反转，再连接，很快就行了。</p>
<h2 id="LeetCode283——移动零（☆）"><a href="#LeetCode283——移动零（☆）" class="headerlink" title="LeetCode283——移动零（☆）"></a>LeetCode283——移动零（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/move-zeroes/">跳转地址</a></p>
<h3 id="自己的代码-11"><a href="#自己的代码-11" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nums.length; i--;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">      nums.splice(i, <span class="number">1</span>);</span><br><span class="line">      nums.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不难，主要是优化：每次执行 splice 相当于把 i 后的数都向前移一位，时间复杂度O(n)， for 循环也是O(n)，所以代码时间复杂度为O(n^2)。</p>
<h3 id="思路-amp-题解-7"><a href="#思路-amp-题解-7" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：</p>
<ol>
<li>左指针左边均为非零数；</li>
<li>右指针左边直到左指针处均为零。</li>
<li>因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = nums.length;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (right &lt; length) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[right]) &#123;</span><br><span class="line">          [nums[left],nums[right]]=[nums[right],nums[left]]</span><br><span class="line">          left++;</span><br><span class="line">      &#125;</span><br><span class="line">      right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 另一种解法</span></span><br><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] !== <span class="number">0</span>)&#123;</span><br><span class="line">            nums[pos++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = pos; i &lt; nums.length; i++) &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 为序列长度。每个位置至多被遍历两次。</p>
<h2 id="LeetCode70——爬楼梯（☆）"><a href="#LeetCode70——爬楼梯（☆）" class="headerlink" title="LeetCode70——爬楼梯（☆）"></a>LeetCode70——爬楼梯（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/climbing-stairs/">跳转地址</a></p>
<h3 id="自己的代码-12"><a href="#自己的代码-12" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全不会，没有一点思路。</p>
<h3 id="思路-amp-题解-8"><a href="#思路-amp-题解-8" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>动态规划：分成多个子问题<strong>（找最近重复子问题）</strong>，爬第 n 阶楼梯的方法数量，等于 2 部分之和：</p>
<ul>
<li>爬上 n-1 阶楼梯的方法数量。因为再爬 1 阶就能到第 n 阶</li>
<li>爬上 n-2 阶楼梯的方法数量。因为再爬 2 阶就能到第 n 阶</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dp = [];</span><br><span class="line">  dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 压缩空间：dp[i] 只与过去的两项：dp[i-1] 和 dp[i-2] 有关，没有必要存下所有计算过的 dp 项。所以用两个变量去存这两个过去的状态就好。</span></span><br><span class="line"><span class="keyword">var</span> climbStairs = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="number">0</span>, f2 = <span class="number">1</span>, f3;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span> ; i++) &#123;</span><br><span class="line">    f3 = f1 + f2;</span><br><span class="line">    f1 = f2;</span><br><span class="line">    f2 = f3; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n）</p>
<h2 id="LeetCode15——三数之和（☆☆-高频）"><a href="#LeetCode15——三数之和（☆☆-高频）" class="headerlink" title="LeetCode15——三数之和（☆☆ 高频）"></a>LeetCode15——三数之和（☆☆ 高频）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/3sum/">跳转地址</a></p>
<h3 id="自己的代码-13"><a href="#自己的代码-13" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num, arr = [], res = [];</span><br><span class="line">  nums = nums.sort();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">      num = <span class="number">0</span> - nums[i] - nums[j];</span><br><span class="line">      <span class="keyword">if</span> (nums.indexOf(num) &gt; j) &#123;</span><br><span class="line">        arr.push(nums[i]);</span><br><span class="line">        arr.push(nums[j]);</span><br><span class="line">        arr.push(num);</span><br><span class="line">        res.push(arr);</span><br><span class="line">        arr = [];</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没过，if() 中的逻辑有点懵了，不知道如何去重。</p>
<h3 id="思路1-amp-题解-4"><a href="#思路1-amp-题解-4" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>三重循环（这竟然没想到）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; nums.length - <span class="number">1</span>; j++) &#123; </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k = j + <span class="number">1</span>; k &lt; nums.length; k++) &#123; </span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] === <span class="number">0</span>) &#123; </span><br><span class="line">          res.push([nums[i], nums[j], nums[k]])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)，n 为数组长度</p>
<h3 id="思路2-amp-题解-4"><a href="#思路2-amp-题解-4" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>首先对数组排序！太重要了。（自己写的时候到最后才想到这一点）</p>
<ul>
<li>排序后固定一个数 nums[i]，再使用左右指针指向 nums[i]后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集。</li>
<li>如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环。</li>
<li>如果 nums[i] = nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过。</li>
<li>当 sum = 0 时，nums[L] = nums[L+1] 则会导致结果重复，应该跳过，L++。</li>
<li>当 sum = 0 时，nums[R] = nums[R-1] 则会导致结果重复，应该跳过，R−−。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> threeSum = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ans = [];</span><br><span class="line">  <span class="keyword">const</span> length = nums.length;</span><br><span class="line">  <span class="keyword">if</span> (nums === <span class="literal">null</span> || length &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">  nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; <span class="keyword">break</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">let</span> L = i + <span class="number">1</span>, R = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">      <span class="keyword">let</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">      <span class="keyword">if</span> (sum === <span class="number">0</span>) &#123;</span><br><span class="line">        ans.push([nums[i], nums[L], nums[R]]);</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] === nums[L + <span class="number">1</span>]) L++;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] === nums[R - <span class="number">1</span>]) R--;</span><br><span class="line">        L++;</span><br><span class="line">        R--;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        L++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        R--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)，n 为数组长度</p>
<h3 id="思路3-amp-题解-2"><a href="#思路3-amp-题解-2" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>哈希表（todo）</p>
<h2 id="LeetCode11——盛最多水的容器（☆☆）"><a href="#LeetCode11——盛最多水的容器（☆☆）" class="headerlink" title="LeetCode11——盛最多水的容器（☆☆）"></a>LeetCode11——盛最多水的容器（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/container-with-most-water/">跳转地址</a></p>
<h3 id="自己的代码-14"><a href="#自己的代码-14" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>, len = height.length, sum;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">      sum = <span class="built_in">Math</span>.min(height[i], height[j]) * (j - i);</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, sum);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>暴破，但是过不了因为时间限制了。（看到题目后只有这一种想法了，不知道如何优化时间复杂度）</p>
<h3 id="思路-amp-题解-9"><a href="#思路-amp-题解-9" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：左右边界 i，j 向中间收敛。<strong>（两根柱子，肯定是双指针）</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>, len = height.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; i &lt; j;)&#123;</span><br><span class="line">    <span class="comment">// 每个循环找到两个柱子中最短的, 挪动最短的柱子(这样面积才有可能变大).</span></span><br><span class="line">    <span class="keyword">let</span> minHeight = height[i] &lt; height[j] ? height[i++] : height[j--];</span><br><span class="line">    <span class="keyword">let</span> area = minHeight * (j - i + <span class="number">1</span>);</span><br><span class="line">    max = <span class="built_in">Math</span>.max(max, area);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样也能遍历每一种情况，且只是单循环。（自己对双指针是真不了解）</p>
<p>时间复杂度：O(N)，双指针总计最多遍历整个数组一次。</p>
<h2 id="LeetCode189——旋转数组（☆☆）"><a href="#LeetCode189——旋转数组（☆☆）" class="headerlink" title="LeetCode189——旋转数组（☆☆）"></a>LeetCode189——旋转数组（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-array/">跳转地址</a></p>
<h3 id="自己的代码-15"><a href="#自己的代码-15" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = nums.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">    nums.unshift(nums[len-<span class="number">1</span>])</span><br><span class="line">    nums.pop(len);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>只能想到pop加unshift这一种方法了，还过不了（超出时间限制）。题目要求最好用三种方法实现=-=我太菜了。</p>
<h3 id="思路1-amp-题解-5"><a href="#思路1-amp-题解-5" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>使用额外的数组：</strong>原来题目要求的空间复杂度O(1)是思考题，害，只能怪自己读题不仔细了。这方法简单（不贴了）。</p>
<p>时间复杂度： O(n)，其中 n 为数组的长度。</p>
<h3 id="思路2-amp-题解-5"><a href="#思路2-amp-题解-5" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>数组翻转：太巧妙了！</p>
<ol>
<li>首先对整个数组实行翻转，这样子原数组中需要翻转的子数组，就会跑到数组最前面。</li>
<li>这时候，从 k 处分隔数组，左右两数组，各自进行翻转即可。</li>
</ol>
<p><img src="https://i.loli.net/2021/06/19/7lAjQBuiYGXET6d.jpg" alt="Snipaste_2021-06-19_16-25-58.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span> (<span class="params">nums, start, end</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">    [nums[start++],nums[end--]]=[nums[end],nums[start]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  k = k % nums;</span><br><span class="line">  reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">  reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> nums</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>k = k % nums;</code>也很关键，容易遗忘。</p>
<p>时间复杂度：O(n)，其中 nn 为数组的长度。每个元素被翻转两次，一共 n 个元素，因此总时间复杂度为 O(2n)=O(n)。</p>
<h3 id="思路3-amp-题解-3"><a href="#思路3-amp-题解-3" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>对于数组nums,向右移动k位移，等价于将原数组第<code>nums.length-k</code>位置到末尾移动到前面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    k = k % nums.length;</span><br><span class="line">    nums.unshift(...nums.splice(nums.length - k));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原来真的可以一两行代码实现。做的时候也有想到如何把后面一堆统一移动到前面。 <strong>splice</strong> 这个方法一定要掌握啊！</p>
<h2 id="LeetCode217——存在重复元素（☆）"><a href="#LeetCode217——存在重复元素（☆）" class="headerlink" title="LeetCode217——存在重复元素（☆）"></a>LeetCode217——存在重复元素（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/contains-duplicate/">跳转地址</a></p>
<h3 id="自己的代码-16"><a href="#自己的代码-16" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = nums.length; i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.indexOf(nums[i])!==i) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>做出来问题不大，但是时间复杂度竟然达到了 O(n^2)！以后写代码一定要注意啊。（indexOf按顺序遍历列表，时间复杂度为O(n)）</p>
<h3 id="思路1-amp-题解-6"><a href="#思路1-amp-题解-6" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>先将数组排序，然后再遍历判断。（为什么做题的时候想不到呢）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">const</span> n = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] === nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(NlogN)，其中 N 为数组的长度。需要对数组进行排序。（时间复杂度太高了！）</p>
<h3 id="思路2-amp-题解-6"><a href="#思路2-amp-题解-6" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>哈希表:</p>
<ol>
<li>创建一个哈希表，然后从左往右遍历数组。</li>
<li>检测哈希表中是否已存在当前字符，若存在，直接返回结果，若不存在，将当前字符加入哈希表，供后续判断使用即可。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map.set(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N)，其中 N 为数组的长度。</p>
<h2 id="LeetCode136——只出现一次的数字（☆）"><a href="#LeetCode136——只出现一次的数字（☆）" class="headerlink" title="LeetCode136——只出现一次的数字（☆）"></a>LeetCode136——只出现一次的数字（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number/">跳转地址</a></p>
<h3 id="自己的代码-17"><a href="#自己的代码-17" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> nums)&#123;</span><br><span class="line">    arr[i] +=<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>感觉思维永远是小学生思维，什么时候才能写出像标答一样的代码啊。</p>
<h3 id="思路1-amp-题解-7"><a href="#思路1-amp-题解-7" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>排序后比较，老生常谈了。</p>
<h3 id="思路2-amp-题解-7"><a href="#思路2-amp-题解-7" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>利用map Hash映射</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    nums.forEach(<span class="function"><span class="params">item</span> =&gt;</span>&#123;</span><br><span class="line">        map.set(item, map.has(item) ? map.get(item) + <span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">        <span class="keyword">if</span>(val === <span class="number">1</span>) <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样空间复杂度为O(n)，时间复杂度 O(n)</p>
<h3 id="思路3-amp-题解-4"><a href="#思路3-amp-题解-4" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>异或运算：</p>
<ul>
<li>一个数和 0 做 XOR 运算等于本身：a⊕0 = a</li>
<li>一个数和其本身做 XOR 运算等于 0：a⊕a = 0</li>
<li>XOR 运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b</li>
<li>将所有数字按照顺序做异或运算，最后剩下的结果即为唯一的数字</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        ans ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> nums.reduce(<span class="function">(<span class="params">pre,cur</span>) =&gt;</span> pre ^ cur);</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，空间复杂度：O(1)</p>
<h2 id="LeetCode350——两个数组的交集-II（☆）"><a href="#LeetCode350——两个数组的交集-II（☆）" class="headerlink" title="LeetCode350——两个数组的交集 II（☆）"></a>LeetCode350——两个数组的交集 II（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">跳转地址</a></p>
<h3 id="自己的代码-18"><a href="#自己的代码-18" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intersect = <span class="function"><span class="keyword">function</span>(<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr1 = [],arr2=[],arr=[];</span><br><span class="line">  arr1 = nums1.length &lt; nums2.length ? [...nums1] : [...nums2];</span><br><span class="line">  arr2 = nums1.length &lt; nums2.length ? [...nums2] : [...nums1];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr2.indexOf(arr1[i]) !== -<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(arr1[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr  <span class="comment">// [1,2] [1,1]=&gt;[1,1]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发现到现在遇到 <strong>判断数组中的某个值是否存在</strong> 还是只会 indexOf ，而这个api感觉不太有用，比如这里没法判断重复 [1,2] [1,1]=&gt;[1]。</p>
<p>突然发现，自己的第3、4行代码好傻。<code> if (nums1.length &lt; nums2.length) [nums1, nums2] = [nums2, nums1];</code> 这不香吗？</p>
<h3 id="思路-amp-题解-10"><a href="#思路-amp-题解-10" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>双指针：先行将数组排序，方便查找，然后正式流程如下：</p>
<ol>
<li>创建一个指针 i 指向 nums1 数组首位，指针 j 指向 nums2 数组首位。</li>
<li>创建一个临时栈，用于存放结果集。</li>
<li>开始比较指针 i 和指针 j 的值大小，若两个值不等，则数字小的指针，往右移一位。</li>
<li>若指针 i 和指针 j 的值相等，则将交集压入栈。</li>
<li>若 nums 或 nums2 有一方遍历结束，代表另一方的剩余值，都是唯一存在，且不会与之产生交集的。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intersect = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    nums1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    nums2.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">0</span>, r = <span class="number">0</span>, ans = [];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; nums1.length &amp;&amp; r &lt; nums2.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1[l] === nums2[r]) &#123;</span><br><span class="line">            ans.push(nums1[l]);</span><br><span class="line">            l++;</span><br><span class="line">            r++;</span><br><span class="line">        &#125; <span class="keyword">else</span> nums1[l] &lt; nums2[r] ? l++ : r++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我为什么这么不愿意先排序数组啊。明明一行代码久能搞定的事。</p>
<blockquote>
<p>有一个疑问：<code>nums1.sort((a, b) =&gt; a - b);</code>和<code>nums1.sort()</code>有什么区别呢？为什么改成后面的就过不了？ A：sort 默认对字符串排序</p>
</blockquote>
<h3 id="思路2-amp-题解-8"><a href="#思路2-amp-题解-8" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>看完网上的，发现自己之前的代码也能实现。O(n^2)暴破：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[];</span><br><span class="line">  <span class="keyword">if</span> (nums1.length &lt; nums2.length) [nums1, nums2] = [nums2, nums1]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums2.indexOf(nums1[i]);</span><br><span class="line">    <span class="keyword">if</span> ( n!== -<span class="number">1</span>) &#123;</span><br><span class="line">      arr.push(...nums2.splice(n,<span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> arr </span><br></pre></td></tr></table></figure>

<p>之前败在arr的长度问题，其实用splice对nums2进行缩减就完全没问题了。注意需要用…拓展运算符将得到的数组变成字符。</p>
<h3 id="思路3-amp-题解-5"><a href="#思路3-amp-题解-5" class="headerlink" title="思路3&amp;题解"></a>思路3&amp;题解</h3><p>哈希表：(还没仔细看)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> intersect = <span class="function">(<span class="params">nums1, nums2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num1 <span class="keyword">of</span> nums1) &#123; <span class="comment">// 记录nums1各个数字的出现次数</span></span><br><span class="line">    <span class="keyword">if</span> (map[num1]) &#123;</span><br><span class="line">      map[num1]++;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">      map[num1] = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> num2 <span class="keyword">of</span> nums2) &#123; <span class="comment">// 遍历nums2，看看有没有数字在nums1出现过</span></span><br><span class="line">    <span class="keyword">const</span> val = map[num2];</span><br><span class="line">    <span class="keyword">if</span> (val &gt; <span class="number">0</span>) &#123;            <span class="comment">// 有出现过</span></span><br><span class="line">      res.push(num2);         <span class="comment">// 推入res数组</span></span><br><span class="line">      map[num2]--;            <span class="comment">// 匹配掉一个，就减一个</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode66——加一（☆）"><a href="#LeetCode66——加一（☆）" class="headerlink" title="LeetCode66——加一（☆）"></a>LeetCode66——加一（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/plus-one/">跳转地址</a></p>
<h3 id="自己的代码-19"><a href="#自己的代码-19" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span> (<span class="params">digits</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = <span class="built_in">parseInt</span>(digits.join(<span class="string">&quot;&quot;</span>))+<span class="number">1</span>+<span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    digits[i] = <span class="built_in">parseInt</span>(s[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> digits</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未 AC。没想到看起来这么简单的一道题目，被卡死了。。看到题目第一眼就是直接对数组最后一位+1，但是没考虑到9。然后又想判断是否为9，对前一位+1，但存在个位数，没有index为-1的情况。</p>
<p>然后换了种方法，数组先变字符串再变数字+1，再变字符串，拆分为数组，最后得到数字数组，但是parseInt有最大限制，用Float也不行。</p>
<h3 id="思路-amp-题解-11"><a href="#思路-amp-题解-11" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>总结一下可能会遇到的问题：</p>
<ol>
<li>当前位是否需要进位？</li>
<li>数字长度是否会改变？</li>
</ol>
<p><del>（为啥这么快就能抓住题目精髓啊）</del></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = digits.length - <span class="number">1</span>; i&gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits[i] &lt; <span class="number">9</span>)&#123;</span><br><span class="line">            digits[i]++</span><br><span class="line">            <span class="keyword">return</span> digits</span><br><span class="line">        &#125;</span><br><span class="line">        digits[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    digits.unshift(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下面的方法其实也一样</span></span><br><span class="line"><span class="keyword">var</span> plusOne = <span class="function"><span class="keyword">function</span>(<span class="params">digits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        digits[i]++</span><br><span class="line">        digits[i] = digits[i] % <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> (digits[i]) <span class="keyword">return</span> digits</span><br><span class="line">    &#125;</span><br><span class="line">    digits.unshift(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> digits</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode36——有效的数独（☆☆）（to-redo）"><a href="#LeetCode36——有效的数独（☆☆）（to-redo）" class="headerlink" title="LeetCode36——有效的数独（☆☆）（to redo）"></a>LeetCode36——有效的数独（☆☆）（to redo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-sudoku/">跳转地址</a></p>
<h3 id="自己的代码-20"><a href="#自己的代码-20" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全没法做这道题目，这是啥啊？感觉符合规则1、2就已经好麻烦了，不知道怎么下手。</p>
<h3 id="思路1-amp-题解-8"><a href="#思路1-amp-题解-8" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>利用map的has来判断。先把横竖验了，再验块状。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> mapRow = <span class="keyword">new</span> <span class="built_in">Map</span>(), mapColumn = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">    mapRow.clear();</span><br><span class="line">    mapColumn.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (mapRow.has(board[i][j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (mapColumn.has(board[j][i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (board[i][j] !== <span class="string">&quot;.&quot;</span>) &#123; mapRow.set(board[i][j], j) &#125;</span><br><span class="line">      <span class="keyword">if</span> (board[j][i] !== <span class="string">&quot;.&quot;</span>) &#123; mapColumn.set(board[j][i], i) &#125; <span class="comment">// set后面的i、j只是值，甚至可以常量</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (m &lt; <span class="number">9</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; <span class="number">9</span>) &#123;</span><br><span class="line">      map.clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = n; i &lt; n + <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = m; j &lt; m + <span class="number">3</span>; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (map.has(board[i][j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">if</span>(board[i][j]!==<span class="string">&quot;.&quot;</span>)&#123; map.set(board[i][j],i) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      n+=<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    m+=<span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h3 id="思路2-amp-题解-9"><a href="#思路2-amp-题解-9" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>用 Set 更方便些。（注意题目只要求对已有数字进行验证！）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidSudoku = <span class="function"><span class="keyword">function</span>(<span class="params">board</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> row = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">        col = <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">        box = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> _row = board[i][j];</span><br><span class="line">      <span class="keyword">let</span> _col = board[j][i];</span><br><span class="line">      <span class="comment">// 使用 i、j 对3*3的框进行迭代</span></span><br><span class="line">      <span class="keyword">let</span> _box = board[<span class="number">3</span>*<span class="built_in">Math</span>.floor(i/<span class="number">3</span>)+<span class="built_in">Math</span>.floor(j/<span class="number">3</span>)][<span class="number">3</span>*(i%<span class="number">3</span>)+(j%<span class="number">3</span>)]</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (_row != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row.has(_row)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        row.add(_row);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (_col != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col.has(_col)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        col.add(_col);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (_box != <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (box.has(_box)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        box.add(_box);</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode22——括号生成（☆☆）"><a href="#LeetCode22——括号生成（☆☆）" class="headerlink" title="LeetCode22——括号生成（☆☆）"></a>LeetCode22——括号生成（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">跳转地址</a></p>
<h3 id="自己的代码-21"><a href="#自己的代码-21" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">let</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params">left, right, n, str</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (left === n &amp;&amp; right === n) &#123;</span><br><span class="line">      res.push(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.单层逻辑 两个 if 就是剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n) generate(left + <span class="number">1</span>, right, n, str + <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) generate(left, right+<span class="number">1</span>, n, str + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  generate(<span class="number">0</span>, <span class="number">0</span>, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，递归实现。</p>
<h2 id="LeetCode169——多数元素（☆）"><a href="#LeetCode169——多数元素（☆）" class="headerlink" title="LeetCode169——多数元素（☆）"></a>LeetCode169——多数元素（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/majority-element/">跳转地址</a></p>
<h3 id="自己的代码-22"><a href="#自己的代码-22" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> map = [];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (map[nums[i]]) &#123;</span><br><span class="line">			map[nums[i]]++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			map[nums[i]] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">in</span> map) &#123;</span><br><span class="line">		<span class="keyword">if</span> (map[c] &gt; nums.length / <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="keyword">return</span> map[c];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，但是很臃肿</p>
<h3 id="思路1-amp-题解-9"><a href="#思路1-amp-题解-9" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 学习！</span></span><br><span class="line">        obj[nums[i]] = obj[nums[i]] + <span class="number">1</span> || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(obj[nums[i]] &gt; nums.length / <span class="number">2</span>)  <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>完全可以简化如上所示。</p>
<h3 id="思路2-amp-题解-10"><a href="#思路2-amp-题解-10" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>排序。因为大于一半, 所以排序后的中间那个数即是。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  	nums.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> a - b)</span><br><span class="line">  	<span class="keyword">return</span> nums[<span class="built_in">Math</span>.floor(nums.length / <span class="number">2</span>)]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-42——连续子数组的最大和（☆）（★★）"><a href="#剑指-Offer-42——连续子数组的最大和（☆）（★★）" class="headerlink" title="剑指 Offer 42——连续子数组的最大和（☆）（★★）"></a>剑指 Offer 42——连续子数组的最大和（☆）（★★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">跳转地址</a></p>
<p>DP:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSubArray = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = [nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = nums[i];</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(...dp);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-03——数组中重复的数字（☆-（★）"><a href="#剑指-Offer-03——数组中重复的数字（☆-（★）" class="headerlink" title="剑指 Offer 03——数组中重复的数字（☆)（★）"></a>剑指 Offer 03——数组中重复的数字（☆)（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">跳转地址</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.get(nums[i])) &#123;</span><br><span class="line">            map.set(nums[i],<span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.has(num))</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        s.add(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC</p>
<h2 id="LeetCode493——翻转对（☆☆☆）"><a href="#LeetCode493——翻转对（☆☆☆）" class="headerlink" title="LeetCode493——翻转对（☆☆☆）"></a>LeetCode493——翻转对（☆☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-pairs/">跳转地址</a></p>
<h3 id="自己的代码-23"><a href="#自己的代码-23" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">2</span> * nums[j]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>毫无疑问超时了。</p>
<h3 id="思路-amp-题解-12"><a href="#思路-amp-题解-12" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p><strong>合并排序：</strong>但是用到 shift，导致数组很大时过不了测试，<a target="_blank" rel="noopener" href="http://stlighter.github.io/2016/06/08/%E5%85%B3%E4%BA%8EJavaScript%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E4%B8%8A%E7%9A%84%E7%96%91%E6%83%91/">具体原因</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reversePairs = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numReversePairs = <span class="number">0</span>; </span><br><span class="line">    mergeSort(nums);</span><br><span class="line">    <span class="keyword">return</span> numReversePairs;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">            left = nums.slice(<span class="number">0</span>, middle),</span><br><span class="line">            right = nums.slice(middle);</span><br><span class="line">        <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result = [];</span><br><span class="line">      <span class="keyword">let</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> rightIndex = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span>(leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">          <span class="keyword">if</span> (left[leftIndex] &gt; <span class="number">2</span> * right[rightIndex]) &#123;</span><br><span class="line">          <span class="comment">// 因为 left 此时已经升序，所以(left.length - leftIndex)里的所有数都比 right[rightIndex] 大。</span></span><br><span class="line">          numReversePairs += (left.length - leftIndex);</span><br><span class="line">          rightIndex++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          leftIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;    </span><br><span class="line">      <span class="keyword">while</span> (left.length &gt; <span class="number">0</span> &amp;&amp; right.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">          result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (left.length) &#123;</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (right.length) &#123;</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因此在合并时，可以用下面代码代替：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">leftIndex = <span class="number">0</span>;</span><br><span class="line">   rightIndex = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">     <span class="keyword">if</span> (left[leftIndex] &lt; right[rightIndex]) &#123;</span><br><span class="line">       nums_sorted.push(left[leftIndex++]);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       nums_sorted.push(right[rightIndex++]);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode718——最长重复子数组（★）"><a href="#LeetCode718——最长重复子数组（★）" class="headerlink" title="LeetCode718——最长重复子数组（★）"></a>LeetCode718——最长重复子数组（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/">跳转地址</a></p>
<h3 id="思路1-amp-题解-10"><a href="#思路1-amp-题解-10" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴力：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> findLength = <span class="function">(<span class="params">A, B</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> m = A.length;</span><br><span class="line">  <span class="keyword">const</span> n = B.length;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (A[i] == B[j]) &#123; </span><br><span class="line">        <span class="keyword">let</span> subLen = <span class="number">1</span>;   </span><br><span class="line">        <span class="comment">//新的一项也相同</span></span><br><span class="line">        <span class="keyword">while</span> (i + subLen &lt; m &amp;&amp; j + subLen &lt; n &amp;&amp; A[i + subLen] == B[j + subLen]) &#123; </span><br><span class="line">          subLen++; </span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">Math</span>.max(subLen, res);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>超时</p>
<h3 id="思路2-amp-题解-11"><a href="#思路2-amp-题解-11" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>DP：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findLength = <span class="function"><span class="keyword">function</span> (<span class="params">nums1, nums2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> m = nums1.length;</span><br><span class="line">    <span class="keyword">let</span> n = nums2.length;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m + <span class="number">1</span>).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] === nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">Math</span>.max(res, dp[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-II-060——出现频率最高的-k-个数字（☆☆）（★todo）"><a href="#剑指-Offer-II-060——出现频率最高的-k-个数字（☆☆）（★todo）" class="headerlink" title="剑指 Offer II 060——出现频率最高的 k 个数字（☆☆）（★todo）"></a>剑指 Offer II 060——出现频率最高的 k 个数字（☆☆）（★todo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/g5c51o/">跳转地址</a></p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="LeetCode14——最长公共前缀（☆）（★）"><a href="#LeetCode14——最长公共前缀（☆）（★）" class="headerlink" title="LeetCode14——最长公共前缀（☆）（★）"></a>LeetCode14——最长公共前缀（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-prefix/">跳转地址</a></p>
<h3 id="自己的代码-24"><a href="#自己的代码-24" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> n = strs.length;</span><br><span class="line"><span class="keyword">var</span> count </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;strs[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">  count = <span class="number">0</span>;</span><br><span class="line">  a = strs[<span class="number">0</span>][i];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs[j].indexOf(a) == i) &#123;</span><br><span class="line">      count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (count==n-<span class="number">1</span>) &#123;</span><br><span class="line">    str1 = str1 + a</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str1 == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真的又臭又长啊。还过不了，硬罗列总会有考虑不到的地方。为什么做题老是想不到用一些<strong>js内置方法</strong>解决呢。（比如这题的substr）</p>
<p>easy题卡了半个多小时哇。。</p>
<h3 id="思路1-amp-题解-11"><a href="#思路1-amp-题解-11" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴力求解：先对数组排序，看最小长度的字符串有没有在其他两个中，没有的话就减少一位。但是复杂度很高。</p>
<h3 id="思路2-amp-题解-12"><a href="#思路2-amp-题解-12" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonPrefix = <span class="function"><span class="keyword">function</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs === <span class="literal">null</span> || strs.leng === <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; strs.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[j].charAt(i) !== c) &#123;</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substr(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 或者直接 for of</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] !== strs[<span class="number">0</span>][i]) <span class="keyword">return</span> s.slice(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>直接用字符串下标的方法按位比较啊！为啥要把字符串的第x位取出来然后和下一个的第x位比较呢？</p>
<p>还有，可以先两两比较，再在下一个循环中两两比较，不用一次性对循环中的所有字符串判断啊。</p>
<p>时间复杂度：O(n)，n 为所有字符串的长度之和</p>
<h2 id="LeetCode5——最长回文子串（☆☆）（to-redo）"><a href="#LeetCode5——最长回文子串（☆☆）（to-redo）" class="headerlink" title="LeetCode5——最长回文子串（☆☆）（to redo）"></a>LeetCode5——最长回文子串（☆☆）（to redo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/">跳转地址</a></p>
<h3 id="自己的代码-25"><a href="#自己的代码-25" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>, res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = s.length-<span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">let</span> newStr = s.slice(i, j);</span><br><span class="line">            <span class="keyword">if</span> (newStr.split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) === newStr &amp;&amp; count &lt; j - i) &#123;</span><br><span class="line">                count = j - i;</span><br><span class="line">                res = newStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC，超时</p>
<h3 id="思路-amp-题解-13"><a href="#思路-amp-题解-13" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>好像是道动态规划的题目，看了一些题解看不懂哇。。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/chao-jian-dan-de-zhong-xin-kuo-san-fa-yi-qini/">https://leetcode-cn.com/problems/longest-palindromic-substring/solution/chao-jian-dan-de-zhong-xin-kuo-san-fa-yi-qini/</a> 占个坑以后再看。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> res = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 回文子串长度是奇数</span></span><br><span class="line">            helper(i, i)</span><br><span class="line">            <span class="comment">// 回文子串长度是偶数</span></span><br><span class="line">            helper(i, i + <span class="number">1</span>) </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">helper</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (m &gt;= <span class="number">0</span> &amp;&amp; n &lt; s.length &amp;&amp; s[m] == s[n]) &#123;</span><br><span class="line">                m--</span><br><span class="line">                n++</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意此处m,n的值循环完后  是恰好不满足循环条件的时刻</span></span><br><span class="line">            <span class="comment">// 此时m到n的距离为n-m+1，但是mn两个边界不能取 所以应该取m+1到n-1的区间  长度是n-m-1</span></span><br><span class="line">            <span class="keyword">if</span> (n - m - <span class="number">1</span> &gt; res.length) &#123;</span><br><span class="line">                <span class="comment">// slice也要取[m+1,n-1]这个区间 </span></span><br><span class="line">                res = s.slice(m + <span class="number">1</span>, n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">const</span> dp = [...new <span class="built_in">Array</span>(s.length + <span class="number">1</span>)].map(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Array</span>(s.length + <span class="number">1</span>).fill(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> lps = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        lps = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] === s[i + <span class="number">1</span>]) dp[i][i+<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(dp[i][i+<span class="number">1</span>]) lps = s.substring(i, i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">2</span>; j &lt; s.length; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] &amp;&amp; s[i] === s[j];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]) lps = lps.length &lt; (j - i + <span class="number">1</span>) ? s.substring(i, j + <span class="number">1</span>) : lps;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode151——翻转字符串里的单词（☆☆）（★★）"><a href="#LeetCode151——翻转字符串里的单词（☆☆）（★★）" class="headerlink" title="LeetCode151——翻转字符串里的单词（☆☆）（★★）"></a>LeetCode151——翻转字符串里的单词（☆☆）（★★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-words-in-a-string/">跳转地址</a></p>
<h3 id="自己的代码-26"><a href="#自己的代码-26" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s=s.trim()</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">  <span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line">  <span class="keyword">var</span> count=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span> ) &#123;</span><br><span class="line">      a.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i + <span class="number">1</span>] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">      arr[count++]=a.join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      a=[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[count]=a.join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">return</span> arr.reverse().join(<span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果真让自己想，肯定做不出来，因为过程中找了怎么将数组连接字符串，怎么往数组中添加字符等等。甚至还尝试了二维数组，只能说掌握太不好了。</p>
<h3 id="思路1-amp-题解-12"><a href="#思路1-amp-题解-12" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ol>
<li>使用 <code>split</code> 将字符串按空格分割成字符串数组；</li>
<li>使用 <code>reverse</code> 将字符串数组进行反转；</li>
<li>使用 <code>join</code> 方法将字符串数组拼成一个字符串。</li>
</ol>
<p><img src="https://i.loli.net/2021/06/14/ZiC1kM2E9msTIKF.jpg" alt="Snipaste_2021-06-14_15-14-36.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正则</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="regexp">/\s+/</span>).reverse().join(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤器</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 也可以用 filter(Boolean)</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&quot; &quot;</span>).filter(<span class="function"><span class="params">v</span> =&gt;</span> v != <span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>？？？这就是 API 的魅力吗？</p>
<p>时间复杂度：O(N)，其中 N 为输入字符串的长度。</p>
<h3 id="思路2-amp-题解-13"><a href="#思路2-amp-题解-13" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>双端队列（不使用 API）</strong>（两端都可以进队的队列）</p>
<ul>
<li>首先去除字符串左右空格</li>
<li>逐个读取字符串中的每个单词，依次放入双端队列的对头</li>
<li>再将队列转换成字符串输出（已空格为分隔符）</li>
</ul>
<p><img src="https://i.loli.net/2021/06/14/25jGUv4EWdwrqnT.jpg" alt="Snipaste_2021-06-14_15-22-42.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> right = s.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> queue = []</span><br><span class="line">    <span class="keyword">let</span> word = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (s.charAt(left) === <span class="string">&#x27; &#x27;</span>) left ++</span><br><span class="line">    <span class="keyword">while</span> (s.charAt(right) === <span class="string">&#x27; &#x27;</span>) right --</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> char = s.charAt(left)</span><br><span class="line">        <span class="keyword">if</span> (char === <span class="string">&#x27; &#x27;</span> &amp;&amp; word) &#123;</span><br><span class="line">            queue.unshift(word)</span><br><span class="line">            word = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (char !== <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            word += char</span><br><span class="line">        &#125;</span><br><span class="line">        left++</span><br><span class="line">    &#125;</span><br><span class="line">    queue.unshift(word)</span><br><span class="line">    <span class="keyword">return</span> queue.join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过unshift插入队列头部，其实跟自己写的<code>arr[count]</code>挺像。</p>
<p>通过charAt得到字符串的字符，好像也可以用s[i]。</p>
<h2 id="LeetCode387——字符串中的第一个唯一字符（☆）"><a href="#LeetCode387——字符串中的第一个唯一字符（☆）" class="headerlink" title="LeetCode387——字符串中的第一个唯一字符（☆）"></a>LeetCode387——字符串中的第一个唯一字符（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">跳转地址</a></p>
<h3 id="自己的代码-27"><a href="#自己的代码-27" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    map.set(s[i], <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> x=map.get(s[i])</span><br><span class="line">    map.set(s[i],x+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(s[i]) === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC，但还是google了“如何让map的值自增”，最后得到7、8行结果。三段循环真又臭又长啊。</p>
<h3 id="思路1-amp-题解-13"><a href="#思路1-amp-题解-13" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ol>
<li>遍历两次字符串，第一次构造哈希map， 存入每个字符出现的次数</li>
<li>第二次判断每个字符次数是否等于1，等于1就返回i</li>
<li>遍历结束，返回-1</li>
</ol>
<p>（和自己最初想的基本一致）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> len = s.length;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 三目运算符，简洁多了</span></span><br><span class="line">        map[s[i]] = map[s[i]] ? map[s[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[s[i]] === <span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O（n）</p>
<h3 id="思路2-amp-题解-14"><a href="#思路2-amp-题解-14" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>唯一字符 首次出现索引 <code>=</code> 该字符最后出现索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> firstUniqChar = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) </span><br><span class="line">        <span class="keyword">if</span> (s.indexOf(s[i]) === s.lastIndexOf(s[i]))</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O（n^2）</p>
<h2 id="LeetCode125——验证回文串（☆）（★）"><a href="#LeetCode125——验证回文串（☆）（★）" class="headerlink" title="LeetCode125——验证回文串（☆）（★）"></a>LeetCode125——验证回文串（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome/">跳转地址</a></p>
<h3 id="自己的代码-28"><a href="#自己的代码-28" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.toLowerCase().split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">let</span> n = s.length;</span><br><span class="line">  <span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/[a-z0-9]/</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pattern.test(s[i])) &#123;</span><br><span class="line">      s.splice(i, <span class="number">1</span>);</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  s = s.join(<span class="string">&quot;&quot;</span>).split(<span class="string">&quot; &quot;</span>).join(<span class="string">&quot;&quot;</span>)</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.floor(s.length/<span class="number">2</span>); i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] !== s[s.length - i - <span class="number">1</span>]) &#123;</span><br><span class="line">      flag=<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>太折磨了。。思路很简单，就是先把字符串变成全小写的字母，然后一头一尾对比。但是遇到了<strong>各种各样的问题</strong>：以<code>&quot;A man, a plan, a canal: Panama&quot; </code>为例：</p>
<ol>
<li>用split(“”)去了空格，但是还剩下，：等特殊字符串。</li>
<li>用正则匹配，折腾了好久因为第一次使用。后来没看见题目说的数字，案例没通过才加了0-9。</li>
<li>，：等特殊字符使用splice()删除，但是删除后原数组长度变化，因此i需要自减。</li>
<li>操作完后的s是一个数组，join(“”)后变成<code>Aman aplan acanal Panama</code>，还是有空格。所以需要split(“ “) 再join(“”) （好麻烦）</li>
<li>然后又犯了个错误，判断不相等时直接return false了，其实应该用flag=false，最后return flag就行。</li>
</ol>
<h3 id="思路1-amp-题解-14"><a href="#思路1-amp-题解-14" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// s.replace(/\W/g, &quot;&quot;) 也可以这样直接匹配非一个单字字符</span></span><br><span class="line">    <span class="keyword">let</span> strArr = s.replace(<span class="regexp">/[^0-9a-zA-Z]/g</span>,<span class="string">&quot;&quot;</span>).toLowerCase().split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> strArr.join(<span class="string">&#x27;&#x27;</span>) == strArr.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>真的佩服。原来可以用^0-9a-zA-Z选定所有其他字符。而且正则可以直接replace，不用new一个pattern再test。（注意：<strong>只有Array才有reverse()方法，String没法调用</strong>）</p>
<h3 id="思路2-amp-题解-15"><a href="#思路2-amp-题解-15" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>双指针：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s = s.replace(<span class="regexp">/[^0-9a-zA-Z]/g</span>,<span class="string">&#x27;&#x27;</span>).toLowerCase();</span><br><span class="line">    <span class="keyword">let</span> n = s.length;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[left] != s[right])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>感觉就是败在了第一步。把这一串字符变成全小写字母竟然要花这么大力气，哎！</p>
<h2 id="1047-删除字符串中的所有相邻重复项（☆）（★）"><a href="#1047-删除字符串中的所有相邻重复项（☆）（★）" class="headerlink" title="1047. 删除字符串中的所有相邻重复项（☆）（★）"></a>1047. 删除字符串中的所有相邻重复项（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">跳转地址</a></p>
<h3 id="自己的代码-29"><a href="#自己的代码-29" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">    s = s.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>,</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === s[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count !== <span class="number">1</span>) &#123;</span><br><span class="line">            s.splice(i, count);</span><br><span class="line">            i = i - count;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>splice 复杂度好像也是O（1）</p>
<h3 id="思路-amp-题解-14"><a href="#思路-amp-题解-14" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">S</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> S)&#123;</span><br><span class="line">      <span class="keyword">if</span>(stack[stack.length - <span class="number">1</span>] === item)&#123;</span><br><span class="line">          stack.pop();</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          stack.push(item);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack.join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好巧妙。。</p>
<h2 id="LeetCode8——字符串转换整数-atoi-（☆☆）（to-redo）"><a href="#LeetCode8——字符串转换整数-atoi-（☆☆）（to-redo）" class="headerlink" title="LeetCode8——字符串转换整数 (atoi)（☆☆）（to redo）"></a>LeetCode8——字符串转换整数 (atoi)（☆☆）（to redo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/string-to-integer-atoi/">跳转地址</a></p>
<h3 id="自己的代码-30"><a href="#自己的代码-30" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  s = s.trim();</span><br><span class="line">  <span class="keyword">let</span> n = s.length,flag=<span class="literal">true</span>,arr=[],num=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isNaN</span>(s[<span class="number">0</span>])) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(s[i])) &#123;</span><br><span class="line">      arr.push(s[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  num = <span class="built_in">Number</span>(arr.join(<span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="comment">//console.log(num &lt; -Math.pow(2, 31))</span></span><br><span class="line">  <span class="keyword">if</span> (num &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span> - <span class="number">1</span>)) &#123;</span><br><span class="line">    num=<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span> - <span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)) &#123;</span><br><span class="line">    num=-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> flag?<span class="built_in">parseInt</span>(arr.join(<span class="string">&quot;&quot;</span>)):-<span class="built_in">parseInt</span>(arr.join(<span class="string">&quot;&quot;</span>))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>好纳闷。。不难的一道题目定为medium果然有道理。就不明白了，为啥<code>console.log(num &lt; -Math.pow(2, 31)) =&gt; false</code>，而<code>console.log(-91283472332 &lt; -2147483648) =&gt; true</code> 一模一样结果咋不同？</p>
<p><strong>心态崩了呀，明天再整</strong></p>
<h3 id="思路-amp-题解-15"><a href="#思路-amp-题解-15" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>题目即JavaScript中的<code>parseInt()</code>这一API的转换规则，但这样写面试肯定过不了，考验的是基本功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> number = <span class="built_in">parseInt</span>(str, <span class="number">10</span>); <span class="comment">// 10最好写上，未防止str以&quot;0x&quot;或者&quot;0X&quot;开头或者&quot;0&quot;开头。</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isNaN</span>(number)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) || number &gt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> number &lt; <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) ? <span class="built_in">Math</span>.pow(-<span class="number">2</span>, <span class="number">31</span>) : <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-16"><a href="#思路2-amp-题解-16" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>挺清晰的，以后要多写写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myAtoi = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>, sign = <span class="number">1</span>, total = <span class="number">0</span>, length = str.length;</span><br><span class="line">    <span class="comment">// 1.Empty string</span></span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2.Remove Spaces 因为 str 是 immutable 的, 所以使用 trim 会带来额外的空间</span></span><br><span class="line">    <span class="keyword">while</span> (str.charAt(index) === <span class="string">&#x27; &#x27;</span> &amp;&amp; index &lt; length) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.Handle signs</span></span><br><span class="line">    <span class="keyword">if</span> (str.charAt(index) === <span class="string">&#x27;+&#x27;</span> || str.charAt(index) === <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        sign = str.charAt(index) === <span class="string">&#x27;-&#x27;</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> MAX_SAFE_32_INT = <span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> MIN_SAFE_32_INT = -<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.Convert number and avoid overflow</span></span><br><span class="line">    <span class="keyword">while</span> (index &lt; length &amp;&amp; str[index].match(<span class="regexp">/[0-9]/</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> digit = str.charAt(index) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (digit &lt; <span class="number">0</span> || digit &gt; <span class="number">9</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// check if total will be overflow after 10 times and add digit</span></span><br><span class="line">        <span class="keyword">if</span> (total &gt; <span class="built_in">Math</span>.floor(MAX_SAFE_32_INT / <span class="number">10</span>) ||</span><br><span class="line">        (total === <span class="built_in">Math</span>.floor(MAX_SAFE_32_INT / <span class="number">10</span>) &amp;&amp; digit &gt; MAX_SAFE_32_INT % <span class="number">10</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (sign === <span class="number">1</span>) ? MAX_SAFE_32_INT  : MIN_SAFE_32_INT ;</span><br><span class="line">        &#125;</span><br><span class="line">        total = total * <span class="number">10</span> + digit;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total * sign;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode38——外观数列（☆☆）-to-redo"><a href="#LeetCode38——外观数列（☆☆）-to-redo" class="headerlink" title="LeetCode38——外观数列（☆☆）(to redo)"></a>LeetCode38——外观数列（☆☆）(to redo)</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-and-say/">跳转地址</a></p>
<h3 id="自己的代码-31"><a href="#自己的代码-31" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>看见递归就没有思路了。。</p>
<h3 id="思路-amp-题解-16"><a href="#思路-amp-题解-16" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递归+正则：</p>
<ul>
<li>/(\d)\1*/g  这个正则表示，全局匹配，匹配一位数字或者匹配相同的多位数字。 (\d)\1匹配两个连续数字字符，因为\1是对(\d)的引用。 *修饰\1，表示可以有0或多个。</li>
<li>对n-1时产生的数组，用 length+值  确定n的数组。比如，[‘21’]=&gt;’2’的length+’2’  +  ‘1’的length+’1’=&gt;’1211’</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countAndSay = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> temp = countAndSay(n-<span class="number">1</span>).match(<span class="regexp">/(\d)\1*/g</span>)</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        result += (temp[i].length + <span class="string">&#x27;&#x27;</span> + temp[i].substring(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode58——最后一个单词的长度（☆）"><a href="#LeetCode58——最后一个单词的长度（☆）" class="headerlink" title="LeetCode58——最后一个单词的长度（☆）"></a>LeetCode58——最后一个单词的长度（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/length-of-last-word/">跳转地址</a></p>
<h3 id="思路-amp-题解-17"><a href="#思路-amp-题解-17" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLastWord = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.trim().split(<span class="string">&quot; &quot;</span>).pop().length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这类题目一定要熟练运用 api 啦。</p>
<h2 id="LeetCode541——反转字符串-II（☆）"><a href="#LeetCode541——反转字符串-II（☆）" class="headerlink" title="LeetCode541——反转字符串 II（☆）"></a>LeetCode541——反转字符串 II（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-string-ii/">跳转地址</a></p>
<p>还是不熟练啊。</p>
<h3 id="思路-amp-题解-18"><a href="#思路-amp-题解-18" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseStr = <span class="function"><span class="keyword">function</span> (<span class="params">s, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i += <span class="number">2</span> * k)&#123;</span><br><span class="line">        res += s.slice(i, i + k).split(<span class="string">&quot;&quot;</span>).reverse().join(<span class="string">&quot;&quot;</span>) + s.slice(i + k, i + <span class="number">2</span> * k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode49——字母异位词分组（☆☆）"><a href="#LeetCode49——字母异位词分组（☆☆）" class="headerlink" title="LeetCode49——字母异位词分组（☆☆）"></a>LeetCode49——字母异位词分组（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">跳转地址</a></p>
<h3 id="自己的代码-32"><a href="#自己的代码-32" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> strs) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = i.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    map[str] ? map[str].push(i) : map[str] = [i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> map) &#123;</span><br><span class="line">    res.push(map[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode438——找到字符串中所有字母异位词（☆☆）-to-redo"><a href="#LeetCode438——找到字符串中所有字母异位词（☆☆）-to-redo" class="headerlink" title="LeetCode438——找到字符串中所有字母异位词（☆☆）(to redo)"></a>LeetCode438——找到字符串中所有字母异位词（☆☆）(to redo)</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">跳转地址</a></p>
<h3 id="思路1-amp-题解-15"><a href="#思路1-amp-题解-15" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findAnagrams = <span class="function"><span class="keyword">function</span>(<span class="params">s, p</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">if</span> (p.length &gt; s.length) <span class="keyword">return</span> result;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> right = p.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(left &lt; s.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = s.substring(left,right);</span><br><span class="line">    <span class="keyword">if</span> ( tmp.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>) === p.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>))&#123;</span><br><span class="line">      result.push(left);</span><br><span class="line">    &#125;</span><br><span class="line">    left++;</span><br><span class="line">    right++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然超时，但是其他题解真看不懂诶。。</p>
<h3 id="思路2-amp-题解（to-understand）"><a href="#思路2-amp-题解（to-understand）" class="headerlink" title="思路2&amp;题解（to understand）"></a>思路2&amp;题解（to understand）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> findAnagrams = <span class="function">(<span class="params">s, p</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> output = [], neededChars = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> char <span class="keyword">of</span> p) &#123;</span><br><span class="line">        neededChars[char] ? neededChars[char]++ : neededChars[char] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">let</span> count = p.length </span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (neededChars[s[right]] &gt; <span class="number">0</span>) count--;</span><br><span class="line">        neededChars[s[right]]--;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">0</span>) output.push(left);</span><br><span class="line">        <span class="keyword">if</span> (right - left == p.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (neededChars[s[left]] &gt;= <span class="number">0</span>) count++;</span><br><span class="line">            neededChars[s[left]]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode680——验证回文字符串-Ⅱ（☆）-to-redo"><a href="#LeetCode680——验证回文字符串-Ⅱ（☆）-to-redo" class="headerlink" title="LeetCode680——验证回文字符串 Ⅱ（☆）(to redo)"></a>LeetCode680——验证回文字符串 Ⅱ（☆）(to redo)</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/">跳转地址</a></p>
<p>好难啊。</p>
<h3 id="思路-amp-题解-19"><a href="#思路-amp-题解-19" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> validPalindrome = <span class="function"><span class="keyword">function</span> (<span class="params">s, flag = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[left] === s[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validPalindrome(s.slice(left, right), <span class="literal">true</span>) || validPalindrome(s.slice(left + <span class="number">1</span>, right + <span class="number">1</span>), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-48（LC3）——最长不含重复字符的子字符串（☆☆）（★★-）"><a href="#剑指-Offer-48（LC3）——最长不含重复字符的子字符串（☆☆）（★★-）" class="headerlink" title="剑指 Offer 48（LC3）——最长不含重复字符的子字符串（☆☆）（★★ ）"></a>剑指 Offer 48（LC3）——最长不含重复字符的子字符串（☆☆）（★★ ）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">跳转地址</a></p>
<p>唯一没做的就遇到了= =（快手一面）</p>
<h3 id="自己的代码-33"><a href="#自己的代码-33" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>使用set（快手实习一面）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; s.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.has(s[j])) &#123;</span><br><span class="line">            i = <span class="built_in">Math</span>.max(map.get(s[j]) + <span class="number">1</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, j - i + <span class="number">1</span>)</span><br><span class="line">        map.set(s[j], j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路-amp-题解-20"><a href="#思路-amp-题解-20" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>滑动窗口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [], max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> index = arr.indexOf(s[i])</span><br><span class="line">        <span class="comment">// 在则删除滑动窗口数组里相同字符及相同字符前的字符，然后将当前字符 push 进数组</span></span><br><span class="line">        <span class="keyword">if</span>(index !== -<span class="number">1</span>) &#123;</span><br><span class="line">            arr.splice(<span class="number">0</span>, index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不在则 push 进数组</span></span><br><span class="line">        arr.push(s.charAt(i))</span><br><span class="line">        max = <span class="built_in">Math</span>.max(arr.length, max) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode1143——最长公共子序列（☆☆）（★）"><a href="#LeetCode1143——最长公共子序列（☆☆）（★）" class="headerlink" title="LeetCode1143——最长公共子序列（☆☆）（★）"></a>LeetCode1143——最长公共子序列（☆☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-common-subsequence/">跳转地址</a></p>
<p>DP：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="function"><span class="keyword">function</span>(<span class="params">text1, text2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!text1 || !text2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> m = text1.length, n = text2.length;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(m+<span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">e</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i - <span class="number">1</span>] === text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">Math</span>.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-43——1～n-整数中-1-出现的次数（☆☆☆）（★）（todo）"><a href="#剑指-Offer-43——1～n-整数中-1-出现的次数（☆☆☆）（★）（todo）" class="headerlink" title="剑指 Offer 43——1～n 整数中 1 出现的次数（☆☆☆）（★）（todo）"></a>剑指 Offer 43——1～n 整数中 1 出现的次数（☆☆☆）（★）（todo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/">跳转地址</a></p>
<h3 id="自己的代码-34"><a href="#自己的代码-34" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countDigitOne = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> str = i.toString();</span><br><span class="line">        <span class="keyword">while</span> (str.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.substr(<span class="number">0</span>, <span class="number">1</span>) === <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            str = str.substr(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC，超时</p>
<h3 id="思路-amp-题解-21"><a href="#思路-amp-题解-21" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><h2 id="字符串按权重排序"><a href="#字符串按权重排序" class="headerlink" title="字符串按权重排序"></a>字符串按权重排序</h2><p>入参格式：[‘1.20.3’,’6.8.9’,’6.0.0’,’3.1.2’]</p>
<p>出参格式：[‘6.8.9’,’6.0.0’,’3.1.2’,’1.20.3’]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    input.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">        a = a.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        b = b.split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] !== b[<span class="number">0</span>]) <span class="keyword">return</span> <span class="built_in">parseInt</span>(b[<span class="number">0</span>]) - <span class="built_in">parseInt</span>(a[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[<span class="number">1</span>] !== b[<span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">parseInt</span>(b[<span class="number">1</span>]) - <span class="built_in">parseInt</span>(a[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">parseInt</span>(b[<span class="number">2</span>]) - <span class="built_in">parseInt</span>(a[<span class="number">2</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> input; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="LeetCode141——环形链表（☆）"><a href="#LeetCode141——环形链表（☆）" class="headerlink" title="LeetCode141——环形链表（☆）"></a>LeetCode141——环形链表（☆）</h2><h2 id="LeetCode142——环形链表II（☆☆）（★★）"><a href="#LeetCode142——环形链表II（☆☆）（★★）" class="headerlink" title="LeetCode142——环形链表II（☆☆）（★★）"></a>LeetCode142——环形链表II（☆☆）（★★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle/">跳转地址</a>、<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">2跳转地址</a></p>
<h3 id="自己的代码-35"><a href="#自己的代码-35" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>正常做法就是创建空数组（或set），然后遍历判断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.has(head)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        set.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AC</p>
<h3 id="思路1-amp-题解-16"><a href="#思路1-amp-题解-16" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>污链表法</strong>：在 Javascript 里面定义的任何数据结构，其类型都是 object。这意味着，可以给一个对象设定任何属性。我们为每次遍历的节点设定一个标记，如果存在环，那么一定存在某个节点已经设定过标记。否则链表遍历结束其不为环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.flag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    head.flag = <span class="literal">true</span>;</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-17"><a href="#思路2-amp-题解-17" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>快慢指针：</strong></p>
<ul>
<li>定义“快指针 fastp”、“慢指针 slowp”，<strong>“快指针”总比“慢指针”快一步</strong>。</li>
<li>进入环形链表，当 fastp === slowp，说明“快指针”追上了“慢指针”。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> slowp = head, fastp = head;</span><br><span class="line">    <span class="keyword">while</span> (fastp.next !== <span class="literal">null</span> &amp;&amp; fastp.next.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        slowp = slowp.next;</span><br><span class="line">        fastp = fastp.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slowp === fastp) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode160——相交链表（☆）"><a href="#LeetCode160——相交链表（☆）" class="headerlink" title="LeetCode160——相交链表（☆）"></a>LeetCode160——相交链表（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">跳转地址</a></p>
<h3 id="自己的代码-36"><a href="#自己的代码-36" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>没有思路，双指针遍历也不会做。</p>
<h3 id="思路1-amp-题解-17"><a href="#思路1-amp-题解-17" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p><strong>哈希集合</strong></p>
<p>首先遍历链表 headA，并将每个节点加入哈希集合（Set）。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中：</p>
<ul>
<li><p>如果当前节点不在哈希集合中，则继续遍历下一个节点；</p>
</li>
<li><p>如果当前节点在哈希集合中，<strong>则后面的节点都在哈希集合中</strong>（应该是不会出现分叉的情况），即从当前节点开始的所有节点都在两个链表的相交部分，因此返回第一个相交节点。</p>
</li>
<li><p>如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span> (<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> visited = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">while</span> (headA) &#123;</span><br><span class="line">        visited.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.has(headB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。需要遍历两个链表各一次。</p>
<h3 id="思路2-amp-题解-18"><a href="#思路2-amp-题解-18" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p><strong>双指针</strong>：**”错的人就算走过了对方的路也还是会错过”**</p>
<p>只有当链表 headA 和 headB 都不为空时，两个链表才可能相交。因此首先判断链表 headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null。</p>
<p>当链表 headA 和 headB 都不为空时，创建两个头指针 pA 和 pB，依次遍历两个链表的每个节点：</p>
<ul>
<li><p>每步操作需要同时更新指针 pA 和 pB。</p>
</li>
<li><p>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</p>
</li>
<li><p>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</p>
</li>
<li><p>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA === <span class="literal">null</span> || headB === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pA = headA, pB = headB;</span><br><span class="line">    <span class="keyword">while</span> (pA !== pB) &#123;</span><br><span class="line">        pA = pA === <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB === <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)，其中 m 和 n 是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p>
<h2 id="LeetCode206——反转链表（☆）（★★★★）"><a href="#LeetCode206——反转链表（☆）（★★★★）" class="headerlink" title="LeetCode206——反转链表（☆）（★★★★）"></a>LeetCode206——反转链表（☆）（★★★★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">跳转地址</a></p>
<h3 id="自己的代码-37"><a href="#自己的代码-37" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">while</span> (head !== <span class="literal">null</span>) &#123;</span><br><span class="line">        arr.unshift(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i].next=arr[i+<span class="number">1</span>].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未AC。瞎写，没想到这是双向链表题。</p>
<h3 id="思路-amp-题解-22"><a href="#思路-amp-题解-22" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>迭代：<a target="_blank" rel="noopener" href="https://leetcode.com/problems/reverse-linked-list/discuss/1449712/Easy-C%2B%2BJavaPythonJavaScript-Explained%2BAnimated">=&gt;动画</a></p>
<ul>
<li>定义“前指针prev”、“当前指针curr”、“后指针next”</li>
<li>对原始链表每个节点：<ul>
<li>首先将 next 初始化为 curr 之后的节点。即（n=cur-&gt;next）。</li>
<li>然后让 curr-&gt;next 指向 prev（下一个节点指针）。</li>
<li>然后让 prev 现在指向（前面一个节点）cur 节点。</li>
<li>最后将 cur 也向前移动一个节点到 next。</li>
</ul>
</li>
<li><strong>最后返回 prev，即可获得整条反向链表</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="literal">null</span>, curr = head, next = head;</span><br><span class="line">    <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">        next = curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解构赋值</span></span><br><span class="line">	<span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    	[curr.next, prev, curr] = [prev, curr, curr.next];</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-19"><a href="#思路2-amp-题解-19" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reverseList = <span class="function">(<span class="params">cur, prev = <span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!cur) <span class="keyword">return</span> prev;</span><br><span class="line">  <span class="keyword">const</span> next = cur.next;</span><br><span class="line">  cur.next = prev;</span><br><span class="line">  <span class="keyword">return</span> reverseList(next, cur);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode21——合并两个有序链表（☆）（高频）"><a href="#LeetCode21——合并两个有序链表（☆）（高频）" class="headerlink" title="LeetCode21——合并两个有序链表（☆）（高频）"></a>LeetCode21——合并两个有序链表（☆）（高频）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">跳转地址</a></p>
<h3 id="自己的代码-38"><a href="#自己的代码-38" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。。有太多种情况，难道都用 if 判断吗？（不开辟新的空间前提下）</p>
<h3 id="思路1-amp-题解-18"><a href="#思路1-amp-题解-18" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<ul>
<li>返回值：每一层调用都返回排序好的链表头</li>
<li>终止条件：l1 为空或 l2 为空时结束</li>
<li>单层递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (l1 === <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">  <span class="keyword">if</span> (l2 === <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">  <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">    <span class="keyword">return</span> l1;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">    <span class="keyword">return</span> l2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-20"><a href="#思路2-amp-题解-20" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>开辟新空间：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span>(<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mergedHead = &#123; <span class="attr">val</span> : -<span class="number">1</span>, <span class="attr">next</span> : <span class="literal">null</span> &#125;,</span><br><span class="line">        crt = mergedHead;</span><br><span class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val &gt; l2.val) &#123;</span><br><span class="line">            crt.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            crt.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        crt = crt.next;</span><br><span class="line">    &#125;</span><br><span class="line">    crt.next = l1 || l2;</span><br><span class="line">    <span class="keyword">return</span> mergedHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode24——两两交换链表中的节点（☆☆）"><a href="#LeetCode24——两两交换链表中的节点（☆☆）" class="headerlink" title="LeetCode24——两两交换链表中的节点（☆☆）"></a>LeetCode24——两两交换链表中的节点（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">跳转地址</a></p>
<h3 id="自己的代码-39"><a href="#自己的代码-39" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> curr = head, res = curr.next;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = curr.next;</span><br><span class="line">    curr.next = next.next;</span><br><span class="line">    next.next = curr;</span><br><span class="line">    curr = next.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没过。逻辑上应该没问题啊。</p>
<h3 id="思路1-amp-题解-19"><a href="#思路1-amp-题解-19" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>迭代：</p>
<ul>
<li>设置虚拟头结点 dummy，因为真实头结点要换人，设置了 dummy 后，dummy.next 就能找到头结点。<strong>（想不到）</strong></li>
<li>开启 while 循环，一对结点的交换有三个指针要改变。<img src="https://i.loli.net/2021/08/12/IUrsqcJ4azfjdCW.png" alt="image.png"></li>
<li>指针推进，准备交换下一对结点。</li>
<li>最后返回 dummy.next 。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  dummy.next = head;</span><br><span class="line">  <span class="keyword">let</span> prev = dummy;</span><br><span class="line">  <span class="keyword">while</span> (head &amp;&amp; head.next) &#123;</span><br><span class="line">    <span class="keyword">let</span> next = head.next;</span><br><span class="line">    <span class="comment">// 三步完成一对交换</span></span><br><span class="line">    head.next = next.next;</span><br><span class="line">    next.next = head;</span><br><span class="line">    prev.next = next;</span><br><span class="line">	<span class="comment">// 指针更新</span></span><br><span class="line">    prev = head;</span><br><span class="line">    head = head.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-21"><a href="#思路2-amp-题解-21" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：</p>
<ul>
<li>交换当前两个节点</li>
<li>递归并连接两组节点。将第三个节点作为递归的参数，<strong>上一组尾部连接下一组头部</strong>(递归返回的值)。</li>
<li>终结条件。当节点为 null 或节点的下一个节点为 null 时，无法交换，递归结束。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> swapPairs = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head.next) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="keyword">var</span> v1 = head, v2 = head.next, v3 = v2.next;</span><br><span class="line">    v2.next = v1;</span><br><span class="line">    v1.next = swapPairs(v3);</span><br><span class="line">    <span class="keyword">return</span> v2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode25——K-个一组翻转链表（☆☆☆）（to-redo）"><a href="#LeetCode25——K-个一组翻转链表（☆☆☆）（to-redo）" class="headerlink" title="LeetCode25——K 个一组翻转链表（☆☆☆）（to redo）"></a>LeetCode25——K 个一组翻转链表（☆☆☆）（to redo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">跳转地址</a></p>
<h3 id="自己的代码-40"><a href="#自己的代码-40" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。思路是在翻转链表的基础上传 k ，但是不知道如何在主函数中调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head, count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="literal">null</span>, curr = head, next = head;</span><br><span class="line">  <span class="keyword">while</span> (count &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    next = curr.next;</span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">    count--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路-amp-题解-23"><a href="#思路-amp-题解-23" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>不需要在反转链表中传 k 值。在 reverseKGroup 函数中通过循环找到首尾节点（head、tail 的间隔就是 k 值），再通过递归，上一组的尾节点链接下一组的头结点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseKGroup</span>(<span class="params">head, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> tail = head;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">    tail = tail.next;</span><br><span class="line">    <span class="keyword">if</span> (!tail) <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> next = tail.next;</span><br><span class="line">  tail.next = <span class="literal">null</span>;</span><br><span class="line">  reverse(head);</span><br><span class="line">  <span class="comment">// 此时 head 为上一组尾节点，next 为下一组头结点</span></span><br><span class="line">  head.next = reverseKGroup(next, k);</span><br><span class="line">  <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">curr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prev = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">    <span class="keyword">var</span> next = curr.next;</span><br><span class="line">    curr.next = prev;</span><br><span class="line">    prev = curr;</span><br><span class="line">    curr = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode144——删除排序链表中的重复元素-II（☆☆）（★todo）"><a href="#LeetCode144——删除排序链表中的重复元素-II（☆☆）（★todo）" class="headerlink" title="LeetCode144——删除排序链表中的重复元素 II（☆☆）（★todo）"></a>LeetCode144——删除排序链表中的重复元素 II（☆☆）（★todo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">跳转地址</a></p>
<h3 id="思路1-amp-题解-20"><a href="#思路1-amp-题解-20" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="keyword">let</span> node = dummy;                                                  </span><br><span class="line">    <span class="keyword">while</span> (node.next) &#123;</span><br><span class="line">        <span class="comment">// 下一个和下一个的下一个比, 如果相同, 记录该值</span></span><br><span class="line">        <span class="keyword">if</span> (node.next.next &amp;&amp; node.next.val === node.next.next.val) &#123;  </span><br><span class="line">            <span class="keyword">let</span> nonValNode = node.next.next.next;</span><br><span class="line">            <span class="comment">// 只要下一个值和这值一样，就把当前的下一个指针指向下下个, 否则移动当前位置</span></span><br><span class="line">            <span class="keyword">while</span> (nonValNode &amp;&amp; node.next.val === nonValNode.val) &#123;   </span><br><span class="line">                nonValNode = nonValNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node.next = nonValNode;                                    </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.next;                                          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-22"><a href="#思路2-amp-题解-22" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tmpHead = <span class="keyword">new</span> ListNode();</span><br><span class="line">    tmpHead.next = head;</span><br><span class="line">    <span class="keyword">let</span> cur = tmpHead;</span><br><span class="line">    <span class="keyword">let</span> visted = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">while</span>(cur.next)&#123;</span><br><span class="line">       <span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">let</span> val = cur.next.val;</span><br><span class="line">       <span class="keyword">let</span> tmp = cur.next;</span><br><span class="line">       <span class="keyword">while</span>(tmp &amp;&amp; tmp.val == val)&#123;</span><br><span class="line">           counter++;</span><br><span class="line">           tmp =  tmp.next</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(counter &gt; <span class="number">1</span>) cur.next = tmp;</span><br><span class="line">       <span class="keyword">else</span> cur = cur.next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmpHead.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-II-026——重排链表（☆☆）（★）（todo）"><a href="#剑指-Offer-II-026——重排链表（☆☆）（★）（todo）" class="headerlink" title="剑指 Offer II 026——重排链表（☆☆）（★）（todo）"></a>剑指 Offer II 026——重排链表（☆☆）（★）（todo）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/LGjMqU/">跳转地址</a></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="LeetCode144——二叉树的前序遍历（☆）"><a href="#LeetCode144——二叉树的前序遍历（☆）" class="headerlink" title="LeetCode144——二叉树的前序遍历（☆）"></a>LeetCode144——二叉树的前序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">跳转地址</a></p>
<h3 id="自己的代码-41"><a href="#自己的代码-41" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>知道二叉树的前序遍历，但是第一次实现是真不会啊。</p>
<h3 id="思路1-amp-题解-21"><a href="#思路1-amp-题解-21" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<ol>
<li>确定递归函数的参数和返回值。</li>
<li>确定终止条件。如果当前遍历的节点是空，那么本层递归结束。</li>
<li>确定单层递归的逻辑。前序遍历是中左右的循序，所以要先取中节点的数值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root,res=[]</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!root) <span class="keyword">return</span> res</span><br><span class="line">     res.push(root.val) <span class="comment">// 根</span></span><br><span class="line">     preorderTraversal(root.left, res) <span class="comment">// 左</span></span><br><span class="line">     preorderTraversal(root.right, res) <span class="comment">// 右</span></span><br><span class="line">     <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-23"><a href="#思路2-amp-题解-23" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。这样出栈的时候就是中左右的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈 右 -&gt; 左</span></span><br><span class="line"><span class="comment">// 出栈 中 -&gt; 左 -&gt; 右</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">const</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.push(cur.val);</span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h2 id="LeetCode94——二叉树的中序遍历（☆）（★）"><a href="#LeetCode94——二叉树的中序遍历（☆）（★）" class="headerlink" title="LeetCode94——二叉树的中序遍历（☆）（★）"></a>LeetCode94——二叉树的中序遍历（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">跳转地址</a></p>
<h3 id="自己的代码-42"><a href="#自己的代码-42" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>知道前序遍历后，中序（左根右），后序（左右根）就很简单：（递归）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    inorderTraversal(root.left, res); </span><br><span class="line">    res.push(root.val)</span><br><span class="line">    inorderTraversal(root.right, res);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
<h3 id="思路2-amp-题解（★）"><a href="#思路2-amp-题解（★）" class="headerlink" title="思路2&amp;题解（★）"></a>思路2&amp;题解（★）</h3><p>迭代：</p>
<p>递归的时候隐式地维护了一个栈，而迭代的时候需要显式地将这个栈模拟出来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span> (stack.length || cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            <span class="comment">// 遍历到左边最深处</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.push(cur.val);</span><br><span class="line">            <span class="comment">// 判断右节点是否存在，若不存在则继续往上pop，直到中间节点，然后放入右节点</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h2 id="LeetCode145——二叉树的后序遍历（☆）"><a href="#LeetCode145——二叉树的后序遍历（☆）" class="headerlink" title="LeetCode145——二叉树的后序遍历（☆）"></a>LeetCode145——二叉树的后序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">跳转地址</a></p>
<h3 id="自己的代码-43"><a href="#自己的代码-43" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    postorderTraversal(root.left, res); </span><br><span class="line">    postorderTraversal(root.right, res);</span><br><span class="line">    res.push(root.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<p>迭代：先序遍历是中左右，后续遍历是左右中。因此只需调整一下先序遍历的代码顺序，变成中右左，再反转res数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈 左 -&gt; 右</span></span><br><span class="line"><span class="comment">// 出栈 中 -&gt; 右 -&gt; 左 结果翻转</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">const</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.push(cur.val);</span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h2 id="LeetCode102——二叉树的层序遍历（☆☆）（★★★）"><a href="#LeetCode102——二叉树的层序遍历（☆☆）（★★★）" class="headerlink" title="LeetCode102——二叉树的层序遍历（☆☆）（★★★）"></a>LeetCode102——二叉树的层序遍历（☆☆）（★★★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-lever-order-traversal/">跳转地址</a></p>
<h3 id="自己的代码-44"><a href="#自己的代码-44" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>自己第一次写还是写不出来</p>
<h3 id="思路1-amp-题解-22"><a href="#思路1-amp-题解-22" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>BFS：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="comment">// 记录当前层节点数</span></span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="comment">// 存放每一层节点</span></span><br><span class="line">        <span class="keyword">let</span> curLevel = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            curLevel.push(node.val);</span><br><span class="line">            <span class="comment">// 存放当前层下一层的节点</span></span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把每层结果放到res</span></span><br><span class="line">        res.push(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-24"><a href="#思路2-amp-题解-24" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>DFS：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> level = <span class="number">0</span>;</span><br><span class="line">    traverse(root, level);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">root, level</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level &gt;= result.length) &#123;</span><br><span class="line">            result[level] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        result[level].push(root.val);</span><br><span class="line">        traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode637——二叉树的层平均值（☆）（★）"><a href="#LeetCode637——二叉树的层平均值（☆）（★）" class="headerlink" title="LeetCode637——二叉树的层平均值（☆）（★）"></a>LeetCode637——二叉树的层平均值（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">跳转地址</a></p>
<p>层序遍历的基础上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> res.map(<span class="function">(<span class="params">i</span>) =&gt;</span> i.reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc + cur, <span class="number">0</span>) / i.length);</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode589——N叉树的前序遍历（☆）"><a href="#LeetCode589——N叉树的前序遍历（☆）" class="headerlink" title="LeetCode589——N叉树的前序遍历（☆）"></a>LeetCode589——N叉树的前序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">跳转地址</a></p>
<h3 id="思路1-amp-题解-23"><a href="#思路1-amp-题解-23" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, ans=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans</span><br><span class="line">    ans.push(root.val)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> root.children)</span><br><span class="line">        preorder(child, ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-25"><a href="#思路2-amp-题解-25" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">let</span> stack = [root];</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">    cur = stack.pop();</span><br><span class="line">    res.push(cur.val);</span><br><span class="line">    <span class="keyword">if</span> (cur.children) &#123;</span><br><span class="line">      cur.children.reverse();</span><br><span class="line">      stack.push(...cur.children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if 可替换为：</span></span><br><span class="line">    <span class="comment">// for(let i = node.children.length - 1; i &gt;= 0; i--) &#123;</span></span><br><span class="line">    <span class="comment">//     stack.push(node.children[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode145——N叉树的后序遍历（☆）"><a href="#LeetCode145——N叉树的后序遍历（☆）" class="headerlink" title="LeetCode145——N叉树的后序遍历（☆）"></a>LeetCode145——N叉树的后序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">跳转地址</a></p>
<h3 id="思路1-amp-题解-24"><a href="#思路1-amp-题解-24" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span> (<span class="params">root, ans = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> root.children)</span><br><span class="line">        postorder(child, ans);</span><br><span class="line">    ans.push(root.val);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-26"><a href="#思路2-amp-题解-26" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">let</span> stack = [root];</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">    cur = stack.pop();</span><br><span class="line">    <span class="keyword">if</span>(cur.children)&#123;</span><br><span class="line">      stack.push(...cur.children);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(cur.val);<span class="comment">//因为是后序遍历，所以要把每次弹出的值压放入栈底</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode429——N叉树的层序遍历（☆☆）（★）"><a href="#LeetCode429——N叉树的层序遍历（☆☆）（★）" class="headerlink" title="LeetCode429——N叉树的层序遍历（☆☆）（★）"></a>LeetCode429——N叉树的层序遍历（☆☆）（★）</h2><h3 id="思路-amp-题解-24"><a href="#思路-amp-题解-24" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [], queue = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> length = queue.length;</span><br><span class="line">      <span class="keyword">let</span> curLevel = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">          curLevel.push(node.val);</span><br><span class="line">          node.children &amp;&amp; queue.push(...node.children);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(curLevel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode104——二叉树的最大深度（☆）（★）"><a href="#LeetCode104——二叉树的最大深度（☆）（★）" class="headerlink" title="LeetCode104——二叉树的最大深度（☆）（★）"></a>LeetCode104——二叉树的最大深度（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">跳转地址</a></p>
<h3 id="自己的代码-45"><a href="#自己的代码-45" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>二叉树的题目还是很不熟练，这么简单的题目都不会写。。</p>
<h3 id="思路1-amp-题解-25"><a href="#思路1-amp-题解-25" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简版</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再次强调<strong>递归三部曲</strong>：</p>
<ol>
<li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度。</li>
<li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li>
<li>确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li>
</ol>
<h3 id="思路2-amp-题解-27"><a href="#思路2-amp-题解-27" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<p>使用层序遍历，最大的深度就是二叉树的层数。</p>
<p>代码见：<a href="##LeetCode102%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89">=&gt;</a></p>
<h2 id="LeetCode104——二叉树的最小深度（☆）"><a href="#LeetCode104——二叉树的最小深度（☆）" class="headerlink" title="LeetCode104——二叉树的最小深度（☆）"></a>LeetCode104——二叉树的最小深度（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">跳转地址</a></p>
<h3 id="思路1-amp-题解-26"><a href="#思路1-amp-题解-26" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = minDepth(root.right);</span><br><span class="line">    <span class="comment">// 注意 “叶子结点”即左右子树都空，需要做判断。（一棵树只有左节点，那就递归左子树）</span></span><br><span class="line">    <span class="keyword">if</span>(!root.left) <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!root.right) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-28"><a href="#思路2-amp-题解-28" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.length;</span><br><span class="line">        dep++;</span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">            <span class="comment">// 到第一个叶子节点 返回 当前深度 </span></span><br><span class="line">            <span class="keyword">if</span>(!node.left &amp;&amp; !node.right) <span class="keyword">return</span> dep;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode101——对称二叉树（☆）"><a href="#LeetCode101——对称二叉树（☆）" class="headerlink" title="LeetCode101——对称二叉树（☆）"></a>LeetCode101——对称二叉树（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">跳转地址</a></p>
<h3 id="自己的代码-46"><a href="#自己的代码-46" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会做，如果硬写只会根据数组的2的n次方分割然后判断是不是对称。按层序遍历也很难判断。</p>
<h3 id="思路1-amp-题解-27"><a href="#思路1-amp-题解-27" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也要同时遍历两棵树。</p>
<p><strong>一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p>
<p><img src="https://i.loli.net/2021/07/29/KOA89QFnphP7C6S.png" alt="image.png"></p>
<p>递归三部曲</p>
<ul>
<li><p>确定递归函数的参数和返回值。参数是左子树节点和右子树节点，返回值是bool类型。</p>
</li>
<li><p>确定终止条件。</p>
<ul>
<li>左节点为空，右节点不为空，return false</li>
<li>左不为空，右为空， return false</li>
<li>左右都为空，return true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同 return false</li>
<li>否则 return true</li>
</ul>
</li>
<li><p>确定单层递归的逻辑。单层递归的逻辑就是处理 右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> compareNode = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//2. 确定终止条件 注意val相等不是终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right !== <span class="literal">null</span> || left !== <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val !== right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">let</span> outSide = compareNode(left.left, right.right);</span><br><span class="line">        <span class="keyword">let</span> inSide = compareNode(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> outSide &amp;&amp; inSide;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compareNode(root.left, root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-29"><a href="#思路2-amp-题解-29" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<p>使用队列来比较两个树（根节点的左右子树）是否相互翻转。手动将对称的节点按顺序入队，然后比较前两个是否相等。</p>
<p>（使用栈也可，只需把 shift 改成 pop ）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//迭代方法判断是否是对称二叉树</span></span><br><span class="line">   <span class="comment">//首先判断root是否为空</span></span><br><span class="line">   <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> queue=[];</span><br><span class="line">   queue.push(root.left);</span><br><span class="line">   queue.push(root.right);</span><br><span class="line">   <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">       <span class="keyword">let</span> leftNode=queue.shift();<span class="comment">//左节点</span></span><br><span class="line">       <span class="keyword">let</span> rightNode=queue.shift();<span class="comment">//右节点</span></span><br><span class="line">       <span class="keyword">if</span>(leftNode===<span class="literal">null</span>&amp;&amp;rightNode===<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftNode===<span class="literal">null</span>||rightNode===<span class="literal">null</span>||leftNode.val!==rightNode.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       queue.push(leftNode.left);<span class="comment">//左节点左孩子入队</span></span><br><span class="line">       queue.push(rightNode.right);<span class="comment">//右节点右孩子入队</span></span><br><span class="line">       queue.push(leftNode.right);<span class="comment">//左节点右孩子入队</span></span><br><span class="line">       queue.push(rightNode.left);<span class="comment">//右节点左孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode222——完全二叉树的节点个数（☆☆）"><a href="#LeetCode222——完全二叉树的节点个数（☆☆）" class="headerlink" title="LeetCode222——完全二叉树的节点个数（☆☆）"></a>LeetCode222——完全二叉树的节点个数（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">跳转地址</a></p>
<h3 id="自己的代码-47"><a href="#自己的代码-47" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>套用迭代版层序遍历模板，比较容易：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> queue = [root], count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">while</span>(length--)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            count++;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路-amp-题解-25"><a href="#思路-amp-题解-25" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>还可以递归（在内部写一个递归函数）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 确定递归函数参数</span></span><br><span class="line">    <span class="keyword">const</span> getNodeSum=<span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 3. 确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">let</span> leftNum=getNodeSum(node.left);</span><br><span class="line">        <span class="keyword">let</span> rightNum=getNodeSum(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftNum+rightNum+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getNodeSum(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode257——二叉树的所有路径（☆）（★）"><a href="#LeetCode257——二叉树的所有路径（☆）（★）" class="headerlink" title="LeetCode257——二叉树的所有路径（☆）（★）"></a>LeetCode257——二叉树的所有路径（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">跳转地址</a></p>
<h3 id="自己的代码-48"><a href="#自己的代码-48" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会，不知道如何用递归表示。</p>
<h3 id="思路-amp-题解-26"><a href="#思路-amp-题解-26" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">// 1.确定递归函数、参数</span></span><br><span class="line">    <span class="keyword">const</span> getPath = <span class="function"><span class="keyword">function</span> (<span class="params">node, curPath</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 2.确定终止条件, 到叶子结点终止</span></span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">            curPath += node.val;</span><br><span class="line">            res.push(curPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.单层递归 逻辑</span></span><br><span class="line">        curPath += node.val + <span class="string">&#x27;-&gt;&#x27;</span>;</span><br><span class="line">        node.left &amp;&amp; getPath(node.left, curPath);</span><br><span class="line">        node.right &amp;&amp; getPath(node.right, curPath);</span><br><span class="line">    &#125;</span><br><span class="line">    getPath(root, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>感觉这样的写法才是真正掌握了递归的用法，好像二叉树的题都能用递归来写。</p>
<h2 id="LeetCode112——路径总和（☆）"><a href="#LeetCode112——路径总和（☆）" class="headerlink" title="LeetCode112——路径总和（☆）"></a>LeetCode112——路径总和（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">跳转地址</a></p>
<h3 id="自己的代码-49"><a href="#自己的代码-49" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="function"><span class="keyword">function</span> (<span class="params">node, curSum</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        curSum += node.val;</span><br><span class="line">        <span class="keyword">if</span> (curSum === targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left &amp;&amp; dfsTree(node.left, curSum);</span><br><span class="line">        node.right &amp;&amp; dfsTree(node.right, curSum);</span><br><span class="line">    &#125;</span><br><span class="line">    res = dfsTree(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>未 AC，输出 undefined 。</p>
<h3 id="思路1-amp-题解-28"><a href="#思路1-amp-题解-28" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归，通过改变 targetSum 进行递归，不必自己弄一个值，然后不断累积：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val === targetSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(N)：其中 N 是树的节点数。对每个节点访问一次。</p>
<h3 id="思路2-amp-题解-30"><a href="#思路2-amp-题解-30" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = queue.shift();</span><br><span class="line">        <span class="keyword">if</span> (!cur.left &amp;&amp; !cur.right &amp;&amp; cur.val == sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.left) &#123;</span><br><span class="line">            cur.left.val += cur.val;</span><br><span class="line">            queue.push (cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right) &#123;</span><br><span class="line">            cur.right.val += cur.val;</span><br><span class="line">            queue.push (cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode404——左叶子之和（☆）"><a href="#LeetCode404——左叶子之和（☆）" class="headerlink" title="LeetCode404——左叶子之和（☆）"></a>LeetCode404——左叶子之和（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">跳转地址</a></p>
<h3 id="自己的代码-50"><a href="#自己的代码-50" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> getLeft=<span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span> ) &#123;</span><br><span class="line">            count += node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left &amp;&amp; getLeft(node.left);</span><br><span class="line">        node.right &amp;&amp; node.right.left &amp;&amp; getLeft(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    getLeft(root);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没有过，这里忽略了 root 为 [1] 的情况，但是想不到如何列出这种情况。</p>
<h3 id="思路-amp-题解-27"><a href="#思路-amp-题解-27" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>通过默认传参的方式标记递归的是左子树还是右子树，根节点默认false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> getLeft=<span class="function"><span class="keyword">function</span>(<span class="params">node, isLeft = <span class="literal">false</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 是左叶子结点再计算总和</span></span><br><span class="line">        <span class="keyword">if</span> (isLeft &amp;&amp; !node.left&amp;&amp; !node.right) &#123;</span><br><span class="line">            count += node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树递归传入true，右子树传入false</span></span><br><span class="line">        node.left &amp;&amp; getLeft(node.left, <span class="literal">true</span>);</span><br><span class="line">        node.right &amp;&amp; getLeft(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    getLeft(root);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode513——找树左下角的值（☆☆）"><a href="#LeetCode513——找树左下角的值（☆☆）" class="headerlink" title="LeetCode513——找树左下角的值（☆☆）"></a>LeetCode513——找树左下角的值（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">跳转地址</a></p>
<h3 id="自己的代码-51"><a href="#自己的代码-51" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [], result=[];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">while</span> (queue.length!= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">let</span> curList = [];</span><br><span class="line">        <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">            <span class="keyword">let</span> curNode = queue.shift();</span><br><span class="line">            curList.push(curNode);</span><br><span class="line">            curNode.left &amp;&amp; queue.push(curNode.left);</span><br><span class="line">            curNode.right &amp;&amp; queue.push(curNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(curList);</span><br><span class="line">    &#125;</span><br><span class="line">    result = res[res.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没有过，想法很简单，就是层序遍历后 return res最后一层的首位，但是最后结果是NaN，应该是哪数据类型错了。（二叉树无法调试=）</p>
<h3 id="思路1-amp-题解-29"><a href="#思路1-amp-题解-29" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>还是迭代，只是不需要借助数组，利用 resNode ，一直覆盖，直到遍历最底层的 curNode.val ，最后 return 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [], resNode;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> curNode = queue.shift();</span><br><span class="line">            <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                resNode = curNode.val;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode.left &amp;&amp; queue.push(curNode.left);</span><br><span class="line">            curNode.right &amp;&amp; queue.push(curNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-31"><a href="#思路2-amp-题解-31" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归比较深度，最深的第一个就是：(最底层最左，也可以是右子树的右子树)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 递归，找前序遍历中最大深度的叶子结点</span></span><br><span class="line">    <span class="keyword">let</span> maxPath = <span class="number">0</span>, resNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="function"><span class="keyword">function</span> (<span class="params">node, curPath</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curPath &gt; maxPath) &#123;</span><br><span class="line">                maxPath = curPath;</span><br><span class="line">                resNode = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.单层递归逻辑</span></span><br><span class="line">        node.left &amp;&amp; dfsTree(node.left, curPath + <span class="number">1</span>);</span><br><span class="line">        node.right &amp;&amp; dfsTree(node.right, curPath + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfsTree(root, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode226——翻转二叉树（☆）（★）"><a href="#LeetCode226——翻转二叉树（☆）（★）" class="headerlink" title="LeetCode226——翻转二叉树（☆）（★）"></a>LeetCode226——翻转二叉树（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/invert-binary-tree/">跳转地址</a></p>
<h3 id="自己的代码-52"><a href="#自己的代码-52" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>竟然没有思路，哎。想着是先左右中的顺序得到二叉树的节点，然后通过节点列表以右左中的顺序构造二叉树，但这样难度明显增大。</p>
<h3 id="思路1-amp-题解-30"><a href="#思路1-amp-题解-30" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ul>
<li><p>首先递归函数会走到底，遇到 root == null， 发现叶子节点没有root.left、root.right，执行为空。</p>
</li>
<li><p>回退，在第二层的节点，发现有 root.left、root.right 了，开始翻转（<strong>左右节点</strong>）。</p>
</li>
</ul>
<ul>
<li>在第一次根节点，继续翻转（<strong>左右子树</strong>）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> left = invertTree(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-32"><a href="#思路2-amp-题解-32" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invertTree</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">      [n.left, n.right] = [n.right, n.left];</span><br><span class="line">      stack.push(n.left, n.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）"><a href="#LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）" class="headerlink" title="LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）"></a>LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">跳转地址</a></p>
<h3 id="自己的代码-53"><a href="#自己的代码-53" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>大致思路理解，后序遍历的最后一个值即为根节点，然后在中序遍历中以根节点为界，左边就是左子树，右边就是右子树，再进行递归。可是不会用代码描述。</p>
<h3 id="思路-amp-题解-28"><a href="#思路-amp-题解-28" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span> (<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!inorder.length) &#123;<span class="keyword">return</span> <span class="literal">null</span>&#125;;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> mid = inorder.indexOf(postorder.pop());</span><br><span class="line">  <span class="comment">//左右子树递归</span></span><br><span class="line">  root.left = buildTree(inorder.slice(<span class="number">0</span>, mid), postorder.slice(<span class="number">0</span>, mid));</span><br><span class="line">  root.right = buildTree(inorder.slice(mid + <span class="number">1</span>), postorder.slice(mid));</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路没错，但是这最后有点没看懂。。</p>
<h2 id="LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）"><a href="#LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）" class="headerlink" title="LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）"></a>LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">跳转地址</a></p>
<h3 id="思路-amp-题解-29"><a href="#思路-amp-题解-29" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!preorder.length || !inorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 根节点</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">//找到preoder[0]对应inorder中的位置</span></span><br><span class="line">  <span class="keyword">let</span> index = inorder.indexOf(preorder.shift());</span><br><span class="line">  <span class="comment">//左右子树递归</span></span><br><span class="line">  node.left = buildTree(preorder, inorder.slice(<span class="number">0</span>, index));</span><br><span class="line">  node.right = buildTree(preorder, inorder.slice(index + <span class="number">1</span>));</span><br><span class="line">  <span class="comment">//返回根节点</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode617——合并二叉树（☆）"><a href="#LeetCode617——合并二叉树（☆）" class="headerlink" title="LeetCode617——合并二叉树（☆）"></a>LeetCode617——合并二叉树（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">跳转地址</a></p>
<h3 id="自己的代码-54"><a href="#自己的代码-54" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root1.left &amp;&amp; !root1.right &amp;&amp;!root2.left &amp;&amp;!root2.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 &amp;&amp; root2) &#123;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没写完，感觉对临界条件的判断还是很乱很乱。想的情况太多了。</p>
<h3 id="思路-amp-题解-30"><a href="#思路-amp-题解-30" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span> (<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件：如果t1 == NULL ，两个树合并就是 t2；如果t2 == NULL，两个数合并就是t1。</span></span><br><span class="line">    <span class="keyword">if</span> (!root1) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 单层递归逻辑（好像不用考虑root2.val是否存在？）</span></span><br><span class="line">    root1.val += root2.val;</span><br><span class="line">    root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">    root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode98——验证二叉搜索树（☆☆）"><a href="#LeetCode98——验证二叉搜索树（☆☆）" class="headerlink" title="LeetCode98——验证二叉搜索树（☆☆）"></a>LeetCode98——验证二叉搜索树（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">跳转地址</a></p>
<h3 id="自己的代码-55"><a href="#自己的代码-55" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全没头绪。</p>
<p>看了一眼题解，原来可以用中序遍历的方法判断是不是升序就行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">const</span> inOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root, res=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    inOrder(root.left, res);</span><br><span class="line">    res.push(root.val);</span><br><span class="line">    inOrder(root.right, res);</span><br><span class="line">  &#125;</span><br><span class="line">  inOrder(root, arr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= arr[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-33"><a href="#思路2-amp-题解-33" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：(写得也太巧了)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, min = -<span class="literal">Infinity</span>, max = <span class="literal">Infinity</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode236——二叉树的最近公共祖先（☆☆）（to-redo）"><a href="#LeetCode236——二叉树的最近公共祖先（☆☆）（to-redo）" class="headerlink" title="LeetCode236——二叉树的最近公共祖先（☆☆）（to redo）"></a>LeetCode236——二叉树的最近公共祖先（☆☆）（to redo）</h2><p>跳转地址</p>
<h3 id="自己的代码-56"><a href="#自己的代码-56" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。。</p>
<h3 id="思路-amp-题解-31"><a href="#思路-amp-题解-31" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>对于根节点 root，p、q 的分布，有两种可能：</p>
<ul>
<li>p、q 分居 root 的左右子树，则最近公共祖先（LCA） 为 root。</li>
<li>p、q 存在于 root 的同一侧子树中，就变成规模小一点的相同问题。</li>
</ul>
<p>从根节点 root 开始往下递归遍历：</p>
<ul>
<li><p>遍历到 p 或 q，比如 p，则 LCA 要么是当前的 p（q 在 p 的子树中），要么是 p 之上的节点（q 不在 p 的子树中），不可能是 p 之下的节点，因此返回当前的 p。</p>
</li>
<li><p>当遍历到 null 节点，没有 LCA，返回 null。</p>
</li>
<li><p>当遍历的节点 root 不是 p 或 q 或 null，则递归搜寻 root 的左右子树：</p>
<ul>
<li>如果左右子树的递归都有结果，说明 p 和 q 分居 root 的左右子树，返回 root。</li>
<li>如果只是一个子树递归调用有结果，说明 p 和 q 都在这个子树，返回该子树递归结果。</li>
<li>如果两个子树递归结果都为 null，说明 p 和 q 都不在这俩子树中，返回 null。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root || root === q || root === p)  <span class="keyword">return</span> root;</span><br><span class="line">  <span class="comment">// 非null 非q 非p，则递归左右子树</span></span><br><span class="line">  <span class="keyword">let</span> left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">  <span class="keyword">let</span> right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">  <span class="comment">// 根据递归的结果，决定谁是LCA</span></span><br><span class="line">  <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="LeetCode20——有效的括号（☆）（★）"><a href="#LeetCode20——有效的括号（☆）（★）" class="headerlink" title="LeetCode20——有效的括号（☆）（★）"></a>LeetCode20——有效的括号（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-parentheses/">跳转地址</a></p>
<h3 id="自己的代码-57"><a href="#自己的代码-57" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            stack.push(s[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (s[i])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack[stack.length-<span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack[stack.length-<span class="number">1</span>] == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>: &#123;</span><br><span class="line">                    <span class="keyword">if</span> (stack[stack.length-<span class="number">1</span>] == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                        stack.pop();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length==<span class="number">0</span>?<span class="literal">true</span>:<span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>又臭又长。</p>
<h3 id="思路-amp-题解-32"><a href="#思路-amp-题解-32" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; s.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span> (c !== stack.pop()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.length === <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者放入 map</span></span><br><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;   </span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">const</span> map = &#123;</span><br><span class="line">      <span class="string">&#x27;(&#x27;</span>: <span class="string">&#x27;)&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;[&#x27;</span>: <span class="string">&#x27;]&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;&#123;&#x27;</span>: <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; s.length ; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> c = s[i];</span><br><span class="line">        <span class="keyword">if</span> (map[c]) &#123;</span><br><span class="line">          stack.push(map[c])</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c !== stack.pop()) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !stack.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>基本类似的思路，但是匹配到左括号时， push 相应的右括号，再由后面的 pop 返回结果。</p>
<h2 id="LeetCode739——每日温度（☆☆）"><a href="#LeetCode739——每日温度（☆☆）" class="headerlink" title="LeetCode739——每日温度（☆☆）"></a>LeetCode739——每日温度（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/daily-temperatures/">跳转地址</a></p>
<h3 id="自己的代码-58"><a href="#自己的代码-58" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dailyTemperatures = <span class="function"><span class="keyword">function</span> (<span class="params">temperatures</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temperatures.length; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">let</span> tem = temperatures[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; temperatures.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tem &lt; temperatures[j]) &#123;</span><br><span class="line">                flag=<span class="literal">true</span></span><br><span class="line">                stack.push(j - i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123; stack.push(<span class="number">0</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>暴力双重循环，时间复杂度太高了。O(n^2)</p>
<h3 id="思路-amp-题解-33"><a href="#思路-amp-题解-33" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递减栈：</p>
<ul>
<li>如果当前元素比栈顶大，则让小项逐个出栈，直到当前元素比栈顶小，停止出栈</li>
<li>此时的栈顶元素就是当前项右边的第一个比自己大的元素索引，计算距离</li>
<li>当前项入栈</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dailyTemperatures = <span class="function">(<span class="params">T</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(T.length).fill(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> stack = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">while</span> (stack.length &amp;&amp; T[i] &gt;= T[stack[stack.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      stack.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stack.length) &#123;</span><br><span class="line">      res[i] = stack[stack.length - <span class="number">1</span>] - i</span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接用fill（0）填充数组。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>一次遍历：O(n)；每个元素都出栈入栈各一次：线性时间的复杂度。综合：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h2 id="LeetCode150——逆波兰表达式求值（☆☆）"><a href="#LeetCode150——逆波兰表达式求值（☆☆）" class="headerlink" title="LeetCode150——逆波兰表达式求值（☆☆）"></a>LeetCode150——逆波兰表达式求值（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">跳转地址</a></p>
<h3 id="自己的代码-59"><a href="#自己的代码-59" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evalRPN = <span class="function"><span class="keyword">function</span>(<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> numStack = [], signStack = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tokens.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(<span class="built_in">parseInt</span>(tokens[i]))) &#123;</span><br><span class="line">            numStack.push(tokens[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">            signStack.push(tokens[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>把数字和符号放进两个栈后不知道该怎么做了。遇到符号，可能数字栈有多于两个数字，就进行操作。若少于2个，就挂起，等超过两个后操作。怎么实现呢？</p>
<h3 id="思路-amp-题解-34"><a href="#思路-amp-题解-34" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> evalRPN = <span class="function"><span class="keyword">function</span>(<span class="params">tokens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stk = [], len = tokens.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp;</span><br><span class="line">        <span class="keyword">switch</span>(tokens[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                temp = stk.pop() + stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="comment">// 后出栈的 减 先出栈的</span></span><br><span class="line">                temp = - stk.pop() + stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                temp = stk.pop() * stk.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="comment">// 后出栈的 除以 先出栈的</span></span><br><span class="line">                <span class="comment">// parseInt 已经满足只保留整数部分的功能</span></span><br><span class="line">                temp = <span class="built_in">parseInt</span>(<span class="number">1</span> / stk.pop() * stk.pop());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其余都是数字</span></span><br><span class="line">                temp = <span class="built_in">parseInt</span>(tokens[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stk.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>自己想太多了，既然是逆波兰表达式，就不可能存在先一个数字再一个符号的情况。设立一个栈，每次对下一个数判断，得到temp值然后push就行。不算难。</p>
<h2 id="LeetCode84——柱状图中最大的矩形（☆☆☆）"><a href="#LeetCode84——柱状图中最大的矩形（☆☆☆）" class="headerlink" title="LeetCode84——柱状图中最大的矩形（☆☆☆）"></a>LeetCode84——柱状图中最大的矩形（☆☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">跳转地址</a></p>
<h3 id="自己的代码-60"><a href="#自己的代码-60" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>暴力求解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largestRectangleArea = <span class="function"><span class="keyword">function</span>(<span class="params">heights</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>, minHeight = <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; heights.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; heights.length; j++)&#123;</span><br><span class="line">      <span class="comment">// 找到一次循环中最小高度的柱子</span></span><br><span class="line">      minHeight = <span class="built_in">Math</span>.min(minHeight, heights[j]);</span><br><span class="line">      maxArea = <span class="built_in">Math</span>.max(maxArea, minHeight * (j-i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度O（n^2）</li>
<li>空间复杂度O（1）</li>
</ul>
<h3 id="思路1-amp-题解-31"><a href="#思路1-amp-题解-31" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴力优化版：（确定柱子后，寻找左右边界）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largestRectangleArea = <span class="function"><span class="keyword">function</span>(<span class="params">heights</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> len = heights.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = i;</span><br><span class="line">    <span class="keyword">let</span> right = i;</span><br><span class="line">    <span class="comment">// 找到第 i 个柱子的 left bounder</span></span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i]) &#123;</span><br><span class="line">      left--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到第 i 个柱子的 right bounder</span></span><br><span class="line">    <span class="keyword">while</span> (right &lt; len &amp;&amp; heights[right] &gt;= heights[i]) &#123;</span><br><span class="line">      right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定 left、right 后就能知道这个柱子围成的面积</span></span><br><span class="line">    maxArea = <span class="built_in">Math</span>.max(maxArea, (right - left - <span class="number">1</span>) * heights[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度O（n^2）</li>
<li>空间复杂度O（1）</li>
</ul>
<h3 id="思路2-amp-题解-34"><a href="#思路2-amp-题解-34" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>单调递增栈：(很牛逼的思路)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largestRectangleArea = <span class="function"><span class="keyword">function</span>(<span class="params">heights</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> maxArea = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="comment">// 第一个 0 为了让第一个柱子有左边界，最后一个 0 为了让最后一个柱子有右边界</span></span><br><span class="line">  heights = [<span class="number">0</span>, ...heights, <span class="number">0</span>]; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 比较栈顶元素值与第 i 个元素值大小，如果前者大于后者，则 pop 前者（因为找到右边界了），后者入栈并计算面积；否则后者入栈。</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span> &amp;&amp; heights[stack[stack.length - <span class="number">1</span>]] &gt; heights[i]) &#123;</span><br><span class="line">      maxArea = <span class="built_in">Math</span>.max(maxArea, heights[stack.pop()] * (i - stack[stack.length - <span class="number">1</span>] - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push 的是下标，通过 height[stack[stack.length - 1]] 得到值</span></span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode42——接雨水（☆☆☆）"><a href="#LeetCode42——接雨水（☆☆☆）" class="headerlink" title="LeetCode42——接雨水（☆☆☆）"></a>LeetCode42——接雨水（☆☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">跳转地址</a></p>
<p>todo，太难了，没看懂题解。（类似 LC84 ）</p>
<h2 id="LeetCode239——滑动窗口最大值（☆☆☆）"><a href="#LeetCode239——滑动窗口最大值（☆☆☆）" class="headerlink" title="LeetCode239——滑动窗口最大值（☆☆☆）"></a>LeetCode239——滑动窗口最大值（☆☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">跳转地址</a></p>
<h3 id="自己的代码-61"><a href="#自己的代码-61" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length - k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> max = -<span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; i + k; j++)&#123;</span><br><span class="line">      max = <span class="built_in">Math</span>.max(max, nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(max);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没过，O（n^2）超出时间限制。。</p>
<h3 id="思路1-amp-题解-32"><a href="#思路1-amp-题解-32" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>暴破：(仍然超时，主要学习一下 api 调用)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span> (<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= nums.length - k; i++) &#123;</span><br><span class="line">        res.push(<span class="built_in">Math</span>.max(...nums.slice(i, i + k)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度：O((N-k)*k)，N 是数组长度。</li>
<li>空间复杂度：O(1)。</li>
</ul>
<h3 id="思路2-amp-题解-35"><a href="#思路2-amp-题解-35" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>维护一个双端队列，保证队列首元素总是最大的。并且队列只存当前窗口有的元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSlidingWindow = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> q = [] <span class="comment">// 存放优先队列的元素下标，为了取值方便</span></span><br><span class="line">  <span class="keyword">const</span> result = [] <span class="comment">// 结果数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果队列不为空，当前元素大于队列里的其他元素，则弹出</span></span><br><span class="line">    <span class="keyword">while</span> (q.length &amp;&amp; nums[i] &gt;= nums[q[q.length - <span class="number">1</span>]]) &#123;</span><br><span class="line">      q.pop()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前元素下标入栈</span></span><br><span class="line">    q.push(i)</span><br><span class="line">    <span class="comment">// 判断当前最大值是否在窗口中，若不在则让其出队（有点没懂？？）</span></span><br><span class="line">    <span class="keyword">while</span> (q[<span class="number">0</span>] &lt;= i - k) &#123;</span><br><span class="line">      q.shift()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 达到窗口大小时，就向结果添加数据</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) result.push(nums[q[<span class="number">0</span>]])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="LeetCode242——有效的字母异位词（☆）"><a href="#LeetCode242——有效的字母异位词（☆）" class="headerlink" title="LeetCode242——有效的字母异位词（☆）"></a>LeetCode242——有效的字母异位词（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-anagram/">跳转地址</a></p>
<h3 id="自己的代码-62"><a href="#自己的代码-62" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>排序后再比较还是很简单的，重点是用 Map 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s1=s.split(<span class="string">&quot;&quot;</span>).sort().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> t1=t.split(<span class="string">&quot;&quot;</span>).sort().join(<span class="string">&quot;&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> s1===t1</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// map（没过）</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(), s1 = s.split(<span class="string">&#x27;&#x27;</span>), t1 = t.split(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s1[i]]) &#123;</span><br><span class="line">      map[s1[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(s1[i], <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t1.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (map[t1[i]]) &#123;</span><br><span class="line">      map[t1[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !map.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原来只要新建 map 时令它为 {} 就行。如果是 new Map，就涉及到 has get set 等 api 。</p>
<h3 id="思路-amp-题解-35"><a href="#思路-amp-题解-35" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>注意 map 不能直接 <code>map[i]++</code> ；字符串可以直接 for of 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t.length !== s.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> counts = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">        <span class="comment">// 学起来！</span></span><br><span class="line">        counts[c] = (counts[c] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!counts[c]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        counts[c]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> isAnagram = <span class="function"><span class="keyword">function</span>(<span class="params">s, t</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length !== t.length) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">        map[s[i]] ? map[s[i]]++ : map[s[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[t[i]]) map[t[i]]--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode49——字母异位词分组（☆☆）-1"><a href="#LeetCode49——字母异位词分组（☆☆）-1" class="headerlink" title="LeetCode49——字母异位词分组（☆☆）"></a>LeetCode49——字母异位词分组（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/group-anagrams/">跳转地址</a></p>
<h3 id="自己的代码-63"><a href="#自己的代码-63" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> groupAnagrams = <span class="function"><span class="keyword">function</span> (<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;, res = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> strs) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = i.split(<span class="string">&#x27;&#x27;</span>).sort().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    map[str] ? map[str].push(i) : map[str] = [i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> map) &#123;</span><br><span class="line">    res.push(map[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>趁热打铁还是能写出来的哈哈。</p>
<h3 id="思路-amp-题解-36"><a href="#思路-amp-题解-36" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>好像是比较简便的方法了，但是最后输出时完全可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.values(map);*</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-61——扑克牌中的顺子（☆）（★）"><a href="#剑指-Offer-61——扑克牌中的顺子（☆）（★）" class="headerlink" title="剑指 Offer 61——扑克牌中的顺子（☆）（★）"></a>剑指 Offer 61——扑克牌中的顺子（☆）（★）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">跳转地址</a></p>
<h3 id="思路-amp-题解-37"><a href="#思路-amp-题解-37" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isStraight = <span class="function"><span class="keyword">function</span> (<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">let</span> [min, max] = [<span class="number">14</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num === <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (set.has(num)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        set.add(num);</span><br><span class="line">        max = <span class="built_in">Math</span>.max(max, num);</span><br><span class="line">        min = <span class="built_in">Math</span>.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max - min &lt; <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/06/09/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">https://asura1211.github.io/2021/06/09/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E7%BB%84/">数组</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/"><img class="prev-cover" src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【阅读笔记】— — 浏览器工作原理（极客时间）</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20pink%E8%80%81%E5%B8%88js%E8%BF%9B%E9%98%B6/"><img class="next-cover" src="https://i.loli.net/2021/06/07/3boUIdzwVjvaMu6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【阅读笔记】— — pink老师js进阶</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Asura1211"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8E%E6%95%88%E7%9A%84%E2%80%9C%E6%8F%92%E5%85%A5%E2%80%9D%E5%92%8C%E2%80%9C%E5%88%A0%E9%99%A4%E2%80%9D"><span class="toc-number">2.1.</span> <span class="toc-text">低效的“插入”和“删除”</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.1.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.1.2.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode1%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">LeetCode1——两数之和（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.2.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode167%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-II-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">LeetCode167——两数之和 II - 输入有序数组（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.3.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.3.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.3.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode724%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">LeetCode724——寻找数组的中心索引（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">2.4.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode88%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%E2%98%85%E2%98%85%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">LeetCode88——合并两个有序数组（☆）（★★★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">2.5.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode56%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">LeetCode56——合并区间（☆☆）（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.6.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.6.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.6.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode2015%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%E2%98%85%EF%BC%89"><span class="toc-number">2.7.</span> <span class="toc-text">LeetCode2015——旋转矩阵（☆☆）（★★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-4"><span class="toc-number">2.7.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">2.7.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">2.7.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">2.7.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode2016%E2%80%94%E2%80%94%E9%9B%B6%E7%9F%A9%E9%98%B5%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">LeetCode2016——零矩阵（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-5"><span class="toc-number">2.8.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode498%E2%80%94%E2%80%94%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88todo%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">LeetCode498——对角线遍历（☆☆）（todo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-6"><span class="toc-number">2.9.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.9.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode561%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86-I%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">LeetCode561——数组拆分 I（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-7"><span class="toc-number">2.10.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">2.10.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode209%E2%80%94%E2%80%94%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.11.</span> <span class="toc-text">LeetCode209——长度最小的子数组（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-8"><span class="toc-number">2.11.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">2.11.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode118%E2%80%94%E2%80%94%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.12.</span> <span class="toc-text">LeetCode118——杨辉三角（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-9"><span class="toc-number">2.12.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">2.12.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode557%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.13.</span> <span class="toc-text">LeetCode557——反转字符串（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-10"><span class="toc-number">2.13.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">2.13.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode283%E2%80%94%E2%80%94%E7%A7%BB%E5%8A%A8%E9%9B%B6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">LeetCode283——移动零（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-11"><span class="toc-number">2.14.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">2.14.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode70%E2%80%94%E2%80%94%E7%88%AC%E6%A5%BC%E6%A2%AF%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.15.</span> <span class="toc-text">LeetCode70——爬楼梯（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-12"><span class="toc-number">2.15.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">2.15.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode15%E2%80%94%E2%80%94%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%EF%BC%88%E2%98%86%E2%98%86-%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.16.</span> <span class="toc-text">LeetCode15——三数之和（☆☆ 高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-13"><span class="toc-number">2.16.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">2.16.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">2.16.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">2.16.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode11%E2%80%94%E2%80%94%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.17.</span> <span class="toc-text">LeetCode11——盛最多水的容器（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-14"><span class="toc-number">2.17.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">2.17.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode189%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.18.</span> <span class="toc-text">LeetCode189——旋转数组（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-15"><span class="toc-number">2.18.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">2.18.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">2.18.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">2.18.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode217%E2%80%94%E2%80%94%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.19.</span> <span class="toc-text">LeetCode217——存在重复元素（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-16"><span class="toc-number">2.19.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">2.19.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">2.19.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode136%E2%80%94%E2%80%94%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.20.</span> <span class="toc-text">LeetCode136——只出现一次的数字（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-17"><span class="toc-number">2.20.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">2.20.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">2.20.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">2.20.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode350%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-II%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.21.</span> <span class="toc-text">LeetCode350——两个数组的交集 II（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-18"><span class="toc-number">2.21.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">2.21.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">2.21.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF3-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">2.21.4.</span> <span class="toc-text">思路3&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode66%E2%80%94%E2%80%94%E5%8A%A0%E4%B8%80%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.22.</span> <span class="toc-text">LeetCode66——加一（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-19"><span class="toc-number">2.22.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-11"><span class="toc-number">2.22.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode36%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88to-redo%EF%BC%89"><span class="toc-number">2.23.</span> <span class="toc-text">LeetCode36——有效的数独（☆☆）（to redo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-20"><span class="toc-number">2.23.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">2.23.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">2.23.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode22%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.24.</span> <span class="toc-text">LeetCode22——括号生成（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-21"><span class="toc-number">2.24.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode169%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">2.25.</span> <span class="toc-text">LeetCode169——多数元素（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-22"><span class="toc-number">2.25.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">2.25.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">2.25.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-42%E2%80%94%E2%80%94%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%E2%98%85%EF%BC%89"><span class="toc-number">2.26.</span> <span class="toc-text">剑指 Offer 42——连续子数组的最大和（☆）（★★）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-03%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E2%98%86-%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">2.27.</span> <span class="toc-text">剑指 Offer 03——数组中重复的数字（☆)（★）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode493%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E5%AF%B9%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">2.28.</span> <span class="toc-text">LeetCode493——翻转对（☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-23"><span class="toc-number">2.28.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-12"><span class="toc-number">2.28.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode718%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">2.29.</span> <span class="toc-text">LeetCode718——最长重复子数组（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">2.29.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-11"><span class="toc-number">2.29.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-II-060%E2%80%94%E2%80%94%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84-k-%E4%B8%AA%E6%95%B0%E5%AD%97%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85todo%EF%BC%89"><span class="toc-number">2.30.</span> <span class="toc-text">剑指 Offer II 060——出现频率最高的 k 个数字（☆☆）（★todo）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode14%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">LeetCode14——最长公共前缀（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-24"><span class="toc-number">3.1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-11"><span class="toc-number">3.1.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-12"><span class="toc-number">3.1.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode5%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88to-redo%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">LeetCode5——最长回文子串（☆☆）（to redo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-25"><span class="toc-number">3.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-13"><span class="toc-number">3.2.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode151%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%E2%98%85%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">LeetCode151——翻转字符串里的单词（☆☆）（★★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-26"><span class="toc-number">3.3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-12"><span class="toc-number">3.3.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-13"><span class="toc-number">3.3.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode387%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">LeetCode387——字符串中的第一个唯一字符（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-27"><span class="toc-number">3.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-13"><span class="toc-number">3.4.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-14"><span class="toc-number">3.4.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode125%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">LeetCode125——验证回文串（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-28"><span class="toc-number">3.5.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-14"><span class="toc-number">3.5.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-15"><span class="toc-number">3.5.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">1047. 删除字符串中的所有相邻重复项（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-29"><span class="toc-number">3.6.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-14"><span class="toc-number">3.6.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode8%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi-%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88to-redo%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">LeetCode8——字符串转换整数 (atoi)（☆☆）（to redo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-30"><span class="toc-number">3.7.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-15"><span class="toc-number">3.7.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-16"><span class="toc-number">3.7.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode38%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89-to-redo"><span class="toc-number">3.8.</span> <span class="toc-text">LeetCode38——外观数列（☆☆）(to redo)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-31"><span class="toc-number">3.8.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-16"><span class="toc-number">3.8.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode58%E2%80%94%E2%80%94%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.9.</span> <span class="toc-text">LeetCode58——最后一个单词的长度（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-17"><span class="toc-number">3.9.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode541%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.10.</span> <span class="toc-text">LeetCode541——反转字符串 II（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-18"><span class="toc-number">3.10.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode49%E2%80%94%E2%80%94%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">3.11.</span> <span class="toc-text">LeetCode49——字母异位词分组（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-32"><span class="toc-number">3.11.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode438%E2%80%94%E2%80%94%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89-to-redo"><span class="toc-number">3.12.</span> <span class="toc-text">LeetCode438——找到字符串中所有字母异位词（☆☆）(to redo)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-15"><span class="toc-number">3.12.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3%EF%BC%88to-understand%EF%BC%89"><span class="toc-number">3.12.2.</span> <span class="toc-text">思路2&amp;题解（to understand）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode680%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2-%E2%85%A1%EF%BC%88%E2%98%86%EF%BC%89-to-redo"><span class="toc-number">3.13.</span> <span class="toc-text">LeetCode680——验证回文字符串 Ⅱ（☆）(to redo)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-19"><span class="toc-number">3.13.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-48%EF%BC%88LC3%EF%BC%89%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%E2%98%85-%EF%BC%89"><span class="toc-number">3.14.</span> <span class="toc-text">剑指 Offer 48（LC3）——最长不含重复字符的子字符串（☆☆）（★★ ）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-33"><span class="toc-number">3.14.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-20"><span class="toc-number">3.14.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode1143%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">3.15.</span> <span class="toc-text">LeetCode1143——最长公共子序列（☆☆）（★）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-43%E2%80%94%E2%80%941%EF%BD%9En-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89%EF%BC%88todo%EF%BC%89"><span class="toc-number">3.16.</span> <span class="toc-text">剑指 Offer 43——1～n 整数中 1 出现的次数（☆☆☆）（★）（todo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-34"><span class="toc-number">3.16.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-21"><span class="toc-number">3.16.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%89%E6%9D%83%E9%87%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">3.17.</span> <span class="toc-text">字符串按权重排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode141%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">LeetCode141——环形链表（☆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode142%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%E2%98%85%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">LeetCode142——环形链表II（☆☆）（★★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-35"><span class="toc-number">4.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-16"><span class="toc-number">4.2.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-17"><span class="toc-number">4.2.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode160%E2%80%94%E2%80%94%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">LeetCode160——相交链表（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-36"><span class="toc-number">4.3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-17"><span class="toc-number">4.3.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-18"><span class="toc-number">4.3.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode206%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%E2%98%85%E2%98%85%E2%98%85%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">LeetCode206——反转链表（☆）（★★★★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-37"><span class="toc-number">4.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-22"><span class="toc-number">4.4.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-19"><span class="toc-number">4.4.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode21%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">LeetCode21——合并两个有序链表（☆）（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-38"><span class="toc-number">4.5.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-18"><span class="toc-number">4.5.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-20"><span class="toc-number">4.5.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode24%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">4.6.</span> <span class="toc-text">LeetCode24——两两交换链表中的节点（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-39"><span class="toc-number">4.6.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-19"><span class="toc-number">4.6.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-21"><span class="toc-number">4.6.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode25%E2%80%94%E2%80%94K-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88to-redo%EF%BC%89"><span class="toc-number">4.7.</span> <span class="toc-text">LeetCode25——K 个一组翻转链表（☆☆☆）（to redo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-40"><span class="toc-number">4.7.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-23"><span class="toc-number">4.7.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode144%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-II%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85todo%EF%BC%89"><span class="toc-number">4.8.</span> <span class="toc-text">LeetCode144——删除排序链表中的重复元素 II（☆☆）（★todo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-20"><span class="toc-number">4.8.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-22"><span class="toc-number">4.8.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-II-026%E2%80%94%E2%80%94%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89%EF%BC%88todo%EF%BC%89"><span class="toc-number">4.9.</span> <span class="toc-text">剑指 Offer II 026——重排链表（☆☆）（★）（todo）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode144%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">LeetCode144——二叉树的前序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-41"><span class="toc-number">5.1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-21"><span class="toc-number">5.1.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-23"><span class="toc-number">5.1.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode94%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">LeetCode94——二叉树的中序遍历（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-42"><span class="toc-number">5.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">思路2&amp;题解（★）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode145%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">LeetCode145——二叉树的后序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-43"><span class="toc-number">5.3.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode102%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%E2%98%85%E2%98%85%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">LeetCode102——二叉树的层序遍历（☆☆）（★★★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-44"><span class="toc-number">5.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-22"><span class="toc-number">5.4.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-24"><span class="toc-number">5.4.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode637%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">LeetCode637——二叉树的层平均值（☆）（★）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode589%E2%80%94%E2%80%94N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">LeetCode589——N叉树的前序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-23"><span class="toc-number">5.6.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-25"><span class="toc-number">5.6.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode145%E2%80%94%E2%80%94N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">LeetCode145——N叉树的后序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-24"><span class="toc-number">5.7.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-26"><span class="toc-number">5.7.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode429%E2%80%94%E2%80%94N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">LeetCode429——N叉树的层序遍历（☆☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-24"><span class="toc-number">5.8.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode104%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">5.9.</span> <span class="toc-text">LeetCode104——二叉树的最大深度（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-45"><span class="toc-number">5.9.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-25"><span class="toc-number">5.9.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-27"><span class="toc-number">5.9.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode104%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.10.</span> <span class="toc-text">LeetCode104——二叉树的最小深度（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-26"><span class="toc-number">5.10.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-28"><span class="toc-number">5.10.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode101%E2%80%94%E2%80%94%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.11.</span> <span class="toc-text">LeetCode101——对称二叉树（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-46"><span class="toc-number">5.11.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-27"><span class="toc-number">5.11.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-29"><span class="toc-number">5.11.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode222%E2%80%94%E2%80%94%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">5.12.</span> <span class="toc-text">LeetCode222——完全二叉树的节点个数（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-47"><span class="toc-number">5.12.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-25"><span class="toc-number">5.12.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode257%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">5.13.</span> <span class="toc-text">LeetCode257——二叉树的所有路径（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-48"><span class="toc-number">5.13.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-26"><span class="toc-number">5.13.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode112%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.14.</span> <span class="toc-text">LeetCode112——路径总和（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-49"><span class="toc-number">5.14.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-28"><span class="toc-number">5.14.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-30"><span class="toc-number">5.14.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode404%E2%80%94%E2%80%94%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.15.</span> <span class="toc-text">LeetCode404——左叶子之和（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-50"><span class="toc-number">5.15.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-27"><span class="toc-number">5.15.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode513%E2%80%94%E2%80%94%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">5.16.</span> <span class="toc-text">LeetCode513——找树左下角的值（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-51"><span class="toc-number">5.16.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-29"><span class="toc-number">5.16.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-31"><span class="toc-number">5.16.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode226%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">5.17.</span> <span class="toc-text">LeetCode226——翻转二叉树（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-52"><span class="toc-number">5.17.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-30"><span class="toc-number">5.17.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-32"><span class="toc-number">5.17.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode106%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">5.18.</span> <span class="toc-text">LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-53"><span class="toc-number">5.18.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-28"><span class="toc-number">5.18.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode105%E2%80%94%E2%80%94%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">5.19.</span> <span class="toc-text">LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-29"><span class="toc-number">5.19.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode617%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">5.20.</span> <span class="toc-text">LeetCode617——合并二叉树（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-54"><span class="toc-number">5.20.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-30"><span class="toc-number">5.20.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode98%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">5.21.</span> <span class="toc-text">LeetCode98——验证二叉搜索树（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-55"><span class="toc-number">5.21.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-33"><span class="toc-number">5.21.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode236%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88to-redo%EF%BC%89"><span class="toc-number">5.22.</span> <span class="toc-text">LeetCode236——二叉树的最近公共祖先（☆☆）（to redo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-56"><span class="toc-number">5.22.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-31"><span class="toc-number">5.22.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode20%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">LeetCode20——有效的括号（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-57"><span class="toc-number">6.1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-32"><span class="toc-number">6.1.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode739%E2%80%94%E2%80%94%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">LeetCode739——每日温度（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-58"><span class="toc-number">6.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-33"><span class="toc-number">6.2.2.</span> <span class="toc-text">思路&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">6.2.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode150%E2%80%94%E2%80%94%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">LeetCode150——逆波兰表达式求值（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-59"><span class="toc-number">6.3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-34"><span class="toc-number">6.3.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode84%E2%80%94%E2%80%94%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">LeetCode84——柱状图中最大的矩形（☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-60"><span class="toc-number">6.4.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">6.4.2.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-31"><span class="toc-number">6.4.3.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">6.4.4.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-34"><span class="toc-number">6.4.5.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode42%E2%80%94%E2%80%94%E6%8E%A5%E9%9B%A8%E6%B0%B4%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">LeetCode42——接雨水（☆☆☆）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode239%E2%80%94%E2%80%94%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E2%98%86%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">LeetCode239——滑动窗口最大值（☆☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-61"><span class="toc-number">6.6.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-32"><span class="toc-number">6.6.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">6.6.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-35"><span class="toc-number">6.6.4.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">7.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode242%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">LeetCode242——有效的字母异位词（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-62"><span class="toc-number">7.1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-35"><span class="toc-number">7.1.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode49%E2%80%94%E2%80%94%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89-1"><span class="toc-number">7.2.</span> <span class="toc-text">LeetCode49——字母异位词分组（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-63"><span class="toc-number">7.2.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-36"><span class="toc-number">7.2.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87-Offer-61%E2%80%94%E2%80%94%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90%EF%BC%88%E2%98%86%EF%BC%89%EF%BC%88%E2%98%85%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">剑指 Offer 61——扑克牌中的顺子（☆）（★）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-37"><span class="toc-number">7.3.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">8.</span> <span class="toc-text">堆</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家社区商城"/></a><div class="content"><a class="title" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城">【项目复盘】— — 贤得家社区商城</a><time datetime="2021-10-31T15:01:17.000Z" title="发表于 2021-10-31 23:01:17">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/11/26/c8CoiAjKTyGNS4a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" title="【学习笔记】— — 字节青训营"><img src="https://i.loli.net/2021/11/20/6kUmfsBR2yEIqnD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【学习笔记】— — 字节青训营"/></a><div class="content"><a class="title" href="/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" title="【学习笔记】— — 字节青训营">【学习笔记】— — 字节青训营</a><time datetime="2021-08-14T15:04:54.000Z" title="发表于 2021-08-14 23:04:54">2021-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/16/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E5%A0%82%E6%A8%A1%E5%9D%97/" title="【项目复盘】— — 贤得家e社区学堂管理系统"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家e社区学堂管理系统"/></a><div class="content"><a class="title" href="/2021/07/16/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E5%A0%82%E6%A8%A1%E5%9D%97/" title="【项目复盘】— — 贤得家e社区学堂管理系统">【项目复盘】— — 贤得家e社区学堂管理系统</a><time datetime="2021-07-16T19:55:25.000Z" title="发表于 2021-07-17 03:55:25">2021-07-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>