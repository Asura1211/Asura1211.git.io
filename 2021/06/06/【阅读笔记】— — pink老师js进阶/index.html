<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【阅读笔记】— — pink老师js进阶 | 青山の博客</title><meta name="keywords" content="JavaScript"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是我在跟学B站javascript视频过程中所做的笔记，也是为了后续更好的复习（这知识过一遍它不进脑子哇~） 部分内容参考自https:&#x2F;&#x2F;taylor12138.gitee.io&#x2F; 面向对象ES6中的类和对象 在 JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。  class类在ES6中新增加了类的概念，可以使用 clas">
<meta property="og:type" content="article">
<meta property="og:title" content="【阅读笔记】— — pink老师js进阶">
<meta property="og:url" content="https://asura1211.github.io/2021/06/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20pink%E8%80%81%E5%B8%88js%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是我在跟学B站javascript视频过程中所做的笔记，也是为了后续更好的复习（这知识过一遍它不进脑子哇~） 部分内容参考自https:&#x2F;&#x2F;taylor12138.gitee.io&#x2F; 面向对象ES6中的类和对象 在 JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。  class类在ES6中新增加了类的概念，可以使用 clas">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/07/3boUIdzwVjvaMu6.jpg">
<meta property="article:published_time" content="2021-06-06T11:04:07.000Z">
<meta property="article:modified_time" content="2021-07-01T13:11:45.348Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/07/3boUIdzwVjvaMu6.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/06/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20pink%E8%80%81%E5%B8%88js%E8%BF%9B%E9%98%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【阅读笔记】— — pink老师js进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-07-01 21:11:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/07/3boUIdzwVjvaMu6.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【阅读笔记】— — pink老师js进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-06T11:04:07.000Z" title="发表于 2021-06-06 19:04:07">2021-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-01T13:11:45.348Z" title="更新于 2021-07-01 21:11:45">2021-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【阅读笔记】— — pink老师js进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在跟学<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kt411w7MP">B站javascript视频</a>过程中所做的笔记，也是为了后续更好的复习（这知识过一遍它不进脑子哇~）</p>
<p>部分内容参考自<a target="_blank" rel="noopener" href="https://taylor12138.gitee.io/">https://taylor12138.gitee.io/</a></p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="ES6中的类和对象"><a href="#ES6中的类和对象" class="headerlink" title="ES6中的类和对象"></a>ES6中的类和对象</h2><blockquote>
<p>在 JavaScript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p>
</blockquote>
<h3 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h3><p>在ES6中新增加了类的概念，可以使用 class关键字声明一个类，之后以这个类来实例化对象。</p>
<p><strong>类</strong>抽象了对象的公共部分，它泛指某大类（class），而 <strong>对象</strong>特指某一个。通过类实例化<strong>一个具体</strong>的对象</p>
<p>面向对象的思维特点：</p>
<ol>
<li>抽取（抽象）对象共用的属性和行为组织（封装）成一个<strong>类</strong>（模板</li>
<li>对类进行实例化获取类的<strong>对象</strong></li>
</ol>
<h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">name</span></span>&#123;</span><br><span class="line">  <span class="comment">// class body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> name()</span><br></pre></td></tr></table></figure>

<h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h3><p><strong>constructor()<strong>方法是类的构造函数（默认方法），</strong>用于传递参数返回实例对象</strong>。通过<strong>new命令</strong>生成对象实例时，自动调用该方法。如果没有显示定义,类内部会自动给我们创建一个 **constructor()**。</p>
<h3 id="创建第一个类和对象"><a href="#创建第一个类和对象" class="headerlink" title="创建第一个类和对象"></a>创建第一个类和对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建类 class 创建一个明显类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">uname, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.uname = uname <span class="comment">//this 指向创建的实例  this=&gt;ldh</span></span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.利用类创建对象</span></span><br><span class="line"><span class="keyword">let</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> zxy = <span class="keyword">new</span> Star(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ldh); <span class="comment">//  &#123;uname: &quot;刘德华&quot;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(zxy); <span class="comment">//  &#123;uname: &quot;张学友&quot;, age: 20&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>通过class 关键字创建类, 类名我们还是习惯性定义<strong>首字母大写</strong></li>
<li>类里面有个constructor 函数,可以<strong>接受</strong>传递过来的<strong>参数</strong>,同时<strong>返回实例对象</strong></li>
<li>constructor 函数 只要 new 生成实例时,就会<strong>自动调用</strong>这个函数,如果我们不写这个函数,类也会<strong>自动生成</strong>这个<strong>函数</strong></li>
<li>生成实例 <strong>new</strong> 不能省略</li>
<li>最后注意语法规范, 创建类时 <strong>类名</strong>后面<strong>不要加小括号</strong>,生成实例时 类名后面<strong>加小括号</strong>, <strong>构造函数不需要加 function</strong></li>
</ol>
<h3 id="类中添加方法"><a href="#类中添加方法" class="headerlink" title="类中添加方法"></a>类中添加方法</h3><p>注意事项：</p>
<ol>
<li>类里边<strong>所有函数不需要写 function 关键字</strong></li>
<li>多个函数或者方法之间<strong>不需要加</strong> <strong>(逗号)</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建类 class 创建一个明显类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">uname, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.uname = uname <span class="comment">//this 指向创建的实例  this=&gt;ldh</span></span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sing</span>(<span class="params">song</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.uname + <span class="string">&#x27;唱&#x27;</span> + song)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.利用类创建对象</span></span><br><span class="line"><span class="keyword">let</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">let</span> zxy = <span class="keyword">new</span> Star(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ldh); <span class="comment">//  &#123;uname: &quot;刘德华&quot;, age: 18&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(zxy); <span class="comment">//  &#123;uname: &quot;张学友&quot;, age: 20&#125;</span></span><br><span class="line"></span><br><span class="line">ldh.sing(<span class="string">&#x27;冰雨&#x27;</span>) <span class="comment">//刘德华唱冰雨</span></span><br><span class="line">zxy.sing(<span class="string">&#x27;李香兰&#x27;</span>) <span class="comment">//张学友唱李香兰</span></span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>在Es6中类<strong>没有变量提升</strong>，所以必须先<strong>定义类</strong>，<strong>才能</strong>通过类<strong>实例化</strong>对象</li>
<li>类里面共有的属性和方法<strong>一定要加this使用</strong></li>
<li>类里边的this指向问题<ul>
<li><strong>constructor里面的this指向实例对象</strong></li>
<li><strong>方法里面的this指向这个方法的调用者</strong></li>
</ul>
</li>
</ol>
<h3 id="this指向问题案例"><a href="#this指向问题案例" class="headerlink" title="this指向问题案例"></a><strong>this指向问题案例</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> that;</span><br><span class="line"><span class="keyword">var</span> _that;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Star</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">uname, age</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// constructor 里面的this 指向的是 创建的实例对象</span></span><br><span class="line">        that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.uname = uname;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="comment">// this.sing();</span></span><br><span class="line">        <span class="built_in">this</span>.btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.btn.onclick = <span class="built_in">this</span>.sing;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sing</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个sing方法里面的this 指向的是 btn 这个按钮,因为这个按钮调用了这个函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(that.uname); <span class="comment">// that.uname刘德华 that里面存储的是constructor里面的this  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">dance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 这个dance里面的this 指向的是实例对象 ldh 因为ldh 调用了这个函数</span></span><br><span class="line">        _that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">//Star &#123;uname: &quot;刘德华&quot;, age: undefined, btn: button&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(that === ldh); <span class="comment">//true</span></span><br><span class="line">ldh.dance();</span><br><span class="line"><span class="built_in">console</span>.log(_that === ldh); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>继承中，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就先执行子类的方法，如果子类里面没有，就去查找父类有没有这个方法，如果有，就执行父类的这个方法（就近原 则）</p>
</blockquote>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">	<span class="comment">//父类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">	<span class="comment">//子类继承父类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.类的继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">money</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son()</span><br><span class="line">son.money()  <span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<h3 id="super-超级的-关键字"><a href="#super-超级的-关键字" class="headerlink" title="super(超级的) 关键字"></a>super(超级的) 关键字</h3><p><strong>super</strong>关键字用于访问和调用对象父类上的函数。可以<strong>调用</strong>父类的<strong>构造函数</strong>，<strong>也可以调用</strong>父类的<strong>普通函数</strong></p>
<p>示例：调用<strong>构造函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="built_in">this</span>.y)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里不能访问父类的 this,父类的sum函数中的this是父类的，子类值没有传递进去</span></span><br><span class="line">    <span class="comment">// this.x = x // 报错</span></span><br><span class="line">    <span class="comment">// this.y = y // 报错</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(x,y);<span class="comment">//调用父类中的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">son.sum() <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>示例：调用<strong>普通函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// super调用父类的普通函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;我是爸爸&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">//调用父类的普通方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">super</span>.say()); <span class="comment">//我是爸爸</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son()</span><br></pre></td></tr></table></figure>

<h3 id="继承方法的同时扩展方法"><a href="#继承方法的同时扩展方法" class="headerlink" title="继承方法的同时扩展方法"></a>继承方法的同时扩展方法</h3><p>需求：继承父类的加法方法的同时，自己扩展一个减法方法。</p>
<p>注意事项：<strong>调用父类的函数时</strong>，super必须在子类this之前调用(<strong>父亲必须放在之前</strong>)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类加法操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sum</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="built_in">this</span>.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类继承父类加法方法的同时扩展减法操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数 super必须在子类this之前调用(父亲必须放在之前)</span></span><br><span class="line">    <span class="built_in">super</span>(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">subtract</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x - <span class="built_in">this</span>.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">son.subtract() <span class="comment">// 2</span></span><br><span class="line">son.sum() <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h2 id="Tab栏-案例"><a href="#Tab栏-案例" class="headerlink" title="Tab栏 案例"></a>Tab栏 案例</h2><p>功能描述：</p>
<ol>
<li>点击Tab栏能实现<strong>切换</strong></li>
<li>Tab栏和内容 点击右上角×号能<strong>删除</strong>当前<strong>栏目和内容</strong></li>
<li>点击加号能实现<strong>增加Tab栏</strong>功能</li>
<li><strong>双击Tab栏</strong>，可以<strong>编辑Tab栏名称</strong></li>
<li><strong>双击内容</strong>，可<strong>编辑内容</strong></li>
</ol>
<h3 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tab</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        <span class="built_in">this</span>.main = <span class="built_in">document</span>.querySelector(id);</span><br><span class="line">        <span class="built_in">this</span>.lis = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.sections = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;section&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// init 初始化操作让相关的元素绑定事件</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">            <span class="built_in">this</span>.lis[i].index = i;</span><br><span class="line">            <span class="comment">//方法后面不能加（），否则直接调用</span></span><br><span class="line">            <span class="built_in">this</span>.lis[i].onclick = <span class="built_in">this</span>.toggleTab;</span><br><span class="line">            <span class="built_in">this</span>.remove[i].onclick = <span class="built_in">this</span>.removeTab;</span><br><span class="line">            <span class="built_in">this</span>.spans[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">            <span class="built_in">this</span>.sections[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 切换功能</span></span><br><span class="line">    <span class="function"><span class="title">toggleTab</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 2. 添加功能</span></span><br><span class="line">    <span class="function"><span class="title">addTab</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 3. 删除功能</span></span><br><span class="line">    <span class="function"><span class="title">removeTab</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    <span class="comment">// 4. 修改功能</span></span><br><span class="line">    <span class="function"><span class="title">editTab</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Tab(<span class="string">&#x27;#tab&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="点击Tab栏能实现切换-Tab栏和内容"><a href="#点击Tab栏能实现切换-Tab栏和内容" class="headerlink" title="点击Tab栏能实现切换 Tab栏和内容"></a>点击Tab栏能实现切换 Tab栏和内容</h3><p><img src="https://i.loli.net/2021/06/06/Wi6KfSmcpPLqTJC.gif" alt="切换tab页.gif"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 切换功能</span></span><br><span class="line"><span class="function"><span class="title">toggleTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 通过var that = this 保存最初调用的this指向</span></span><br><span class="line">    that.clearClass();</span><br><span class="line">    <span class="built_in">this</span>.className = <span class="string">&#x27;liactive&#x27;</span>;</span><br><span class="line">    that.sections[<span class="built_in">this</span>.index].className = <span class="string">&#x27;conactive&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 清除所有li 和section 的类</span></span><br><span class="line"><span class="function"><span class="title">clearClass</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.lis[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.sections[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点击加号能实现增加Tab栏效果"><a href="#点击加号能实现增加Tab栏效果" class="headerlink" title="点击加号能实现增加Tab栏效果"></a>点击加号能实现增加Tab栏效果</h3><p><img src="https://i.loli.net/2021/06/06/ROI3PrLAwiGjCKp.gif" alt="新增tab页.gif"></p>
<blockquote>
<p>如下代码都为在原来的基础上新增</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取元素</span></span><br><span class="line">    <span class="built_in">this</span>.add = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.tabadd&#x27;</span>);</span><br><span class="line">    <span class="comment">// li的父元素</span></span><br><span class="line">    <span class="built_in">this</span>.ul = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.fisrstnav ul:first-child&#x27;</span>);</span><br><span class="line">    <span class="comment">// section 父元素</span></span><br><span class="line">    <span class="built_in">this</span>.fsection = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.tabscon&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.updateNode();</span><br><span class="line">    <span class="comment">// init 初始化操作让相关的元素绑定事件</span></span><br><span class="line">    <span class="built_in">this</span>.add.onclick = <span class="built_in">this</span>.addTab;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.lis[i].index = i;</span><br><span class="line">        <span class="built_in">this</span>.lis[i].onclick = <span class="built_in">this</span>.toggleTab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为我们动态添加元素 所以需要重新获取对应的元素 这样就不会出现点击新增tab没有相应事件的bug</span></span><br><span class="line"><span class="function"><span class="title">updateNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lis = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.sections = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;section&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 添加功能</span></span><br><span class="line"><span class="function"><span class="title">addTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    that.clearClass();</span><br><span class="line">    <span class="comment">// (1) 创建li元素和section元素 </span></span><br><span class="line">    <span class="keyword">var</span> random = <span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">var</span> li = <span class="string">&#x27;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> section = <span class="string">&#x27;&lt;section class=&quot;conactive&quot;&gt;测试 &#x27;</span> + random + <span class="string">&#x27;&lt;/section&gt;&#x27;</span>;</span><br><span class="line">    <span class="comment">// (2) 把这两个元素追加到对应的父元素里面</span></span><br><span class="line">    that.ul.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, li);</span><br><span class="line">    that.fsection.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, section);</span><br><span class="line">    <span class="comment">// (3)最后初始化，重新获取节点</span></span><br><span class="line">    that.init(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="点击右上角×号能删除当前栏目和内容"><a href="#点击右上角×号能删除当前栏目和内容" class="headerlink" title="点击右上角×号能删除当前栏目和内容"></a>点击右上角×号能删除当前栏目和内容</h3><p><img src="https://i.loli.net/2021/06/06/cRVQv5kJtOYoz73.gif" alt="删除tab页.gif"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">           <span class="built_in">this</span>.remove[i].onclick = <span class="built_in">this</span>.removeTab;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="title">updateNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="comment">//删除时也是动态添加元素了，所以需要重新获取</span></span><br><span class="line">       <span class="built_in">this</span>.remove = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;.icon-guanbi&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3. 删除功能</span></span><br><span class="line">   <span class="function"><span class="title">removeTab</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">       <span class="comment">// 阻止冒泡 防止触发li 的切换点击事件！</span></span><br><span class="line">       e.stopPropagation(); </span><br><span class="line">       <span class="comment">//x没有索引号，但是可以拿到父亲的索引</span></span><br><span class="line">       <span class="keyword">var</span> index = <span class="built_in">this</span>.parentNode.index;</span><br><span class="line">       <span class="comment">// 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素</span></span><br><span class="line">       that.lis[index].remove();</span><br><span class="line">       that.sections[index].remove();</span><br><span class="line">       <span class="comment">//删除完后重新获取节点数目</span></span><br><span class="line">       that.init();</span><br><span class="line">       <span class="comment">// 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变(即不执行index--后面代码)</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.liactive&#x27;</span>)) <span class="keyword">return</span>;</span><br><span class="line">       <span class="comment">// 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态</span></span><br><span class="line">       index--;</span><br><span class="line">       <span class="comment">// 手动调用我们的点击事件(即切换active)  不需要鼠标触发</span></span><br><span class="line">       <span class="comment">//删除最后一个tag时，会报错，因为索引为-1的没有点击事件 that.lis[index].click(); 先判断前面是否为真</span></span><br><span class="line">       that.lis[index] &amp;&amp; that.lis[index].click();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="双击Tab栏，可以编辑Tab栏名称"><a href="#双击Tab栏，可以编辑Tab栏名称" class="headerlink" title="双击Tab栏，可以编辑Tab栏名称"></a>双击Tab栏，可以编辑Tab栏名称</h3><p><img src="https://i.loli.net/2021/06/07/uXGUIc1B4OPwZko.gif" alt="编辑tab页.gif"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">           <span class="comment">//双击</span></span><br><span class="line">           <span class="built_in">this</span>.spans[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">           <span class="built_in">this</span>.sections[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">updateNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.spans = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;.fisrstnav li span:first-child&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4. 修改功能</span></span><br><span class="line">   <span class="function"><span class="title">editTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="comment">//获取原先内容</span></span><br><span class="line">       <span class="keyword">var</span> str = <span class="built_in">this</span>.innerHTML;</span><br><span class="line">       <span class="comment">// 双击禁止选定文字</span></span><br><span class="line">       <span class="built_in">window</span>.getSelection ? <span class="built_in">window</span>.getSelection().removeAllRanges() : <span class="built_in">document</span>.selection.empty();</span><br><span class="line">       <span class="comment">// 双击文字的时候，在里面生成一个文本框, 当失去焦点或者按下回车 把文本框输入的值给原先元素</span></span><br><span class="line">       <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;&lt;input type=&quot;text&quot; /&gt;&#x27;</span>;</span><br><span class="line">       <span class="keyword">var</span> input = <span class="built_in">this</span>.children[<span class="number">0</span>];</span><br><span class="line">       <span class="comment">//若没有更改，则赋值原先内容</span></span><br><span class="line">       input.value = str;</span><br><span class="line">       <span class="comment">// 出现文本框时，里面的文字处于选定状态</span></span><br><span class="line">       input.select();</span><br><span class="line">       <span class="comment">// 当我们离开文本框就把文本框里面的值给span </span></span><br><span class="line">       input.onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           <span class="comment">//this指向input</span></span><br><span class="line">           <span class="built_in">this</span>.parentNode.innerHTML = <span class="built_in">this</span>.value;</span><br><span class="line">       &#125;;</span><br><span class="line">       <span class="comment">// 按下回车也可以把文本框里面的值给span</span></span><br><span class="line">       input.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">               <span class="comment">// 手动调用表单失去焦点事件  不需要鼠标离开操作</span></span><br><span class="line">               <span class="built_in">this</span>.blur();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="需注意的一些细节"><a href="#需注意的一些细节" class="headerlink" title="需注意的一些细节"></a>需注意的一些细节</h3><ol>
<li><strong>删除</strong>一个栏目<strong>后默认选中前一个</strong>栏目</li>
<li>新增的栏目<strong>也能实现基本功能</strong></li>
<li>当默认选中的是第一个，并且删除的时候，选中删除后的第一个</li>
<li>在编辑Tab名称的时候，<strong>回车键</strong>也能<strong>确认</strong>编辑</li>
<li>新增的栏目<strong>默认选中</strong></li>
</ol>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><strong>html：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>面向对象 Tab<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./styles/tab.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./styles/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span>&gt;</span></span><br><span class="line">            Js 面向对象 动态添加标签页</span><br><span class="line">        <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabsbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tab&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- tab 标签 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;fisrstnav&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;liactive&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-guanbi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-guanbi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;iconfont icon-guanbi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabadd&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">span</span>&gt;</span>+<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- tab 内容 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tabscon&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;conactive&quot;</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">section</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">section</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/tab.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>css:</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">main</span> <span class="selector-tag">h4</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabsbox</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">900px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid lightsalmon;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-class">.liactive</span> &#123;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">2px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#tab</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    user-select: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabadd</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="comment">/* width: 100px; */</span></span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabadd</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span>;</span><br><span class="line">    user-select: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabscon</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabscon</span> <span class="selector-tag">section</span>,</span><br><span class="line"><span class="selector-class">.tabscon</span> <span class="selector-tag">section</span><span class="selector-class">.conactive</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.tabscon</span> <span class="selector-tag">section</span><span class="selector-class">.conactive</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>javascript:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> that;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tab</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">this</span>.main = <span class="built_in">document</span>.querySelector(id);</span><br><span class="line">        <span class="built_in">this</span>.add = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.tabadd&#x27;</span>);</span><br><span class="line">        <span class="comment">// li的父元素</span></span><br><span class="line">        <span class="built_in">this</span>.ul = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.fisrstnav ul:first-child&#x27;</span>);</span><br><span class="line">        <span class="comment">// section 父元素</span></span><br><span class="line">        <span class="built_in">this</span>.fsection = <span class="built_in">this</span>.main.querySelector(<span class="string">&#x27;.tabscon&#x27;</span>);</span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.updateNode();</span><br><span class="line">            <span class="comment">// init 初始化操作让相关的元素绑定事件</span></span><br><span class="line">            <span class="built_in">this</span>.add.onclick = <span class="built_in">this</span>.addTab;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.lis[i].index = i;</span><br><span class="line">                <span class="built_in">this</span>.lis[i].onclick = <span class="built_in">this</span>.toggleTab;</span><br><span class="line">                <span class="built_in">this</span>.remove[i].onclick = <span class="built_in">this</span>.removeTab;</span><br><span class="line">                <span class="built_in">this</span>.spans[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line">                <span class="built_in">this</span>.sections[i].ondblclick = <span class="built_in">this</span>.editTab;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为我们动态添加元素 需要从新获取对应的元素</span></span><br><span class="line">    <span class="function"><span class="title">updateNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lis = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.sections = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;section&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.remove = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;.icon-guanbi&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.spans = <span class="built_in">this</span>.main.querySelectorAll(<span class="string">&#x27;.fisrstnav li span:first-child&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 切换功能</span></span><br><span class="line">    <span class="function"><span class="title">toggleTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="comment">// console.log(this.index);</span></span><br><span class="line">            that.clearClass();</span><br><span class="line">            <span class="built_in">this</span>.className = <span class="string">&#x27;liactive&#x27;</span>;</span><br><span class="line">            that.sections[<span class="built_in">this</span>.index].className = <span class="string">&#x27;conactive&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清除所有li 和section 的类</span></span><br><span class="line">    <span class="function"><span class="title">clearClass</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">                <span class="built_in">this</span>.lis[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                <span class="built_in">this</span>.sections[i].className = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 添加功能</span></span><br><span class="line">    <span class="function"><span class="title">addTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            that.clearClass();</span><br><span class="line">            <span class="comment">// (1) 创建li元素和section元素 </span></span><br><span class="line">            <span class="keyword">var</span> random = <span class="built_in">Math</span>.random();</span><br><span class="line">            <span class="keyword">var</span> li = <span class="string">&#x27;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">var</span> section = <span class="string">&#x27;&lt;section class=&quot;conactive&quot;&gt;测试 &#x27;</span> + random + <span class="string">&#x27;&lt;/section&gt;&#x27;</span>;</span><br><span class="line">            <span class="comment">// (2) 把这两个元素追加到对应的父元素里面</span></span><br><span class="line">            that.ul.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, li);</span><br><span class="line">            that.fsection.insertAdjacentHTML(<span class="string">&#x27;beforeend&#x27;</span>, section);</span><br><span class="line">            that.init();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 删除功能</span></span><br><span class="line">    <span class="function"><span class="title">removeTab</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">            e.stopPropagation(); <span class="comment">// 阻止冒泡 防止触发li 的切换点击事件</span></span><br><span class="line">            <span class="keyword">var</span> index = <span class="built_in">this</span>.parentNode.index;</span><br><span class="line">            <span class="built_in">console</span>.log(index);</span><br><span class="line">            <span class="comment">// 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素</span></span><br><span class="line">            that.lis[index].remove();</span><br><span class="line">            that.sections[index].remove();</span><br><span class="line">            that.init();</span><br><span class="line">            <span class="comment">// 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.liactive&#x27;</span>)) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="comment">// 手动调用我们的点击事件  不需要鼠标触发</span></span><br><span class="line">            that.lis[index] &amp;&amp; that.lis[index].click();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 修改功能</span></span><br><span class="line">    <span class="function"><span class="title">editTab</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> str = <span class="built_in">this</span>.innerHTML;</span><br><span class="line">        <span class="comment">// 双击禁止选定文字</span></span><br><span class="line">        <span class="built_in">window</span>.getSelection ? <span class="built_in">window</span>.getSelection().removeAllRanges() : <span class="built_in">document</span>.selection.empty();</span><br><span class="line">        <span class="comment">// alert(11);</span></span><br><span class="line">        <span class="built_in">this</span>.innerHTML = <span class="string">&#x27;&lt;input type=&quot;text&quot; /&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">var</span> input = <span class="built_in">this</span>.children[<span class="number">0</span>];</span><br><span class="line">        input.value = str;</span><br><span class="line">        input.select(); <span class="comment">// 文本框里面的文字处于选定状态</span></span><br><span class="line">        <span class="comment">// 当我们离开文本框就把文本框里面的值给span </span></span><br><span class="line">        input.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.parentNode.innerHTML = <span class="built_in">this</span>.value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 按下回车也可以把文本框里面的值给span</span></span><br><span class="line">        input.onkeyup = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.keyCode === <span class="number">13</span>) &#123;</span><br><span class="line">                <span class="comment">// 手动调用表单失去焦点事件  不需要鼠标离开操作</span></span><br><span class="line">                <span class="built_in">this</span>.blur();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Tab(<span class="string">&#x27;#tab&#x27;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="构造函数和原型"><a href="#构造函数和原型" class="headerlink" title="构造函数和原型"></a>构造函数和原型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在<strong>ES6之前</strong>，对象不是基于类创建的，而是用一种称为<strong>构造函数</strong>的特殊函数来定义对象和他们的特征。</p>
<p>创建对象可通过以下三种方式：</p>
<p>1.对象字面量 <code>var obj1 = &#123;&#125;</code></p>
<p>2.new Object() <code>var obj2 = new Object()</code></p>
<p>3.利用构造函数创建对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.uname = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会唱歌&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ldh = <span class="keyword">new</span> Star(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">var</span> zxy = <span class="keyword">new</span> Star(<span class="string">&#x27;张学友&#x27;</span>, <span class="number">19</span>);</span><br><span class="line">ldh.sing();</span><br><span class="line">zxy.sing();</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><strong>构造函数</strong>是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p>
<p>在 JS 中，使用构造函数时要注意以下两点：</p>
<ol>
<li>构造函数用于创建某一类对象，其首字母要大写</li>
<li>构造函数要和 new 一起使用才有意义：构造一个对象，如new Array()，创建一个数组对象</li>
</ol>
<p><strong>new 在执行时会做四件事情</strong>：</p>
<ol>
<li>在内存中创建一个新的空对象。</li>
<li>让 this 指向这个新的对象。</li>
<li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li>
<li>返回这个新对象（所以构造函数里面<strong>不需要 return</strong> ）。</li>
</ol>
<p>JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为<strong>静态成员</strong>和<strong>实例成员</strong>。</p>
<ol>
<li><p>静态成员：在构造函数本上添加的成员称为静态成员，只能由<strong>构造函数本身</strong>来访问</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 静态成员 在构造函数本身上添加的成员  sex 就是静态成员</span></span><br><span class="line">Star.sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="comment">// 静态成员只能通过构造函数来访问</span></span><br><span class="line"><span class="built_in">console</span>.log(Star.sex); <span class="comment">//男</span></span><br><span class="line"><span class="built_in">console</span>.log(ldh.sex); <span class="comment">// undefined 不能通过对象来访问</span></span><br></pre></td></tr></table></figure></li>
<li><p>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由<strong>实例化的对象</strong>来访问</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.实例成员就是构造函数内部通过this添加的成员 uname age sing 就是实例成员</span></span><br><span class="line"><span class="comment">// 实例成员只能通过实例化的对象来访问</span></span><br><span class="line"><span class="built_in">console</span>.log(ldh.uname); <span class="comment">// 刘德华</span></span><br><span class="line">ldh.sing(); <span class="comment">// 我会唱歌</span></span><br><span class="line"><span class="built_in">console</span>.log(Star.uname); <span class="comment">// undefined 不可以通过构造函数来访问实例成员</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>但是构造函数存在浪费内存的问题：</p>
<p><img src="https://i.loli.net/2021/06/07/52ZDcTCJgspBIvO.jpg" alt="Snipaste_2021-06-07_09-30-44.jpg"></p>
<h2 id="构造函数原型对象-prototype"><a href="#构造函数原型对象-prototype" class="headerlink" title="构造函数原型对象 prototype"></a>构造函数原型对象 prototype</h2><p>构造函数通过原型分配的函数是所有对象所<strong>共享的</strong></p>
<p>JavaScript规定，<strong>每个构造函数都有一个prototype属性</strong>，指向另一个对象，注意这个prototype（原型）就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有</p>
<p>因此，我们把那些<strong>不变的方法，直接定义在prototype对象</strong>上，这样所有对象的实例就可以<strong>共享这个方法</strong></p>
<!--一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上-->

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Star.prototype.sing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象原型-proto"><a href="#对象原型-proto" class="headerlink" title="对象原型__proto__"></a>对象原型<code>__proto__</code></h2><p><strong>对象都会有一个属性</strong> <code>__proto__</code> 指向构造函数的prototype原型对象，之所以我们对象可以使用构造函数prototype原型对象的属性和方法，就是因为 <code>__proto__</code> 的存在</p>
<p><code>__proto__</code>对象原型和原型对象 prototype 是等价的(<code>ldh.__proto__ === Star.prototype</code>)</p>
<p>方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing。如果有sing 这个方法,因为有<code>__proto__ </code>的存在,就去构造函数原型对象prototype身上去查找sing这个方法。</p>
<h2 id="constructor构造函数"><a href="#constructor构造函数" class="headerlink" title="constructor构造函数"></a>constructor构造函数</h2><p>对象原型（ <code>__proto__</code>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。</p>
<p>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</p>
<p>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取<strong>对象形式赋值</strong>，但是这样就会<strong>覆盖</strong>构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就<strong>不再指向当前构造函数</strong>了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数 </span></span><br><span class="line"><span class="comment">// Star.prototype.sing = function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;我会唱歌&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="comment">// Star.prototype.movie = function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(&#x27;我会演电影&#x27;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Star.prototype = &#123;</span><br><span class="line">    <span class="comment">// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</span></span><br><span class="line">    <span class="attr">constructor</span>: Star,</span><br><span class="line">    <span class="attr">sing</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会唱歌&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">movie</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会演电影&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数、实例、原型对象三者之间的关系"><a href="#构造函数、实例、原型对象三者之间的关系" class="headerlink" title="构造函数、实例、原型对象三者之间的关系"></a><strong>构造函数、实例、原型对象三者之间的关系</strong></h2><p><img src="https://i.loli.net/2021/06/07/4MQYaFsWUuBK1hf.jpg" alt="Snipaste_2021-06-07_09-46-34.jpg"></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Star.prototype);<span class="comment">//Object</span></span><br><span class="line">                            <span class="comment">// sing: ƒ ()</span></span><br><span class="line">                            <span class="comment">// constructor: ƒ Star(uname, age)</span></span><br><span class="line">                            <span class="comment">// __proto__: Object</span></span><br><span class="line"><span class="built_in">console</span>.log(Star.prototype.__proto__ === <span class="built_in">Object</span>.prototype);<span class="comment">//true</span></span><br><span class="line"><span class="comment">// 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__);<span class="comment">//null</span></span><br><span class="line"><span class="comment">// 3. 我们Object.prototype原型对象里面的__proto__原型  指向为 null</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/06/07/XdFVuiIo1hE6e4J.jpg" alt="Snipaste_2021-06-07_09-49-53.jpg"></p>
<h2 id="JavaScript-的成员查找机制-规则"><a href="#JavaScript-的成员查找机制-规则" class="headerlink" title="JavaScript 的成员查找机制(规则)"></a><strong>JavaScript</strong> <strong>的成员查找机制</strong>(规则)</h2><ol>
<li>当访问一个对象的属性（包括方法）时，<strong>首先</strong>查找这个对象自身有没有该属性。</li>
<li>如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。</li>
<li>如果还没有就查找原型对象的原型（Object的原型对象）。</li>
<li>依此类推一直找到 Object 为止（null）。</li>
<li><code>__proto__</code>对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</li>
</ol>
<h2 id="原型对象this指向"><a href="#原型对象this指向" class="headerlink" title="原型对象this指向"></a><strong>原型对象</strong>this指向</h2><p>构造函数中的this 指向我们实例对象.</p>
<p><strong>原型对象</strong>里面放的是方法, 这个方法里面的<strong>this 指向</strong>的是 这个方法的<strong>调用者</strong>, 也就是这个<strong>实例对象.</strong></p>
<h2 id="扩展内置对象"><a href="#扩展内置对象" class="headerlink" title="扩展内置对象"></a><strong>扩展</strong>内置对象</h2><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p>
<blockquote>
<p>注意：数组和字符串内置对象<strong>不能给原型对象覆盖操作</strong> Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">        sum += <span class="built_in">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sum()); <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype); <span class="comment">// 能找到sum方法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr1.sum()); <span class="comment">// 66</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h1><p>ES6之前并没有给我们提供 extends 继承。我们可以通过<strong>构造函数+原型对象</strong>模拟实现继承，被称为<strong>组合继承</strong>。</p>
<h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>调用这个函数, 并且修改函数运行时的 this 指向  </p>
<p><code>fun.call(thisArg, arg1, arg2, ...) </code></p>
<ul>
<li>lthisArg ：当前调用函数 this 的指向对象</li>
<li>larg1，arg2：传递的其他参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象</span></span><br><span class="line">fn.call(o, <span class="number">1</span>, <span class="number">2</span>);   <span class="comment">//&#123;name:&#x27;andy&#x27;&#125;</span></span><br><span class="line">                    <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="借用构造函数继承父类型属性"><a href="#借用构造函数继承父类型属性" class="headerlink" title="借用构造函数继承父类型属性"></a><strong>借用构造函数继承父</strong>类型属性</h2><p>核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 借用父构造函数继承属性</span></span><br><span class="line"><span class="comment">// 1. 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="built_in">this</span>.uname = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 .子构造函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    Father.call(<span class="built_in">this</span>, uname, age);</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">// Son &#123;uname: &quot;刘德华&quot;, age: 18, score: 100&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="借用原型对象继承父类型方法"><a href="#借用原型对象继承父类型方法" class="headerlink" title="借用原型对象继承父类型方法"></a><strong>借用原型对象继承</strong>父<strong>类型方法</strong></h2><p>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。 </p>
<p> 核心原理： </p>
<ol>
<li>将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类() </li>
<li>本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象</li>
<li>将子类的 constructor 从新指向子类的构造函数</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向父构造函数的对象实例</span></span><br><span class="line">    <span class="built_in">this</span>.uname = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.money = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">100000</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2 .子构造函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, score</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// this 指向子构造函数的对象实例</span></span><br><span class="line">    Father.call(<span class="built_in">this</span>, uname, age);</span><br><span class="line">    <span class="built_in">this</span>.score = score;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化</span></span><br><span class="line"><span class="comment">// 实例化一个Father对象</span></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数</span></span><br><span class="line">Son.prototype.constructor = Son;</span><br><span class="line"><span class="comment">// 这个是子构造函数专门的方法</span></span><br><span class="line">Son.prototype.exam = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;孩子要考试&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son); <span class="comment">// Son &#123; age: 18, score: 100, uname: &quot;刘德华&quot;, __proto__: Father &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(Father.prototype); <span class="comment">// 有 money 方法，无 exam 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(Son.prototype.constructor); <span class="comment">// 指向Son</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/06/07/HfRFt4dpGuSsKVT.jpg" alt="Snipaste_2021-06-07_10-23-58.jpg"></p>
<h2 id="类的本质"><a href="#类的本质" class="headerlink" title="类的本质"></a><strong>类的本质</strong></h2><ol>
<li>class本质还是function.所以我们可以认为类就是构造函数的另一种写法</li>
<li>类有原型对象prototype，里面有constructor 指向类本身。并且类的所有方法都定义在类的prototype属性上</li>
<li>类创建的实例对象里面也有<code>__proto__ </code>原型指向类的prototype原型对象</li>
<li>类也可以通过原型对象添加方法</li>
<li>ES6的类其实就是语法糖:语法糖就是一种便捷写法.  简单理解, 有两种方法可以实现同样的功能, 但是一种写法更加清晰、方便,那么这个方法就是语法糖</li>
</ol>
<hr>
<h1 id="ES5-中的新增方法"><a href="#ES5-中的新增方法" class="headerlink" title="ES5 中的新增方法"></a>ES5 中的新增方法</h1><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a><strong>数组方法</strong></h2><p>迭代(遍历)方法：forEach()、map()、filter()、some()、every()；</p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p><code>array.forEach(function(currentValue, index, arr))</code></p>
<ul>
<li>lcurrentValue：数组当前项的值</li>
<li>lindex：数组当前项的索引</li>
<li>larr：数组对象本身</li>
</ul>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>array.filter(function(currentValue, index, arr))</code></p>
<ul>
<li><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素,主要用于筛选数组</p>
</li>
<li><p>注意它直接返回一个<strong>新数组</strong></p>
</li>
<li><p>currentValue: 数组当前项的值</p>
</li>
<li><p>index：数组当前项的索引</p>
</li>
<li><p>arr：数组对象本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">66</span>, <span class="number">4</span>, <span class="number">88</span>, <span class="number">3</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(newArr); <span class="comment">// [ 12,66,4,88 ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p><code>array.some(function(currentValue, index, arr))</code></p>
<ul>
<li>some() 方法用于检测数组中的元素是否满足指定条件.  通俗点 查找数组中是否有满足条件的元素 </li>
<li>注意它返回值是<strong>布尔值</strong>, 如果查找到这个元素, 就返回true ,  如果查找不到就返回false.</li>
<li>如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</li>
<li>currentValue: 数组当前项的值</li>
<li>index：数组当前项的索引</li>
<li>arr：数组对象本身</li>
</ul>
<blockquote>
<p>forEach()与some()区别：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;pink&#x27;</span>];</span><br><span class="line"><span class="comment">// 1. forEach迭代 遍历</span></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;找到了该元素&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 在forEach 里面 return 不会终止迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果查询数组中唯一的元素, 用some方法更合适</span></span><br><span class="line">arr.some(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;找到了该元素&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//  在some 里面 遇到 return true 就终止遍历 迭代效率更高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="string">&#x27;green&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;找到了该元素&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//  // filter 里面 return 不会终止迭代</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>array.map(function(currentValue, index, arr), thisValue)</code></p>
<p><code>map()</code> 方法返回一个<strong>新数组</strong>，数组中的元素为原始数组元素调用函数处理后的值。和forEach相似，不同在于：</p>
<p> 如果更改数组内的值，<code>forEach</code> 不能确保数组的不变性。这个方法只有在你不接触里面的任何值时，才能保证不变性。</p>
<p> 由于它们之间的主要区别在于是否有返回值，所以你会希望使用 <code>map</code> 来制作一个新的数组，而使用 <code>forEach</code> 只是为了映射到数组上(修改原来的数组)。</p>
<p><strong>返回值加入新数组中</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newarr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">value, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>map的不变性：当数组为基础类型时原数组不变</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> newArray=array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> item*<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArray);<span class="comment">//[2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<p><strong>当数组为引用类型时原数组发生改变：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [&#123; <span class="attr">name</span>: <span class="string">&#x27;Anna&#x27;</span>, <span class="attr">age</span>: <span class="number">16</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;James&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span> &#125;]</span><br><span class="line"><span class="keyword">let</span> newArray=array.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item.like=<span class="string">&#x27;eat&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArray);<span class="comment">//[&#123; name: &#x27;Anna&#x27;, age: 16,like: &quot;eat&quot;&#125;,&#123; name: &#x27;James&#x27;, age: 18,like: &quot;eat&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><p><code>array.every(function(currentValue, index, arr), thisValue)</code></p>
<p><code>every()</code> 方法用于检测数组所有元素是否都符合指定条件</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p><code>arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</code></p>
<ul>
<li>callback：回调函数</li>
<li>initialValue：初始值</li>
</ul>
<p><strong>对数组中所有内容进行汇总，点像递归</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = a.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">preValue, currValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> preValue + currValue;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 遍历到第一次时，preValue为初始值，currValue为数组里的第一个值</span></span><br><span class="line"><span class="comment">// 遍历到第二次时，preValue为第一次返回的值，currValue为数组里第二个数</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h2><p>trim() 方法会从一个字符串的两端删除空白字符。trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。</p>
<p><code>str.trim()</code></p>
<h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a><strong>对象</strong>方法</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>Object.keys() 用于获取对象自身所有的属性</p>
<p><code>Object.keys(obj)</code></p>
<ul>
<li>效果类似 for…in</li>
<li>返回一个由属性名组成的数组</li>
</ul>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty()"></a>Object.defineProperty()</h3><p>Object.defineProperty() 定义对象中新属性或修改原有的属性。(了解)</p>
<p><code>Object.defineProperty(obj, prop, descriptor)</code></p>
<ul>
<li>obj：必需。目标对象 </li>
<li>prop：必需。需定义或修改的属性的名字</li>
<li>descriptor：必需。以对象形式 { } 书写:<ul>
<li>value: 设置属性的值 默认为undefined</li>
<li>writable: 值是否可以重写。true | false 默认为false</li>
<li>enumerable: 目标属性是否可以被枚举。true | false 默认为 false</li>
<li>configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false 默认为false</li>
</ul>
</li>
</ul>
<hr>
<h1 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h1><h2 id="函数的定义方式"><a href="#函数的定义方式" class="headerlink" title="函数的定义方式"></a><strong>函数的定义方式</strong></h2><ol>
<li>函数声明方式 function 关键字 (命名函数)  <code>function fn() &#123;&#125;;</code></li>
<li>函数表达式 (匿名函数)  <code>var fun = function() &#123;&#125;;</code></li>
<li>new Function(‘参数1’,’参数2’, ‘函数体’)  <strong>（了解就行）</strong></li>
<li>所有函数都是 Function 的实例(对象) </li>
<li>函数也属于对象</li>
</ol>
<h2 id="函数的调用方式"><a href="#函数的调用方式" class="headerlink" title="函数的调用方式"></a><strong>函数的</strong>调用<strong>方式</strong></h2><ol>
<li><p>普通函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//something </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//somethin</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.sayHi();</span><br></pre></td></tr></table></figure></li>
<li><p>构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Star</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Star();</span><br></pre></td></tr></table></figure></li>
<li><p>绑定事件函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;   <span class="comment">// 点击了按钮就可以调用这个函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>定时器函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, <span class="number">1000</span>);  <span class="comment">//这个函数是定时器自动1秒钟调用一次</span></span><br></pre></td></tr></table></figure></li>
<li><p>立即执行函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//something</span></span><br><span class="line">&#125;)();  <span class="comment">// 立即执行函数是自动调用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="函数内-this-的指向"><a href="#函数内-this-的指向" class="headerlink" title="函数内 this 的指向"></a><strong>函数</strong>内 <strong>this</strong> <strong>的</strong>指向</h1><p>这些 this 的指向，是当我们调用函数的时候确定的。 调用方式的不同决定了this 的指向不同.一般指向我们的调用者.</p>
<p><img src="https://i.loli.net/2021/06/07/BtNE9pdsyIrq6wk.jpg" alt="Snipaste_2021-06-07_11-16-40.jpg"></p>
<p>但是立即执行函数还得看这时this是否在对象方法或者构造函数中，第二个虽然是立即执行函数，但是它先找的是全局变量foo，再找到foo.bar，所以this返回的是foo作用域的a</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.bar());            <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)());          <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar=foo.bar)());  <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>“匿名函数的执行环境具有全局性”</strong>，所以最里层那个函数中this指向全局环境，全局环境没有定义foo变量所以输出undefined。在匿名函数外部将this保存到一个内部函数可以访问的变量self中，可以通过self访问这个对象，所以self.foo为bar</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myobject = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">    <span class="attr">func</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);</span><br><span class="line">        <span class="built_in">console</span>.log(self.foo);</span><br><span class="line"></span><br><span class="line">        (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);<span class="comment">//undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(self.foo);<span class="comment">//bar</span></span><br><span class="line">        &#125;)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myobject.func();</span><br></pre></td></tr></table></figure>

<h2 id="类的this指向"><a href="#类的this指向" class="headerlink" title="类的this指向"></a>类的this指向</h2><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params">text</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，<strong>如果将这个方法提取出来单独使用</strong>，<code>this</code>会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是<code>undefined</code>），从而导致找不到<code>print</code>方法而报错。</p>
<p>（1）一个比较简单的解决方法是，在构造方法（constructor）中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）另一种解决方法是使用箭头函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getThis = <span class="function">() =&gt;</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myObj = <span class="keyword">new</span> Obj();</span><br><span class="line">myObj.getThis() === myObj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="改变函数内部-this-指向"><a href="#改变函数内部-this-指向" class="headerlink" title="改变函数内部 this 指向"></a><strong>改变</strong>函数<strong>内部</strong> <strong>this</strong> <strong>指向</strong></h2><p>JavaScript 为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部 this 的指向问题，常用的有 bind()、call()、apply() 三种方法。</p>
<h3 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call <strong>方法</strong></h3><p>call() 方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</p>
<p><code>fun.call(thisArg, arg1, arg2, ...) </code></p>
<ol>
<li><p>thisArg：在 fun 函数运行时指定的 this 值</p>
</li>
<li><p>arg1，arg2：传递的其他参数</p>
</li>
<li><p>返回值就是函数的返回值，因为它就是调用函数</p>
</li>
<li><p>因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call，比如继承</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call 的主要作用可以实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">uname, age, sex</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.uname = uname;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">uname, age, sex</span>) </span>&#123;</span><br><span class="line">    Father.call(<span class="built_in">this</span>, uname, age, sex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;刘德华&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a><strong>apply</strong> <strong>方法</strong></h3><p>apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</p>
<p><code>fun.apply(thisArg, [argsArray])</code> </p>
<ol>
<li><p>thisArg：在fun函数运行时指定的 this 值</p>
</li>
<li><p>argsArray：传递的值，必须包含在<strong>数组</strong>里面</p>
</li>
<li><p>返回值就是函数的返回值，因为它就是调用函数</p>
</li>
<li><p>因此 apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply 的主要应用 比如说我们可以利用 apply 借助于数学内置对象求数组最大值 </span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">66</span>, <span class="number">3</span>, <span class="number">99</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// var max = Math.max.apply(null, arr); null在严格模式下有问题</span></span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min.apply(<span class="built_in">Math</span>, arr);</span><br><span class="line"><span class="built_in">console</span>.log(max, min); <span class="comment">// 99 1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a><strong>bind</strong> <strong>方法</strong></h3><p>bind() 方法不会调用函数。但是能改变函数内部this 指向 </p>
<p><code>fun.bind(thisArg, arg1, arg2, ...) </code></p>
<ol>
<li><p>thisArg：在 fun 函数运行时指定的 this 值</p>
</li>
<li><p>arg1，arg2：传递的其他参数</p>
</li>
<li><p>返回由指定的 this 值和初始化参数改造的<strong>原函数拷贝</strong></p>
</li>
<li><p>因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  如果有的函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind</span></span><br><span class="line"><span class="comment">//  我们有一组按钮,当我们点击了某个按钮之后,就禁用这个按钮,2秒钟之后开启这个按钮</span></span><br><span class="line"><span class="keyword">var</span> btns = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">    btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.disabled = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.disabled = <span class="literal">false</span>;</span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>), <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面内容见笔记（一）</p>
</blockquote>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.lis.length; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.lis[i].index = i;</span><br><span class="line">        <span class="comment">// 去除了之前 var that = this ，通过 bind 绑定this指向</span></span><br><span class="line">        <span class="built_in">this</span>.lis[i].onclick = <span class="built_in">this</span>.toggleTab.bind(<span class="built_in">this</span>.lis[i],<span class="built_in">this</span>);</span><br><span class="line">        <span class="built_in">this</span>.remove[i].onclick = <span class="built_in">this</span>.removeTab.bind(<span class="built_in">this</span>.remove[i],<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// that 形参 即调用时传入的 this 指向，this 指向调用时传入的 this.lis[i] </span></span><br><span class="line"><span class="function"><span class="title">toggleTab</span>(<span class="params">that</span>)</span> &#123;</span><br><span class="line">    that.clearClass();</span><br><span class="line">    <span class="built_in">this</span>.className = <span class="string">&#x27;liactive&#x27;</span>;</span><br><span class="line">    that.sections[<span class="built_in">this</span>.index].className = <span class="string">&#x27;conactive&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><strong>相同点</strong></p>
<p>都可以改变函数内部的this指向.</p>
<p><strong>区别点</strong></p>
<p>1.call 和 apply 会调用函数, 并且改变函数内部this指向.</p>
<p>2.call 和 apply 传递的参数不一样, call 传递参数 aru1, aru2..形式 apply 必须数组形式[arg]</p>
<p>3.bind 不会调用函数, 可以改变函数内部this指向.</p>
<p><strong>主要应用场景</strong>**</p>
<p>1.call 经常做继承. </p>
<p>2.apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</p>
<p>3.bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向. </p>
<hr>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p><strong>高阶函数</strong>是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    callback&amp;&amp;callback();</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">&#x27;hi&#x27;</span>)&#125;</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>此时fn 就是一个高阶函数。函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。 最典型的就是作为回调函数。同理函数也可以作为返回值传递回来。</p>
<h2 id="函数的柯里化"><a href="#函数的柯里化" class="headerlink" title="函数的柯里化"></a><strong>函数的柯里化</strong></h2><p>通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式（比如React实现传参的回调函数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">b</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">c</span>)=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a+b+c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a><strong>变量作用域</strong></h2><p>变量根据作用域的不同分为两种：全局变量和局部变量。</p>
<ol>
<li> 函数内部可以使用全局变量。</li>
<li> 函数外部不可以使用局部变量。</li>
<li> 当函数执行完毕，本作用域内的局部变量会销毁。</li>
</ol>
<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a><strong>什么是闭包</strong></h2><p>闭包（closure）指有权访问另一个函数作用域中变量的<strong>函数</strong>。 —– JavaScript 高级程序设计</p>
<p>简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;    <span class="comment">// fn1 就是闭包函数，闭包就是典型的高阶函数</span></span><br><span class="line">　　　<span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line">　　　<span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　　　　 <span class="built_in">console</span>.log(num); <span class="comment">// 10</span></span><br><span class="line">　　　&#125;</span><br><span class="line">     fn2()</span><br><span class="line">&#125;</span><br><span class="line">fn1();</span><br></pre></td></tr></table></figure>

<h2 id="在-chrome-中调试闭包"><a href="#在-chrome-中调试闭包" class="headerlink" title="在 chrome 中调试闭包"></a><strong>在 chrome 中</strong>调试闭包</h2><ol>
<li>打开浏览器，按 F12 键启动 chrome 调试工具。</li>
<li>设置断点。</li>
<li>找到 Scope 选项（Scope 作用域的意思）。</li>
<li>当我们重新刷新页面，会进入断点调试，Scope 里面会有两个参数（global 全局作用域、local 局部作用域）。</li>
<li>当执行到 fn2() 时，Scope 里面会多一个 Closure 参数 ，这就表明产生了闭包。</li>
</ol>
<h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a><strong>闭包的作用</strong></h2><p><strong>提问：我们怎么能在 fn() 函数外面访问 fn() 中的局部变量 num 呢 ？</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;　　　　</span><br><span class="line">   <span class="keyword">var</span> num = <span class="number">10</span>;　　　　</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> </span>&#123;　　　 <span class="comment">// 返回一个匿名函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(num); <span class="comment">// 10         　　　　</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> f = fn();</span><br><span class="line"> <span class="comment">// 类似于</span></span><br><span class="line"> <span class="comment">// var f = function() &#123;</span></span><br><span class="line"> <span class="comment">//         console.log(num);</span></span><br><span class="line"> <span class="comment">//     &#125;</span></span><br><span class="line"> f() <span class="comment">// 10 调用 f ，得到 fn 内部的变量 num</span></span><br></pre></td></tr></table></figure>

<h2 id="闭包案例"><a href="#闭包案例" class="headerlink" title="闭包案例"></a><strong>闭包案例</strong></h2><h3 id="循环注册点击事件"><a href="#循环注册点击事件" class="headerlink" title="循环注册点击事件"></a>循环注册点击事件</h3><blockquote>
<p>存在内存泄漏，所以闭包不一定都有用 （若不点击，i不会销毁）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用闭包的方式得到当前小li 的索引号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 利用for循环创建了4个立即执行函数</span></span><br><span class="line">    <span class="comment">// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量</span></span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// console.log(i);</span></span><br><span class="line">        lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环中的-setTimeout"><a href="#循环中的-setTimeout" class="headerlink" title="循环中的 setTimeout()"></a>循环中的 setTimeout()</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包应用--3秒钟之后,打印所有li元素的内容</span></span><br><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.nav&#x27;</span>).querySelectorAll(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(lis[i].innerHTML);</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思考题 1： 没有产生闭包(未访问函数内变量)</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()) <span class="comment">// The Window</span></span><br><span class="line"><span class="comment">// 展开就类似于</span></span><br><span class="line"><span class="keyword">var</span> f = object.getNameFunc();</span><br><span class="line"><span class="comment">// this 在匿名函数里面，指向 window</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 思考题 2： 产生了闭包</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;The Window&quot;</span>;　　</span><br><span class="line"><span class="keyword">var</span> object = &#123;　　　　</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;My Object&quot;</span>,</span><br><span class="line">    <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getNameFunc()()) <span class="comment">// My Object</span></span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><p>如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。</p>
<p>由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 <strong>return</strong>。</p>
<h2 id="利用递归遍历数据"><a href="#利用递归遍历数据" class="headerlink" title="利用递归遍历数据"></a><strong>利用递归遍历数据</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;家电&#x27;</span>,</span><br><span class="line">    <span class="attr">goods</span>: [&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">11</span>,</span><br><span class="line">        <span class="attr">gname</span>: <span class="string">&#x27;冰箱&#x27;</span>,</span><br><span class="line">        <span class="attr">goods</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">111</span>,</span><br><span class="line">            <span class="attr">gname</span>: <span class="string">&#x27;海尔&#x27;</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="number">112</span>,</span><br><span class="line">            <span class="attr">gname</span>: <span class="string">&#x27;美的&#x27;</span></span><br><span class="line">        &#125;, ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="attr">gname</span>: <span class="string">&#x27;洗衣机&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;服饰&#x27;</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 我们想要做输入id号,就可以返回的数据对象</span></span><br><span class="line"><span class="comment">// 1. 利用 forEach 去遍历里面的每一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getID</span>(<span class="params">json, id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">    json.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item.id == id) &#123;</span><br><span class="line">            o = item;</span><br><span class="line">            <span class="comment">// 2. 我们想要得里层的数据 11 12 可以利用递归函数</span></span><br><span class="line">            <span class="comment">// 里面应该有goods这个数组并且数组的长度不为 0 </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.goods &amp;&amp; item.goods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            o = getID(item.goods, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a><strong>浅拷贝和深拷贝</strong></h2><ol>
<li><p>浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用.</p>
</li>
<li><p>深拷贝拷贝多层, 每一级别的数据都会拷贝.</p>
</li>
<li><p>Object.assign(<em>target</em>, …<em>sources</em>)  es6 新增方法可以浅拷贝</p>
<p><img src="https://i.loli.net/2021/06/07/A5Wr62mhoqZRbnp.jpg" alt="Snipaste_2021-06-07_14-33-37.jpg"></p>
</li>
</ol>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span>,</span><br><span class="line">    <span class="attr">msg</span>: &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="comment">// k 是属性名   obj[k] 属性值</span></span><br><span class="line">    o[k] = obj[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法二 ES6</span></span><br><span class="line"><span class="built_in">Object</span>.assign(o, obj);</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 深拷贝拷贝多层, 每一级别的数据都会拷贝.</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;andy&#x27;</span>,</span><br><span class="line">    <span class="attr">msg</span>: &#123;</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">color</span>: [<span class="string">&#x27;pink&#x27;</span>, <span class="string">&#x27;red&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 封装函数 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">newobj, oldobj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> oldobj) &#123;</span><br><span class="line">        <span class="comment">// 判断我们的属性值属于那种数据类型</span></span><br><span class="line">        <span class="comment">// 1. 获取属性值  oldobj[k]</span></span><br><span class="line">        <span class="keyword">var</span> item = oldobj[k];</span><br><span class="line">        <span class="comment">// 2. 判断这个值是否是数组</span></span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">            newobj[k] = [];</span><br><span class="line">            deepCopy(newobj[k], item)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">            <span class="comment">// 3. 判断这个值是否是对象</span></span><br><span class="line">            newobj[k] = &#123;&#125;;</span><br><span class="line">            deepCopy(newobj[k], item)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 属于简单数据类型</span></span><br><span class="line">            newobj[k] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">deepCopy(o, obj);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong>正则表达式（</strong> Regular Expression <strong>）</strong>是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。</p>
<p>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文**(匹配)<strong>。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词</strong>(替换)<strong>，或从字符串中获取我们想要的特定部分</strong>(提取)**等 。</p>
<p>其他语言也会使用正则表达式，本阶段我们主要是利用 JavaScript 正则表达式完成表单验证。</p>
<h2 id="正则表达式在-JavaScript-中的使用"><a href="#正则表达式在-JavaScript-中的使用" class="headerlink" title="正则表达式在 JavaScript 中的使用"></a><strong>正则表达式</strong>在 <strong>JavaScript</strong> <strong>中的使用</strong></h2><h3 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a><strong>创建正则表达式</strong></h3><p><strong>1. 通过调用 RegExp 对象的构造函数创建</strong></p>
<p><code>var 变量名 = new RegExp(/表达式/修饰符); </code></p>
<p><code>var 变量名 = new RegExp(&#39;表达式&#39;, &#39;修饰符&#39;)</code></p>
<p><strong>2. 通过字面量创建</strong>（正则表达式不需要加引号，不管是数字型还是字符串型）</p>
<p><code>var 变量名 = /表达式/修饰符; </code></p>
<p>// 注释中间放表达式就是正则字面量</p>
<h3 id="测试正则表达式-test"><a href="#测试正则表达式-test" class="headerlink" title="测试正则表达式 test"></a><strong>测试</strong>正则表达式 <strong>test</strong></h3><p>test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。</p>
<p> <code>regexObj.test(str)</code></p>
<ol>
<li><p>regexObj 是写的正则表达式</p>
</li>
<li><p>str 我们要测试的文本，就是检测str文本是否符合我们写的正则表达式规范.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/123/</span>;</span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/123/g</span>;</span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="number">123</span>));   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="number">12123</span>));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>g：全局模式，查找字符串全部内容，再次匹配时会向前搜索下一个匹配项</p>
<p>i：不区分大小写</p>
<p>m：多行模式，表示查找到一行末尾会继续查找</p>
<p>y：粘附模式，每次调用<code>exec()</code>就只会在lastIndex的位置上寻找匹配字段</p>
<p>u：Unicode模式</p>
<p>s：dotAll模式，表示元字符 <code>.</code> 可以匹配任何字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;address_address&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> rg = <span class="regexp">/a/g</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(a, <span class="string">&quot;g&quot;</span>)  <span class="comment">//在正则中使用变量</span></span><br><span class="line">rg.test(<span class="string">&quot;字符串&quot;</span>);             <span class="comment">//是否包含该字符串，返回布尔值</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">`/a<span class="subst">$&#123;a&#125;</span>/`</span>).test(<span class="string">&quot;字符串&quot;</span>) <span class="comment">//在正则中使用变量 + 其他字符</span></span><br><span class="line">a.match(rg);                  <span class="comment">//返回匹配的字符串 + 具体信息，若正则启用全局模式，则返回一个数组，包含所有匹配的字符串</span></span><br><span class="line">rg.exec(a);                   <span class="comment">//和match差不多，只不过不受全局模式的影响，如果开全局模式，下次再匹配一次，则从lastIndex</span></span><br><span class="line">                              <span class="comment">//开始匹配，在这里也就是从 下标为1的d 开始匹配</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="正则表达式中的特殊字符"><a href="#正则表达式中的特殊字符" class="headerlink" title="正则表达式中的特殊字符"></a><strong><strong>正则表达式</strong></strong>中的特殊字符</h2><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a><strong>正则表达式的组成</strong></h3><p>一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。</p>
<p>正则表达式速查表：<a target="_blank" rel="noopener" href="https://www.runoob.com/regexp/regexp-metachar.html">https://www.runoob.com/regexp/regexp-metachar.html</a></p>
<p>正则表达式在线测试：<a target="_blank" rel="noopener" href="https://c.runoob.com/front-end/854">https://c.runoob.com/front-end/854</a></p>
<h3 id="边界符"><a href="#边界符" class="headerlink" title="边界符"></a><strong>边界符</strong></h3><p>提示字符所处的位置</p>
<p><img src="https://i.loli.net/2021/06/07/Tzu9xCw2Hbd5GZN.jpg" alt="Snipaste_2021-06-07_15-08-33.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/^abc/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;abcd&#x27;</span>));  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;babc&#x27;</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="comment">//必须是abc,类似全等</span></span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/^abc$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;abcd&#x27;</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;abcabc&#x27;</span>));  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a><strong>字符类</strong></h3><p>**[]**表示有一系列字符可供选择，只要匹配到其中一个就可以了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/[abc]/</span>;    <span class="comment">//只要包含有a或者b或者c就返回true</span></span><br><span class="line"><span class="built_in">console</span>.log(rg.test(<span class="string">&#x27;andy&#x27;</span>));  <span class="comment">//返回true</span></span><br><span class="line"><span class="comment">//var rg = /^[abc]$/ 是三选一，只有是单个a或者b或者c才返回true</span></span><br></pre></td></tr></table></figure>

<p>[][]<strong>[-]方括号内部范围符</strong>- ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/^[a-z]$/</span>;   <span class="comment">//26个英文小写字母任何一个字母都返回true</span></span><br><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/^[a-zA-Z]$/</span>;  <span class="comment">//26个英文字母任何一个字母都返回true</span></span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/^[a-z0-9_-]$/</span>; <span class="comment">//任何单个26小写字母，0-9数字，_, -,都返回true</span></span><br></pre></td></tr></table></figure>

<p><strong>[^]方括号内部 取反符^</strong> 表示取反的意思。注意和边界符 ^ 区别，边界符写到方括号外面。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/^[^a-z]$/</span>;  <span class="comment">//26个英文小写字母任何一个字母都返回false</span></span><br></pre></td></tr></table></figure>

<p><strong>字符组合：</strong>方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/[a-z1-<span class="number">9</span>]/.test(<span class="string">&#x27;andy&#x27;</span>)     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a><strong>量词符</strong></h3><p>用来设定某个模式出现的次数，有<code>*</code>、 <code>+</code>、 <code>？</code>、 <code>&#123;&#125;</code>，<code>&#123;&#125;</code>的量词间不要有空格，可以用test来检测下方正则表达式</p>
<p><img src="https://i.loli.net/2021/06/07/ZMGynQa5FsN6pVI.jpg" alt="Snipaste_2021-06-07_15-07-36.jpg"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rg = <span class="regexp">/^a*$/</span>;  <span class="comment">//a可以出现0-n次，n&gt;=0 </span></span><br><span class="line"><span class="keyword">var</span> rg1 = <span class="regexp">/^a+$/</span>; <span class="comment">//a可以出现1-n次，n&gt;=1</span></span><br><span class="line"><span class="keyword">var</span> rg2 = <span class="regexp">/^a?$/</span>; <span class="comment">//a可以出现1或0次 (?也可以表示禁止贪婪，往最少的匹配方式去选择)</span></span><br><span class="line"><span class="keyword">var</span> rg3 = <span class="regexp">/^a&#123;3&#125;$/</span>; <span class="comment">//a只能可以出现3次</span></span><br><span class="line"><span class="keyword">var</span> rg4 = <span class="regexp">/^a&#123;3,&#125;$/</span>; <span class="comment">//a只可以出现3-n次 n&gt;=3 </span></span><br><span class="line"><span class="keyword">var</span> rg5 = <span class="regexp">/^a&#123;3,16&#125;$/</span>; <span class="comment">//a只可以出现3-16次</span></span><br><span class="line"><span class="comment">//普遍的用户名规定：</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="regexp">/^[a-zA-Z0-9_-]&#123;6, 16&#125;$/</span></span><br></pre></td></tr></table></figure>

<h3 id="用户名验证案例"><a href="#用户名验证案例" class="headerlink" title="用户名验证案例"></a><strong>用户名验证案例</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  量词是设定某个模式出现的次数</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^[a-zA-Z0-9_-]&#123;6,16&#125;$/</span>; <span class="comment">// 这个模式用户只能输入英文字母 数字 下划线 短横线但是有边界符和[] 这就限定了只能多选1</span></span><br><span class="line"><span class="keyword">var</span> uname = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.uname&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> span = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">uname.onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reg.test(<span class="built_in">this</span>.value)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;正确的&#x27;</span>);</span><br><span class="line">        span.className = <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">        span.innerHTML = <span class="string">&#x27;用户名格式输入正确&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;错误的&#x27;</span>);</span><br><span class="line">        span.className = <span class="string">&#x27;wrong&#x27;</span>;</span><br><span class="line">        span.innerHTML = <span class="string">&#x27;用户名格式输入不正确&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="括号总结"><a href="#括号总结" class="headerlink" title="括号总结"></a><strong>括号总结</strong></h3><ul>
<li><code>[]</code>中括号：字符集合，匹配方括号中的任意字符</li>
<li><code>&#123;&#125;</code> 大括号：量词符，里面表示重复次数，但只让大括号前面一个字符重复 （注意：<code>/^abc&#123;3&#125;$/</code>，只让c重复三次，即abccc）</li>
<li><code>()</code> 小括号：表示优先级 可以用来：<code>/^(abc)&#123;3&#125;$/</code>，表示让abc重复三次，即abcabc</li>
</ul>
<h3 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h3><p>预定义类指的是某些常见模式的<strong>简写方式</strong>。</p>
<p><img src="https://i.loli.net/2021/06/07/ARhQDZ6CXcrUuw1.jpg" alt="Snipaste_2021-06-07_14-59-12.jpg"></p>
<h2 id="正则表达式中的替换"><a href="#正则表达式中的替换" class="headerlink" title="正则表达式中的替换"></a>正则表达式中的替换</h2><h3 id="replace-替换"><a href="#replace-替换" class="headerlink" title="replace 替换"></a><strong>replace</strong> <strong>替换</strong></h3><p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。</p>
<p>  <code>stringObject.replace(regexp/substr,replacement)</code></p>
<ol>
<li>第一个参数:  被替换的字符串 或者 正则表达式</li>
<li>第二个参数:  替换为的字符串</li>
<li>返回值是一个替换完毕的新字符串</li>
</ol>
<p>但是replace只能替换掉第一个匹配的字符/正则表达式，无法满足替换掉多个敏感词</p>
<p>可以使用: <code>/表达式/[switch]</code> swtich也成为修饰符，即按照什么样的模式来匹配</p>
<h3 id="敏感词过渡案例"><a href="#敏感词过渡案例" class="headerlink" title="敏感词过渡案例"></a><strong>敏感词过渡案例</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;textarea&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    div.innerHTML = text.value.replace(<span class="regexp">/red|blue/g</span>, <span class="string">&#x27;**&#x27;</span>); <span class="comment">// 把 red blue 替换成**</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的<strong>一项脚本语言的标准化规范</strong>。</p>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a><strong>let</strong></h2><p><strong>let声明的变量只在所处于的块级有效</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">     <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用域特性。</p>
</blockquote>
<p><strong>不存在变量提升</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// a is not defined </span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><strong>暂时性死区</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    tmp = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>经典面试题</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    arr[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">0</span>]();</span><br><span class="line">arr[<span class="number">1</span>]();</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/06/07/HJeYAPzISwTdM67.jpg" alt="Snipaste_2021-06-07_15-34-38.jpg"></p>
<p><strong>图解：</strong>此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值。</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a><strong>const</strong></h2><p>作用：声明常量，常量就是值（内存地址）不能变化的量。</p>
<p><strong>具有块级作用域</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>声明常量时必须赋值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI; <span class="comment">// Missing initializer in const declaration</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<p><strong>常量赋值后，值不能修改。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">100</span>; <span class="comment">// Assignment to constant variable. </span></span><br><span class="line"><span class="keyword">const</span> ary = [<span class="number">100</span>, <span class="number">200</span>];</span><br><span class="line">ary[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>; ary[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ary); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]; </span></span><br><span class="line">ary = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]; <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h2 id="let、const、var-的区别"><a href="#let、const、var-的区别" class="headerlink" title="let、const、var 的区别"></a><strong>let</strong>、<strong><strong>const</strong></strong>、var <strong>的区别</strong></h2><ol>
<li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象。</li>
<li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升。</li>
<li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值。</li>
</ol>
<p><img src="https://i.loli.net/2021/06/07/a1g5iulkjcfoNPM.jpg" alt="Snipaste_2021-06-07_15-38-24.jpg"></p>
<h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a><strong>解</strong>构赋值</h2><p>ES6中允许从数组中提取值，按照对应位置，对变量赋值。对象也可以实现解构。</p>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a><strong>数组解构</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组解构允许我们按照一一对应的关系从数组中提取值 然后将值赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c, d, e] = ary;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(e) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a><strong>对象</strong>解构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象解构允许我们使用变量的名字匹配对象的属性 匹配成功 将对象属性的值赋值给变量</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;lisi&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age, sex &#125; = person;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// lisi</span></span><br><span class="line"><span class="built_in">console</span>.log(age)  <span class="comment">// 30</span></span><br><span class="line"><span class="built_in">console</span>.log(sex)  <span class="comment">// 男</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>: myName&#125; = person; <span class="comment">// myName 属于别名</span></span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">// lisi</span></span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a><strong>箭头函数</strong></h2><p>ES6中新增的定义函数的方式。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>箭头函数是用来简化函数定义语法的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">123</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p>在箭头函数中，如果函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2;	 </span><br><span class="line"><span class="keyword">const</span> result = sum(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<p>在箭头函数中如果形参只有一个，形参外侧的小括号也是可以省略的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">	alert(v);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>箭头函数若不绑定 this ，则箭头函数没有自己的 this 关键字。this关键字将指向<strong>箭头函数定义位置</strong>中的上下文this（一般 window ）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// window</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> resFn = fn.call(obj);</span><br><span class="line">resFn(); <span class="comment">// zhangsan</span></span><br></pre></td></tr></table></figure>

<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">	<span class="attr">say</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">		alert(<span class="built_in">this</span>.age)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say(); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a><strong>剩余参数</strong></h2><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">first, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(first); <span class="comment">// 10</span></span><br><span class="line">    <span class="built_in">console</span>.log(args); <span class="comment">// [20, 30] </span></span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<p>剩余参数和解构配合使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> students = [<span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [s1, ...s2] = students; </span><br><span class="line"><span class="built_in">console</span>.log(s1);  <span class="comment">// &#x27;wangwu&#x27; </span></span><br><span class="line"><span class="built_in">console</span>.log(s2);  <span class="comment">// [&#x27;zhangsan&#x27;, &#x27;lisi&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-的扩展方法"><a href="#Array-的扩展方法" class="headerlink" title="Array 的扩展方法"></a><strong>Array</strong> <strong>的扩展方法</strong></h2><h3 id="扩展运算符（展开语法"><a href="#扩展运算符（展开语法" class="headerlink" title="扩展运算符（展开语法)"></a><strong>扩展运算符（展开语法)</strong></h3><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">...ary  <span class="comment">// 1, 2, 3</span></span><br><span class="line"><span class="built_in">console</span>.log(...ary);    <span class="comment">// 1 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>扩展运算符可以应用于合并数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一 </span></span><br><span class="line"> <span class="keyword">let</span> ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="keyword">let</span> ary2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"> <span class="keyword">let</span> ary3 = [...ary1, ...ary2];</span><br><span class="line"> <span class="comment">// 方法二 </span></span><br><span class="line"> ary1.push(...ary2);</span><br></pre></td></tr></table></figure>

<p>将类数组或可遍历对象转换为真正的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oDivs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line">oDivs = [...oDivs];</span><br></pre></td></tr></table></figure>

<h3 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a><strong>构造函数方法：</strong>Array.from()</h3><p>将类数组或可遍历对象转换为真正的数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; </span><br><span class="line">    <span class="string">&quot;0&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;1&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;length&quot;</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newAry = <span class="built_in">Array</span>.from(aryLike, <span class="function"><span class="params">item</span> =&gt;</span> item *<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="实例方法：find"><a href="#实例方法：find" class="headerlink" title="实例方法：find()"></a><strong>实例方法：</strong>find()</h3><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [&#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三‘</span></span><br><span class="line"><span class="string">&#125;, &#123; </span></span><br><span class="line"><span class="string">    id: 2,</span></span><br><span class="line"><span class="string">    name: &#x27;</span>李四‘</span><br><span class="line">&#125;]; </span><br><span class="line"><span class="keyword">let</span> target = ary.find(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item.id == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="实例方法：findIndex"><a href="#实例方法：findIndex" class="headerlink" title="实例方法：findIndex()"></a><strong>实例方法：</strong>findIndex()</h3><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line"><span class="keyword">let</span> index = ary.findIndex(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value &gt; <span class="number">9</span>); </span><br><span class="line"><span class="built_in">console</span>.log(index); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h3 id="实例方法：includes"><a href="#实例方法：includes" class="headerlink" title="实例方法：includes()"></a><strong>实例方法：</strong>includes()</h3><p>表示某个数组是否包含给定的值，返回布尔值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>) <span class="comment">// true </span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="String-的扩展方法"><a href="#String-的扩展方法" class="headerlink" title="String 的扩展方法"></a><strong>String</strong> <strong>的扩展方法</strong></h2><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a><strong>模板字符串</strong></h3><p>ES6新增的创建字符串的方式，使用反引号定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">`zhangsan`</span>;</span><br></pre></td></tr></table></figure>

<p>模板字符串中可以解析变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;张三&#x27;</span>; </span><br><span class="line"><span class="keyword">let</span> sayHello = <span class="string">`hello,my name is <span class="subst">$&#123;name&#125;</span>`</span>; <span class="comment">// hello, my name is zhangsan</span></span><br></pre></td></tr></table></figure>

<p>模板字符串中可以换行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = &#123; </span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zhangsan&#x27;</span>, </span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>, </span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">let</span> html = <span class="string">` &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.name&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.age&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;<span class="subst">$&#123;result.sex&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt; `</span>;</span><br></pre></td></tr></table></figure>

<p>在模板字符串中可以调用函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;哈哈哈哈 追不到我吧 我就是这么强大&#x27;</span>;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> greet = <span class="string">`<span class="subst">$&#123;sayHello()&#125;</span> 哈哈哈哈`</span>; </span><br><span class="line"><span class="built_in">console</span>.log(greet); <span class="comment">// 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</span></span><br></pre></td></tr></table></figure>

<h3 id="实例方法：startsWith-和-endsWith"><a href="#实例方法：startsWith-和-endsWith" class="headerlink" title="实例方法：startsWith()和 endsWith()"></a><strong>实例方法：</strong>startsWith()<strong>和</strong> <strong>endsWith</strong>()</h3><ul>
<li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li>
<li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">str.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true </span></span><br><span class="line">str.endsWith(<span class="string">&#x27;!&#x27;</span>)       <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a><strong>实例方法：</strong>repeat()</h3><p>repeat方法表示将原字符串重复n次，返回一个新字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>)      <span class="comment">// &quot;xxx&quot; </span></span><br><span class="line"><span class="string">&#x27;hello&#x27;</span>.repeat(<span class="number">2</span>)  <span class="comment">// &quot;hellohello&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Set-数据结构"><a href="#Set-数据结构" class="headerlink" title="Set 数据结构"></a><strong>Set</strong> <strong>数据结构</strong></h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<p>Set本身是一个构造函数，用来生成 Set 数据结构。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br></pre></td></tr></table></figure>

<p>Set函数可以接受一个数组作为参数，用来初始化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>

<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a><strong>实例方法</strong></h3><ul>
<li>add(value)：添加某个值，返回 Set 结构本身</li>
<li>ldelete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li>
<li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li>
<li>clear()：清除所有成员，没有返回值</li>
</ul>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a><strong>遍历</strong></h3><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.forEach(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/06/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20pink%E8%80%81%E5%B8%88js%E8%BF%9B%E9%98%B6/">https://asura1211.github.io/2021/06/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20pink%E8%80%81%E5%B8%88js%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/07/3boUIdzwVjvaMu6.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/09/%E3%80%90%E5%9F%BA%E6%9C%AC%E5%8A%9F%E3%80%91%E2%80%94%20%E2%80%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><img class="prev-cover" src="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【基本功】— — 数据结构</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"><img class="next-cover" src="https://i.loli.net/2021/06/07/xyGvCbmdgHPf1E8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">我的第一篇博客文章</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/06/24/【阅读笔记】— — 你不知道的JavaScript（上）/" title="【阅读笔记】— — 你不知道的JavaScript（上）"><img class="cover" src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-25</div><div class="title">【阅读笔记】— — 你不知道的JavaScript（上）</div></div></a></div><div><a href="/2021/07/03/【面试准备】— — JavaScript篇/" title="【面试准备】— — JavaScript篇"><img class="cover" src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-04</div><div class="title">【面试准备】— — JavaScript篇</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Asura1211"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">ES6中的类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#class%E7%B1%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-number">2.1.2.</span> <span class="toc-text">创建类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#constructor-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">constructor 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.4.</span> <span class="toc-text">创建第一个类和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.5.</span> <span class="toc-text">类中添加方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.1.6.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B"><span class="toc-number">2.1.7.</span> <span class="toc-text">this指向问题案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super-%E8%B6%85%E7%BA%A7%E7%9A%84-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">super(超级的) 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E7%9A%84%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">继承方法的同时扩展方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tab%E6%A0%8F-%E6%A1%88%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">Tab栏 案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">模块划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%87%BBTab%E6%A0%8F%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%88%87%E6%8D%A2-Tab%E6%A0%8F%E5%92%8C%E5%86%85%E5%AE%B9"><span class="toc-number">2.3.2.</span> <span class="toc-text">点击Tab栏能实现切换 Tab栏和内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%8A%A0%E5%8F%B7%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%8A%A0Tab%E6%A0%8F%E6%95%88%E6%9E%9C"><span class="toc-number">2.3.3.</span> <span class="toc-text">点击加号能实现增加Tab栏效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92%C3%97%E5%8F%B7%E8%83%BD%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E6%A0%8F%E7%9B%AE%E5%92%8C%E5%86%85%E5%AE%B9"><span class="toc-number">2.3.4.</span> <span class="toc-text">点击右上角×号能删除当前栏目和内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%87%BBTab%E6%A0%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%BC%96%E8%BE%91Tab%E6%A0%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">2.3.5.</span> <span class="toc-text">双击Tab栏，可以编辑Tab栏名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B3%A8%E6%84%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="toc-number">2.3.6.</span> <span class="toc-text">需注意的一些细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">2.3.7.</span> <span class="toc-text">源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E5%8E%9F%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">构造函数和原型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1-prototype"><span class="toc-number">3.3.</span> <span class="toc-text">构造函数原型对象 prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%9E%8B-proto"><span class="toc-number">3.4.</span> <span class="toc-text">对象原型__proto__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">constructor构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E5%AE%9E%E4%BE%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.6.</span> <span class="toc-text">构造函数、实例、原型对象三者之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.7.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%9A%84%E6%88%90%E5%91%98%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6-%E8%A7%84%E5%88%99"><span class="toc-number">3.8.</span> <span class="toc-text">JavaScript 的成员查找机制(规则)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1this%E6%8C%87%E5%90%91"><span class="toc-number">3.9.</span> <span class="toc-text">原型对象this指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.10.</span> <span class="toc-text">扩展内置对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-number">4.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#call"><span class="toc-number">4.1.</span> <span class="toc-text">call()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">借用构造函数继承父类型属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">借用原型对象继承父类型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">4.4.</span> <span class="toc-text">类的本质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES5-%E4%B8%AD%E7%9A%84%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">ES5 中的新增方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">数组方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forEach"><span class="toc-number">5.1.1.</span> <span class="toc-text">forEach()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#filter"><span class="toc-number">5.1.2.</span> <span class="toc-text">filter()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#some"><span class="toc-number">5.1.3.</span> <span class="toc-text">some()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">5.1.4.</span> <span class="toc-text">map()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#every"><span class="toc-number">5.1.5.</span> <span class="toc-text">every()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reduce"><span class="toc-number">5.1.6.</span> <span class="toc-text">reduce()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">字符串方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">对象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-keys"><span class="toc-number">5.3.1.</span> <span class="toc-text">Object.keys()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperty"><span class="toc-number">5.3.2.</span> <span class="toc-text">Object.defineProperty()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-number">6.</span> <span class="toc-text">函数的定义和调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">函数的定义方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">函数的调用方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85-this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="toc-number">7.</span> <span class="toc-text">函数内 this 的指向</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84this%E6%8C%87%E5%90%91"><span class="toc-number">7.1.</span> <span class="toc-text">类的this指向</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8-this-%E6%8C%87%E5%90%91"><span class="toc-number">7.2.</span> <span class="toc-text">改变函数内部 this 指向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#call-%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.1.</span> <span class="toc-text">call 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply-%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">apply 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind-%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.3.</span> <span class="toc-text">bind 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">8.1.</span> <span class="toc-text">函数的柯里化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">9.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">9.1.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85"><span class="toc-number">9.2.</span> <span class="toc-text">什么是闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-chrome-%E4%B8%AD%E8%B0%83%E8%AF%95%E9%97%AD%E5%8C%85"><span class="toc-number">9.3.</span> <span class="toc-text">在 chrome 中调试闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">9.4.</span> <span class="toc-text">闭包的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%A1%88%E4%BE%8B"><span class="toc-number">9.5.</span> <span class="toc-text">闭包案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%B3%A8%E5%86%8C%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">9.5.1.</span> <span class="toc-text">循环注册点击事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84-setTimeout"><span class="toc-number">9.5.2.</span> <span class="toc-text">循环中的 setTimeout()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">9.5.3.</span> <span class="toc-text">思考题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">10.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92"><span class="toc-number">10.1.</span> <span class="toc-text">什么是递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE"><span class="toc-number">10.2.</span> <span class="toc-text">利用递归遍历数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">10.3.</span> <span class="toc-text">浅拷贝和深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">10.3.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">10.3.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">11.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9C%A8-JavaScript-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">正则表达式在 JavaScript 中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">11.2.1.</span> <span class="toc-text">创建正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-test"><span class="toc-number">11.2.2.</span> <span class="toc-text">测试正则表达式 test</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-number">11.3.</span> <span class="toc-text">正则表达式中的特殊字符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">11.3.1.</span> <span class="toc-text">正则表达式的组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E7%AC%A6"><span class="toc-number">11.3.2.</span> <span class="toc-text">边界符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%B1%BB"><span class="toc-number">11.3.3.</span> <span class="toc-text">字符类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8F%E8%AF%8D%E7%AC%A6"><span class="toc-number">11.3.4.</span> <span class="toc-text">量词符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%90%8D%E9%AA%8C%E8%AF%81%E6%A1%88%E4%BE%8B"><span class="toc-number">11.3.5.</span> <span class="toc-text">用户名验证案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E6%80%BB%E7%BB%93"><span class="toc-number">11.3.6.</span> <span class="toc-text">括号总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB"><span class="toc-number">11.3.7.</span> <span class="toc-text">预定义类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">11.4.</span> <span class="toc-text">正则表达式中的替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#replace-%E6%9B%BF%E6%8D%A2"><span class="toc-number">11.4.1.</span> <span class="toc-text">replace 替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%8F%E6%84%9F%E8%AF%8D%E8%BF%87%E6%B8%A1%E6%A1%88%E4%BE%8B"><span class="toc-number">11.4.2.</span> <span class="toc-text">敏感词过渡案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6"><span class="toc-number">12.</span> <span class="toc-text">ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#let"><span class="toc-number">12.1.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">12.2.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let%E3%80%81const%E3%80%81var-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.3.</span> <span class="toc-text">let、const、var 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">12.4.</span> <span class="toc-text">解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%A7%A3%E6%9E%84"><span class="toc-number">12.4.1.</span> <span class="toc-text">数组解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">12.4.2.</span> <span class="toc-text">对象解构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">12.5.</span> <span class="toc-text">箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">12.5.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">12.5.2.</span> <span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">12.6.</span> <span class="toc-text">剩余参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">12.7.</span> <span class="toc-text">Array 的扩展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95"><span class="toc-number">12.7.1.</span> <span class="toc-text">扩展运算符（展开语法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%96%B9%E6%B3%95%EF%BC%9AArray-from"><span class="toc-number">12.7.2.</span> <span class="toc-text">构造函数方法：Array.from()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Afind"><span class="toc-number">12.7.3.</span> <span class="toc-text">实例方法：find()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AfindIndex"><span class="toc-number">12.7.4.</span> <span class="toc-text">实例方法：findIndex()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Aincludes"><span class="toc-number">12.7.5.</span> <span class="toc-text">实例方法：includes()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">12.8.</span> <span class="toc-text">String 的扩展方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">12.8.1.</span> <span class="toc-text">模板字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AstartsWith-%E5%92%8C-endsWith"><span class="toc-number">12.8.2.</span> <span class="toc-text">实例方法：startsWith()和 endsWith()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Arepeat"><span class="toc-number">12.8.3.</span> <span class="toc-text">实例方法：repeat()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.9.</span> <span class="toc-text">Set 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">12.9.1.</span> <span class="toc-text">实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">12.9.2.</span> <span class="toc-text">遍历</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/14/%E3%80%90%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E3%80%91%E2%80%94%20%E2%80%94%20%E9%9D%A2%E7%BB%8F/" title="【面试记录】— — 面经"><img src="https://ibb.co/RB8wSRz" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试记录】— — 面经"/></a><div class="content"><a class="title" href="/2021/11/14/%E3%80%90%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E3%80%91%E2%80%94%20%E2%80%94%20%E9%9D%A2%E7%BB%8F/" title="【面试记录】— — 面经">【面试记录】— — 面经</a><time datetime="2021-11-14T15:02:21.000Z" title="发表于 2021-11-14 23:02:21">2021-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家社区商城"/></a><div class="content"><a class="title" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城">【项目复盘】— — 贤得家社区商城</a><time datetime="2021-10-31T15:01:17.000Z" title="发表于 2021-10-31 23:01:17">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇"><img src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 前端综合篇"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇">【面试准备】— — 前端综合篇</a><time datetime="2021-10-11T12:53:49.000Z" title="发表于 2021-10-11 20:53:49">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>