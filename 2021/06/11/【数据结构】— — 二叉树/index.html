<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【数据结构】— — 二叉树 | 青山の博客</title><meta name="keywords" content="二叉树"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="LeetCode144——二叉树的前序遍历（☆）跳转地址 自己的代码知道二叉树的前序遍历，但是第一次实现是真不会啊。 思路1&amp;题解递归：  确定递归函数的参数和返回值。 确定终止条件。如果当前遍历的节点是空，那么本层递归结束。 确定单层递归的逻辑。前序遍历是中左右的循序，所以要先取中节点的数值。   var preorderTraversal &#x3D; function(root,res&#x3D;[])">
<meta property="og:type" content="article">
<meta property="og:title" content="【数据结构】— — 二叉树">
<meta property="og:url" content="https://asura1211.github.io/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="LeetCode144——二叉树的前序遍历（☆）跳转地址 自己的代码知道二叉树的前序遍历，但是第一次实现是真不会啊。 思路1&amp;题解递归：  确定递归函数的参数和返回值。 确定终止条件。如果当前遍历的节点是空，那么本层递归结束。 确定单层递归的逻辑。前序遍历是中左右的循序，所以要先取中节点的数值。   var preorderTraversal &#x3D; function(root,res&#x3D;[])">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg">
<meta property="article:published_time" content="2021-06-11T19:42:29.000Z">
<meta property="article:modified_time" content="2021-08-21T09:40:56.387Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="二叉树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E4%BA%8C%E5%8F%89%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【数据结构】— — 二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-21 17:40:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【数据结构】— — 二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-11T19:42:29.000Z" title="发表于 2021-06-12 03:42:29">2021-06-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-21T09:40:56.387Z" title="更新于 2021-08-21 17:40:56">2021-08-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【数据结构】— — 二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="LeetCode144——二叉树的前序遍历（☆）"><a href="#LeetCode144——二叉树的前序遍历（☆）" class="headerlink" title="LeetCode144——二叉树的前序遍历（☆）"></a>LeetCode144——二叉树的前序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">跳转地址</a></p>
<h3 id="自己的代码"><a href="#自己的代码" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>知道二叉树的前序遍历，但是第一次实现是真不会啊。</p>
<h3 id="思路1-amp-题解"><a href="#思路1-amp-题解" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<ol>
<li>确定递归函数的参数和返回值。</li>
<li>确定终止条件。如果当前遍历的节点是空，那么本层递归结束。</li>
<li>确定单层递归的逻辑。前序遍历是中左右的循序，所以要先取中节点的数值。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root,res=[]</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!root) <span class="keyword">return</span> res</span><br><span class="line">     res.push(root.val) <span class="comment">// 中</span></span><br><span class="line">     preorderTraversal(root.left, res) <span class="comment">// 左</span></span><br><span class="line">     preorderTraversal(root.right, res) <span class="comment">// 右</span></span><br><span class="line">     <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="思路2-amp-题解"><a href="#思路2-amp-题解" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h2><p>迭代：</p>
<p>前序遍历是中左右，每次先处理的是中间节点，那么先将跟节点放入栈中，然后将右孩子加入栈，再加入左孩子。这样出栈的时候就是中左右的顺序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈 右 -&gt; 左</span></span><br><span class="line"><span class="comment">// 出栈 中 -&gt; 左 -&gt; 右</span></span><br><span class="line"><span class="keyword">var</span> preorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">const</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.push(cur.val);</span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h2 id="LeetCode94——二叉树的中序遍历（☆）"><a href="#LeetCode94——二叉树的中序遍历（☆）" class="headerlink" title="LeetCode94——二叉树的中序遍历（☆）"></a>LeetCode94——二叉树的中序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">跳转地址</a></p>
<h3 id="自己的代码-1"><a href="#自己的代码-1" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>知道前序遍历后，中序（左根右），后序（左右根）就很简单：（递归）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    inorderTraversal(root.left, res); </span><br><span class="line">    res.push(root.val)</span><br><span class="line">    inorderTraversal(root.right, res);</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>
</li>
<li><p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>
</li>
</ul>
<h3 id="思路2-amp-题解-1"><a href="#思路2-amp-题解-1" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<p>递归的时候隐式地维护了一个栈，而迭代的时候需要显式地将这个栈模拟出来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> stack = [];</span><br><span class="line">    <span class="keyword">let</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span> (stack.length || cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            <span class="comment">// 遍历到左边最深处</span></span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            res.push(cur.val);</span><br><span class="line">            <span class="comment">// 判断右节点是否存在，若不存在则继续往上pop，直到中间节点，然后放入右节点</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>同1</p>
<h2 id="LeetCode145——二叉树的后序遍历（☆）"><a href="#LeetCode145——二叉树的后序遍历（☆）" class="headerlink" title="LeetCode145——二叉树的后序遍历（☆）"></a>LeetCode145——二叉树的后序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">跳转地址</a></p>
<h3 id="自己的代码-2"><a href="#自己的代码-2" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    postorderTraversal(root.left, res); </span><br><span class="line">    postorderTraversal(root.right, res);</span><br><span class="line">    res.push(root.val)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<p>迭代：先序遍历是中左右，后续遍历是左右中。因此只需调整一下先序遍历的代码顺序，变成中右左，再反转res数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入栈 左 -&gt; 右</span></span><br><span class="line"><span class="comment">// 出栈 中 -&gt; 右 -&gt; 左 结果翻转</span></span><br><span class="line"><span class="keyword">var</span> postorderTraversal = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">const</span> stack = [root];</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(stack.length) &#123;</span><br><span class="line">        cur = stack.pop();</span><br><span class="line">        res.push(cur.val);</span><br><span class="line">        cur.left &amp;&amp; stack.push(cur.left);</span><br><span class="line">        cur.right &amp;&amp; stack.push(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h2 id="LeetCode102——二叉树的层序遍历（☆☆）（高频）"><a href="#LeetCode102——二叉树的层序遍历（☆☆）（高频）" class="headerlink" title="LeetCode102——二叉树的层序遍历（☆☆）（高频）"></a>LeetCode102——二叉树的层序遍历（☆☆）（高频）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-lever-order-traversal/">跳转地址</a></p>
<h3 id="自己的代码-3"><a href="#自己的代码-3" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>自己第一次写还是写不出来</p>
<h3 id="思路1-amp-题解-1"><a href="#思路1-amp-题解-1" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>BFS：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [root];</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="comment">// 记录当前层节点数</span></span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="comment">// 存放每一层节点</span></span><br><span class="line">        <span class="keyword">let</span> curLevel = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            curLevel.push(node.val);</span><br><span class="line">            <span class="comment">// 存放当前层下一层的节点</span></span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把每层结果放到res</span></span><br><span class="line">        res.push(curLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-2"><a href="#思路2-amp-题解-2" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>DFS：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> level = <span class="number">0</span>;</span><br><span class="line">    traverse(root, level);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">traverse</span>(<span class="params">root, level</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (level &gt;= result.length) &#123;</span><br><span class="line">            result[level] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        result[level].push(root.val);</span><br><span class="line">        traverse(root.left, level + <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, level + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode589——N叉树的前序遍历（☆）"><a href="#LeetCode589——N叉树的前序遍历（☆）" class="headerlink" title="LeetCode589——N叉树的前序遍历（☆）"></a>LeetCode589——N叉树的前序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">跳转地址</a></p>
<h3 id="思路1-amp-题解-2"><a href="#思路1-amp-题解-2" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, ans=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> ans</span><br><span class="line">    ans.push(root.val)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> child <span class="keyword">of</span> root.children)</span><br><span class="line">        preorder(child, ans)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-3"><a href="#思路2-amp-题解-3" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">let</span> stack = [root];</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">    cur = stack.pop();</span><br><span class="line">    res.push(cur.val);</span><br><span class="line">    <span class="keyword">if</span> (cur.children) &#123;</span><br><span class="line">      cur.children.reverse();</span><br><span class="line">      stack.push(...cur.children);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if 可替换为：</span></span><br><span class="line">    <span class="comment">// for(let i = node.children.length - 1; i &gt;= 0; i--) &#123;</span></span><br><span class="line">    <span class="comment">//     stack.push(node.children[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode145——N叉树的后序遍历（☆）"><a href="#LeetCode145——N叉树的后序遍历（☆）" class="headerlink" title="LeetCode145——N叉树的后序遍历（☆）"></a>LeetCode145——N叉树的后序遍历（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">跳转地址</a></p>
<h3 id="思路1-amp-题解-3"><a href="#思路1-amp-题解-3" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">order</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.children) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; node.children.length; i++)&#123;</span><br><span class="line">        order(node.children[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// or  for(child of node.children)&#123;...&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    res.push(node.val);</span><br><span class="line">  &#125;</span><br><span class="line">  order(root);</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-4"><a href="#思路2-amp-题解-4" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> postorder = <span class="function"><span class="keyword">function</span>(<span class="params">root, res = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">let</span> stack = [root];</span><br><span class="line">  <span class="keyword">let</span> cur = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(stack.length)&#123;</span><br><span class="line">    cur = stack.pop();</span><br><span class="line">    <span class="keyword">if</span>(cur.children)&#123;</span><br><span class="line">      stack.push(...cur.children);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push(cur.val);<span class="comment">//因为是后序遍历，所以要把每次弹出的值压放入栈底</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.reverse();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode429——N叉树的层序遍历（☆☆）"><a href="#LeetCode429——N叉树的层序遍历（☆☆）" class="headerlink" title="LeetCode429——N叉树的层序遍历（☆☆）"></a>LeetCode429——N叉树的层序遍历（☆☆）</h2><h3 id="思路-amp-题解"><a href="#思路-amp-题解" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = [], queue = [];</span><br><span class="line">  queue.push(root);</span><br><span class="line">  <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">      <span class="keyword">let</span> length = queue.length;</span><br><span class="line">      <span class="keyword">let</span> curLevel = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">          <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">          curLevel.push(node.val);</span><br><span class="line">          node.children &amp;&amp; queue.push(...node.children);</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(curLevel);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode104——二叉树的最大深度（☆）"><a href="#LeetCode104——二叉树的最大深度（☆）" class="headerlink" title="LeetCode104——二叉树的最大深度（☆）"></a>LeetCode104——二叉树的最大深度（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">跳转地址</a></p>
<h3 id="自己的代码-4"><a href="#自己的代码-4" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>二叉树的题目还是很不熟练，这么简单的题目都不会写。。</p>
<h3 id="思路1-amp-题解-4"><a href="#思路1-amp-题解-4" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> left = maxDepth(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = maxDepth(root.right);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简版</span></span><br><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>再次强调<strong>递归三部曲</strong>：</p>
<ol>
<li>确定递归函数的参数和返回值：参数就是传入树的根节点，返回就返回这棵树的深度。</li>
<li>确定终止条件：如果为空节点的话，就返回0，表示高度为0。</li>
<li>确定单层递归的逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</li>
</ol>
<h3 id="思路2-amp-题解-5"><a href="#思路2-amp-题解-5" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<p>使用层序遍历，最大的深度就是二叉树的层数。</p>
<p>代码见上（ LC102 二叉树的层序遍历）</p>
<h2 id="LeetCode104——二叉树的最小深度（☆）"><a href="#LeetCode104——二叉树的最小深度（☆）" class="headerlink" title="LeetCode104——二叉树的最小深度（☆）"></a>LeetCode104——二叉树的最小深度（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">跳转地址</a></p>
<h3 id="思路1-amp-题解-5"><a href="#思路1-amp-题解-5" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> left = minDepth(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = minDepth(root.right);</span><br><span class="line">    <span class="comment">// 注意 “叶子结点”即左右子树都空，需要做判断。（一棵树只有左节点，那就递归左子树）</span></span><br><span class="line">    <span class="keyword">if</span>(!left) <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!right) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(left, right)+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-6"><a href="#思路2-amp-题解-6" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> queue = [root];</span><br><span class="line">    <span class="keyword">let</span> dep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> size = queue.length;</span><br><span class="line">        dep++;</span><br><span class="line">        <span class="keyword">while</span>(size--)&#123;</span><br><span class="line">            <span class="keyword">const</span> node = queue.shift();</span><br><span class="line">            <span class="comment">// 到第一个叶子节点 返回 当前深度 </span></span><br><span class="line">            <span class="keyword">if</span>(!node.left &amp;&amp; !node.right) <span class="keyword">return</span> dep;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode101——对称二叉树（☆）"><a href="#LeetCode101——对称二叉树（☆）" class="headerlink" title="LeetCode101——对称二叉树（☆）"></a>LeetCode101——对称二叉树（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/symmetric-tree/">跳转地址</a></p>
<h3 id="自己的代码-5"><a href="#自己的代码-5" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会做，如果硬写只会根据数组的2的n次方分割然后判断是不是对称。按层序遍历也很难判断。</p>
<h3 id="思路1-amp-题解-6"><a href="#思路1-amp-题解-6" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也要同时遍历两棵树。</p>
<p><strong>一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p>
<p><img src="https://i.loli.net/2021/07/29/KOA89QFnphP7C6S.png" alt="image.png"></p>
<p>递归三部曲</p>
<ul>
<li><p>确定递归函数的参数和返回值。参数是左子树节点和右子树节点，返回值是bool类型。</p>
</li>
<li><p>确定终止条件。</p>
<ul>
<li>左节点为空，右节点不为空，return false</li>
<li>左不为空，右为空， return false</li>
<li>左右都为空，return true</li>
</ul>
<p>此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：</p>
<ul>
<li>左右都不为空，比较节点数值，不相同 return false</li>
<li>否则 return true</li>
</ul>
</li>
<li><p>确定单层递归的逻辑。单层递归的逻辑就是处理 右节点都不为空，且数值相同的情况。</p>
<ul>
<li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li>
<li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li>
<li>如果左右都对称就返回true ，有一侧不对称就返回false 。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> compareNode = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//2. 确定终止条件 注意val相等不是终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right !== <span class="literal">null</span> || left !== <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left === <span class="literal">null</span> &amp;&amp; right === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left.val !== right.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">let</span> outSide = compareNode(left.left, right.right);</span><br><span class="line">        <span class="keyword">let</span> inSide = compareNode(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> outSide &amp;&amp; inSide;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> compareNode(root.left, root.right);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-7"><a href="#思路2-amp-题解-7" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>迭代：</p>
<p>使用队列来比较两个树（根节点的左右子树）是否相互翻转。手动将对称的节点按顺序入队，然后比较前两个是否相等。</p>
<p>（使用栈也可，只需把 shift 改成 pop ）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isSymmetric = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//迭代方法判断是否是对称二叉树</span></span><br><span class="line">   <span class="comment">//首先判断root是否为空</span></span><br><span class="line">   <span class="keyword">if</span>(root===<span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">let</span> queue=[];</span><br><span class="line">   queue.push(root.left);</span><br><span class="line">   queue.push(root.right);</span><br><span class="line">   <span class="keyword">while</span>(queue.length)&#123;</span><br><span class="line">       <span class="keyword">let</span> leftNode=queue.shift();<span class="comment">//左节点</span></span><br><span class="line">       <span class="keyword">let</span> rightNode=queue.shift();<span class="comment">//右节点</span></span><br><span class="line">       <span class="keyword">if</span>(leftNode===<span class="literal">null</span>&amp;&amp;rightNode===<span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(leftNode===<span class="literal">null</span>||rightNode===<span class="literal">null</span>||leftNode.val!==rightNode.val)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       queue.push(leftNode.left);<span class="comment">//左节点左孩子入队</span></span><br><span class="line">       queue.push(rightNode.right);<span class="comment">//右节点右孩子入队</span></span><br><span class="line">       queue.push(leftNode.right);<span class="comment">//左节点右孩子入队</span></span><br><span class="line">       queue.push(rightNode.left);<span class="comment">//右节点左孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode222——完全二叉树的节点个数（☆☆）"><a href="#LeetCode222——完全二叉树的节点个数（☆☆）" class="headerlink" title="LeetCode222——完全二叉树的节点个数（☆☆）"></a>LeetCode222——完全二叉树的节点个数（☆☆）</h2><p>跳转地址</p>
<h3 id="自己的代码-6"><a href="#自己的代码-6" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>套用迭代版层序遍历模板，比较容易：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [], count = <span class="number">0</span>;;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="comment">// 其实 while(length--) 就好</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> node = queue.shift();</span><br><span class="line">            count++;</span><br><span class="line">            node.left &amp;&amp; queue.push(node.left);</span><br><span class="line">            node.right &amp;&amp; queue.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路-amp-题解-1"><a href="#思路-amp-题解-1" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>还可以递归（在内部写一个递归函数）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countNodes = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 确定递归函数参数</span></span><br><span class="line">    <span class="keyword">const</span> getNodeSum=<span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 2. 确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node===<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 3. 确定单层递归逻辑</span></span><br><span class="line">        <span class="keyword">let</span> leftNum=getNodeSum(node.left);</span><br><span class="line">        <span class="keyword">let</span> rightNum=getNodeSum(node.right);</span><br><span class="line">        <span class="keyword">return</span> leftNum+rightNum+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getNodeSum(root);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode257——二叉树的所有路径（☆）"><a href="#LeetCode257——二叉树的所有路径（☆）" class="headerlink" title="LeetCode257——二叉树的所有路径（☆）"></a>LeetCode257——二叉树的所有路径（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">跳转地址</a></p>
<h3 id="自己的代码-7"><a href="#自己的代码-7" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会，不知道如何用递归表示。</p>
<h3 id="思路-amp-题解-2"><a href="#思路-amp-题解-2" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [];</span><br><span class="line">    <span class="comment">// 1.确定递归函数、参数</span></span><br><span class="line">    <span class="keyword">const</span> getPath = <span class="function"><span class="keyword">function</span> (<span class="params">node, curPath</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 2.确定终止条件, 到叶子结点终止</span></span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === right) &#123;</span><br><span class="line">            curPath += node.val;</span><br><span class="line">            res.push(curPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.单层递归 逻辑</span></span><br><span class="line">        curPath += node.val + <span class="string">&#x27;-&gt;&#x27;</span>;</span><br><span class="line">        node.left &amp;&amp; getPath(node.left, curPath);</span><br><span class="line">        node.right &amp;&amp; getPath(node.right, curPath);</span><br><span class="line">    &#125;</span><br><span class="line">    getPath(root, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种遍历方法 （深度优先搜索，即递归）</span></span><br><span class="line"><span class="keyword">var</span> binaryTreePaths = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> paths = [];</span><br><span class="line">    <span class="keyword">const</span> construct_paths = <span class="function">(<span class="params">root, path</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            path += root.val.toString();</span><br><span class="line">            <span class="keyword">if</span> (root.left === <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>) &#123; </span><br><span class="line">                paths.push(path); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path += <span class="string">&quot;-&gt;&quot;</span>; </span><br><span class="line">                construct_paths(root.left, path);</span><br><span class="line">                construct_paths(root.right, path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    construct_paths(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> paths;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>感觉这样的写法才是真正掌握了递归的用法，好像二叉树的题都能用递归来写。</p>
<h2 id="LeetCode404——左叶子之和（☆）"><a href="#LeetCode404——左叶子之和（☆）" class="headerlink" title="LeetCode404——左叶子之和（☆）"></a>LeetCode404——左叶子之和（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-left-leaves/">跳转地址</a></p>
<h3 id="自己的代码-8"><a href="#自己的代码-8" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> getLeft=<span class="function"><span class="keyword">function</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span> ) &#123;</span><br><span class="line">            count += node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left &amp;&amp; getLeft(node.left);</span><br><span class="line">        node.right &amp;&amp; node.right.left &amp;&amp; getLeft(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    getLeft(root);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没有过，这里忽略了 root 为 [1] 的情况，但是想不到如何列出这种情况。</p>
<h3 id="思路-amp-题解-3"><a href="#思路-amp-题解-3" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>通过默认传参的方式标记递归的是左子树还是右子树，根节点默认false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sumOfLeftLeaves = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> getLeft=<span class="function"><span class="keyword">function</span>(<span class="params">node, isLeft = <span class="literal">false</span></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 是左叶子结点再计算总和</span></span><br><span class="line">        <span class="keyword">if</span> (isLeft &amp;&amp; !node.left&amp;&amp; !node.right) &#123;</span><br><span class="line">            count += node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树递归传入true，右子树传入false</span></span><br><span class="line">        node.left &amp;&amp; getLeft(node.left, <span class="literal">true</span>);</span><br><span class="line">        node.right &amp;&amp; getLeft(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    getLeft(root);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode513——找树左下角的值（☆☆）"><a href="#LeetCode513——找树左下角的值（☆☆）" class="headerlink" title="LeetCode513——找树左下角的值（☆☆）"></a>LeetCode513——找树左下角的值（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-bottom-left-tree-value/">跳转地址</a></p>
<h3 id="自己的代码-9"><a href="#自己的代码-9" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = [], queue = [], result=[];</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">while</span> (queue.length!= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">let</span> curList = [];</span><br><span class="line">        <span class="keyword">while</span> (length--) &#123;</span><br><span class="line">            <span class="keyword">let</span> curNode = queue.shift();</span><br><span class="line">            curList.push(curNode);</span><br><span class="line">            curNode.left &amp;&amp; queue.push(curNode.left);</span><br><span class="line">            curNode.right &amp;&amp; queue.push(curNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(curList);</span><br><span class="line">    &#125;</span><br><span class="line">    result = res[res.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> result[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没有过，想法很简单，就是层序遍历后 return res最后一层的首位，但是最后结果是NaN，应该是哪数据类型错了。（二叉树无法调试=）</p>
<h3 id="思路1-amp-题解-7"><a href="#思路1-amp-题解-7" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>还是迭代，只是不需要借助数组，利用 resNode ，一直覆盖，直到遍历最底层的 curNode.val ，最后 return 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> queue = [], resNode;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">        <span class="keyword">let</span> length = queue.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">let</span> curNode = queue.shift();</span><br><span class="line">            <span class="keyword">if</span> (i === <span class="number">0</span>) &#123;</span><br><span class="line">                resNode = curNode.val;</span><br><span class="line">            &#125;</span><br><span class="line">            curNode.left &amp;&amp; queue.push(curNode.left);</span><br><span class="line">            curNode.right &amp;&amp; queue.push(curNode.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resNode</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-8"><a href="#思路2-amp-题解-8" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归比较深度，最深的第一个就是：(最底层最左，也可以是右子树的右子树)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findBottomLeftValue = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 递归，找前序遍历中最大深度的叶子结点</span></span><br><span class="line">    <span class="keyword">let</span> maxPath = <span class="number">0</span>, resNode = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="function"><span class="keyword">function</span> (<span class="params">node, curPath</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 2.确定终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curPath &gt; maxPath) &#123;</span><br><span class="line">                maxPath = curPath;</span><br><span class="line">                resNode = node.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.单层递归逻辑</span></span><br><span class="line">        node.left &amp;&amp; dfsTree(node.left, curPath + <span class="number">1</span>);</span><br><span class="line">        node.right &amp;&amp; dfsTree(node.right, curPath + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfsTree(root, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> resNode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode112——路径总和（☆）"><a href="#LeetCode112——路径总和（☆）" class="headerlink" title="LeetCode112——路径总和（☆）"></a>LeetCode112——路径总和（☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/path-sum/">跳转地址</a></p>
<h3 id="自己的代码-10"><a href="#自己的代码-10" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span></span><br><span class="line"><span class="function">    <span class="title">let</span> <span class="title">res</span> = <span class="title">false</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> dfsTree = <span class="function"><span class="keyword">function</span> (<span class="params">node, curSum</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        curSum += node.val;</span><br><span class="line">        <span class="keyword">if</span> (curSum === targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left &amp;&amp; dfsTree(node.left, curSum);</span><br><span class="line">        node.right &amp;&amp; dfsTree(node.right, curSum);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    res = dfsTree(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没通过，输出 undefined ，不知道为啥。</p>
<h3 id="思路1-amp-题解-8"><a href="#思路1-amp-题解-8" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><p>递归，通过改变 targetSum 进行递归，不必自己弄一个值，然后不断累积：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hasPathSum = <span class="function"><span class="keyword">function</span>(<span class="params">root, targetSum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!root.left &amp;&amp; !root.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> root.val === targetSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li>时间复杂度O(N)：其中 N 是树的节点数。对每个节点访问一次。</li>
<li>空间复杂度O(H)：其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。</li>
</ul>
<h2 id="LeetCode226——翻转二叉树（☆）"><a href="#LeetCode226——翻转二叉树（☆）" class="headerlink" title="LeetCode226——翻转二叉树（☆）"></a>LeetCode226——翻转二叉树（☆）</h2><p>跳转地址</p>
<h3 id="自己的代码-11"><a href="#自己的代码-11" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>竟然没有思路，哎。想着是先左右中的顺序得到二叉树的节点，然后通过节点列表以右左中的顺序构造二叉树，但这样难度明显增大。</p>
<h3 id="思路1-amp-题解-9"><a href="#思路1-amp-题解-9" class="headerlink" title="思路1&amp;题解"></a>思路1&amp;题解</h3><ul>
<li><p>首先递归函数会走到底，遇到 root == null， 发现叶子节点没有root.left、root.right，执行为空。</p>
</li>
<li><p>回退，在第二层的节点，发现有 root.left、root.right 了，开始翻转（<strong>左右节点</strong>）。</p>
</li>
</ul>
<ul>
<li>在第一次根节点，继续翻转（<strong>左右子树</strong>）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> invertTree = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> left = invertTree(root.left);</span><br><span class="line">    <span class="keyword">const</span> right = invertTree(root.right);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-9"><a href="#思路2-amp-题解-9" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invertTree</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack = [root];</span><br><span class="line">  <span class="keyword">while</span> (stack.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="literal">null</span>) &#123;</span><br><span class="line">      [n.left, n.right] = [n.right, n.left];</span><br><span class="line">      stack.push(n.left, n.right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）"><a href="#LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）" class="headerlink" title="LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）"></a>LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">跳转地址</a></p>
<h3 id="自己的代码-12"><a href="#自己的代码-12" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>大致思路理解，后序遍历的最后一个值即为根节点，然后在中序遍历中以根节点为界，左边就是左子树，右边就是右子树，再进行递归。可是不会用代码描述。</p>
<h3 id="思路-amp-题解-4"><a href="#思路-amp-题解-4" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span> (<span class="params">inorder, postorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!inorder.length) &#123;<span class="keyword">return</span> <span class="literal">null</span>&#125;;</span><br><span class="line">  <span class="keyword">let</span> root = <span class="keyword">new</span> TreeNode(postorder[postorder.length-<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">let</span> mid = inorder.indexOf(postorder.pop());</span><br><span class="line">  <span class="comment">//左右子树递归</span></span><br><span class="line">  root.left = buildTree(inorder.slice(<span class="number">0</span>, mid), postorder.slice(<span class="number">0</span>, mid));</span><br><span class="line">  root.right = buildTree(inorder.slice(mid + <span class="number">1</span>), postorder.slice(mid));</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>思路没错，但是这最后有点没看懂。。</p>
<h2 id="LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）"><a href="#LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）" class="headerlink" title="LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）"></a>LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">跳转地址</a></p>
<h3 id="思路-amp-题解-5"><a href="#思路-amp-题解-5" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buildTree = <span class="function"><span class="keyword">function</span>(<span class="params">preorder, inorder</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!preorder.length || !inorder.length) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 根节点</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">//找到preoder[0]对应inorder中的位置</span></span><br><span class="line">  <span class="keyword">let</span> index = inorder.indexOf(preorder.shift());</span><br><span class="line">  <span class="comment">//左右子树递归</span></span><br><span class="line">  node.left = buildTree(preorder, inorder.slice(<span class="number">0</span>, index));</span><br><span class="line">  node.right = buildTree(preorder, inorder.slice(index + <span class="number">1</span>));</span><br><span class="line">  <span class="comment">//返回根节点</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="LeetCode617——合并二叉树（☆）"><a href="#LeetCode617——合并二叉树（☆）" class="headerlink" title="LeetCode617——合并二叉树（☆）"></a>LeetCode617——合并二叉树（☆）</h2><p>跳转地址</p>
<h3 id="自己的代码-13"><a href="#自己的代码-13" class="headerlink" title="自己的代码"></a>自己的代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span>(<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root1.left &amp;&amp; !root1.right &amp;&amp;!root2.left &amp;&amp;!root2.right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1 &amp;&amp; root2) &#123;</span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没写完，感觉对临界条件的判断还是很乱很乱。想的情况太多了。</p>
<h3 id="思路-amp-题解-6"><a href="#思路-amp-题解-6" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span> (<span class="params">root1, root2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 2.终止条件：如果t1 == NULL ，两个树合并就是 t2。反过来如果t2 == NULL，那么两个数合并就是t1。</span></span><br><span class="line">    <span class="keyword">if</span> (!root1) &#123;</span><br><span class="line">        <span class="keyword">return</span> root2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.单层递归逻辑（好像不用考虑root2.val是否存在？）</span></span><br><span class="line">    root1.val += root2.val;</span><br><span class="line">    root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">    root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">    <span class="keyword">return</span> root1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode98——验证二叉搜索树（☆☆）"><a href="#LeetCode98——验证二叉搜索树（☆☆）" class="headerlink" title="LeetCode98——验证二叉搜索树（☆☆）"></a>LeetCode98——验证二叉搜索树（☆☆）</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/validate-binary-search-tree/">跳转地址</a></p>
<h3 id="自己的代码-14"><a href="#自己的代码-14" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>完全没头绪。</p>
<p>看了一眼题解，原来可以用中序遍历的方法判断是不是升序就行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">const</span> inOrder = <span class="function"><span class="keyword">function</span> (<span class="params">root, res=[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    inOrder(root.left, res);</span><br><span class="line">    res.push(root.val);</span><br><span class="line">    inOrder(root.right, res);</span><br><span class="line">  &#125;</span><br><span class="line">  inOrder(root, arr);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= arr[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路2-amp-题解-10"><a href="#思路2-amp-题解-10" class="headerlink" title="思路2&amp;题解"></a>思路2&amp;题解</h3><p>递归：(写得也太巧了)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValidBST = <span class="function"><span class="keyword">function</span>(<span class="params">root, min = -<span class="literal">Infinity</span>, max = <span class="literal">Infinity</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="LeetCode236——二叉树的最近公共祖先（☆☆）"><a href="#LeetCode236——二叉树的最近公共祖先（☆☆）" class="headerlink" title="LeetCode236——二叉树的最近公共祖先（☆☆）"></a>LeetCode236——二叉树的最近公共祖先（☆☆）</h2><p>跳转地址</p>
<h3 id="自己的代码-15"><a href="#自己的代码-15" class="headerlink" title="自己的代码"></a>自己的代码</h3><p>不会。。</p>
<h3 id="思路-amp-题解-7"><a href="#思路-amp-题解-7" class="headerlink" title="思路&amp;题解"></a>思路&amp;题解</h3><p>对于根节点 root，p、q 的分布，有两种可能：</p>
<ul>
<li>p、q 分居 root 的左右子树，则最近公共祖先（LCA） 为 root。</li>
<li>p、q 存在于 root 的同一侧子树中，就变成规模小一点的相同问题。</li>
</ul>
<p>从根节点 root 开始往下递归遍历：</p>
<ul>
<li><p>遍历到 p 或 q，比如 p，则 LCA 要么是当前的 p（q 在 p 的子树中），要么是 p 之上的节点（q 不在 p 的子树中），不可能是 p 之下的节点，因此返回当前的 p。</p>
</li>
<li><p>当遍历到 null 节点，没有 LCA，返回 null。</p>
</li>
<li><p>当遍历的节点 root 不是 p 或 q 或 null，则递归搜寻 root 的左右子树：</p>
<ul>
<li>如果左右子树的递归都有结果，说明 p 和 q 分居 root 的左右子树，返回 root。</li>
<li>如果只是一个子树递归调用有结果，说明 p 和 q 都在这个子树，返回该子树递归结果。</li>
<li>如果两个子树递归结果都为 null，说明 p 和 q 都不在这俩子树中，返回 null。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lowestCommonAncestor = <span class="function"><span class="keyword">function</span>(<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!root || root === q || root === p)  <span class="keyword">return</span> root;</span><br><span class="line">  <span class="comment">// 非null 非q 非p，则递归左右子树</span></span><br><span class="line">  <span class="keyword">let</span> left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">  <span class="keyword">let</span> right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">  <span class="comment">// 根据递归的结果，决定谁是LCA</span></span><br><span class="line">  <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> left ? left : right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>











</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E4%BA%8C%E5%8F%89%E6%A0%91/">https://asura1211.github.io/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E4%BA%8C%E5%8F%89%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E5%93%88%E5%B8%8C%E8%A1%A8/"><img class="prev-cover" src="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【数据结构】— — 哈希表</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/11/%E3%80%90%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%91%E2%80%94%20%E2%80%94%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"><img class="next-cover" src="https://i.loli.net/2021/06/07/X5Hr7RzyGbnYDf1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【数据结构】— — 栈和队列</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Asura1211"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode144%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">LeetCode144——二叉树的前序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode94%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">LeetCode94——二叉树的中序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-1"><span class="toc-number">3.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">3.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">3.4.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode145%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">LeetCode145——二叉树的后序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-2"><span class="toc-number">4.1.</span> <span class="toc-text">自己的代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode102%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">LeetCode102——二叉树的层序遍历（☆☆）（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-3"><span class="toc-number">5.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">5.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">5.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode589%E2%80%94%E2%80%94N%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">LeetCode589——N叉树的前序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">6.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">6.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode145%E2%80%94%E2%80%94N%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">LeetCode145——N叉树的后序遍历（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">7.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">7.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode429%E2%80%94%E2%80%94N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">LeetCode429——N叉树的层序遍历（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3"><span class="toc-number">8.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode104%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">LeetCode104——二叉树的最大深度（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-4"><span class="toc-number">9.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">9.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">9.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode104%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">LeetCode104——二叉树的最小深度（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">10.1.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">10.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode101%E2%80%94%E2%80%94%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">LeetCode101——对称二叉树（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-5"><span class="toc-number">11.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">11.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">11.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode222%E2%80%94%E2%80%94%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">LeetCode222——完全二叉树的节点个数（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-6"><span class="toc-number">12.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-1"><span class="toc-number">12.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode257%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">LeetCode257——二叉树的所有路径（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-7"><span class="toc-number">13.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-2"><span class="toc-number">13.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode404%E2%80%94%E2%80%94%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">LeetCode404——左叶子之和（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-8"><span class="toc-number">14.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-3"><span class="toc-number">14.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode513%E2%80%94%E2%80%94%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">LeetCode513——找树左下角的值（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-9"><span class="toc-number">15.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">15.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">15.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode112%E2%80%94%E2%80%94%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">LeetCode112——路径总和（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-10"><span class="toc-number">16.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-8"><span class="toc-number">16.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">16.3.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode226%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">17.</span> <span class="toc-text">LeetCode226——翻转二叉树（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-11"><span class="toc-number">17.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">17.2.</span> <span class="toc-text">思路1&amp;题解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-9"><span class="toc-number">17.3.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode106%E2%80%94%E2%80%94%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">LeetCode106——从中序与后序遍历序列构造二叉树（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-12"><span class="toc-number">18.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-4"><span class="toc-number">18.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode105%E2%80%94%E2%80%94%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">19.</span> <span class="toc-text">LeetCode105——从前序与中序遍历序列构造二叉树（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-5"><span class="toc-number">19.1.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode617%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E2%98%86%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">LeetCode617——合并二叉树（☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-13"><span class="toc-number">20.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-6"><span class="toc-number">20.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode98%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">21.</span> <span class="toc-text">LeetCode98——验证二叉搜索树（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-14"><span class="toc-number">21.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-amp-%E9%A2%98%E8%A7%A3-10"><span class="toc-number">21.2.</span> <span class="toc-text">思路2&amp;题解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LeetCode236%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%EF%BC%88%E2%98%86%E2%98%86%EF%BC%89"><span class="toc-number">22.</span> <span class="toc-text">LeetCode236——二叉树的最近公共祖先（☆☆）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81-15"><span class="toc-number">22.1.</span> <span class="toc-text">自己的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-amp-%E9%A2%98%E8%A7%A3-7"><span class="toc-number">22.2.</span> <span class="toc-text">思路&amp;题解</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%98%BF%E9%87%8C%E7%BB%83%E4%B9%A0%E7%94%9F/" title="【学习笔记】— — 阿里练习生"><img src="https://i.loli.net/2021/11/20/6kUmfsBR2yEIqnD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【学习笔记】— — 阿里练习生"/></a><div class="content"><a class="title" href="/2021/11/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%98%BF%E9%87%8C%E7%BB%83%E4%B9%A0%E7%94%9F/" title="【学习笔记】— — 阿里练习生">【学习笔记】— — 阿里练习生</a><time datetime="2021-11-14T19:07:06.000Z" title="发表于 2021-11-15 03:07:06">2021-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/14/%E3%80%90%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E3%80%91%E2%80%94%20%E2%80%94%20%E9%9D%A2%E7%BB%8F/" title="【面试记录】— — 面经"><img src="https://i.loli.net/2021/11/20/jROsEmxYHqpdNyV.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试记录】— — 面经"/></a><div class="content"><a class="title" href="/2021/11/14/%E3%80%90%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E3%80%91%E2%80%94%20%E2%80%94%20%E9%9D%A2%E7%BB%8F/" title="【面试记录】— — 面经">【面试记录】— — 面经</a><time datetime="2021-11-14T15:02:21.000Z" title="发表于 2021-11-14 23:02:21">2021-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家社区商城"/></a><div class="content"><a class="title" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城">【项目复盘】— — 贤得家社区商城</a><time datetime="2021-10-31T15:01:17.000Z" title="发表于 2021-10-31 23:01:17">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题"><img src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 常见问题"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题">【面试准备】— — 常见问题</a><time datetime="2021-10-11T14:03:14.000Z" title="发表于 2021-10-11 22:03:14">2021-10-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>