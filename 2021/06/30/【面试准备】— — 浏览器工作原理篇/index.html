<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【面试准备】— — 浏览器工作原理篇 | 青山の博客</title><meta name="keywords" content="浏览器"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是我在复习浏览器相关知识，准备实习面试时整理的笔记，参考自一些已经整理好的博客：「查缺补漏」送你18道浏览器面试题，侵权删。 从输入URL到界面展示发生了什么（高频） 首先对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非">
<meta property="og:type" content="article">
<meta property="og:title" content="【面试准备】— — 浏览器工作原理篇">
<meta property="og:url" content="https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是我在复习浏览器相关知识，准备实习面试时整理的笔记，参考自一些已经整理好的博客：「查缺补漏」送你18道浏览器面试题，侵权删。 从输入URL到界面展示发生了什么（高频） 首先对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg">
<meta property="article:published_time" content="2021-06-30T20:55:18.000Z">
<meta property="article:modified_time" content="2021-10-20T13:48:36.971Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="浏览器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【面试准备】— — 浏览器工作原理篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-20 21:48:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【面试准备】— — 浏览器工作原理篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-30T20:55:18.000Z" title="发表于 2021-07-01 04:55:18">2021-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-20T13:48:36.971Z" title="更新于 2021-10-20 21:48:36">2021-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【面试准备】— — 浏览器工作原理篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习浏览器相关知识，准备实习面试时整理的笔记，参考自一些已经整理好的博客：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573215830933512">「查缺补漏」送你18道浏览器面试题</a>，侵权删。</p>
<h1 id="从输入URL到界面展示发生了什么（高频）"><a href="#从输入URL到界面展示发生了什么（高频）" class="headerlink" title="从输入URL到界面展示发生了什么（高频）"></a>从输入URL到界面展示发生了什么（高频）</h1><ol>
<li>首先对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</li>
<li>浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</li>
<li>先需要获取输入的 URL 中的域名 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</li>
<li>当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，我们本机的 MAC 地址为源 MAC 地址，目的 MAC 地址需要分情况处理，通过将 IP 地址与我们本机的子网掩码相与，我们可以判断我们是否与请求主机在同一个子网里，如果在同一个子网里，我们可以使用 APR 协议获取到目的主机的 MAC 地址；如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</li>
<li>下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接建立。</li>
<li>如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</li>
<li>当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</li>
<li>浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，不然 script 的加载和执行会造成页面渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，根据渲染树来进行布局。布局完成后，使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</li>
<li>最后一步是 TCP 断开连接的四次挥手过程。</li>
</ol>
<h2 id="哪些阶段可以优化提升效率？"><a href="#哪些阶段可以优化提升效率？" class="headerlink" title="哪些阶段可以优化提升效率？"></a>哪些阶段可以优化提升效率？</h2><h2 id="强缓存、协商缓存发生在哪些阶段？"><a href="#强缓存、协商缓存发生在哪些阶段？" class="headerlink" title="强缓存、协商缓存发生在哪些阶段？"></a>强缓存、协商缓存发生在哪些阶段？</h2><h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="cookie，localStorage，sessionStorage，indexDB"><a href="#cookie，localStorage，sessionStorage，indexDB" class="headerlink" title="cookie，localStorage，sessionStorage，indexDB"></a>cookie，localStorage，sessionStorage，indexDB</h2><p>indexDB 不常见，主要是 cookie 和 localStorage 的区别。</p>
<p>![_Y_G2YI_S______R~NTP`F5.png](<a target="_blank" rel="noopener" href="https://i.loli.net/2021/09/11/N49TzFGH8Y6CRvx.png">https://i.loli.net/2021/09/11/N49TzFGH8Y6CRvx.png</a>)</p>
<p>从上表可以看到，<code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p>
<p>对于 <code>cookie</code> 来说，我们还需要注意安全性。</p>
<p><img src="https://i.loli.net/2021/09/11/Uh1amdz9rvwJg4x.png" alt="image.png"></p>
<h2 id="什么是-Cookie-？（高频）"><a href="#什么是-Cookie-？（高频）" class="headerlink" title="什么是 Cookie ？（高频）"></a>什么是 Cookie ？（高频）</h2><p>深入了解：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017332168">一文带你看懂cookie</a></p>
<p>cookie 是服务器提供的一种<strong>用于维护会话状态信息的数据</strong>，通过服务器发送到浏览器，浏览器保存在本地。当下一次有同源的请求时，浏览器会自动将保存的 cookie 值添加到请求头部，发送给服务端。cookie 一般可以存储 <strong>4k 大小</strong>的数据，并且只能够被同源的网页所共享访问。Cookie 主要用于以下三个方面：</p>
<ul>
<li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li>
<li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li>
</ul>
<p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了9个属性值 </p>
<ul>
<li>name。名字</li>
<li>value。值</li>
<li>expires。指定 cookie 失效的时间</li>
<li>domain。域名</li>
<li>path。路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问</li>
<li>secure。规定 cookie 只能在确保安全的情况下传输</li>
<li>HttpOnly。规定这个 cookie 只能被服务器访问，不能使用 js 脚本访问</li>
<li>SameSite。限制第三方 cookie</li>
<li>Priority。是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。</li>
</ul>
<p>在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</p>
<h3 id="什么是-Cookie-隔离？"><a href="#什么是-Cookie-隔离？" class="headerlink" title="什么是 Cookie 隔离？"></a>什么是 Cookie 隔离？</h3><p><strong>网站向服务器请求的时候，会自动带上cookie这样增加表头信息量，使请求变慢。</strong></p>
<p>如果静态文件都放在主域名下，那静态文件请求的时候都会把带有 cookie 的数据提交给 server，非常浪费流量，所以不如隔离开，静态资源放 CDN。</p>
<p>因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名时，请求头中就不会带有cookie数据，这样可以降低请求头的大小和请求时间，从而达到降低整体请求延时的目的。</p>
<p>同时这种方式不会将 cookie 传入 WebServer，减少了 WebServer 对 cookie 的处理分析环节，提高了 WebServer 对 http 请求的解析速度。</p>
<h2 id="什么是-Session？"><a href="#什么是-Session？" class="headerlink" title="什么是 Session？"></a><strong>什么是 Session？</strong></h2><p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储<strong>特定用户会话所需的属性及配置信息</strong>。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<h2 id="Cookie-和-Session-有什么区别？"><a href="#Cookie-和-Session-有什么区别？" class="headerlink" title="Cookie 和 Session 有什么区别？"></a>Cookie 和 Session 有什么区别？</h2><p>深入了解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ityouknow/p/10856177.html">https://www.cnblogs.com/ityouknow/p/10856177.html</a></p>
<ul>
<li>作用范围不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li>存取方式的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li>有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li>隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
<li>存储大小不同， 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h1 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h1><p>浏览器的缓存机制指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。</p>
<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。本问题参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733763675488269/section/6844733763771990029">前端面试之道</a>。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903781084184584">https://juejin.cn/post/6844903781084184584</a></p>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有<strong>优先级</strong>，当依次查找缓存且都没有命中的时候，才会去请求网络</p>
<ol>
<li><p>Service Worker：Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。</p>
<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 <code>fetch</code> 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是<strong>从 Service Worker 中获取的内容</strong>。</p>
</li>
<li><p>Memory Cache：即内存中的缓存，读取内存中的数据肯定比磁盘快。<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong> 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>
</li>
<li><p>Disk Cache：即存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong></p>
<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></p>
</li>
<li><p>Push Cache：是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</strong></p>
</li>
<li><p>网络请求：如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</p>
</li>
</ol>
<h2 id="缓存策略（高频）"><a href="#缓存策略（高频）" class="headerlink" title="缓存策略（高频）"></a>缓存策略（高频）</h2><p>通常浏览器缓存策略分为两种：<strong>强缓存</strong>和<strong>协商缓存</strong>，并且缓存策略都是通过设置 HTTP Header 来实现的。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018342655">彻底理解浏览器的缓存机制（http缓存机制）</a></p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>强缓存可以通过设置两种 HTTP Header 实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，state code 为 <strong>200</strong>。</p>
<ol>
<li><strong>Expires：</strong>（<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code>）<code>Expires</code> 是 HTTP/1 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> <strong>受限于本地时间</strong>，如果修改了本地时间，可能会造成缓存失效。</li>
<li><strong>Cache-control：</strong>（<code>Cache-control: max-age=30</code>）<code>Cache-Control</code> 出现于 HTTP/1.1，**优先级高于 **<code>Expires</code> 。该属性值表示资源会在 30 秒后过期，需要再次请求。<code>Cache-Control</code> <strong>可以在请求头或者响应头中设置</strong>，并且可以组合使用多种指令</li>
</ol>
<p><img src="https://i.loli.net/2021/09/11/b8Dz94rL5aeByWK.png" alt="image.png"></p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：<code>Last-Modified</code> 和 <code>ETag</code> 。</p>
<p>当浏览器发起请求验证资源时，如果资源没有改变，服务端就会返回 <strong>304</strong> 状态码，并且更新浏览器缓存有效期。</p>
<ol>
<li><p><strong>Last-Modified：</strong>表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。但是 <code>Last-Modified</code> 存在一些弊端：</p>
<ul>
<li><p>如果本地打开缓存文件，即使没有对文件进行修改，还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</p>
</li>
<li><p>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</p>
</li>
</ul>
<p>因为以上这些弊端，所以在 HTTP / 1.1 出现了 <code>ETag</code> 。</p>
</li>
<li><p><strong>ETag：</strong>类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <strong><code>ETag</code> 优先级比 <code>Last-Modified</code> 高</strong>。</p>
</li>
</ol>
<p><strong>如果什么缓存策略都没设置，那么浏览器会怎么处理？</strong></p>
<p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 10% 作为缓存时间。</p>
<h2 id="实际场景缓存策略"><a href="#实际场景缓存策略" class="headerlink" title="实际场景缓存策略"></a>实际场景缓存策略</h2><ul>
<li><strong>频繁变动的资源：</strong>首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</li>
<li><strong>代码文件：</strong>特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。一般来说，现在都会使用工具来打包代码，那么就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此就可以给代码文件设置缓存有效期一年 <code>Cache-Control: max-age=31536000</code>，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。</li>
</ul>
<h2 id="什么是-Service-Worker？"><a href="#什么是-Service-Worker？" class="headerlink" title="*什么是 Service Worker？"></a>*什么是 Service Worker？</h2><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p>
<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><p>参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733763675488269/section/6844733763771957256">前端面试之道</a></p>
<h2 id="一、浏览器接收到-HTML-文件并转换为-DOM-树"><a href="#一、浏览器接收到-HTML-文件并转换为-DOM-树" class="headerlink" title="一、浏览器接收到 HTML 文件并转换为 DOM 树"></a>一、浏览器接收到 HTML 文件并转换为 DOM 树</h2><p>当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。当浏览器接收到这些字节数据以后，它会将这些<strong>字节数据转换为字符串</strong>，也就是我们写的代码。</p>
<p>当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为<strong>标记</strong>（token），这一过程在词法分析中叫做<strong>标记化</strong>（tokenization）。</p>
<p>当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。</p>
<p><img src="https://i.loli.net/2021/09/11/9l5tgzC67v8XdIV.png" alt="image.png"></p>
<h2 id="二、将-CSS-文件转换为-CSSOM-树"><a href="#二、将-CSS-文件转换为-CSSOM-树" class="headerlink" title="二、将 CSS 文件转换为 CSSOM 树"></a>二、将 CSS 文件转换为 CSSOM 树</h2><p>在这一过程中，浏览器会确定下每一个节点的<strong>样式</strong>到底是什么，并且这一过程其实是<strong>很消耗资源</strong>的。因为样式可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得<strong>递归</strong> CSSOM 树，然后确定具体的元素到底是什么样式。所以我们应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器（例如 <code>div &gt; a &gt; span</code>），然后对于 HTML 来说也尽量少的添加无意义标签，保证<strong>层级扁平</strong>。</p>
<h2 id="三、生成渲染树"><a href="#三、生成渲染树" class="headerlink" title="三、生成渲染树"></a>三、生成渲染树</h2><p>当生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。</p>
<p><img src="https://i.loli.net/2021/09/11/SkfPoQpEnyXaA3V.png" alt="image.png"></p>
<p>在这一过程中，不是简单的将两者合并。渲染树只会包括<strong>需要显示的节点</strong>和这些节点的样式信息，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</p>
<p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。</p>
<p><strong>测量渲染速度：</strong></p>
<p>当发生 <code>DOMContentLoaded</code> 事件后，就会生成渲染树，生成渲染树就可以进行渲染。</p>
<h2 id="为什么操作-DOM-慢？"><a href="#为什么操作-DOM-慢？" class="headerlink" title="为什么操作 DOM 慢？"></a>为什么操作 DOM 慢？</h2><p>DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</p>
<h2 id="重绘（Repaint）和回流（重排）（Reflow）（高频）"><a href="#重绘（Repaint）和回流（重排）（Reflow）（高频）" class="headerlink" title="重绘（Repaint）和回流（重排）（Reflow）（高频）"></a>重绘（Repaint）和回流（重排）（Reflow）（高频）</h2><p>重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。</p>
<ul>
<li>重绘是当<strong>节点需要更改外观而不会影响布局</strong>的，比如改变 <code>color</code> </li>
<li>回流是<strong>布局或者几何属性需要改变</strong></li>
</ul>
<p>回流<strong>必定</strong>会发生重绘，重绘<strong>不一定</strong>会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。以下几个动作可能会导致性能问题：</p>
<ul>
<li>改变 <code>window</code> 大小</li>
<li>改变字体</li>
<li>添加或删除样式（可见的DOM元素）</li>
<li>内容变化，比如在input框中输入文字</li>
<li>定位或者浮动</li>
<li>计算 offsetTop、offsetLeft 等布局信息</li>
<li>激活CSS伪类，例如 :hover</li>
<li>盒模型</li>
</ul>
<h3 id="减少重绘和回流（避免浏览器重排）"><a href="#减少重绘和回流（避免浏览器重排）" class="headerlink" title="减少重绘和回流（避免浏览器重排）"></a>减少重绘和回流（避免浏览器重排）</h3><ul>
<li><p>使用 <code>transform</code> 替代 <code>top</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引起回流</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>).style.top = <span class="string">&#x27;100px&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>visibility:hidden</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</p>
</li>
<li><p>不要把节点的属性值放在一个循环里当成循环里的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局。通常可用 ul、li、span等标签取代 table 系列标签生成表格</p>
</li>
<li><p>动画实现的速度选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></p>
</li>
<li><p>避免设置多层内联样式。浏览器的CSS解析器解析css文件时，对CSS规则是<strong>从右到左匹配</strong>查找，样式层级过多会影响重排重绘效率。</p>
</li>
<li><p>将频繁重绘或者回流的节点设置为图层。图层能够阻止该节点的渲染行为影响别的节点，比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。设置节点为图层的方式有很多：</p>
<ul>
<li><code>will-change</code> 属性</li>
<li><code>video</code>、<code>iframe</code> 标签</li>
</ul>
</li>
</ul>
<h3 id="如何获取某个-DOM-节点的位置？"><a href="#如何获取某个-DOM-节点的位置？" class="headerlink" title="如何获取某个 DOM 节点的位置？"></a>如何获取某个 DOM 节点的位置？</h3><p>获取布局信息的属性如下：</p>
<ul>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
</ul>
<h3 id="用-clientTop-和-clinetLeft-为什么会导致浏览器重排？"><a href="#用-clientTop-和-clinetLeft-为什么会导致浏览器重排？" class="headerlink" title="用 clientTop 和 clinetLeft 为什么会导致浏览器重排？"></a>用 clientTop 和 clinetLeft 为什么会导致浏览器重排？</h3><p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是，当获取布局信息的操作的时候，会<strong>强制清空队列</strong>，因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。</p>
<p>具体见<a target="_blank" rel="noopener" href="https://www.chenhanpeng.com/reflow-and-repaint/">重绘重排全解</a>。</p>
<h1 id="跨域（高频）"><a href="#跨域（高频）" class="headerlink" title="跨域（高频）"></a>跨域（高频）</h1><h2 id="浏览器的同源政策"><a href="#浏览器的同源政策" class="headerlink" title="浏览器的同源政策"></a>浏览器的同源政策</h2><p>浏览器出于安全考虑，有同源策略。一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源指的是两个域的<strong>协议、域名、端口号</strong>必须相同，<strong>有一个不同就是跨域</strong>。</p>
<p>同源政策主要限制了三个方面：</p>
<ul>
<li><p>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p>
</li>
<li><p>当前域下的 js 脚本不能够操作或访问其他域下的 DOM。</p>
</li>
<li><p>当前域下 ajax 无法发送跨域请求。</p>
</li>
</ul>
<h3 id="为什么引入这种机制？"><a href="#为什么引入这种机制？" class="headerlink" title="为什么引入这种机制？"></a><strong>为什么引入这种机制？</strong></h3><p>主要用来防止 CSRF 攻击。CSRF 攻击是利用用户的登录态发起恶意请求。在没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得用户的任何信息。</p>
<p>同源政策主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="怎么算跨域？（todo）"><a href="#怎么算跨域？（todo）" class="headerlink" title="怎么算跨域？（todo）"></a>怎么算跨域？（todo）</h3><p>a.baidu.com和b.baidu.com跨域吗？baidu.com/a和baidu.com/b跨域吗</p>
<h2 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h2><p>如果只是想要实现主域名下的不同子域名的跨域操作，可以设置 document.domain 来解决。</p>
<p><strong>1、document.domain：</strong>该方式只能用于<strong>二级域名相同</strong>的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 。只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域</p>
<p>（2）使用 location.hash 的方法，我们可以在主页面动态的修改 iframe 窗口的 hash 值，然后在 iframe 窗口里实现监听函数来实现这样一个单向的通信。因为在 iframe 是没有办法访问到不同源的父级窗口的，所以我们不能直接修改父级窗口的 hash 值来实现通信，我们可以在 iframe 中再加入一个 iframe ，这个 iframe 的内容是和父级页面同源的，所以我们可以 window.parent.parent 来修改最顶级页面的 src，以此来实现双向通信。</p>
<p>（3）使用 window.name 的方法，主要是基于同一个窗口中设置了 window.name 后不同源的页面也可以访问，所以不同源的子页面可以首先在 window.name 中写入数据，然后跳转到一个和父级同源的页面。这个时候级页面就可以访问同源的子页面中 window.name 中的数据了，这种方式的好处是可以传输的数据量大。</p>
<p><strong>2、postMessage：</strong>通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">&#x27;message&#x27;</span>, <span class="string">&#x27;http://test.com&#x27;</span>)</span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">mc.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin</span><br><span class="line">  <span class="keyword">if</span> (origin === <span class="string">&#x27;http://test.com&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;验证通过&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>3、jsonp：</strong> JSONP 的原理很简单，就是<strong>利用 <code>&lt;script&gt;</code> 标签没有跨域的访问限制</strong>。通过动态构建  <code>&lt;script&gt; </code> 标签，在请求的 url 后指定一个回调函数，然后服务器在返回数据的时候，构建一个 json 数据的包装，这个包装就是回调函数，再返回给前端，前端接收到数据后，因为请求的是脚本文件，所以会直接执行。这样先前定义好的回调函数就可以被调用，从而实现跨域请求的处理。JSONP 使用简单且兼容性不错，但是只限于 <code>get</code> 请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    	<span class="built_in">console</span>.log(data)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">	&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span>    </span><br></pre></td></tr></table></figure>

<p><strong>4、CORS：</strong>（跨域资源共享）需要浏览器和后端同时支持。IE 8 和 9 需要通过 <code>XDomainRequest</code> 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p>
<p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p>
<p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为<strong>简单请求和复杂请求</strong>。</p>
<ul>
<li>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是会在头信息之中，增加一个 Origin 字段。Origin 字段用来说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。对于如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。如果成功的话会包含一些以 Access-Control- 开头的字段。</li>
<li>非简单请求，浏览器会先发出一次预检请求，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起请求。</li>
</ul>
<p>（7）使用 websocket 协议，这个协议没有同源限制。</p>
<p>（8）使用服务器来代理跨域的访问请求，就是有跨域的请求操作时发送请求给后端，让后端代为请求，然后最后将获取的结果发返回。</p>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><p>参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733763675488269/section/6844733763776151565">前端面试之道</a>。</p>
<h2 id="什么是-XSS-攻击？（高频）"><a href="#什么是-XSS-攻击？（高频）" class="headerlink" title="什么是 XSS 攻击？（高频）"></a>什么是 XSS 攻击？（高频）</h2><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>
<p>XSS 分为<strong>持久型和非持久型</strong>:</p>
<ul>
<li><p>持久型也就是攻击的代码被服务端写入进<strong>数据库</strong>中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为可以在评论中输入以下内容<code>&lt;script&gt; alert(1) &lt;/script&gt;</code>。</p>
</li>
<li><p>非持久型一般通过<strong>修改 URL 参数</strong>的方式加入攻击代码，诱导用户访问链接从而进行攻击。举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何防范-XSS-攻击？（高频）"><a href="#如何防范-XSS-攻击？（高频）" class="headerlink" title="如何防范 XSS 攻击？（高频）"></a>如何防范 XSS 攻击？（高频）</h2><p><strong>通过转义字符：</strong></p>
<p>对于用户的输入应该永远不信任。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quto;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">&#x27;&amp;#96;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2F;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用<strong>白名单过滤</strong>的办法。</p>
<p>还可以<strong>对一些敏感信息进行保护</strong>，比如 cookie 使用 http-only ，使得脚本无法获取。也可以使用<strong>验证码</strong>，避免脚本伪装成用户执行一些操作。</p>
<h2 id="什么是-CSP-？"><a href="#什么是-CSP-？" class="headerlink" title="什么是 CSP ？"></a>什么是 CSP ？</h2><p>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。我们可以通过这种方式来<strong>尽量减少 XSS 攻击</strong>。**(最有效的方法)**</p>
<p>通常有两种方式来开启 CSP：</p>
<ol>
<li>设置 HTTP Header 中的 <code>Content-Security-Policy</code></li>
<li>设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ol>
<p>以设置 HTTP Header 来举例</p>
<ul>
<li>只允许加载本站资源 <code>Content-Security-Policy: default-src ‘self’</code></li>
<li>只允许加载 HTTPS 协议图片 <code>Content-Security-Policy: img-src https://*</code></li>
<li>允许加载任何来源框架 <code>Content-Security-Policy: child-src &#39;none&#39;</code></li>
</ul>
<h2 id="什么是-CSRF-攻击？（高频）"><a href="#什么是-CSRF-攻击？（高频）" class="headerlink" title="什么是 CSRF 攻击？（高频）"></a>什么是 CSRF 攻击？（高频）</h2><p>CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。CSRF 攻击的<strong>本质</strong>是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</p>
<p>CSRF 攻击类型一般有三种：</p>
<ul>
<li><p>GET 类型，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</p>
</li>
<li><p>POST 类型，比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</p>
</li>
<li><p>链接类型，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</p>
</li>
</ul>
<h2 id="如何防范-CSRF-攻击？（高频）"><a href="#如何防范-CSRF-攻击？（高频）" class="headerlink" title="如何防范 CSRF 攻击？（高频）"></a>如何防范 CSRF 攻击？（高频）</h2><p>防范 CSRF 攻击需要遵循以下几种规则：</p>
<ol>
<li>Get 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie</li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 Token</li>
</ol>
<p><strong>防范方法：</strong></p>
<ol>
<li><p><strong>SameSite：</strong>对 Cookie 设置 <code>SameSite</code> 属性，表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容，且因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都会重新登录。</p>
<p>Samesite 一共有两种模式，在严格模式（strict）下 cookie 在任何情况都不可能作为第三方 Cookie 使用；在宽松模式（Lax）下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p>
</li>
<li><p><strong>验证 Referer：</strong>同源检测的方法，对于需要防范 CSRF 的请求，可以通过验证 http 请求头中的 Referer 来判断该请求是否为第三方网站发起的。</p>
<p><strong>缺点</strong>是有些情况下 referer 可以被伪造。同时这种方法把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</p>
</li>
<li><p><strong>Token：</strong>服务器向用户返回一个随机数 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</p>
<p><strong>缺点</strong>是我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证。这种情况我们可以通过改变 token 的构建方式来解决。</p>
</li>
<li><p><strong>双重 Cookie 验证：</strong>服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较验证。</p>
<p>这种方式利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。这种方法比 CSRF Token 的方法更加方便，且不涉及分布式访问的问题。<strong>缺点</strong>是如果网站存在 XSS 漏洞，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</p>
</li>
</ol>
<h2 id="什么是点击劫持？如何防范"><a href="#什么是点击劫持？如何防范" class="headerlink" title="什么是点击劫持？如何防范?"></a>什么是点击劫持？如何防范?</h2><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<p><strong>防范：</strong></p>
<ol>
<li><p><strong>X-FRAME-OPTIONS：</strong>是一个 HTTP 响应头，为了防御用 <code>iframe</code> 嵌套的点击劫持攻击。<code>header(&#39;X-Frame-Options:DENY&#39;)</code>。该响应头有三个值可选：</p>
<ul>
<li><p><code>DENY</code>，表示页面不允许通过 <code>iframe</code> 的方式展示</p>
</li>
<li><p><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 <code>iframe</code> 的方式展示</p>
</li>
<li><p><code>ALLOW-FROM</code>，表示页面可以在指定来源的 <code>iframe</code> 中展示</p>
</li>
</ul>
</li>
<li><p><strong>JS 防御：</strong>对于某些远古浏览器来说，并不能支持上面的这种方式，只有通过 JS 的方式来防御点击劫持。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (top.location != <span class="built_in">window</span>.location)&#123;</span><br><span class="line">        top.location = <span class="built_in">window</span>.location </span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="什么是中间人攻击？如何防范？"><a href="#什么是中间人攻击？如何防范？" class="headerlink" title="什么是中间人攻击？如何防范？"></a>什么是中间人攻击？如何防范？</h2><p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。</p>
<p>通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。</p>
<p>防御中间人攻击其实并不难，只需要<strong>增加一个安全通道来传输信息</strong>。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。</p>
<h2 id="SQL-注入攻击？"><a href="#SQL-注入攻击？" class="headerlink" title="SQL 注入攻击？"></a>SQL 注入攻击？</h2><p>SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</p>
<h1 id="事件机制（高频）"><a href="#事件机制（高频）" class="headerlink" title="事件机制（高频）"></a>事件机制（高频）</h1><p>事件是用户操作网页时发生的交互动作，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<h2 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h2><p>事件触发有三个阶段：</p>
<ul>
<li>window 往事件触发处传播，遇到注册的<strong>捕获</strong>事件会触发</li>
<li>传播到事件触发处时触发<strong>注册</strong>事件</li>
<li>从事件触发处往 window 传播，遇到注册的<strong>冒泡</strong>事件会触发</li>
</ul>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p>
<h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><p>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值或对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</p>
<ul>
<li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li>
<li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li>
<li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li>
</ul>
<p>如果希望事件只触发在目标上，可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但还能阻止该事件目标执行别的注册事件。</p>
<h2 id="三种事件模型？"><a href="#三种事件模型？" class="headerlink" title="三种事件模型？"></a>三种事件模型？</h2><ul>
<li><p>DOM0 级模型。这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。这种方式是所有浏览器都兼容的。</p>
</li>
<li><p>IE 事件模型。在该事件模型中一次事件共有两个过程，<strong>事件处理阶段</strong>和<strong>事件冒泡阶段</strong>。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 <code>attachEvent</code> 来添加监听函数，可以添加多个监听函数，按顺序依次执行。</p>
</li>
<li><p>DOM2 级事件模型。在该事件模型中一次事件共有三个过程，第一个过程是<strong>事件捕获阶段</strong>。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型绑定的函数是 <code>addEventListener</code>，第三个参数可以指定事件是否在捕获阶段执行。</p>
</li>
</ul>
<h2 id="IE-与火狐事件机制的区别"><a href="#IE-与火狐事件机制的区别" class="headerlink" title="IE 与火狐事件机制的区别"></a>IE 与火狐事件机制的区别</h2><p>IE 支持事件冒泡、Firefox 支持事件冒泡和事件捕获。</p>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话<strong>应该注册在父节点上</strong>（如 ul 里面的 li）。事件代理的方式相较于直接给目标注册事件来说，有以下优点：</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="常见的浏览器内核有哪些"><a href="#常见的浏览器内核有哪些" class="headerlink" title="常见的浏览器内核有哪些?"></a>常见的浏览器内核有哪些?</h2><table>
<thead>
<tr>
<th>浏览器/RunTime</th>
<th>内核（渲染引擎）</th>
<th>JavaScript 引擎</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>webkit-&gt;blink</td>
<td>V8</td>
</tr>
<tr>
<td>FireFox</td>
<td>Gecko</td>
<td>SpiderMonkey</td>
</tr>
<tr>
<td>Safari</td>
<td>Webkit</td>
<td>JavaScriptCore</td>
</tr>
<tr>
<td>Edge</td>
<td>EdgeHTML</td>
<td>Chakra(for JavaScript)</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
<td>JScript（IE3.0-IE8.0）</td>
</tr>
<tr>
<td>Opera</td>
<td>Presto-&gt;blink</td>
<td>Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-）</td>
</tr>
<tr>
<td>Node.js</td>
<td>-</td>
<td>V8</td>
</tr>
</tbody></table>
<p>浏览器的内核引擎，基本上是四分天下：</p>
<ul>
<li>Trident: IE 以Trident 作为内核引擎；</li>
<li>Gecko: Firefox 是基于 Gecko 开发；</li>
<li>WebKit: Safari, Google Chrome,傲游3,猎豹浏览器,百度浏览器 opera浏览器；</li>
<li>Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台–Opera mini。</li>
</ul>
<h2 id="浏览器的主要组成部分是什么？"><a href="#浏览器的主要组成部分是什么？" class="headerlink" title="浏览器的主要组成部分是什么？"></a>浏览器的主要组成部分是什么？</h2><ol>
<li><strong>「用户界面」</strong> - 包括地址栏、前进/后退按钮、书签菜单等。</li>
<li><strong>「浏览器引擎」</strong> - 在用户界面和呈现引擎之间传送指令。</li>
<li><strong>「呈现引擎」</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>
<li><strong>「网络」</strong> - 用于网络调用，比如 HTTP 请求。</li>
<li><strong>「用户界面后端」</strong> -用于绘制基本的窗口小部件，比如组合框和窗口。</li>
<li><strong>「JavaScript 解释器」</strong>- 用于解析和执行 JavaScript 代码。</li>
<li><strong>「数据存储」</strong> - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>
</ol>
<p>注意，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p>
<h2 id="为什么-JavaScript-是单线程的，与异步冲突吗"><a href="#为什么-JavaScript-是单线程的，与异步冲突吗" class="headerlink" title="为什么 JavaScript 是单线程的，与异步冲突吗"></a>为什么 JavaScript 是单线程的，与异步冲突吗</h2><p>JS 的单线程是指一个浏览器进程中只有一个JS的执行线程，同一时刻内只会有一段代码在执行。</p>
<p>异步机制是浏览器的两个或以上常驻线程共同完成的，举个例子，比如异步请求由两个常驻线程，JS执行线程和事件触发线程共同完成的。</p>
<ul>
<li>JS执行线程发起异步请求（浏览器会开启一个HTTP请求线程来执行请求，这时JS的任务完成，继续执行线程队列中剩下任务）</li>
<li>然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待JS处理</li>
</ul>
<p>再比如定时器触发(settimeout和setinterval) 是由<strong>浏览器的定时器线程</strong>执行的定时计数，然后在定时时间把定时处理函数的执行请求插入到JS执行队列的尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。</p>
<p>所以 JS 单线程与异步更多是浏览器行为，不冲突。</p>
<h2 id="什么情况阻塞渲染？"><a href="#什么情况阻塞渲染？" class="headerlink" title="什么情况阻塞渲染？"></a>什么情况阻塞渲染？</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenjg/p/7126822.html">https://www.cnblogs.com/chenjg/p/7126822.html</a></p>
<p><strong>CSS：</strong></p>
<ul>
<li><p><code>CSS</code>不会阻塞<code>DOM</code>解析，但会阻塞<code>DOM</code>渲染。</p>
<p>因为DOM 和 CSSOM通常是并行构建的，但Render Tree 是依赖DOM Tree和 CSSOM Tree的，所以它必须等到两者都加载完毕后，完成相应的构建，才开始渲染。</p>
</li>
<li><p><code>CSS</code>会阻塞JS执行，并不会阻塞JS文件下载</p>
<p>因为如果脚本的内容是获取元素的样式，宽高等<code>CSS</code>控制的属性，浏览器是需要计算的，也就是依赖于<code>CSS</code>。浏览器也无法感知脚本内容到底是什么，为避免样式获取，因而只好等前面所有的样式下载完后，再执行<code>JS</code>。JS文件下载和CSS文件下载是并行的，有时候CSS文件很大，所以JS需要等待。</p>
</li>
</ul>
<p><strong>JS：</strong></p>
<p>由于 JavaScript 可操纵 DOM ，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。因此为了防止渲染出现不可预期的结果，浏览器设置 <strong>GUI 渲染线程与 JavaScript 引擎为互斥</strong>的关系。</p>
<ul>
<li><p>当 JavaScript 引擎执行时，GUI 线程会被挂起，GUI 更新会被保存在一个队列中，等到引擎线程空闲时立即被执行。</p>
</li>
<li><p>当浏览器在执行 JavaScript 程序时，GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成才接着执行。</p>
</li>
</ul>
<p>因此如果 JS 执行时间过长就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<h2 id="哪些操作会造成内存泄漏？"><a href="#哪些操作会造成内存泄漏？" class="headerlink" title="哪些操作会造成内存泄漏？"></a>哪些操作会造成内存泄漏？</h2><ul>
<li>意外的全局变量。由于使用未声明的变量，而意外的创建了一个全局变量，这个变量一直留在内存中无法被回收。</li>
<li>被遗忘的计时器或回调函数。设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，无法被回收。</li>
<li>脱离 DOM 的引用。获取一个 DOM 元素的引用，而后这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>闭包。不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
<h2 id="移动端的点击事件延迟是多久，为什么会有？-怎么解决？"><a href="#移动端的点击事件延迟是多久，为什么会有？-怎么解决？" class="headerlink" title="移动端的点击事件延迟是多久，为什么会有？ 怎么解决？"></a>移动端的点击事件延迟是多久，为什么会有？ 怎么解决？</h2><p>移动端点击有 300ms 的延迟是因为<strong>移动端会有双击缩放</strong>的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p>
<p>有三种办法来解决这个问题：</p>
<ul>
<li>通过 meta 标签禁用网页的缩放。</li>
<li>通过 meta 标签将网页的 viewport 设置为 ideal viewport。</li>
<li>调用一些 js 库，比如 FastClick</li>
</ul>
<p>click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</p>
<h2 id="检测浏览器版本有哪些方式？"><a href="#检测浏览器版本有哪些方式？" class="headerlink" title="检测浏览器版本有哪些方式？"></a>检测浏览器版本有哪些方式？</h2><ul>
<li><p>检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</p>
</li>
<li><p>功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</p>
</li>
</ul>
<h2 id="什么是-Polyfill-？"><a href="#什么是-Polyfill-？" class="headerlink" title="*什么是 Polyfill ？"></a>*什么是 Polyfill ？</h2><p>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p>
<p>比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</p>
<h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="如何检测浏览器所支持的最小字体大小？"><a href="#如何检测浏览器所支持的最小字体大小？" class="headerlink" title="如何检测浏览器所支持的最小字体大小？"></a>如何检测浏览器所支持的最小字体大小？</h2><p>用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</p>
<h2 id="插入几万个-DOM，如何实现页面不卡顿？"><a href="#插入几万个-DOM，如何实现页面不卡顿？" class="headerlink" title="插入几万个 DOM，如何实现页面不卡顿？"></a>插入几万个 DOM，如何实现页面不卡顿？</h2><p>分批次部分渲染 DOM：</p>
<p>1、通过 <code>requestAnimationFrame</code> 的方式去循环的插入 DOM。</p>
<p>2、<strong>虚拟滚动</strong>（virtualized scroller）。原理是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。</p>
<h2 id="实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。"><a href="#实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。" class="headerlink" title="实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。"></a>实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。</h2><p>通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，我们可以使用 content 来传递数据。最后我们通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。</p>
<p>使用 pushState 来实现有两个问题，一个是打开首页时没有记录，我们可以使用 replaceState 来将首页的记录替换，另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</p>
<h2 id="如何判断当前脚本运行在浏览器还是-node-环境中？"><a href="#如何判断当前脚本运行在浏览器还是-node-环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是 node 环境中？"></a>如何判断当前脚本运行在浏览器还是 node 环境中？</h2><p><code>typeof window === &#39;undefined&#39; ? &#39;node&#39; : &#39;browser&#39;;</code></p>
<p>通过判断当前环境的 window 对象类型是否为 undefined，如果是undefined，则说明当前脚本运行在node环境，否则说明运行在window环境。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/">https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/"><img class="prev-cover" src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【面试准备】— — JavaScript篇</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/29/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20HTML+CSS%E7%AF%87/"><img class="next-cover" src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【面试准备】— — CSS篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">从输入URL到界面展示发生了什么（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">哪些阶段可以优化提升效率？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E3%80%81%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%8F%91%E7%94%9F%E5%9C%A8%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">强缓存、协商缓存发生在哪些阶段？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">3.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%EF%BC%8ClocalStorage%EF%BC%8CsessionStorage%EF%BC%8CindexDB"><span class="toc-number">3.1.</span> <span class="toc-text">cookie，localStorage，sessionStorage，indexDB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Cookie-%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">什么是 Cookie ？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Cookie-%E9%9A%94%E7%A6%BB%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么是 Cookie 隔离？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Session%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">什么是 Session？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie-%E5%92%8C-Session-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">Cookie 和 Session 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">浏览器的缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.1.</span> <span class="toc-text">缓存位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">缓存策略（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-number">4.2.1.</span> <span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">4.2.2.</span> <span class="toc-text">协商缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">4.3.</span> <span class="toc-text">实际场景缓存策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Service-Worker%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">*什么是 Service Worker？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">浏览器渲染原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8E%A5%E6%94%B6%E5%88%B0-HTML-%E6%96%87%E4%BB%B6%E5%B9%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA-DOM-%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">一、浏览器接收到 HTML 文件并转换为 DOM 树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%B0%86-CSS-%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA-CSSOM-%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">二、将 CSS 文件转换为 CSSOM 树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%94%9F%E6%88%90%E6%B8%B2%E6%9F%93%E6%A0%91"><span class="toc-number">5.3.</span> <span class="toc-text">三、生成渲染树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C-DOM-%E6%85%A2%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">为什么操作 DOM 慢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%BB%98%EF%BC%88Repaint%EF%BC%89%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89%EF%BC%88Reflow%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">重绘（Repaint）和回流（重排）（Reflow）（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%88%E9%81%BF%E5%85%8D%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E6%8E%92%EF%BC%89"><span class="toc-number">5.5.1.</span> <span class="toc-text">减少重绘和回流（避免浏览器重排）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA-DOM-%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">5.5.2.</span> <span class="toc-text">如何获取某个 DOM 节点的位置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-clientTop-%E5%92%8C-clinetLeft-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="toc-number">5.5.3.</span> <span class="toc-text">用 clientTop 和 clinetLeft 为什么会导致浏览器重排？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">跨域（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96"><span class="toc-number">6.1.</span> <span class="toc-text">浏览器的同源政策</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E8%BF%99%E7%A7%8D%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">为什么引入这种机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%AE%97%E8%B7%A8%E5%9F%9F%EF%BC%9F%EF%BC%88todo%EF%BC%89"><span class="toc-number">6.1.2.</span> <span class="toc-text">怎么算跨域？（todo）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">如何解决跨域？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">7.</span> <span class="toc-text">安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">什么是 XSS 攻击？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">如何防范 XSS 攻击？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSP-%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">什么是 CSP ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">什么是 CSRF 攻击？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">如何防范 CSRF 攻击？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83"><span class="toc-number">7.6.</span> <span class="toc-text">什么是点击劫持？如何防范?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">什么是中间人攻击？如何防范？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">7.8.</span> <span class="toc-text">SQL 注入攻击？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">事件机制（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E4%B8%89%E9%98%B6%E6%AE%B5"><span class="toc-number">8.1.</span> <span class="toc-text">事件触发三阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.2.</span> <span class="toc-text">注册事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">三种事件模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IE-%E4%B8%8E%E7%81%AB%E7%8B%90%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.</span> <span class="toc-text">IE 与火狐事件机制的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">8.5.</span> <span class="toc-text">事件代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">9.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">9.1.</span> <span class="toc-text">常见的浏览器内核有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">浏览器的主要组成部分是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JavaScript-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%86%B2%E7%AA%81%E5%90%97"><span class="toc-number">9.3.</span> <span class="toc-text">为什么 JavaScript 是单线程的，与异步冲突吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E9%98%BB%E5%A1%9E%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">什么情况阻塞渲染？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">哪些操作会造成内存泄漏？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%BB%B6%E8%BF%9F%E6%98%AF%E5%A4%9A%E4%B9%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%EF%BC%9F-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">移动端的点击事件延迟是多久，为什么会有？ 怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">9.7.</span> <span class="toc-text">检测浏览器版本有哪些方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Polyfill-%EF%BC%9F"><span class="toc-number">9.8.</span> <span class="toc-text">*什么是 Polyfill ？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">如何检测浏览器所支持的最小字体大小？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%87%A0%E4%B8%87%E4%B8%AA-DOM%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%8D%A1%E9%A1%BF%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">插入几万个 DOM，如何实现页面不卡顿？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%95%B4%E9%A1%B5%E5%88%B7%E6%96%B0%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E3%80%81%E5%90%8E%E9%80%80%E6%97%B6%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E3%80%82"><span class="toc-number">10.3.</span> <span class="toc-text">实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BF%98%E6%98%AF-node-%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">如何判断当前脚本运行在浏览器还是 node 环境中？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 常见问题"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题">【面试准备】— — 常见问题</a><time datetime="2021-10-11T14:03:14.000Z" title="发表于 2021-10-11 22:03:14">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 前端综合篇"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇">【面试准备】— — 前端综合篇</a><time datetime="2021-10-11T12:53:49.000Z" title="发表于 2021-10-11 20:53:49">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/%E3%80%90%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E3%80%91%E2%80%94%20%E2%80%94%20git%20%E6%93%8D%E4%BD%9C/" title="【知识整理】— — git 操作"><img src="https://i.loli.net/2021/10/13/K1ZJbqocNyQfnws.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【知识整理】— — git 操作"/></a><div class="content"><a class="title" href="/2021/09/29/%E3%80%90%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E3%80%91%E2%80%94%20%E2%80%94%20git%20%E6%93%8D%E4%BD%9C/" title="【知识整理】— — git 操作">【知识整理】— — git 操作</a><time datetime="2021-09-29T15:12:34.000Z" title="发表于 2021-09-29 23:12:34">2021-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>