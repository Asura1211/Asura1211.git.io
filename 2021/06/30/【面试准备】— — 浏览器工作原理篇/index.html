<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【面试准备】— — 浏览器工作原理篇 | 青山の博客</title><meta name="keywords" content="浏览器"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是我在复习浏览器相关知识，准备实习面试时整理的笔记，参考自一些已经整理好的博客：「查缺补漏」送你18道浏览器面试题，侵权删。 从输入URL到界面展示发生了什么（高频） 构建请求：首先对 URL 进行解析，分析所需要使用的传输协议和请求资源的路径。  如果输入 URL 中的协议或者主机名不合法，会把地址栏中输入的内容传递给搜索引擎。 如果没有问题，浏览器会检查 URL 中是否出现非法字符，如">
<meta property="og:type" content="article">
<meta property="og:title" content="【面试准备】— — 浏览器工作原理篇">
<meta property="og:url" content="https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是我在复习浏览器相关知识，准备实习面试时整理的笔记，参考自一些已经整理好的博客：「查缺补漏」送你18道浏览器面试题，侵权删。 从输入URL到界面展示发生了什么（高频） 构建请求：首先对 URL 进行解析，分析所需要使用的传输协议和请求资源的路径。  如果输入 URL 中的协议或者主机名不合法，会把地址栏中输入的内容传递给搜索引擎。 如果没有问题，浏览器会检查 URL 中是否出现非法字符，如">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg">
<meta property="article:published_time" content="2021-06-30T20:55:18.000Z">
<meta property="article:modified_time" content="2021-12-07T04:44:39.936Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="浏览器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【面试准备】— — 浏览器工作原理篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-07 12:44:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【面试准备】— — 浏览器工作原理篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-30T20:55:18.000Z" title="发表于 2021-07-01 04:55:18">2021-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-07T04:44:39.936Z" title="更新于 2021-12-07 12:44:39">2021-12-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>54分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【面试准备】— — 浏览器工作原理篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习浏览器相关知识，准备实习面试时整理的笔记，参考自一些已经整理好的博客：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573215830933512">「查缺补漏」送你18道浏览器面试题</a>，侵权删。</p>
<h1 id="从输入URL到界面展示发生了什么（高频）"><a href="#从输入URL到界面展示发生了什么（高频）" class="headerlink" title="从输入URL到界面展示发生了什么（高频）"></a>从输入URL到界面展示发生了什么（高频）</h1><ol>
<li><p><strong>构建请求</strong>：首先对 URL 进行解析，分析所需要使用的<strong>传输协议</strong>和请求资源的<strong>路径</strong>。</p>
<ul>
<li>如果输入 URL 中的协议或者主机名不合法，会把地址栏中输入的内容传递给搜索引擎。</li>
<li>如果没有问题，浏览器会检查 URL 中是否出现非法字符，如果存在则对其进行转义。</li>
</ul>
</li>
<li><p><strong>查找缓存</strong>：在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。先检查强缓存，如果命中的话直接使用，否则向服务器发起新的请求。</p>
</li>
<li><p><strong>DNS 解析</strong>：获取输入 URL 的域名 IP 地址。</p>
<ul>
<li>首先查看是否有对应的域名<strong>缓存</strong>，有的话直接用缓存的 IP 访问。</li>
<li>如果缓存中没有，则去查找 <strong>hosts</strong> 文件。</li>
<li>如果 hosts 文件里没找到域名，则将域名发往<strong>本地 DNS 服务器</strong>。</li>
<li>如果本地 DNS 服务器有相应域名的记录则返回。</li>
<li>如果没有就先向<strong>根域名服务器</strong>发起请求，它会根据请求的域名，返回对应的顶级域名服务器。</li>
<li>再向<strong>顶级域名服务器</strong>请求，它会返回权威域名服务器的地址。</li>
<li>再向<strong>权威域名服务器</strong>请求，它会返回域名的 IP 地址。</li>
<li>最后，本地 DNS 服务器将 IP 地址返回给客户端。</li>
</ul>
<p>客户端向本地 DNS 服务器发起请求属于<strong>递归请求</strong>，本地 DNS 服务器向各级域名服务器发起请求属于<strong>迭代请求。</strong></p>
</li>
<li><p><strong>获取目的主机 MAC 地址</strong>：</p>
<ul>
<li>应用层下发数据给<strong>传输层</strong>，TCP 协议会指定<strong>源端口号</strong>和<strong>目的端口号</strong>。</li>
<li>然后下发给<strong>网络层</strong>，会将本机地址作为<strong>源地址</strong>，获取的 IP 地址作为<strong>目的地址</strong>。</li>
<li>然后下发给<strong>数据链路层</strong>，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址为<strong>源 MAC 地址</strong>，<strong>目的 MAC 地址</strong>需要分情况处理。通过将 IP 地址与我们本机的子网掩码相与，可以判断本机是否与请求主机在同一个子网里：<ul>
<li>在同一个子网里，就可以使用 APR 协议获取目的主机的 MAC 地址；</li>
<li>不在一个子网里，请求就应该转发给网关，由它代为转发，同样可以通过 ARP 协议获取网关的 MAC 地址。该地址即为目的主机的 MAC 地址。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>建立 TCP 连接</strong>：通过<strong>三次握手</strong>建立客户端和服务器之间的连接：</p>
<ul>
<li>首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号。</li>
<li>服务端接收到请求后向服务器端发送一个 SYN ACK 报文段，确认连接请求，并且也向客户端发送一个随机序号。 </li>
<li>客户端接收服务器的确认应答后进入连接建立的状态，同时向服务器也发送一个 ACK 确认报文段。</li>
<li>服务器端接收到确认后，也进入连接建立状态。此时双方的连接建立。</li>
</ul>
<p>（ 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。）</p>
</li>
<li><p><strong>发送 HTTP 请求：</strong>TCP 连接完成后，开始与服务器通信。发送请求需要携带请求行，请求头和请求体。</p>
</li>
<li><p><strong>网络响应</strong>：当页面请求发送到服务器端后，会返回一个 html 文件作为响应，响应具有响应行、响应头和响应体。浏览器接收到响应后，对 html 文件进行解析，开始页面的渲染过程。</p>
</li>
<li><p><strong>渲染阶段</strong>：</p>
<ul>
<li>首先浏览器会根据 html 文件构建 DOM 树。</li>
<li>根据解析到的 css 文件构建 CSSOM 树。</li>
<li>如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，否则 script 的加载和执行会造成页面渲染的阻塞。</li>
<li>当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。</li>
<li>渲染树构建好后，根据渲染树来进行布局，计算每个节点的位置。</li>
<li>布局完成后，调用 GPU 绘制，合成图层，显示在屏幕上。这时整个页面就能看见了。</li>
</ul>
</li>
<li><p><strong>断开 TCP 连接：</strong>四次挥手。（具体见计网篇四次挥手）</p>
</li>
</ol>
<h2 id="哪些阶段可以优化提升效率？"><a href="#哪些阶段可以优化提升效率？" class="headerlink" title="哪些阶段可以优化提升效率？"></a>哪些阶段可以优化提升效率？</h2><ol>
<li><p><strong>增加安全性</strong>：用 https 代替 http</p>
</li>
<li><p><strong>减少请求次数</strong>：利用缓存，对静态资源实现强缓存和协商缓存</p>
</li>
<li><p>DNS 优化：尽量减少 DNS 请求；分服务器部署，增加 HTTP 并发性</p>
</li>
<li><p>TCP 优化：开启长连接</p>
</li>
<li><p>数据传输：</p>
<ul>
<li><p>减少传输体积</p>
<ul>
<li>内容压缩</li>
<li>服务端开启 GZIP 压缩(一般压缩 60%)</li>
<li>数据量大则分批次请求</li>
</ul>
</li>
<li><p>减少 HTTP 请求次数</p>
<ul>
<li>资源文件合并处理</li>
<li>使用字体图标来代替图片</li>
<li>雪碧图 CSS-Sprit</li>
<li>图片 base64</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>减少单次请求所花费的时间</strong>：CDN。CDN 的核心点有两个，一个是缓存，一个是回源。“缓存”指把资源 copy 一份到 CDN 服务器，“回源”指 CDN 发现自己没有这个资源（一般是缓存的数据过期），转头向根服务器（或者它的上层服务器）去要这个资源的过程。</p>
</li>
<li><p>渲染阶段下载文件时，使用HTTP 2.0，极大提高多图的下载效率</p>
</li>
<li><p>减少白屏时间</p>
<ul>
<li>loading</li>
<li>骨架屏</li>
<li>图片懒加载</li>
</ul>
</li>
<li><p>js 如果没有操作 DOM，可以用 sync 或者 defer</p>
</li>
<li><p>减少 DOM 回流</p>
</li>
</ol>
<h2 id="过程中哪些是GPU、哪些CPU做的（todo）"><a href="#过程中哪些是GPU、哪些CPU做的（todo）" class="headerlink" title="*过程中哪些是GPU、哪些CPU做的（todo）"></a>*过程中哪些是GPU、哪些CPU做的（todo）</h2><ul>
<li>GPU进程：也只有一个，用于3D/动画绘制等等</li>
</ul>
<h1 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h1><h2 id="cookie，localStorage，sessionStorage区别？（高频）"><a href="#cookie，localStorage，sessionStorage区别？（高频）" class="headerlink" title="cookie，localStorage，sessionStorage区别？（高频）"></a>cookie，localStorage，sessionStorage区别？（高频）</h2><p>![_Y_G2YI_S______R~NTP`F5.png](<a target="_blank" rel="noopener" href="https://i.loli.net/2021/09/11/N49TzFGH8Y6CRvx.png">https://i.loli.net/2021/09/11/N49TzFGH8Y6CRvx.png</a>)</p>
<p><strong>sessionStorage：</strong>为每一个给定的源维持一个独立的存储区域。</p>
<p><code>cookie</code> 不建议用于存储，如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p>
<h3 id="localStorage-和-sessionStorage-区别？"><a href="#localStorage-和-sessionStorage-区别？" class="headerlink" title="localStorage 和 sessionStorage 区别？"></a>localStorage 和 sessionStorage 区别？</h3><p><strong>相同点</strong></p>
<ul>
<li>都与 HTTP 无关，是 HTML5 提供的标准，当发起 HTTP 请求时不会与 Cookie 一样自动携带。</li>
<li>都是以键值对的形式存在，即 Key-Value 形式。</li>
<li>存储类型都是 String 类型，当进行存储时，会调用 toString() 方法转为 String 类型。</li>
<li>对于每个域容量是有限的，不同浏览器不一样，大部分存储为 5M 左右。</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li>
<li>SessionStorage 会在用户关闭浏览器后，即会话结束后，数据失效；SessionStorage 与服务端 Session 无关。</li>
</ul>
<p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"><span class="built_in">localStorage</span>.clear();</span><br><span class="line">sessionStorage.setItem(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 由于存储数据会调用 toString() 方法</span></span><br><span class="line"><span class="comment"> * Object 类型会存储为 [object Object] 字符串</span></span><br><span class="line"><span class="comment"> * 所以进行存储时需调用 JSON.stringify() 转化为字符串</span></span><br><span class="line"><span class="comment"> * 取出时调用 JSON.parse() 将字符串转回对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="cookie-和-webstorage-区别？"><a href="#cookie-和-webstorage-区别？" class="headerlink" title="cookie 和 webstorage 区别？"></a>cookie 和 webstorage 区别？</h3><p>参考自 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/141039605">彻底弄清楚session,cookie,WebStorage的区别及应用场景</a>、<a target="_blank" rel="noopener" href="https://blog.fundebug.com/2019/04/08/about-browser-storage/">https://blog.fundebug.com/2019/04/08/about-browser-storage/</a></p>
<p>HTML5 的 WebStorage 提供了两种API：localStorage（本地存储）和 sessionStorage（会话存储）。</p>
<p>区别：</p>
<ol>
<li><strong>存储大小</strong>：localStorage 和 sessionStorage 的存储数据大小一般都是：5MB</li>
<li><strong>存储位置</strong>：cookie 在浏览器和服务器间来回传递，而 localStorage 和 sessionStorage 都保存在客户端，不与服务器进行交互通信，（减少了客户端和服务器端的交互，节省网络流量，速度也更快，更安全）</li>
<li><strong>数据有效期</strong>：sessionStorage 仅在当前浏览器窗口关闭前有效；localStorage 始终有效；cookie 只在设置的 cookie 过期时间（expires）之前一直有效，即使窗口或浏览器关闭。</li>
<li><strong>存储内容类型</strong>：localStorage 和 sessionStorage 只能存储字符串类型，对于复杂的对象可以使用 JSON 对象的 stringify 和 parse 来处理。</li>
<li><strong>作用域</strong>：sessionStorage 即便是相同域名下的两个页面，只要不在同一个浏览器窗口中打开，就无法共享；localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。</li>
<li>获取方式：localStorage：<code>window.localStorage</code>；sessionStorage：<code>window.sessionStorage</code>；cookie：<code>document.cookie</code></li>
<li>应用场景：localStoragese 常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据（令牌）。sessionStorage用于敏感账号一次性登录；</li>
</ol>
<h2 id="什么是-Cookie-？（高频）"><a href="#什么是-Cookie-？（高频）" class="headerlink" title="什么是 Cookie ？（高频）"></a>什么是 Cookie ？（高频）</h2><p>深入了解：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017332168">一文带你看懂cookie</a></p>
<p>cookie 是服务器提供的<strong>用于维护会话状态信息的数据（文本形式）</strong>，通过服务器发送到浏览器，浏览器保存在本地。当下一次有同源的请求时，浏览器会自动将 cookie 添加到请求头部，发送给服务端。cookie 可以存储 <strong>4k 大小</strong>的数据，并且只能够被同源的网页所共享访问，<strong>默认有效期 20min 左右</strong>。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li><strong>会话状态管理</strong>（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li><strong>个性化设置</strong>（如用户自定义设置、主题等）</li>
<li><strong>浏览器行为跟踪</strong>（如跟踪分析用户行为等）</li>
</ul>
<p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。cookie 的属性值：</p>
<ul>
<li>value：如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</li>
<li>secure：规定 cookie 只能在协议为 HTTPS 的请求中携带</li>
<li>HttpOnly：规定这个 cookie 只能被服务器访问，不能通过 JS 访问 Cookie。<strong>减少 XSS 攻击</strong></li>
<li>SameSite：规定浏览器不能在跨域请求中携带 Cookie，<strong>减少 CSRF 攻击</strong></li>
<li><strong>expires：指定 cookie 失效的时间</strong></li>
<li>domain：域名</li>
<li>path：路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问</li>
<li>name：名字</li>
<li>Priority：是 chrome 的提案，定义了三种优先级，当 cookie 数量超出时低优先级的 cookie 会被优先清除。</li>
</ul>
<p>在发生 xhr 的跨域请求的时候，即使是同源下的 cookie，也不会被自动添加到请求头部，除非显示地规定。</p>
<h3 id="什么是-Cookie-隔离？"><a href="#什么是-Cookie-隔离？" class="headerlink" title="*什么是 Cookie 隔离？"></a>*什么是 Cookie 隔离？</h3><p><strong>网站向服务器请求的时候，会自动带上 cookie 这样增加表头信息量，使请求变慢。</strong></p>
<p>如果静态文件都放在主域名下，那静态文件请求的时候会把带有 cookie 的数据提交给 server，非常浪费流量，所以不如隔离开，静态资源放 CDN。</p>
<p>因为 cookie 有域的限制，因此不能跨域提交请求，故使用非主要域名时，请求头中就不会带有 cookie 数据，这样可以降低请求头的大小和请求时间，从而达到降低整体请求延时的目的。</p>
<p>同时这种方式不会将 cookie 传入 WebServer，减少了 WebServer 对 cookie 的处理分析环节，提高了 WebServer 对 http 请求的解析速度。</p>
<h2 id="什么是-Session？"><a href="#什么是-Session？" class="headerlink" title="什么是 Session？"></a>什么是 Session？</h2><p>Session 代表着<strong>服务器和客户端一次会话的过程</strong>。Session 存储<strong>特定用户会话所需的属性及配置信息</strong>。这样当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量不会丢失，而是在整个用户会话中一直存在。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<p>当服务器收到请求需要创建 Session 对象时，首先会检查客户端请求中是否包含 sessionid。如果有 sessionid，服务器将根据该 id 返回对应 Session 对象。如果没有，服务器会创建新的 Session 对象，并把 sessionid 在本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端。</p>
<h3 id="Cookie-和-Session-有什么区别？（高频）"><a href="#Cookie-和-Session-有什么区别？（高频）" class="headerlink" title="Cookie 和 Session 有什么区别？（高频）"></a>Cookie 和 Session 有什么区别？（高频）</h3><p>深入了解：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ityouknow/p/10856177.html">https://www.cnblogs.com/ityouknow/p/10856177.html</a> 、 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904115080790023#heading-11">https://juejin.cn/post/6844904115080790023#heading-11</a></p>
<ul>
<li><strong>存储位置</strong>：Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li><strong>存储大小</strong>： 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
<li><strong>存储内容</strong>：Cookie 只能保存<strong>字符串</strong>类型，以文本的方式；Session 通过与 Hashtable 类似的数据结构来保存，能支持任何类型的<strong>对象</strong>。一般情况下可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li><strong>有效期</strong>：Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>安全性</strong>：Cookie 存储在客户端，比较容易遭到不法获取（Cookie欺骗，Cookie截获）；Session 存储在服务端，安全性相对 Cookie 要好一些。</li>
</ul>
<p><strong>Cookie 缺点：</strong></p>
<p>（1）大小受限</p>
<p>（2）用户可以操作（禁用）cookie，使功能受限</p>
<p>（3）安全性较低</p>
<p>（4）有些状态不可能保存在客户端。</p>
<p>（5）每次访问都要传送cookie给服务器，浪费带宽。</p>
<p>（6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</p>
<p><strong>Session 缺点：</strong></p>
<p>（1）Session 保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p>
<p>（2）依赖于 Cookie。如果禁用 cookie，则要使用URL重写，不安全。</p>
<p>（3）创建 Session 变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以过度使用 Session 变量将导致代码不可读且不好维护。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>Cookie：</strong></p>
<p>（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果删除 Cookie，则每次登录必须重新填写登录的相关信息。</p>
<p>（2）保存上次登录的时间等信息。</p>
<p>（3）保存上次查看的页面</p>
<p>（4）浏览计数</p>
<p><strong>Session：</strong>用于保存每个用户的专用信息，变量的值保存在服务器端，通过 SessionID 来区分不同的客户。</p>
<p>（1）网上商城中的购物车</p>
<p>（2）保存用户登录信息</p>
<p>（3）将某些数据放入 Session 中，供同一用户的不同页面使用</p>
<p>（4）防止用户非法登录</p>
<h3 id="怎么用-session-区别用户（todo）"><a href="#怎么用-session-区别用户（todo）" class="headerlink" title="*怎么用 session 区别用户（todo）"></a>*怎么用 session 区别用户（todo）</h3><h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><p>浏览器的缓存机制：在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内发起对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，不向服务器发起请求。</p>
<p>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。本问题参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733763675488269/section/6844733763771990029">前端面试之道</a>。</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903781084184584">https://juejin.cn/post/6844903781084184584</a></p>
<h2 id="缓存策略（高频）"><a href="#缓存策略（高频）" class="headerlink" title="缓存策略（高频）"></a>缓存策略（高频）</h2><p>通常浏览器缓存策略分为两种：<strong>强缓存</strong>和<strong>协商缓存</strong>，并且缓存策略都是通过设置 HTTP Header 来实现的。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000018342655">彻底理解浏览器的缓存机制（http缓存机制）</a></p>
<h3 id="强缓存（cache-control-高频）"><a href="#强缓存（cache-control-高频）" class="headerlink" title="强缓存（cache-control 高频）"></a>强缓存（cache-control 高频）</h3><p>强缓存：给浏览器缓存设置过期时间，超过这个时间之后缓存就过期，需要重新请求。可以通过设置两种 HTTP Header 实现：<code>Expires</code> 和 <code>Cache-Control</code> 。state code 为 <strong>200</strong>。</p>
<ol>
<li><strong>Expires：</strong>（<code>Expires: Wed, 22 Oct 2018 08:41:00 GMT</code>）Expires 是 HTTP/1 的字段，给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。 Expires <strong>受限于本地时间</strong>，如果修改了本地时间，可能会造成缓存失效。（因此出现 Cache-control）</li>
<li><strong>Cache-control：</strong>（<code>Cache-control: max-age=30</code>）<code>Cache-Control</code> 出现于 HTTP/1.1，<strong>优先级高于 <strong><code>Expires</code> 。max-age 设置的是</strong>相对缓存时间</strong>开始往后的多少秒，因此不再受日期不准确的影响。<code>Cache-Control</code> 可以组合使用多种指令：</li>
</ol>
<p><img src="https://i.loli.net/2021/09/11/b8Dz94rL5aeByWK.png" alt="image.png"></p>
<p>强缓存的问题：该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端就不能及时获取最新的资源。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>协商缓存解决了<strong>无法及时获取更新资源</strong>的问题。</p>
<p>协商缓存可以通过设置两种 HTTP Header 实现：<code>Last-Modified</code> 和 <code>ETag</code> 。当浏览器发起请求验证资源时，如果资源没有改变，服务端就会返回 <strong>304</strong> 状态码，并且更新浏览器缓存有效期。</p>
<ol>
<li><p><strong>Last-Modified：</strong>表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。但是 <code>Last-Modified</code> 存在一些弊端：</p>
<ul>
<li><p>如果本地打开缓存文件，即使没有对文件进行修改，还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</p>
</li>
<li><p>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</p>
</li>
</ul>
<p>因为以上这些弊端，所以在 HTTP / 1.1 出现了 <code>ETag</code> 。</p>
</li>
<li><p><strong>ETag：</strong>类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <strong><code>ETag</code> 优先级比 <code>Last-Modified</code> 高</strong>。</p>
</li>
</ol>
<p><strong>如果什么缓存策略都没设置，那么浏览器会怎么处理？</strong></p>
<p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 10% 作为缓存时间。</p>
<h3 id="实际场景缓存策略"><a href="#实际场景缓存策略" class="headerlink" title="实际场景缓存策略"></a>实际场景缓存策略</h3><ul>
<li><p><strong>不需要缓存的资源</strong>：可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存。</p>
</li>
<li><p><strong>频繁变动的资源：</strong>首先使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p>
</li>
<li><p><strong>代码文件：</strong>给代码文件设置缓存有效期一年 <code>Cache-Control: max-age=31536000</code>并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件（对文件名进行哈希处理，只有当代码修改后才会生成新的文件名）。</p>
</li>
</ul>
<h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="*缓存位置"></a>*缓存位置</h2><p>从缓存位置上来说分为四种，并且各自有<strong>优先级</strong>，当依次查找缓存且都没有命中的时候，才会去请求网络。</p>
<ol>
<li><p>Service Worker：Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。</p>
<p>当 Service Worker 没有命中缓存的时候，我们需要去调用 <code>fetch</code> 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是<strong>从 Service Worker 中获取的内容</strong>。</p>
</li>
<li><p>Memory Cache：即内存中的缓存，读取内存中的数据肯定比磁盘快。<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong> 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p>
</li>
<li><p>Disk Cache：即存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong></p>
<p>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></p>
</li>
<li><p>Push Cache：是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</strong></p>
</li>
<li><p>网络请求：如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</p>
</li>
</ol>
<h2 id="移动端缓存？"><a href="#移动端缓存？" class="headerlink" title="移动端缓存？"></a>移动端缓存？</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5de13c7a8954">https://www.jianshu.com/p/5de13c7a8954</a></p>
<h2 id="什么是-Service-Worker？"><a href="#什么是-Service-Worker？" class="headerlink" title="*什么是 Service Worker？"></a>*什么是 Service Worker？</h2><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p>
<h1 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="headerlink" title="浏览器渲染原理"></a>浏览器渲染原理</h1><h2 id="渲染过程（高频）"><a href="#渲染过程（高频）" class="headerlink" title="渲染过程（高频）"></a>渲染过程（高频）</h2><p>参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733763675488269/section/6844733763771957256">前端面试之道</a> 、<a target="_blank" rel="noopener" href="https://juejin.cn/post/6916157109906341902/#heading-36">https://juejin.cn/post/6916157109906341902/#heading-36</a></p>
<p><strong>一、浏览器接收到 HTML 文件并转换为 DOM 树：</strong>（遇到img标签就加载图片）</p>
<ul>
<li><p>打开一个网页时，浏览器会去请求对应的 HTML 文件。当浏览器接收到这些字节数据以后，它会将这些<strong>字节数据转换为字符串</strong>，也就是我们写的代码。</p>
</li>
<li><p>数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为<strong>标记</strong>（token），这一过程在词法分析中叫做<strong>标记化</strong>（tokenization）。</p>
</li>
<li><p>结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/09/11/9l5tgzC67v8XdIV.png" alt="image.png"></p>
<p><strong>二、将 CSS 文件转换为 CSSOM 树：</strong></p>
<p>这一过程 浏览器会确定每一个节点的<strong>样式</strong>（很消耗资源）。因为样式可以自行设置给某个节点，也可以通过继承获得。浏览器会<strong>递归</strong> CSSOM 树，然后确定具体的元素的样式。所以应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器（例如 <code>div &gt; a &gt; span</code>），也尽量少添加无意义标签，保证<strong>层级扁平</strong>。</p>
<p><strong>三、根据 DOM 树和 CSSOM 规则树生成渲染树：</strong></p>
<p>（当发生 <code>DOMContentLoaded</code> 事件后，就会生成渲染树）</p>
<p><img src="https://i.loli.net/2021/09/11/SkfPoQpEnyXaA3V.png" alt="image.png"></p>
<p>渲染树的节点被称为渲染对象，和 DOM 元素相对应，但不是一对一的，不可见的 DOM 元素不会被插入渲染树。</p>
<p><strong>四、根据渲染树来进行布局：</strong></p>
<p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。</p>
<p><strong>五、绘制阶段：</strong></p>
<p>遍历渲染树，调用 GPU 绘制，合成图层，显示在屏幕上。</p>
<h2 id="什么情况阻塞渲染？"><a href="#什么情况阻塞渲染？" class="headerlink" title="什么情况阻塞渲染？"></a>什么情况阻塞渲染？</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenjg/p/7126822.html">https://www.cnblogs.com/chenjg/p/7126822.html</a></p>
<p><strong>CSS：</strong></p>
<ul>
<li><p><code>CSS</code>不会阻塞<code>DOM</code>解析，但会阻塞<code>DOM</code>渲染。</p>
<p>因为 DOM 和 CSSOM 通常是并行构建的，但 Render Tree 是依赖 DOM Tree和 CSSOM Tree 的，所以它必须等到两者都加载完毕后，完成相应的构建，才开始渲染。</p>
</li>
<li><p><code>CSS</code>会阻塞 JS 执行，并不会阻塞 JS 文件下载</p>
<p>因为如果脚本的内容是获取元素的样式，宽高等属性，浏览器需要计算，也就是依赖于 CSS。为避免样式获取，浏览器只好等前面所有的样式下载完后，再执行 JS。JS 文件下载和 CSS 文件下载是并行的。</p>
</li>
</ul>
<p><strong>JS：</strong></p>
<p>由于 JavaScript 可操纵 DOM ，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。因此浏览器设置 <strong>GUI 渲染线程与 JS 引擎为互斥的关系</strong>。</p>
<ul>
<li>当 JavaScript 引擎执行时，GUI 线程会被挂起。GUI 更新被保存在一个队列中，等到引擎线程空闲时立即执行。</li>
</ul>
<p>因此如果 JS 执行时间过长就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<h2 id="页面渲染优化"><a href="#页面渲染优化" class="headerlink" title="页面渲染优化"></a>页面渲染优化</h2><p>参考自<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904134307495943">https://juejin.cn/post/6844904134307495943</a></p>
<ul>
<li>HTML文档结构层次尽量少，保证层级扁平</li>
<li>JS 脚本尽量后放</li>
<li>样式结构层次尽量简单</li>
<li>少量首屏样式使用内联方式放在标签内</li>
<li>在脚本中尽量减少 DOM 操作，尽量访问离线 DOM 样式信息，避免过度触发回流</li>
<li>减少通过 JS 代码修改元素样式，尽量使用修改 class 名方式操作样式或动画</li>
<li>尽量减少浏览器重排和重绘</li>
<li>不要使用 <code>table</code> 布局</li>
<li>CSS 动画中尽量只使用 <code>transform</code> 和 <code>opacity</code> ，不会发生重排和重绘</li>
<li>隐藏在屏幕外，或在页面滚动时，尽量停止动画</li>
<li>尽可能只使用 CSS 做动画，CSS动画肯定比 JS 动画要好很多</li>
<li>避免浏览器的隐式合成</li>
<li>改变复合层的尺寸</li>
</ul>
<h2 id="为什么-JS-操作-DOM-慢？"><a href="#为什么-JS-操作-DOM-慢？" class="headerlink" title="为什么 JS 操作 DOM 慢？"></a>为什么 JS 操作 DOM 慢？</h2><p>DOM 属于<strong>渲染引擎</strong>的东西，而 JS 又属于 <strong>JS 引擎</strong>。当通过 JS 操作 DOM 时，涉及两个线程之间的通信，会带来性能上的损耗。操作 DOM 次数一多，就等同于一直在进行<strong>线程之间的通信</strong>，并且还可能造成来<strong>重绘回流</strong>，影响性能。</p>
<h2 id="重绘（Repaint）和回流（重排）（Reflow）（高频）"><a href="#重绘（Repaint）和回流（重排）（Reflow）（高频）" class="headerlink" title="重绘（Repaint）和回流（重排）（Reflow）（高频）"></a>重绘（Repaint）和回流（重排）（Reflow）（高频）</h2><p>重绘和回流会在设置节点样式时频繁出现，同时也会很大程度上影响性能。</p>
<ul>
<li>重绘：<strong>当节点需要更改外观而不影响布局</strong>，比如改变 color </li>
<li>回流：<strong>布局或者几何属性需要改变</strong></li>
</ul>
<p><strong>回流必定会发生重绘，重绘不一定会引发回流</strong>。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。以下几个动作可能会导致回流：</p>
<ul>
<li>浏览器窗口尺寸改变</li>
<li>元素尺寸改变</li>
<li>添加或删除可见的 DOM 元素</li>
<li>内容变化，比如在 input 框中输入文字</li>
<li>定位或者浮动</li>
<li>计算 offsetTop、offsetLeft 等布局信息</li>
<li>激活 CSS 伪类，例如 :hover</li>
<li>设置 style 属性的值</li>
<li>盒模型</li>
</ul>
<h3 id="减少重绘和回流？"><a href="#减少重绘和回流？" class="headerlink" title="减少重绘和回流？"></a>减少重绘和回流？</h3><p>部分参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904083212468238#heading-15">https://juejin.cn/post/6844904083212468238#heading-15</a></p>
<p>减少重排范围：尽量以局部布局的形式组织 html 结构，尽可能小的影响重排的范围。</p>
<ul>
<li><strong>不要使用 <code>table</code> 布局</strong>，因为很小的一个改动就会造成整个 <code>table</code> 的重新布局。通常可用 ul、li、span 等标签取代 table。</li>
<li>尽可能在低层级的 DOM 节点上改变样式。</li>
</ul>
<p>减少重排次数：</p>
<ul>
<li><p>使用 <code>transform</code> 替代 <code>top</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引起回流</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>).style.top = <span class="string">&#x27;100px&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>visibility:hidden</code> 替换 <code>display: none</code> ，前者只会引起重绘，后者会引发回流（改变了布局）</p>
</li>
<li><p>不要把节点的属性值放在一个循环里当成循环里的变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;.test&#x27;</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>样式集中改变：</strong>对于静态页面，可以更改类名而不是修改样式。对于动态页面，统一在 cssText 变量中编辑。</p>
</li>
<li><p><strong>分离读写操作：</strong>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作（原来的操作会导致四次重排，读写分离之后实际上只触发了一次重排，这都得益于浏览器的[渲染队列机制](###用 clientTop 和 clinetLeft 为什么会导致浏览器重排？)）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad 强制刷新 触发四次重排+重绘</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.right = div.offsetRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.bottom = div.offsetBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good 缓存布局信息 相当于读写分离 触发一次重排+重绘</span></span><br><span class="line"><span class="keyword">var</span> curLeft = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> curTop = div.offsetTop;</span><br><span class="line"><span class="keyword">var</span> curRight = div.offsetRight;</span><br><span class="line"><span class="keyword">var</span> curBottom = div.offsetBottom;</span><br><span class="line"></span><br><span class="line">div.style.left = curLeft + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.top = curTop + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.right = curRight + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">div.style.bottom = curBottom + <span class="number">1</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>优化动画</strong>：动画速度越快，回流次数越多，因此可以使用 <code>requestAnimationFrame</code> 作为动画帧。（浏览器刷新频率为60Hz，即每 16.6ms 更新一次，而 requestAnimationFrame() 正是以 16.6ms 的速度更新一次。）</p>
</li>
<li><p><strong>避免设置多层内联样式</strong>。浏览器的 CSS 解析器解析 css 文件时，规则是<strong>从右到左匹配</strong>查找，样式层级过多会影响重排重绘效率。</p>
</li>
<li><p>将频繁重绘或者回流的节点<strong>设置为图层</strong>。图层能够阻止该节点的渲染行为影响别的节点，比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。设置节点为图层的方式：</p>
<ul>
<li><code>will-change</code> 属性</li>
<li><code>video</code>、<code>iframe</code> 标签</li>
</ul>
</li>
</ul>
<h3 id="如何获取某个-DOM-节点的位置？"><a href="#如何获取某个-DOM-节点的位置？" class="headerlink" title="*如何获取某个 DOM 节点的位置？"></a>*如何获取某个 DOM 节点的位置？</h3><p>获取布局信息的属性如下：</p>
<ul>
<li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li>
<li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li>
<li>clientTop、clientLeft、clientWidth、clientHeight</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
</ul>
<h3 id="用-clientTop-和-clinetLeft-为什么会导致浏览器重排？"><a href="#用-clientTop-和-clinetLeft-为什么会导致浏览器重排？" class="headerlink" title="用 clientTop 和 clinetLeft 为什么会导致浏览器重排？"></a>用 clientTop 和 clinetLeft 为什么会导致浏览器重排？</h3><p><strong>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程</strong>。浏览器会将修改操作放入到队列里，直到过一段时间或者操作达到阈值，才清空队列。但是，当获取布局信息的操作时，会<strong>强制清空队列</strong>。因为队列中可能会有影响到这些值的操作，为了给出最精确的值，浏览器会立即重排。</p>
<p>具体见<a target="_blank" rel="noopener" href="https://www.chenhanpeng.com/reflow-and-repaint/">重绘重排全解</a>。</p>
<h1 id="跨域（高频）"><a href="#跨域（高频）" class="headerlink" title="跨域（高频）"></a>跨域（高频）</h1><h2 id="浏览器的同源政策"><a href="#浏览器的同源政策" class="headerlink" title="浏览器的同源政策"></a>浏览器的同源政策</h2><p>浏览器出于安全考虑，有同源策略。一个域下的 js 脚本在未经允许的情况下，不能够访问另一个域的内容。这里的同源指的是两个域的<strong>协议、域名、端口号</strong>必须相同，<strong>有一个不同就是跨域</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://a.baidu.com/">https://a.baidu.com</a> 和 <a href="https://b.baidu.com：不同域名（主域相同，子域不同），跨">https://b.baidu.com：不同域名（主域相同，子域不同），跨</a></p>
<p><a target="_blank" rel="noopener" href="https://baidu.com/a">https://baidu.com/a</a> 和 <a target="_blank" rel="noopener" href="https://baidu.com/b%EF%BC%9A%E5%90%8C%E4%B8%80%E5%9F%9F%E5%90%8D%EF%BC%8C%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6%E6%88%96%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%B8%8D%E8%B7%A8">https://baidu.com/b：同一域名，不同文件或路径，不跨</a></p>
<p>同源政策主要限制三个方面：</p>
<ul>
<li><p>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</p>
</li>
<li><p>当前域下的 js 脚本不能够操作或访问其他域下的 DOM。</p>
</li>
<li><p>当前域下 ajax 无法发送跨域请求。</p>
</li>
</ul>
<h3 id="为什么引入这种机制？"><a href="#为什么引入这种机制？" class="headerlink" title="为什么引入这种机制？"></a><strong>为什么引入这种机制？</strong></h3><p>主要用来防止 CSRF 攻击。CSRF 攻击是利用用户的登录态发起恶意请求。在没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得用户的任何信息。</p>
<p>同源政策主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制。</p>
<h2 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h2><p>参考自 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011145364">https://segmentfault.com/a/1190000011145364</a></p>
<h3 id="一、JSONP"><a href="#一、JSONP" class="headerlink" title="一、JSONP"></a>一、JSONP</h3><p>部分参考自 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008445998">https://segmentfault.com/a/1190000008445998</a></p>
<p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，再通过相应的标签从不同域名下加载静态资源。基于此，可以动态创建script，再请求一个带参网址实现跨域通信。</p>
<p><strong>原理：利用 <code>&lt;script&gt;</code> 标签没有同源策略限制</strong>。通过动态构建  <code>&lt;script&gt; </code> 标签，在请求的 url 后指定一个回调函数 <code>handleCallback</code> ，后端解析到后加上需要传的数据再返回，前端接收到返回数据后直接执行，调用定义好的回调函数，实现跨域请求的处理。</p>
<p>优点：兼容性好，IE 低版本不能使用 CORS 但可以使用 JSONP。</p>
<p><strong>缺点</strong>：JSONP 只能实现 <code>get</code> 请求。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showJsonp</span>(<span class="params">obj</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(obj.message);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> url = <span class="string">&#x27;http://127.0.0.1:8787/?func=showJsonp&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span></span><br><span class="line"><span class="javascript">    script.setAttribute(<span class="string">&#x27;src&#x27;</span>, url);</span></span><br><span class="line"><span class="javascript">    script.setAttribute(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;text/javascript&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>后台代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;*&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> callback = req.query.func;</span><br><span class="line">  <span class="keyword">let</span> content = callback+<span class="string">&quot;(&#123;&#x27;message&#x27;:&#x27;测试数据2&#x27;&#125;)&quot;</span>;</span><br><span class="line">  res.send(content);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 后台根据请求构造出的数据如下（返回时即执行全局函数）：</span></span><br><span class="line">showJsonp(&#123;<span class="string">&#x27;message&#x27;</span>:<span class="string">&#x27;测试数据2&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="二、document-domain-iframe"><a href="#二、document-domain-iframe" class="headerlink" title="二、document.domain + iframe"></a>二、document.domain + iframe</h3><p>此方案仅限主域相同，子域不同的跨域应用场景（比如 <code>a.test.com</code> 和 <code>b.test.com</code> ）</p>
<p><strong>实现原理：</strong>两个页面都通过 js 强制设置 document.domain 为基础主域（<code>document.domain = &#39;test.com&#39;</code>），就实现了同域。</p>
<ol>
<li><p>父窗口：(<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=QTxtg4sAjsr3h5wz1dA4qA==.kajf9EO7b8bSC2Fio2L6eeugK+KQTJiP/2pe6TdFqXQ=">http://www.domain.com/a.html)</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> user = <span class="string">&#x27;admin&#x27;</span>;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>子窗口：(<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=nEAJElNDst4eWHQ5h++4eg==.gGev6WApEnBZcOrk799egtrDPM5JJ0PZUAPL53hnyzE=">http://child.domain.com/b.html)</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取父窗口中变量</span></span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="built_in">window</span>.parent.user);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="三、postMessage"><a href="#三、postMessage" class="headerlink" title="三、postMessage"></a>三、postMessage</h3><p>H5 新增。通常用于获取嵌入页面中的第三方页面数据：一个页面发送消息，另一个页面判断来源并接收消息。postMessage(data,origin)方法接受两个参数。</p>
<ol>
<li><p>a.html：(<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=5uNwoh3fieYbgK7Lft4h8w==.p/cljpA1KaxGCadLZr6WqYGAwXBJef6Imxq2eUfZmqc=">http://www.domain1.com/a.html)</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">       </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>: <span class="string">&#x27;aym&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 向domain2传送跨域数据</span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接受domain2返回数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>b.html：(<a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=VQCtTj5K0kZQtyO/bU8jBw==.+/Evv1jtgt8weDGKDgDYReGgSDp9zbpSuE7wtSTbMpQ=">http://www.domain2.com/b.html)</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收domain1的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (data) &#123;</span></span><br><span class="line"><span class="javascript">            data.number = <span class="number">16</span>;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 处理后再发回domain1</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="四、跨域资源共享（CORS）"><a href="#四、跨域资源共享（CORS）" class="headerlink" title="四、跨域资源共享（CORS）"></a>四、跨域资源共享（CORS）</h3><ul>
<li>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置</li>
<li>带cookie请求：前后端都需要设置。</li>
</ul>
<p>CORS也已经成为主流的跨域解决方案。具体见 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000017135064">跨域资源共享——CORS</a>。</p>
<p><strong>1、 前端设置：</strong></p>
<ul>
<li><p>原生 ajax</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9需用window.XDomainRequest兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;user=admin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>vue</p>
<ul>
<li>axios 设置：<code>axios.defaults.withCredentials = true</code></li>
<li>vue-resource 设置：<code>Vue.http.options.credentials = true</code></li>
</ul>
</li>
</ul>
<p><strong>2、 服务端设置</strong></p>
<h4 id="CORS-的-response-头部字段是什么"><a href="#CORS-的-response-头部字段是什么" class="headerlink" title="CORS 的 response 头部字段是什么"></a>CORS 的 response 头部字段是什么</h4><p>跨域请求，CORS要求服务端设置一些头部字段，最重要的一个就是 <code>Access-Control-Allow-Origin</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Client http://localhost:8080</span></span><br><span class="line"><span class="function"><span class="title">simpleRequest</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/api/simple&#x27;</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Server http://localhost:3000</span></span><br><span class="line">app.use(cors());</span><br><span class="line">router.get(<span class="string">&#x27;/api/simple&#x27;</span>, <span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.body = &#123; <span class="attr">result</span>: <span class="string">&#x27;simple request success&#x27;</span> &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/16/vp7j1JySKXs4Yx9.png" alt="image.png"></p>
<p><strong>HTTP 报文：</strong></p>
<p><img src="https://i.loli.net/2021/10/16/9yMSPeWIKB5YxLv.png" alt="image.png"></p>
<p>HTTP 请求头部有个 <code>Origin</code> 字段，表示请求来自哪里。HTTP 响应头部中的 <code>Access-Control-Allow-Origin</code> 表示哪个域可以访问该资源。使用 <code>Origin</code> 和 <code>Access-Control-Allow-Origin</code> 就完成了最简单的访问控制。</p>
<h4 id="跨域能携带-Cookie-吗？"><a href="#跨域能携带-Cookie-吗？" class="headerlink" title="跨域能携带 Cookie 吗？"></a>跨域能携带 Cookie 吗？</h4><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6999262693715050533">https://juejin.cn/post/6999262693715050533</a></p>
<p>除了withCrenditial还需要在header做什么处理才能携带cookie？</p>
<h4 id="简单请求和非简单（复杂）请求"><a href="#简单请求和非简单（复杂）请求" class="headerlink" title="简单请求和非简单（复杂）请求"></a>简单请求和非简单（复杂）请求</h4><p>部分参考自<a target="_blank" rel="noopener" href="https://juejin.cn/post/6976817041625841701">https://juejin.cn/post/6976817041625841701</a></p>
<p>浏览器将 ajax 请求分为<code>简单请求</code>和<code>非简单请求</code>。同时满足以下两个条件，就是简单请求：</p>
<ul>
<li>请求方法是 HEAD、GET、POST 三种方法之一</li>
<li>HTTP的头信息不超出以下几种字段：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 <code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code><ul>
<li>application/x-www-form-urlencoded: 表示使用URL编码的方式来编码表单。如果没有将enctype属性设置为任何值，那么这就是<strong>默认值</strong>。</li>
<li>multipart/form-data: 当用户想<strong>上传文件</strong>这种<strong>二进制等文件</strong>或者前面的那个方式不能满足时，使用这种类型的表单</li>
<li>text/plain: <strong>文本形式</strong>，只发送数据而不进行任何编码时使用</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>简单请求的处理:</strong></p>
<ul>
<li>对于简单请求，浏览器直接发出 CORS 请求。会在头信息中增加 Origin 字段，用来说明本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</li>
</ul>
<ul>
<li><p>如果 Origin 指定的源不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现回应的头信息没有包含 Access-Control-Allow-Origin 字段，就知道出错了，从而抛出一个错误，ajax 不会收到响应信息。</p>
</li>
<li><p>如果成功就会包含一些以 Access-Control- 开头的字段。</p>
</li>
</ul>
<p><strong>非简单请求的处理：</strong></p>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<ul>
<li>非简单请求会在正式通信之前，增加一次HTTP查询请求，称为<strong>预检请求</strong>，来判断该域名是否在服务器的白名单中，如果收到肯定回复后才会发起正式的XMLHttpRequest请求，否则就报错。</li>
<li>**”预检”请求用的请求方法是<code>OPTIONS</code>**，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</li>
<li>如果服务器否定了”预检”请求，会返回一个<strong>正常的HTTP回应</strong>，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。</li>
<li>一旦服务器通过了”预检”请求，以后每次浏览器正常的<code>CORS</code>请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一<code>个Access-Control-Allow-Origin</code>头信息字段。</li>
</ul>
<h3 id="五、nginx-代理"><a href="#五、nginx-代理" class="headerlink" title="五、nginx 代理"></a>五、nginx 代理</h3><p>（读法：engine X）</p>
<p><img src="https://i.loli.net/2021/10/14/afCSliZJ53EDxVQ.png" alt="image.png"></p>
<p>Nginx 是一种高性能的反向代理服务器，可以用来轻松解决跨域问题。</p>
<ul>
<li>正向代理帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端。（服务器是帮客户端做事情）</li>
<li>反向代理拿到客户端的请求，将请求转发给其他的服务器，主要的场景是<strong>维持服务器集群的负载均衡</strong>，即：反向代理帮其它的服务器拿到请求，然后选择一个合适的服务器，将请求转交给它。（服务器是帮其它的服务器做事情）</li>
</ul>
<p><strong>1、 nginx 配置解决 iconfont 跨域：</strong> 浏览器跨域访问 js、css、img 等常规静态资源被同源策略许可，但 iconfont字体文件例外，此时可在 nginx 的静态资源服务器中加入以下配置。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、 nginx 反向代理接口跨域</strong>：实现思路：通过 nginx 配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，这个跳板机的域名也是 domain1.com。然后让客户端首先访问 domain1.com/api，这当然没有跨域，然后 Nginx 服务器作为反向代理，将请求转发给 domain2.com:8080。（并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录）具体配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#proxy服务器</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">81</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        <span class="attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h4><p><strong>正向代理</strong>：即常说的代理。正向代理隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。</p>
<p><strong>反向代理</strong>：隐藏了真实的服务端，当我们向一个网站发起请求的时候，背后可能有成千上万台服务器为我们服务。反向代理服务器会帮我们把请求转发到真实的服务器，反向代理服务器一般用来实现<strong>负载平衡</strong>。</p>
<h4 id="负载平衡的两种实现方式？"><a href="#负载平衡的两种实现方式？" class="headerlink" title="负载平衡的两种实现方式？"></a>负载平衡的两种实现方式？</h4><ol>
<li><p>反向代理：用户的请求都发送到反向代理服务上，然后由反向代理服务器来转发请求到真实的服务器上，以此来实现集群的负载平衡。</p>
</li>
<li><p>DNS ：DNS 可以用于在冗余的服务器上实现负载平衡。现在一般的大型网站使用多台服务器提供服务，因此一个域名可能会对应多个服务器地址。当用户向网站域名请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合，但在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。</p>
<p><strong>缺点</strong>：由于 DNS 服务器中存在缓存，所以有可能一个服务器出现故障后，域名解析仍然返回的是那个 IP 地址，就会造成访问的问题。</p>
</li>
</ol>
<h3 id="六、WebSocket-协议"><a href="#六、WebSocket-协议" class="headerlink" title="六、WebSocket 协议"></a>六、WebSocket 协议</h3><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>
<p>使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<ol>
<li><p>前端代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> socket = io(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;Server socket has closed.&#x27;</span>); </span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">&#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="built_in">this</span>.value);</span></span><br><span class="line"><span class="javascript">&#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Nodejs socket后台：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启http服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听socket连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">client</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收信息</span></span><br><span class="line">    client.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        client.send(<span class="string">&#x27;hello：&#x27;</span> + msg);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;data from client: ---&gt; &#x27;</span> + msg);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 断开处理</span></span><br><span class="line">    client.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Client socket has closed.&#x27;</span>); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="项目中遇到的跨域"><a href="#项目中遇到的跨域" class="headerlink" title="项目中遇到的跨域"></a>项目中遇到的跨域</h2><p><strong>Vue项目开发中解决跨域：</strong></p>
<ol>
<li><p>打开 config 文件夹（vue-cli 配置文件）里的 inedx.js，在 proxyTable 中设置跨域。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// 配置跨域</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://x.x.x.x:x/&#x27;</span>,  <span class="comment">// 请求的目标服务器接口</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,  <span class="comment">// 设置允许跨域</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;  <span class="comment">// 这个重写不可省略！因为真正请求的地址并不含 /api</span></span><br><span class="line">            <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> <span class="comment">/* 浏览器中看到的请求地址为：http://localhost:8080/api/data/getdata ，因为重写了/api ，所以实际上访问的地址是：http://x.x.x.x:x/data/getdata */</span></span><br><span class="line">        &#125;              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在 vue 项目 src 目录下找到 main.js 文件，在创建 axios 实例的时候将 baseURL 设置为 /api</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">Vue.prototype.$axios = axios</span><br><span class="line"><span class="comment">//配置请求的根路径</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;/api&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>原理</strong>：将域名发送给本地的服务器（启动vue项目的服务，localhost:8080），再由本地的服务器去请求真正的服务器。</p>
<p><strong>生产环境解决跨域：</strong></p>
<p>使用nginx反向代理，在配置文件nginx.conf中找到server{}对象，更改项目地址root和配置代理地址proxy_pass（适合前端静态文件使用）：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   D:/browseClient/dist;  <span class="comment">#自己的前端项目地址</span></span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#解决跨域</span></span><br><span class="line"><span class="attribute">location</span> /api &#123;                                <span class="comment"># 自定义nginx接口前缀</span></span><br><span class="line">    <span class="attribute">proxy_pass</span>   http://127.0.0.1:3000;            <span class="comment"># 后台api接口地址</span></span><br><span class="line">            <span class="attribute">proxy_redirect</span> default;      </span><br><span class="line">    <span class="comment">#设置主机头和客户端真实地址，以便服务器获取客户端真实IP</span></span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h1><p>参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733763675488269/section/6844733763776151565">前端面试之道</a>。</p>
<h2 id="什么是-XSS-攻击？（高频）"><a href="#什么是-XSS-攻击？（高频）" class="headerlink" title="什么是 XSS 攻击？（高频）"></a>什么是 XSS 攻击？（高频）</h2><p>XSS 攻击：跨站脚本攻击，是一种<strong>代码注入攻击</strong>。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>XSS <strong>本质</strong>：因为网站<strong>没有对恶意代码进行过滤</strong>，与正常的代码混合在一起，导致浏览器没有办法分辨哪些脚本是可信的，从而导致恶意代码的执行。</p>
<p>XSS 分为<strong>持久型和非持久型</strong>:</p>
<ul>
<li><p>持久型：攻击的代码被服务端写入进<strong>数据库</strong>中，这种攻击危害性很大，因为如果网站访问量很大，就会导致大量正常访问页面的用户都受到攻击。举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为可以在评论中输入以下内容<code>&lt;script&gt; alert(1) &lt;/script&gt;</code>。</p>
</li>
<li><p>非持久型：一般通过<strong>修改 URL 参数</strong>的方式加入攻击代码，诱导用户访问链接从而进行攻击。举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>     </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何防范-XSS-攻击？（高频）"><a href="#如何防范-XSS-攻击？（高频）" class="headerlink" title="如何防范 XSS 攻击？（高频）"></a>如何防范 XSS 攻击？（高频）</h2><ol>
<li><p><strong>转义字符：</strong>对于用户的输入应该永远不信任。最普遍的做法就是转义输入输出的内容，对引号、尖括号、斜杠进行转义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&#x27;&amp;amp;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">&#x27;&amp;lt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">&#x27;&amp;gt;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&quot;/g</span>, <span class="string">&#x27;&amp;quto;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&amp;#39;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">&#x27;&amp;#96;&#x27;</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">&#x27;&amp;#x2F;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>白名单过滤（CSP）</strong>：对于显示富文本来说，显然不能转义所有字符，因为这样会把需要的格式也过滤掉，因此采用白名单过滤。</p>
</li>
<li><p><strong>对一些敏感信息进行保护</strong>：比如 cookie 使用 http-only，使得脚本无法获取。</p>
</li>
<li><p><strong>验证码</strong>，避免脚本伪装成用户执行一些操作。</p>
</li>
</ol>
<h3 id="什么是-CSP-？"><a href="#什么是-CSP-？" class="headerlink" title="什么是 CSP ？"></a>什么是 CSP ？</h3><p>CSP：内容安全策略，本质是<strong>建立一个白名单，告诉浏览器哪些外部资源可以加载和执行</strong>。只需要配置规则，如何拦截由浏览器自己来实现。可以通过这种方式来<strong>尽量减少 XSS 攻击 (最有效的方法)</strong></p>
<p>开启 CSP 的方式：</p>
<ol>
<li>设置 HTTP Header 中的 <code>Content-Security-Policy</code><ul>
<li>只允许加载本站资源 <code>Content-Security-Policy: default-src ‘self’</code></li>
<li>只允许加载 HTTPS 协议图片 <code>Content-Security-Policy: img-src https://*</code></li>
<li>允许加载任何来源框架 <code>Content-Security-Policy: child-src &#39;none&#39;</code></li>
</ul>
</li>
<li>设置 <code>meta</code> 标签 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ol>
<h2 id="什么是-CSRF-攻击？（高频）"><a href="#什么是-CSRF-攻击？（高频）" class="headerlink" title="什么是 CSRF 攻击？（高频）"></a>什么是 CSRF 攻击？（高频）</h2><p>CSRF：<strong>跨站请求伪造</strong>。原理是<strong>攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。</strong>如果用户在登录状态下，后端就以为是用户在操作，从而进行相应的逻辑。CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点</strong>，以此来实现用户的冒充。</p>
<p>CSRF 攻击类型一般有三种：</p>
<ul>
<li><p>GET 类型，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</p>
</li>
<li><p>POST 类型，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</p>
</li>
<li><p>链接类型，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</p>
</li>
</ul>
<h2 id="如何防范-CSRF-攻击？（高频）"><a href="#如何防范-CSRF-攻击？（高频）" class="headerlink" title="如何防范 CSRF 攻击？（高频）"></a>如何防范 CSRF 攻击？（高频）</h2><p>防范 CSRF 攻击需要遵循以下几种规则：</p>
<ol>
<li>GET 请求不对数据进行修改</li>
<li>不让第三方网站访问到用户 Cookie</li>
<li>阻止第三方网站请求接口</li>
<li>请求时附带验证信息，比如验证码或者 Token</li>
</ol>
<p><strong>具体防范方法：</strong></p>
<ol>
<li><p><strong>SameSite：</strong>对 Cookie 设置 SameSite 属性，表示 Cookie 不随着跨域请求发送。可以很大程度减少 CSRF 的攻击。Samesite 一共两种模式，严格模式（strict）下 Cookie 在任何情况都不可能作为第三方 Cookie 使用；宽松模式（Lax）下，Cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</p>
<p><strong>缺点</strong>：该属性目前并不是所有浏览器都兼容，且因为它不支持子域，所以子域没有办法与主域共享登录信息，每次转入子域的网站，都会重新登录。</p>
</li>
<li><p><strong>验证 Referer：</strong>同源检测的方法，对于需要防范 CSRF 的请求，可以通过验证 http 请求头中的 Referer 来判断该请求是否为第三方网站发起的。</p>
<p><strong>缺点</strong>：有些情况下 Referer 可以被伪造。同时这种方法把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</p>
</li>
<li><p><strong>Token：</strong>服务器向用户返回一个随机数 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。</p>
<p><strong>缺点</strong>：需要给网站中的所有请求都添加上这个 token，操作比较繁琐。此外如果请求经过负载平衡，转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没法验证。这种情况可以通过改变 token 的构建方式来解决。</p>
</li>
<li><p><strong>双重 Cookie 验证：</strong>服务器在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 Cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 Cookie 中的数据和参数中的数据进行比较验证。这种方式利用了攻击者只能利用 Cookie，但是不能访问获取 Cookie 的特点，比 Token 的方法更加方便，且不涉及分布式访问的问题。</p>
<p><strong>缺点</strong>：如果网站存在 XSS 漏洞，那么这种方式会失效。同时不能做到子域名的隔离。</p>
</li>
</ol>
<h2 id="什么是中间人攻击？如何防范？（高频）"><a href="#什么是中间人攻击？如何防范？（高频）" class="headerlink" title="什么是中间人攻击？如何防范？（高频）"></a>什么是中间人攻击？如何防范？（高频）</h2><p>中间人攻击：<strong>攻击方同时与服务端和客户端建立连接</strong>，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制。攻击者不仅能获得双方的通信信息，还能修改通信信息。通常不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。</p>
<p>攻击过程如下:</p>
<ul>
<li>客户端发送请求到服务端，请求被中间⼈截获</li>
<li>服务器向客户端发送公钥</li>
<li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端</li>
<li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li>
<li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li>
<li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li>
</ul>
<p>防御中间人攻击：<strong>增加一个安全通道来传输信息</strong>（HTTPS）。</p>
<h2 id="SQL-注入攻击？"><a href="#SQL-注入攻击？" class="headerlink" title="SQL 注入攻击？"></a>SQL 注入攻击？</h2><p>SQL 注入攻击：攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构造，破坏原有 SQL 结构，并在数据库中执行。</p>
<h2 id="点击劫持？"><a href="#点击劫持？" class="headerlink" title="点击劫持？"></a>点击劫持？</h2><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击。</p>
<p><strong>防范：</strong></p>
<ol>
<li><p><strong>X-FRAME-OPTIONS：</strong>一个 HTTP 响应头，<code>header(&#39;X-Frame-Options:DENY&#39;)</code>。有三个值可选：</p>
<ul>
<li><p><code>DENY</code>，表示页面不允许通过 <code>iframe</code> 的方式展示</p>
</li>
<li><p><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 <code>iframe</code> 的方式展示</p>
</li>
<li><p><code>ALLOW-FROM</code>，表示页面可以在指定来源的 <code>iframe</code> 中展示</p>
</li>
</ul>
</li>
<li><p><strong>JS 防御：</strong>对于某些远古浏览器来说，并不能支持上面的这种方式，只有通过 JS 的方式来防御点击劫持。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span> (top.location != <span class="built_in">window</span>.location)&#123;</span><br><span class="line">        top.location = <span class="built_in">window</span>.location </span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="事件机制（高频）"><a href="#事件机制（高频）" class="headerlink" title="事件机制（高频）"></a>事件机制（高频）</h1><p>事件是用户操作网页时发生的交互动作，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<h2 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h2><ul>
<li>window 往事件触发处传播，遇到注册的<strong>捕获</strong>事件会触发</li>
<li>传播到事件触发处时触发<strong>注册</strong>事件</li>
<li>从事件触发处往 window 传播，遇到注册的<strong>冒泡</strong>事件会触发</li>
</ul>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例：<strong>如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p>
<h2 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h2><p><code>addEventListener</code> ：第三个参数可以是布尔值或对象。布尔值参数<code>useCapture</code>（是否捕获）默认值为 false，表示冒泡。对象参数的属性：</p>
<ul>
<li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li>
<li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li>
<li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li>
</ul>
<p>如果希望事件只触发在目标上，可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，还能阻止该事件目标执行别的注册事件。</p>
<h2 id="三种事件模型？"><a href="#三种事件模型？" class="headerlink" title="三种事件模型？"></a>三种事件模型？</h2><ul>
<li><p><strong>DOM0级模型</strong>，也称为原始事件模型。这种模型<strong>不会传播</strong>，所以没有事件流的概念。</p>
</li>
<li><p><strong>IE 事件模型</strong>。在该事件模型中一次事件共有两个过程：<strong>事件处理阶段</strong>和<strong>事件冒泡阶段</strong>。事件处理阶段会首先执行目标元素绑定的监听事件。事件冒泡阶段会依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过 <code>attachEvent</code> 来添加监听函数，可以添加多个监听函数，按顺序依次执行。</p>
</li>
<li><p><strong>DOM2级事件模型</strong>，是<code>W3C</code>制定的标准模型。三个过程：捕获、目标、冒泡。<strong>事件捕获阶段</strong>：捕获指事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型绑定的函数是 <code>addEventListener</code>，第三个参数指定事件是否在捕获阶段执行。</p>
</li>
</ul>
<h3 id="IE-与火狐事件机制的区别"><a href="#IE-与火狐事件机制的区别" class="headerlink" title="IE 与火狐事件机制的区别"></a>IE 与火狐事件机制的区别</h3><p>IE 支持事件冒泡、Firefox 支持事件冒泡和事件捕获。</p>
<h2 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h2><p>如果一个节点中的子节点是动态生成的，那么子节点注册事件<strong>应该注册在父节点上</strong>（如 ul 里面的 li）。事件代理相较于直接给目标注册事件有以下优点：</p>
<ul>
<li>节省内存</li>
<li>不需要给子节点注销事件</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="*其他"></a>*其他</h1><h2 id="常见的浏览器内核有哪些"><a href="#常见的浏览器内核有哪些" class="headerlink" title="*常见的浏览器内核有哪些?"></a>*常见的浏览器内核有哪些?</h2><table>
<thead>
<tr>
<th>浏览器/RunTime</th>
<th>内核（渲染引擎）</th>
<th>JavaScript 引擎</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>webkit-&gt;blink</td>
<td>V8</td>
</tr>
<tr>
<td>FireFox</td>
<td>Gecko</td>
<td>SpiderMonkey</td>
</tr>
<tr>
<td>Safari</td>
<td>Webkit</td>
<td>JavaScriptCore</td>
</tr>
<tr>
<td>Edge</td>
<td>EdgeHTML</td>
<td>Chakra(for JavaScript)</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
<td>JScript（IE3.0-IE8.0）</td>
</tr>
<tr>
<td>Opera</td>
<td>Presto-&gt;blink</td>
<td>Linear A（4.0-6.1）/ Linear B（7.0-9.2）/ Futhark（9.5-10.2）/ Carakan（10.5-）</td>
</tr>
<tr>
<td>Node.js</td>
<td>-</td>
<td>V8</td>
</tr>
</tbody></table>
<p>浏览器的内核引擎，基本上是四分天下：</p>
<ul>
<li>Trident: IE 以Trident 作为内核引擎；</li>
<li>Gecko: Firefox 是基于 Gecko 开发；</li>
<li>WebKit: Safari, Google Chrome,傲游3,猎豹浏览器,百度浏览器 opera浏览器；</li>
<li>Presto: Opera的内核，但由于市场选择问题，主要应用在手机平台–Opera mini。</li>
</ul>
<h2 id="浏览器的主要组成部分是什么？"><a href="#浏览器的主要组成部分是什么？" class="headerlink" title="*浏览器的主要组成部分是什么？"></a>*浏览器的主要组成部分是什么？</h2><ol>
<li><strong>「用户界面」</strong> - 包括地址栏、前进/后退按钮、书签菜单等。</li>
<li><strong>「浏览器引擎」</strong> - 在用户界面和呈现引擎之间传送指令。</li>
<li><strong>「呈现引擎」</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li>
<li><strong>「网络」</strong> - 用于网络调用，比如 HTTP 请求。</li>
<li><strong>「用户界面后端」</strong> -用于绘制基本的窗口小部件，比如组合框和窗口。</li>
<li><strong>「JavaScript 解释器」</strong>- 用于解析和执行 JavaScript 代码。</li>
<li><strong>「数据存储」</strong> - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li>
</ol>
<p>注意，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p>
<h2 id="移动端的点击事件延迟是多久，为什么会有？-怎么解决？"><a href="#移动端的点击事件延迟是多久，为什么会有？-怎么解决？" class="headerlink" title="*移动端的点击事件延迟是多久，为什么会有？ 怎么解决？"></a>*移动端的点击事件延迟是多久，为什么会有？ 怎么解决？</h2><p>移动端点击有 300ms 的延迟是因为<strong>移动端会有双击缩放</strong>的这个操作，因此浏览器在 click 之后要等待 300ms，看用户有没有下一次点击，来判断这次操作是不是双击。</p>
<p>有三种办法来解决这个问题：</p>
<ul>
<li><p>通过 meta 标签禁用网页的缩放。<code>&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;</code></p>
</li>
<li><p>通过 meta 标签更改默认的视口宽度。<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; </code>浏览器在包含 width=device-width 也就是视口宽度=设备宽度或者设置为比 viewport 值更小的页面上<strong>禁用双击缩放行为</strong>。</p>
</li>
<li><p><strong>touch-action</strong>：CSS 的 touch-action 属性用于设置触摸屏用户如何操纵元素的区域，它允许移除特定元素或整个文档的触发延迟，而无需禁用缩放。</p>
</li>
<li><p>调用一些 js 库，比如 FastClick</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    FastClick.attach(<span class="built_in">document</span>.body);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，我们发现当这个元素隐藏后，触发了这个元素下的一个元素的点击事件，这就是点击穿透。</p>
<h2 id="检测浏览器版本有哪些方式？"><a href="#检测浏览器版本有哪些方式？" class="headerlink" title="*检测浏览器版本有哪些方式？"></a>*检测浏览器版本有哪些方式？</h2><ul>
<li><p>检测 window.navigator.userAgent 的值，但这种方式很不可靠，因为 userAgent 可以被改写，并且早期的浏览器如 ie，会通过伪装自己的 userAgent 的值为 Mozilla 来躲过服务器的检测。</p>
</li>
<li><p>功能检测，根据每个浏览器独有的特性来进行判断，如 ie 下独有的 ActiveXObject。</p>
</li>
</ul>
<h2 id="如何判断当前脚本运行环境？"><a href="#如何判断当前脚本运行环境？" class="headerlink" title="*如何判断当前脚本运行环境？"></a>*如何判断当前脚本运行环境？</h2><p><code>typeof window === &#39;undefined&#39; ? &#39;node&#39; : &#39;browser&#39;;</code></p>
<p>如果是 undefined，则当前脚本运行在 node 环境，否则运行在 window 环境。</p>
<h2 id="什么是-Polyfill-？"><a href="#什么是-Polyfill-？" class="headerlink" title="*什么是 Polyfill ？"></a>*什么是 Polyfill ？</h2><p>Polyfill 指的是用于实现浏览器并不支持的原生 API 的代码。</p>
<p>比如说 querySelectorAll 是很多现代浏览器都支持的原生 Web API，但是有些古老的浏览器并不支持，那么假设有人写了一段代码来实现这个功能使这些浏览器也支持了这个功能，那么这就可以成为一个 Polyfill。</p>
<h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><h2 id="如何检测浏览器所支持的最小字体大小？"><a href="#如何检测浏览器所支持的最小字体大小？" class="headerlink" title="如何检测浏览器所支持的最小字体大小？"></a>如何检测浏览器所支持的最小字体大小？</h2><p>用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。</p>
<h2 id="插入几万个-DOM，如何实现页面不卡顿？"><a href="#插入几万个-DOM，如何实现页面不卡顿？" class="headerlink" title="插入几万个 DOM，如何实现页面不卡顿？"></a>插入几万个 DOM，如何实现页面不卡顿？</h2><p>分批次部分渲染 DOM：</p>
<p>1、通过 <code>requestAnimationFrame</code> 的方式去循环的插入 DOM。</p>
<p>2、<strong>虚拟滚动</strong>（virtualized scroller）。原理是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。</p>
<h2 id="实现一个-页面操作不会整页刷新-的网站，并且能在浏览器前进、后退时正确响应。"><a href="#实现一个-页面操作不会整页刷新-的网站，并且能在浏览器前进、后退时正确响应。" class="headerlink" title="实现一个 页面操作不会整页刷新 的网站，并且能在浏览器前进、后退时正确响应。"></a>实现一个 页面操作不会整页刷新 的网站，并且能在浏览器前进、后退时正确响应。</h2><p>通过使用 pushState + ajax 实现浏览器无刷新前进后退，当一次 ajax 调用成功后我们将一条 state 记录加入到 history对象中。一条 state 记录包含了 url、title 和 content 属性，在 popstate 事件中可以获取到这个 state 对象，使用 content 来传递数据。最后通过对 window.onpopstate 事件监听来响应浏览器的前进后退操作。</p>
<p>使用 pushState 来实现有两个问题：</p>
<ul>
<li>一个是打开首页时没有记录，可以使用 replaceState 来将首页的记录替换。</li>
<li>另一个问题是当一个页面刷新的时候，仍然会向服务器端请求数据，因此如果请求的 url 需要后端的配合将其重定向到一个页面。</li>
</ul>
<h2 id="两个HTML页面之前如何传递参数？"><a href="#两个HTML页面之前如何传递参数？" class="headerlink" title="两个HTML页面之前如何传递参数？"></a>两个HTML页面之前如何传递参数？</h2><p>（比如一个表单分两页，在第二页提交表单时如何获取到第一页的数据）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_ds/article/details/78393564">https://blog.csdn.net/csdn_ds/article/details/78393564</a></p>
<h2 id="不同-tab-之间通信？"><a href="#不同-tab-之间通信？" class="headerlink" title="不同 tab 之间通信？"></a>不同 tab 之间通信？</h2><p>[面试官：前端跨页面通信，你知道哪些方法？](</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/">https://asura1211.github.io/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/"><img class="prev-cover" src="https://i.loli.net/2021/11/26/IjNHoiM76eEFcsB.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【面试准备】— — JavaScript篇</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/29/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20HTML+CSS%E7%AF%87/"><img class="next-cover" src="https://i.loli.net/2021/11/26/CpWEmB1qg8FKO3a.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【面试准备】— — CSS篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Asura1211"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E7%95%8C%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">从输入URL到界面展示发生了什么（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E9%98%B6%E6%AE%B5%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">哪些阶段可以优化提升效率？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%98%AFGPU%E3%80%81%E5%93%AA%E4%BA%9BCPU%E5%81%9A%E7%9A%84%EF%BC%88todo%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">*过程中哪些是GPU、哪些CPU做的（todo）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8"><span class="toc-number">3.</span> <span class="toc-text">存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie%EF%BC%8ClocalStorage%EF%BC%8CsessionStorage%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">cookie，localStorage，sessionStorage区别？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#localStorage-%E5%92%8C-sessionStorage-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">localStorage 和 sessionStorage 区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie-%E5%92%8C-webstorage-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">cookie 和 webstorage 区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Cookie-%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">什么是 Cookie ？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Cookie-%E9%9A%94%E7%A6%BB%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">*什么是 Cookie 隔离？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Session%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">什么是 Session？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-%E5%92%8C-Session-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">Cookie 和 Session 有什么区别？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-session-%E5%8C%BA%E5%88%AB%E7%94%A8%E6%88%B7%EF%BC%88todo%EF%BC%89"><span class="toc-number">3.3.3.</span> <span class="toc-text">*怎么用 session 区别用户（todo）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">浏览器缓存机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">缓存策略（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%EF%BC%88cache-control-%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">强缓存（cache-control 高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">4.1.2.</span> <span class="toc-text">协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">4.1.3.</span> <span class="toc-text">实际场景缓存策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.2.</span> <span class="toc-text">*缓存位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">移动端缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Service-Worker%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">*什么是 Service Worker？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">浏览器渲染原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">渲染过程（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E9%98%BB%E5%A1%9E%E6%B8%B2%E6%9F%93%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">什么情况阻塞渲染？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96"><span class="toc-number">5.3.</span> <span class="toc-text">页面渲染优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-JS-%E6%93%8D%E4%BD%9C-DOM-%E6%85%A2%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">为什么 JS 操作 DOM 慢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E7%BB%98%EF%BC%88Repaint%EF%BC%89%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%88%E9%87%8D%E6%8E%92%EF%BC%89%EF%BC%88Reflow%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">重绘（Repaint）和回流（重排）（Reflow）（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%EF%BC%9F"><span class="toc-number">5.5.1.</span> <span class="toc-text">减少重绘和回流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%AA-DOM-%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">5.5.2.</span> <span class="toc-text">*如何获取某个 DOM 节点的位置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-clientTop-%E5%92%8C-clinetLeft-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8D%E6%8E%92%EF%BC%9F"><span class="toc-number">5.5.3.</span> <span class="toc-text">用 clientTop 和 clinetLeft 为什么会导致浏览器重排？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">跨域（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E6%94%BF%E7%AD%96"><span class="toc-number">6.1.</span> <span class="toc-text">浏览器的同源政策</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5%E8%BF%99%E7%A7%8D%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">6.1.1.</span> <span class="toc-text">为什么引入这种机制？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">如何解决跨域？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JSONP"><span class="toc-number">6.2.1.</span> <span class="toc-text">一、JSONP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81document-domain-iframe"><span class="toc-number">6.2.2.</span> <span class="toc-text">二、document.domain + iframe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81postMessage"><span class="toc-number">6.2.3.</span> <span class="toc-text">三、postMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%EF%BC%88CORS%EF%BC%89"><span class="toc-number">6.2.4.</span> <span class="toc-text">四、跨域资源共享（CORS）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS-%E7%9A%84-response-%E5%A4%B4%E9%83%A8%E5%AD%97%E6%AE%B5%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.2.4.1.</span> <span class="toc-text">CORS 的 response 头部字段是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%83%BD%E6%90%BA%E5%B8%A6-Cookie-%E5%90%97%EF%BC%9F"><span class="toc-number">6.2.4.2.</span> <span class="toc-text">跨域能携带 Cookie 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82%E5%92%8C%E9%9D%9E%E7%AE%80%E5%8D%95%EF%BC%88%E5%A4%8D%E6%9D%82%EF%BC%89%E8%AF%B7%E6%B1%82"><span class="toc-number">6.2.4.3.</span> <span class="toc-text">简单请求和非简单（复杂）请求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81nginx-%E4%BB%A3%E7%90%86"><span class="toc-number">6.2.5.</span> <span class="toc-text">五、nginx 代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">6.2.5.1.</span> <span class="toc-text">正向代理和反向代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">6.2.5.2.</span> <span class="toc-text">负载平衡的两种实现方式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81WebSocket-%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.2.6.</span> <span class="toc-text">六、WebSocket 协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E8%B7%A8%E5%9F%9F"><span class="toc-number">6.3.</span> <span class="toc-text">项目中遇到的跨域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8"><span class="toc-number">7.</span> <span class="toc-text">浏览器安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">什么是 XSS 攻击？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-XSS-%E6%94%BB%E5%87%BB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">如何防范 XSS 攻击？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSP-%EF%BC%9F"><span class="toc-number">7.2.1.</span> <span class="toc-text">什么是 CSP ？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">什么是 CSRF 攻击？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83-CSRF-%E6%94%BB%E5%87%BB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">如何防范 CSRF 攻击？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">什么是中间人攻击？如何防范？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">SQL 注入攻击？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">点击劫持？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">事件机制（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E4%B8%89%E9%98%B6%E6%AE%B5"><span class="toc-number">8.1.</span> <span class="toc-text">事件触发三阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">8.2.</span> <span class="toc-text">注册事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">三种事件模型？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IE-%E4%B8%8E%E7%81%AB%E7%8B%90%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.1.</span> <span class="toc-text">IE 与火狐事件机制的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">8.4.</span> <span class="toc-text">事件代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">9.</span> <span class="toc-text">*其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">9.1.</span> <span class="toc-text">*常见的浏览器内核有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">*浏览器的主要组成部分是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%BB%B6%E8%BF%9F%E6%98%AF%E5%A4%9A%E4%B9%85%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%EF%BC%9F-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">*移动端的点击事件延迟是多久，为什么会有？ 怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%89%88%E6%9C%AC%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">*检测浏览器版本有哪些方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E8%84%9A%E6%9C%AC%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">*如何判断当前脚本运行环境？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Polyfill-%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">*什么是 Polyfill ？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">10.</span> <span class="toc-text">场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%80%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">如何检测浏览器所支持的最小字体大小？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%87%A0%E4%B8%87%E4%B8%AA-DOM%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E4%B8%8D%E5%8D%A1%E9%A1%BF%EF%BC%9F"><span class="toc-number">10.2.</span> <span class="toc-text">插入几万个 DOM，如何实现页面不卡顿？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-%E9%A1%B5%E9%9D%A2%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E6%95%B4%E9%A1%B5%E5%88%B7%E6%96%B0-%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%89%8D%E8%BF%9B%E3%80%81%E5%90%8E%E9%80%80%E6%97%B6%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E3%80%82"><span class="toc-number">10.3.</span> <span class="toc-text">实现一个 页面操作不会整页刷新 的网站，并且能在浏览器前进、后退时正确响应。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAHTML%E9%A1%B5%E9%9D%A2%E4%B9%8B%E5%89%8D%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">10.4.</span> <span class="toc-text">两个HTML页面之前如何传递参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C-tab-%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">10.5.</span> <span class="toc-text">不同 tab 之间通信？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家社区商城"/></a><div class="content"><a class="title" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城">【项目复盘】— — 贤得家社区商城</a><time datetime="2021-10-31T15:01:17.000Z" title="发表于 2021-10-31 23:01:17">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/11/26/c8CoiAjKTyGNS4a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" title="【学习笔记】— — 字节青训营"><img src="https://i.loli.net/2021/11/20/6kUmfsBR2yEIqnD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【学习笔记】— — 字节青训营"/></a><div class="content"><a class="title" href="/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" title="【学习笔记】— — 字节青训营">【学习笔记】— — 字节青训营</a><time datetime="2021-08-14T15:04:54.000Z" title="发表于 2021-08-14 23:04:54">2021-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/16/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E5%A0%82%E6%A8%A1%E5%9D%97/" title="【项目复盘】— — 贤得家e社区学堂管理系统"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家e社区学堂管理系统"/></a><div class="content"><a class="title" href="/2021/07/16/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E5%A0%82%E6%A8%A1%E5%9D%97/" title="【项目复盘】— — 贤得家e社区学堂管理系统">【项目复盘】— — 贤得家e社区学堂管理系统</a><time datetime="2021-07-16T19:55:25.000Z" title="发表于 2021-07-17 03:55:25">2021-07-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>