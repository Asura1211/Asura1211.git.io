<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【面试准备】— — JavaScript篇 | 青山の博客</title><meta name="keywords" content="JavaScript"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是我在复习JavaScript，准备实习面试时整理的笔记，主要参考自周游学长的博客：JavaScript 面试知识点总结，其他涉及到的优质博客也已附上链接，侵权删。 JavaScript 基础知识js 中的命名规则（1）第一个字符必须是字母、下划线（_）或美元符号（$）（2）余下的字符可以是下划线、美元符号或任何字母或数字字符 一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 EC">
<meta property="og:type" content="article">
<meta property="og:title" content="【面试准备】— — JavaScript篇">
<meta property="og:url" content="https://asura1211.github.io/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是我在复习JavaScript，准备实习面试时整理的笔记，主要参考自周游学长的博客：JavaScript 面试知识点总结，其他涉及到的优质博客也已附上链接，侵权删。 JavaScript 基础知识js 中的命名规则（1）第一个字符必须是字母、下划线（_）或美元符号（$）（2）余下的字符可以是下划线、美元符号或任何字母或数字字符 一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 EC">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg">
<meta property="article:published_time" content="2021-07-03T19:26:44.000Z">
<meta property="article:modified_time" content="2021-10-14T06:24:33.869Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【面试准备】— — JavaScript篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-14 14:24:33'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【面试准备】— — JavaScript篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-03T19:26:44.000Z" title="发表于 2021-07-04 03:26:44">2021-07-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-14T06:24:33.869Z" title="更新于 2021-10-14 14:24:33">2021-10-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>111分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【面试准备】— — JavaScript篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习JavaScript，准备实习面试时整理的笔记，主要参考自周游学长的博客：<a target="_blank" rel="noopener" href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/JavaScript/JavaScript.md">JavaScript 面试知识点总结</a>，其他涉及到的优质博客也已附上链接，侵权删。</p>
<h1 id="JavaScript-基础知识"><a href="#JavaScript-基础知识" class="headerlink" title="JavaScript 基础知识"></a>JavaScript 基础知识</h1><h2 id="js-中的命名规则"><a href="#js-中的命名规则" class="headerlink" title="js 中的命名规则"></a>js 中的命名规则</h2><p>（1）第一个字符必须是字母、下划线（_）或美元符号（$）<br>（2）余下的字符可以是下划线、美元符号或任何字母或数字字符</p>
<p>一般我们推荐使用驼峰法来对变量名进行命名，因为这样可以与 ECMAScript 内置的函数和对象命名格式保持一致。</p>
<h2 id="js-的基本数据类型？"><a href="#js-的基本数据类型？" class="headerlink" title="js 的基本数据类型？"></a>js 的基本数据类型？</h2><p>js 一共有六种基本数据类型，分别是 Undefined、Null、Boolean、Number、String，还有在 ES6 中新增的 Symbol 和 ES10 中新增的 BigInt 类型。<br>Symbol 代表创建后独一无二且不可变的数据类型，主要是为了解决可能出现的全局变量冲突的问题。<br>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</p>
<h2 id="JavaScript-有几种类型的值？"><a href="#JavaScript-有几种类型的值？" class="headerlink" title="JavaScript 有几种类型的值？"></a>JavaScript 有几种类型的值？</h2><ul>
<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型的区别是：存储位置不同。</p>
<ul>
<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据。</li>
<li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在<strong>栈中存储了指针</strong>，指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，然后从堆中获得实体。</li>
</ul>
<p><img src="https://i.loli.net/2021/07/04/ypQAzYnGjm2FeuK.jpg" alt="Snipaste_2021-07-04_19-37-40.jpg"></p>
<h2 id="内部属性-Class-是什么？"><a href="#内部属性-Class-是什么？" class="headerlink" title="内部属性 [[Class]] 是什么？"></a>内部属性 [[Class]] 是什么？</h2><p>所有 typeof 返回值为 “object” 的对象（如数组）都包含一个内部属性 [[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过 <code>Object.prototype.toString(..)</code> 来查看。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call( [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] );</span><br><span class="line"><span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call( <span class="regexp">/regex-literal/i</span> );</span><br><span class="line"><span class="comment">// &quot;[object RegExp]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们自己创建的类就不会有这份特殊待遇，因为 toString() 找不到 toStringTag 属性时只好返回默认的 Object 标签</span></span><br><span class="line"><span class="comment">// 默认情况类的[[Class]]返回[object Object]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class1</span> </span>&#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> Class1()); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="comment">// 需要定制[[Class]]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">  get [<span class="built_in">Symbol</span>.toStringTag]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Class2&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> Class2()); <span class="comment">// &quot;[object Class2]&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="js-有哪些内置对象？"><a href="#js-有哪些内置对象？" class="headerlink" title="js 有哪些内置对象？"></a>js 有哪些内置对象？</h2><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的<strong>全局的对象是说在全局作用域里的对象</strong>。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p>
<p>标准内置对象的分类</p>
<p>（1）<strong>值属性</strong>，这些全局属性返回一个简单值，这些值没有自己的属性和方法。例如 Infinity、NaN、undefined、null 字面量</p>
<p>（2）<strong>函数属性</strong>，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。例如 eval()、parseFloat()、parseInt() 等</p>
<p>（3）<strong>基本对象</strong>，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。例如 Object、Function、Boolean、Symbol、Error 等</p>
<p>（4）<strong>数字和日期对象</strong>，用来表示数字、日期和执行数学计算的对象。例如 Number、Math、Date</p>
<p>（5）<strong>字符串</strong>，用来表示和操作字符串的对象。例如 String、RegExp</p>
<p>（6）<strong>可索引的集合对象</strong>，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p>
<p>（7）<strong>使用键的集合对象</strong>，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。例如 Map、Set、WeakMap、WeakSet</p>
<p>（8）<strong>矢量集合</strong>，SIMD 矢量集合中的数据会被组织为一个数据序列。例如 SIMD 等</p>
<p>（9）<strong>结构化数据</strong>，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。例如 JSON 等</p>
<p>（10）<strong>控制抽象对象</strong>。例如 Promise、Generator 等</p>
<p>（11）<strong>反射</strong>。例如 Reflect、Proxy</p>
<p>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。例如 Intl、Intl.Collator 等</p>
<p>（13）WebAssembly</p>
<p>（14）其他例如 arguments</p>
<h2 id="undefined-与-undeclared-的区别？"><a href="#undefined-与-undeclared-的区别？" class="headerlink" title="undefined 与 undeclared 的区别？"></a>undefined 与 undeclared 的区别？</h2><p>已在作用域中声明但还没有赋值的变量，是 undefined 的。相反，还没有在作用域中声明过的变量，是 undeclared 的。</p>
<p>对于 undeclared 变量的引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。但是我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p>
<h2 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h2><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p>
<p>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。</p>
<p>undefined 在 js 中不是一个保留字，这意味着我们可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。但是我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p>
<p>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。当我们使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<h2 id="for-of-和-for-in-的区别？"><a href="#for-of-和-for-in-的区别？" class="headerlink" title="for of 和 for in 的区别？"></a>for of 和 for in 的区别？</h2><ul>
<li>for in ：遍历方法，可遍历对象和数组</li>
<li>for of ：遍历方法，只能遍历数组，不能遍历非iterable对象</li>
</ul>
<h2 id="typeof-和-instanceof-的区别？"><a href="#typeof-和-instanceof-的区别？" class="headerlink" title="typeof 和 instanceof 的区别？"></a>typeof 和 instanceof 的区别？</h2><p><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型，对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> <strong>并不能准确判断变量到底是什么类型</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果我们想判断一个对象的正确类型，就可以考虑使用 <code>instanceof</code>，因为内部机制是通过原型链来判断的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="let，const，var-区别？（高频）"><a href="#let，const，var-区别？（高频）" class="headerlink" title="let，const，var 区别？（高频）"></a>let，const，var 区别？（高频）</h2><ul>
<li>var 声明变量可以重复声明，而 let、const 不可以重复声明。</li>
<li>var 不受限于块级作用域的，而 let、const 受限。</li>
<li>var 会与 window 相映射（会挂一个属性），而 let、const 不与 window 相映射。</li>
<li>var 可以在声明的上面访问变量（变量提升），而 let、const 有暂时性死区，在声明的上面访问变量会报错。</li>
<li>const 声明之后必须赋值，否则会报错。</li>
<li>const 定义不可变的量，改变了就会报错。</li>
</ul>
<h2 id="document-ready-和-onload-的区别？"><a href="#document-ready-和-onload-的区别？" class="headerlink" title="document.ready 和 onload 的区别？"></a>document.ready 和 onload 的区别？</h2><p>页面加载完成有两种事件，一是 ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是 onload，指示页面包含图片等文件在内的所有元素都加载完成。</p>
<p>ready 事件在 DOM 结构绘制完成之后就会执行，这样能确保就算有大量的媒体文件没加载出来，JS 代码一样可以执行。</p>
<p>load 事件必须等到网页中所有内容全部加载完毕之后才被执行。如果一个网页中有大量的图片的话，则就会出现这种情况：网页文档已经呈现出来，但由于网页数据还没有完全加载完毕，导致 load 事件不能够即时被触发。</p>
<h2 id="如何获取安全的-undefined-值？"><a href="#如何获取安全的-undefined-值？" class="headerlink" title="如何获取安全的 undefined 值？"></a>如何获取安全的 undefined 值？</h2><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。</p>
<p>表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。</p>
<p>按惯例我们用 void 0 来获得 undefined。</p>
<h2 id="说几条写-JavaScript-的基本规范？"><a href="#说几条写-JavaScript-的基本规范？" class="headerlink" title="说几条写 JavaScript 的基本规范？"></a>说几条写 JavaScript 的基本规范？</h2><p>（1）一个函数作用域中所有的变量声明应该尽量提到函数首部，用一个 var 声明，<strong>不允许出现两个连续的 var 声明</strong>。声明时，如果变量没有值，应该给该变量赋值对应类型的<strong>初始值</strong>，便于他人阅读代码时，能够一目了然的知道变量对应的类型值。</p>
<p>（2）代码中出现地址、时间等字符串时需要使用<strong>常量代替</strong>。</p>
<p>（3）在进行比较的时候吧，尽量使用**’===’, ‘!==’代替’==’, ‘!=’**。</p>
<p>（4）<strong>不要在内置对象的原型上添加方法</strong>，如 Array, Date。</p>
<p>（5）switch 语句必须带有 <strong>default 分支</strong>。</p>
<p>（6）for 循环必须使用<strong>大括号</strong>。</p>
<p>（7）if 语句必须使用<strong>大括号</strong>。</p>
<h2 id="JavaScript-原型，原型链？（高频）"><a href="#JavaScript-原型，原型链？（高频）" class="headerlink" title="JavaScript 原型，原型链？（高频）"></a>JavaScript 原型，原型链？（高频）</h2><p>可以经常回顾 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903749345886216">深入JavaScript系列（六）：原型与原型链</a>。</p>
<p>在 js 中我们是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性值，它是一个对象，包含了可以由该构造函数的所有实例共享的属性和方法。<strong>原型:</strong> 对象中固有的__proto__属性，该属性指向对象的 prototype 原型属性。</p>
<p><strong>获取对象的原型有三种方法：</strong></p>
<ul>
<li><code>p.__proto__</code></li>
<li><code>p.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(p)</code></li>
</ul>
<p><strong>原型链</strong>：当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，这就是原型链的概念。原型链的尽头一般来说都是 Object.prototype，所以这也是我们新建的对象为什么能够使用 toString() 等方法的原因。</p>
<p><strong>特点：</strong>JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<p><img src="https://i.loli.net/2021/09/10/vgMdz1XLq3HCEuD.png" alt="image.png"></p>
<h2 id="JavaScript-中的作用域与变量声明提升？"><a href="#JavaScript-中的作用域与变量声明提升？" class="headerlink" title="JavaScript 中的作用域与变量声明提升？"></a>JavaScript 中的作用域与变量声明提升？</h2><p><strong>作用域</strong>：可访问变量，对象，函数的集合。</p>
<p><strong>变量提升：</strong>无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，因此可以在变量声明前访问到而不会报错。</p>
<p>变量声明提升的<strong>本质原因</strong>： js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当我们访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象是在代码解析的时候创建的。这就是会出现变量声明提升的根本原因。</p>
<h2 id="JavaScript-的作用域链？"><a href="#JavaScript-的作用域链？" class="headerlink" title="JavaScript 的作用域链？"></a>JavaScript 的作用域链？</h2><p>作用域链的<strong>作用</strong>：保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，我们可以访问到外层环境的变量和函数。</p>
<p>作用域链的<strong>本质</strong>：一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象，作用域链的顶端始终是当前执行上下文的变量对象，底端始终是全局执行上下文的变量对象（也就是全局对象）。</p>
<p>当我们查找一个变量时，如果当前执行环境中没有找到，我们可以沿着作用域链向下查找。</p>
<h2 id="谈谈-This-对象的理解"><a href="#谈谈-This-对象的理解" class="headerlink" title="谈谈 This 对象的理解"></a>谈谈 This 对象的理解</h2><p>this 对象是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li><strong>函数</strong>调用模式。当一个函数不是一个对象的属性，直接作为函数来调用时，this 指向全局对象。</li>
<li><strong>方法</strong>调用模式。如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li><strong>构造器</strong>调用模式。如果一个函数用 new 调用，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li><strong>apply 、 call 和 bind</strong> 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply 、 call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h3 id="箭头函数的-this"><a href="#箭头函数的-this" class="headerlink" title="箭头函数的 this"></a>箭头函数的 this</h3><p>箭头函数其实是没有 this 的，它会捕获自己在<strong>定义时</strong>（注意，是定义时，不是调用时）所处的<strong>外层执行环境的this</strong>，并继承这个 this 值。所以，箭头函数中 this 的指向在它被定义的时候就已经确定了，永远不会改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;Global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// setTimeout中使用普通函数</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// setTimeout中使用箭头函数</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun1.call(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Global&#x27;</span></span><br><span class="line"></span><br><span class="line">fun2.call(&#123;<span class="attr">id</span>: <span class="string">&#x27;Obj&#x27;</span>&#125;);     <span class="comment">// &#x27;Obj&#x27;</span></span><br></pre></td></tr></table></figure>

<p>箭头函数的 this 在定义时就确定了，它继承了它外层 fun2 的执行环境中的 this ，而 fun2 调用时 this 被 call 方法改变到了对象 {id: ‘Obj’} 中，所以输出 ‘Obj’ 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="string">&#x27;GLOBAL&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;OBJ&#x27;</span>,</span><br><span class="line">  <span class="attr">a</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">b</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.a();    <span class="comment">// &#x27;OBJ&#x27;</span></span><br><span class="line">obj.b();    <span class="comment">// &#x27;GLOBAL&#x27;</span></span><br></pre></td></tr></table></figure>

<p>箭头函数中的 this 实际是继承的它定义时所处的全局执行环境中的 this ，所以指向 Window 对象，输出 ‘GLOBAL’ 。</p>
<h2 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h2><p>具体见 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903805960585224">https://juejin.cn/post/6844903805960585224</a></p>
<p>1、语法更加简洁、清晰</p>
<p>2、箭头函数不会创建自己的this</p>
<p>3、箭头函数继承而来的this指向永远不变</p>
<p>4、.call()/.apply()/.bind()无法改变箭头函数中this的指向</p>
<p>5、箭头函数不能作为构造函数使用</p>
<p>6、箭头函数没有自己的 arguments。在箭头函数中访问 arguments实际上获得的是外层局部（函数）执行环境中的值。因此<strong>可以在箭头函数中使用rest参数代替arguments对象，来访问箭头函数的参数列表。</strong></p>
<p>7、箭头函数没有原型prototype</p>
<p>8、箭头函数不能用作Generator函数，不能使用yeild关键字</p>
<h2 id="new-的过程？"><a href="#new-的过程？" class="headerlink" title="new 的过程？"></a>new 的过程？</h2><ol>
<li>首先创建了一个新的空对象。</li>
<li>设置原型，将对象的原型（[[Prototype]]）设置为构造函数的 prototype 对象。</li>
<li>让函数的 this 指向新对象，执行构造函数的代码（为这个新对象添加属性）。</li>
<li>判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</li>
</ol>
<h2 id="call-、apply-和-bind-的区别？"><a href="#call-、apply-和-bind-的区别？" class="headerlink" title="call() 、apply() 和 bind() 的区别？"></a>call() 、apply() 和 bind() 的区别？</h2><p>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个集合，可以为数组，也可以为类数组。apply 方法把这个集合中的元素作为参数传递给被调用的函数。</p>
<p>call 传入的参数数量不固定，第一个参数代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</p>
<p>bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。<strong>这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</strong>不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定。</p>
<h2 id="js-中整数的安全范围是多少？"><a href="#js-中整数的安全范围是多少？" class="headerlink" title="js 中整数的安全范围是多少？"></a>js 中整数的安全范围是多少？</h2><p>安全整数指的是，在这个范围内的整数转化为二进制存储的时候不会出现精度丢失，能够被“安全”呈现的最大整数是 2^53 - 1。在 ES6 中被定义为 Number.MAX_SAFE_INTEGER。最小整数在 ES6 中被定义为Number.MIN_SAFE_INTEGER。</p>
<p>如果某次计算的结果得到了一个超过 JavaScript 数值范围的值，那么这个值会被自动转换为特殊的 Infinity 值。如果某次计算返回了正或负的 Infinity 值，那么该值将无法参与下一次的计算。判断一个数是不是有穷的，可以使用 isFinite 函数来判断。</p>
<h2 id="ES6-中有使用过什么？"><a href="#ES6-中有使用过什么？" class="headerlink" title="ES6 中有使用过什么？"></a>ES6 中有使用过什么？</h2><p>这边可说的实在太多，可以列举 1 - 2 个点。比如说说 <code>class</code>，那么 <code>class</code> 又可以拉回到原型的问题；可以说说 <code>promise</code>，那么线就被拉到了异步的内容；可以说说 <code>proxy</code>，那么如果使用过 Vue 这个框架，就可以谈谈响应式原理的内容；同样也可以说说 <code>let</code> 这些声明变量的语法，那么就可以谈及与 <code>var</code> 的不同，说到提升这块的内容。</p>
<h2 id="typeof-NaN-的结果是什么？"><a href="#typeof-NaN-的结果是什么？" class="headerlink" title="typeof NaN 的结果是什么？"></a>typeof NaN 的结果是什么？</h2><p>NaN 意指“不是一个数字”，是一个“警戒值”，用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<p><code>typeof NaN; // &quot;number&quot;</code>  NaN 是一个特殊值，它和自身不相等，是<strong>唯一一个非自反</strong>的值。</p>
<h2 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h2><p>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此<strong>非数字值传入也会返回 true</strong> ，会影响 NaN 的判断。</p>
<p>函数 Number.isNaN 会<strong>首先判断传入参数是否为数字</strong>，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</p>
<h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><h3 id="To-字符串"><a href="#To-字符串" class="headerlink" title="To 字符串"></a>To 字符串</h3><p>抽象操作 ToString 负责处理非字符串到字符串的强制类型转换。</p>
<p>（1）Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</p>
<p>（2）Boolean 类型，true 转换为 “true”，false 转换为 “false”。</p>
<p>（3）Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</p>
<p>（4）Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</p>
<p>（5）对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</p>
<h3 id="To-数字值"><a href="#To-数字值" class="headerlink" title="To 数字值"></a>To 数字值</h3><p>抽象操作 ToNumber：</p>
<p>（1）Undefined 类型的值转换为 NaN。</p>
<p>（2）Null 类型的值转换为 0。</p>
<p>（3）Boolean 类型的值，true 转换为 1，false 转换为 0。</p>
<p>（4）String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</p>
<p>（5）Symbol 类型的值<strong>不能转换</strong>为数字，会报错。</p>
<p>（6）对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</p>
<p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先检查该值是否有<code>valueOf()</code>方法，如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用<code>toString() </code>的返回值来进行强制类型转换。如果 <code>valueOf()</code> 和<code>toString()</code>均不返回基本类型值，会产生 TypeError 错误。</p>
<h3 id="To-布尔值"><a href="#To-布尔值" class="headerlink" title="To 布尔值"></a>To 布尔值</h3><p>抽象操作 ToBoolean，以下这些是假值：</p>
<ul>
<li> undefined</li>
<li> null</li>
<li> false</li>
<li> +0、-0 和 NaN</li>
<li> “”</li>
</ul>
<p>假值的布尔强制类型转换结果为 false，假值列表以外的都是真值。</p>
<h3 id="对象转原始类型（拆箱转换）"><a href="#对象转原始类型（拆箱转换）" class="headerlink" title="对象转原始类型（拆箱转换）"></a>对象转原始类型（拆箱转换）</h3><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑如下：</p>
<ul>
<li>如果已经是原始类型，不需要转换</li>
<li>如果转字符串类型就调用 <code>x.toString()</code>，转换为基础类型的话就返回转换的值。不是字符串的话就先调用 <code>valueOf</code>，结果不是 基础类型 再调用 <code>toString</code>。</li>
<li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li>
<li>如果都没有返回原始类型，就会报错</li>
</ul>
<h3 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h3><p>加法运算符不同于其他几个运算符，它有以下几个特点：</p>
<ul>
<li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li>
<li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;11&#x27;</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// &quot;41,2,3&quot; 将数组通过 toString 转为字符串 1,2,3</span></span><br></pre></td></tr></table></figure>

<p>另外对于加法还需要注意：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> + + <span class="string">&#x27;b&#x27;</span> <span class="comment">// -&gt; &quot;aNaN&quot;，因为 + &#x27;b&#x27; 等于 NaN，所以结果为 &quot;aNaN&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ol>
<li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li>
<li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li>
</ol>
<h2 id="和-的-valueOf-和-toString-的结果是什么？"><a href="#和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="{} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>{} 和 [] 的 valueOf 和 toString 的结果是什么？</h2><p>valueOf : 返回对象的<strong>原始值</strong>表示。</p>
<p>toString : 返回对象的<strong>字符串</strong>表示。</p>
<p>{} 的 valueOf 结果为 {} ，toString 的结果为 “[object Object]”</p>
<p>[] 的 valueOf 结果为 [] ，toString 的结果为 “”</p>
<h2 id="操作符的作用？"><a href="#操作符的作用？" class="headerlink" title="~ 操作符的作用？"></a>~ 操作符的作用？</h2><p>反转被操作数的位：~ 返回 2 的补码，并且 ~ 会将数字转换为 32 位整数，因此我们可以使用 ~ 来进行取整操作。~x 大致等同于 -(x+1)。</p>
<h2 id="eval-是做什么的？"><a href="#eval-是做什么的？" class="headerlink" title="eval 是做什么的？"></a>eval 是做什么的？</h2><p>它的功能是把对应的字符串解析成 JS 代码并运行。</p>
<p>应该避免使用 eval，不安全，非常耗性能（2次，一次解析成 js 语句，一次执行）。</p>
<h2 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h2><p>DOM 指的是<strong>文档对象模型</strong>，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p>
<p>BOM 指的是<strong>浏览器对象模型</strong>，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着<strong>在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在</strong>。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 最根本的 document 对象也是 window 的子对象。</p>
<h2 id="解析字符串中的数字和将字符串强制类型转换为数字之间的区别是什么？"><a href="#解析字符串中的数字和将字符串强制类型转换为数字之间的区别是什么？" class="headerlink" title="解析字符串中的数字和将字符串强制类型转换为数字之间的区别是什么？"></a>解析字符串中的数字和将字符串强制类型转换为数字之间的区别是什么？</h2><ul>
<li>① 允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就<strong>停止</strong>。</li>
<li>②（如 Number ()）不允许出现非数字字符，否则会<strong>失败</strong>并返回 NaN。</li>
</ul>
<h2 id="布尔值的隐式强制类型转换？"><a href="#布尔值的隐式强制类型转换？" class="headerlink" title="布尔值的隐式强制类型转换？"></a>布尔值的隐式强制类型转换？</h2><p>（1） if (..) 语句中的条件判断表达式。<br>（2） for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。<br>（3） while (..) 和 do..while(..) 循环中的条件判断表达式。<br>（4） ? : 中的条件判断表达式。<br>（5） 逻辑运算符 ||（逻辑或）和 &amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p>
<h2 id="和-amp-amp-操作符的返回值？"><a href="#和-amp-amp-操作符的返回值？" class="headerlink" title="|| 和 &amp;&amp; 操作符的返回值？"></a>|| 和 &amp;&amp; 操作符的返回值？</h2><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后再执行条件判断。</p>
<p>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</p>
<p>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</p>
<p>|| 和 &amp;&amp; 返回它们其中一个<strong>操作数的值</strong>，而非条件判断的结果。</p>
<h2 id="操作符的强制类型转换规则？"><a href="#操作符的强制类型转换规则？" class="headerlink" title="== 操作符的强制类型转换规则？"></a>== 操作符的强制类型转换规则？</h2><p>（1）字符串和数字之间的相等比较，将字符串转换为数字之后再进行比较。</p>
<p>（2）其他类型和布尔类型之间的相等比较，先将布尔值转换为数字后，再应用其他规则进行比较。</p>
<p>（3）null 和 undefined 比较，结果为真。其他值和它们进行比较都返回假值。</p>
<p>（4）对象和非对象之间的相等比较，对象先调用 ToPrimitive 抽象操作后，再进行比较。</p>
<p>（5）如果一个操作值为 NaN ，则相等比较返回 false 。</p>
<p>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true，否则，返回 false。</p>
<h2 id="Object-is-与比较操作符-“-”、“-”-的区别？"><a href="#Object-is-与比较操作符-“-”、“-”-的区别？" class="headerlink" title="Object.is() 与比较操作符 “===”、“==” 的区别？"></a>Object.is() 与比较操作符 “===”、“==” 的区别？</h2><p>两等号判等，会在比较时进行类型转换。</p>
<p>三等号判等（判断严格），比较时不进行隐式类型转换。</p>
<p>Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 。 Object.is(NaN, NaN) 返回 true，Object.is(-0，+0)返回 false 。</p>
<p>Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol>
<li><p>先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></p>
</li>
<li><p>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></p>
</li>
<li><p>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</p>
</li>
<li><p>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span> == &#123; <span class="attr">name</span>: <span class="string">&#x27;yck&#x27;</span> &#125;</span><br><span class="line">        ↓</span><br><span class="line"><span class="string">&#x27;1&#x27;</span> == <span class="string">&#x27;[object Object]&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="如何将字符串转化为数字，例如-‘12-3b’"><a href="#如何将字符串转化为数字，例如-‘12-3b’" class="headerlink" title="如何将字符串转化为数字，例如 ‘12.3b’?"></a>如何将字符串转化为数字，例如 ‘12.3b’?</h2><p>（1）使用 Number() 方法，前提是所包含的字符串不包含不合法字符。</p>
<p>（2）使用 parseInt() 方法，parseInt() 函数可解析一个字符串，并返回一个整数。还可以设置要解析的数字的基数。当基数的值为 0，或没有设置该参数时，parseInt() 会根据 string 来判断数字的基数。</p>
<p>（3）使用 parseFloat() 方法，该函数解析一个字符串参数并返回一个浮点数。</p>
<p>（4）使用 + 操作符的隐式转换，前提是所包含的字符串不包含不合法字符。</p>
<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）匹配 16 进制颜色值</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）匹配 qq 号</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）手机号码正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^1[34578]\d&#123;9&#125;$/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）用户名正则</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;</span><br></pre></td></tr></table></figure>

<h2 id="javascript-创建对象的几种方式？"><a href="#javascript-创建对象的几种方式？" class="headerlink" title="javascript 创建对象的几种方式？"></a>javascript 创建对象的几种方式？</h2><p>（1）工厂模式。主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。<strong>缺点</strong>是对象无法识别，因为所有的实例都指向一个原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">&#x27;kevin&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（2）构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么我们就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此使用 this 给对象赋值。<strong>优点</strong>是实例可以识别为一个特定的类型。<strong>缺点</strong>是每次创建实例时，每个方法都要被创建一次，对函数对象的创建会浪费不必要的内存空间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（3）原型模式。每一个函数都有一个 prototype 属性，包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。<strong>优点</strong>是方法不会重新创建。<strong>缺点</strong>是 1. 所有的属性和方法都共享。 2. 不能初始化参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;keivn&#x27;</span>;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型模式优化</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="comment">// 实例可以通过constructor属性找到所属构造函数</span></span><br><span class="line">    <span class="attr">constructor</span>: Person,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;kevin&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优点：封装性好了一点</span></span><br><span class="line"><span class="comment">// 缺点：原型模式该有的缺点还是有</span></span><br></pre></td></tr></table></figure>

<p>（4）组合使用构造函数模式和原型模式。这是创建自定义类型的最常见方式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。<strong>缺点</strong>是对于代码的封装性不够好。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: Person,</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>（5）动态原型模式。将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。<strong>优点</strong>是很好地对上面的混合模式进行了封装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span>.getName != <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>（6）寄生构造函数模式。寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个new。这样既不用修改原来的构造函数，也达到了扩展对象的目的(比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改Array构造函数)。<strong>缺点</strong>和工厂模式一样，无法实现对象的识别。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;kevin&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-继承的几种实现方式？"><a href="#JavaScript-继承的几种实现方式？" class="headerlink" title="JavaScript 继承的几种实现方式？"></a>JavaScript 继承的几种实现方式？</h2><p>具体可参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903475021627400">JS原型链与继承别再被问倒了</a>。</p>
<p>（1）以<strong>原型链</strong>的方式。缺点是在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p>
<p>（2）借用<strong>构造函数</strong>。这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p>
<p>（3）<strong>组合继承</strong>。组合继承是将原型链和借用构造函数组合起来使用的一种方式。核心是在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。这种继承方式<strong>优点</strong>在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是<strong>缺点</strong>是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/09/10/25vMPF7DaKJxwU8.png" alt="image.png"></p>
<p>（4）<strong>原型式继承</strong>。原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p>
<p>（5）<strong>寄生式继承</strong>。寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是我们的自定义类型时。缺点是没有办法实现函数的复用。</p>
<p>（6）<strong>寄生式组合继承</strong>。组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的核心是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在组合继承的代码基础上，Child.prototype = new Parent() 改为:</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: Child,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/09/10/ZqK1HvNfya8PXn5.png" alt="image.png"></p>
<p>（7）<strong>Class 继承</strong>。ES6 可以使用 <code>class</code> 去实现继承。核心在于使用 <code>extends</code> 表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code>，因为这段代码可以看成 <code>Parent.call(this, value)</code>。（<code>class</code> 的本质就是函数）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure>




<h2 id="事件委托是什么？（实现见实现部分）"><a href="#事件委托是什么？（实现见实现部分）" class="headerlink" title="事件委托是什么？（实现见实现部分）"></a>事件委托是什么？（实现见实现部分）</h2><p>事件委托<strong>本质</strong>：利用浏览器事件冒泡的机制。因为事件在冒泡过程中会上传到父节点，并且父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。</p>
<p>使用事件代理我们可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且还可以实现事件的动态绑定，比如说新增了一个子节点，我们并不需要单独地为它添加一个监听事件，它所发生的事件会交给父元素中的监听函数来处理。</p>
<h2 id="JavaScript-如何绑定事件？"><a href="#JavaScript-如何绑定事件？" class="headerlink" title="JavaScript 如何绑定事件？"></a>JavaScript 如何绑定事件？</h2><ol>
<li><p>使用内联</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(1);&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在一个元素上面直接绑定了一个点击 onclick 事件，此事件为 DOM 0 级标准，优先级最高。</p>
</li>
<li><p>使用对象.事件的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bt = <span class="built_in">document</span>.getElementsBytagname(<span class="string">&quot;input&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">bt.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此事件也是 DOM 0 级标准。</p>
<p><strong>前两种的弊端：一个元素只能添加一个事件。</strong></p>
</li>
<li><p>使用事件监听 addEventListener 的方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bt.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	alert(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第三个参数：是否捕获。默认是 false （即为冒泡）</p>
</li>
</ol>
<h2 id="什么是闭包？（高频）"><a href="#什么是闭包？（高频）" class="headerlink" title="什么是闭包？（高频）"></a>什么是闭包？（高频）</h2><p>闭包：<strong>有权访问另一个函数作用域中变量的函数。</strong> ——《JavaScript高级程序设计》</p>
<p><strong>（函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。）</strong></p>
<p>创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>闭包的<strong>用途</strong>：</p>
<ul>
<li>在函数外部能够访问到函数内部的变量，通过这种方法来<strong>创建私有变量</strong>。</li>
<li>使已经运行结束的函数上下文中的变量对象继续留在内存中。因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>
<li>模拟块级作用域。</li>
<li>创建模块。</li>
</ul>
<p>闭包的<strong>缺点</strong>：会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<h2 id="“use-strict”-目的-使用它区别是什么？"><a href="#“use-strict”-目的-使用它区别是什么？" class="headerlink" title="“use strict” 目的 ? 使用它区别是什么？"></a>“use strict” 目的 ? 使用它区别是什么？</h2><p>use strict 是一种 ECMAScript5 添加的（严格）运行模式，这种模式使得 JavaScript 在更严格的条件下运行。设立”严格模式”的目的主要有以下几个：</p>
<ul>
<li>消除 JavaScript 语法的一些不合理、不严谨之处，减少一些怪异行为；</li>
<li>消除代码运行的一些不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 JavaScript 做好铺垫。</li>
</ul>
<p>区别：</p>
<ul>
<li>禁止使用 with 语句。</li>
<li>禁止 this 关键字指向全局对象。this 为 undefined ，所以访问 this 的属性就会报错。</li>
<li>对象不能有重名的属性。</li>
</ul>
<h2 id="JavaScript的全局函数有哪些？"><a href="#JavaScript的全局函数有哪些？" class="headerlink" title="JavaScript的全局函数有哪些？"></a>JavaScript的全局函数有哪些？</h2><p>全局函数指的是 ECMAScript 中定义的 global 方法。</p>
<p>编码相关：</p>
<p>  escape()、unescape()、encodeURI()、decodeURI()、</p>
<p>  encodeURIComponent()、decodeURIComponent()</p>
<p>数据处理：</p>
<p>  Number()、String()</p>
<p>数字相关：</p>
<p>  isFinite()、isNaN()、parseFloat()、parseInt()</p>
<p>特殊：</p>
<p>  eval()</p>
<h2 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h2><ul>
<li><p>使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
</li>
<li><p>通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p>
</li>
<li><p>如果需要判断的是某个内置的引用类型的话，可以使用 <code>Object.prototype.toString()</code> 方法来打印对象的 [[Class]] 属性来进行判断。</p>
</li>
</ul>
<h2 id="对于-JSON-的了解？"><a href="#对于-JSON-的了解？" class="headerlink" title="对于 JSON 的了解？"></a>对于 JSON 的了解？</h2><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。在项目开发中，我们使用 JSON 作为前后端数据交换的方式。前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后传递到后端。后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此实现前后端数据的传递。</p>
<p>JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p>
<p><code>JSON.stringify()</code>：通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</p>
<p> <code>JSON.parse()</code> ：将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</p>
<h2 id="NOSCRIPT-标签是做什么用的？"><a href="#NOSCRIPT-标签是做什么用的？" class="headerlink" title="NOSCRIPT 标签是做什么用的？"></a>NOSCRIPT 标签是做什么用的？</h2><p>用来定义在脚本未被执行时的替代内容，也可以用在检测浏览器是否支持脚本，若不支持脚本则可以显示 NOSCRIPT 标签里的 innerText 。</p>
<h2 id="js-延迟加载的方式有哪些？"><a href="#js-延迟加载的方式有哪些？" class="headerlink" title="js 延迟加载的方式有哪些？"></a>js 延迟加载的方式有哪些？</h2><p>js 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度，一般有以下几种方式：</p>
<ul>
<li>defer 属性</li>
<li>async 属性</li>
<li>动态创建 DOM 方式</li>
<li>使用 setTimeout 延迟方法</li>
<li>让 JS 最后加载</li>
</ul>
<h2 id="Ajax-是什么-如何创建一个-Ajax？（见实现篇手写Ajax）"><a href="#Ajax-是什么-如何创建一个-Ajax？（见实现篇手写Ajax）" class="headerlink" title="Ajax 是什么? 如何创建一个 Ajax？（见实现篇手写Ajax）"></a>Ajax 是什么? 如何创建一个 Ajax？（见实现篇手写Ajax）</h2><p>Ajax（Asynchronous JavaScript and XML）指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。具体来说，AJAX 包括以下几个步骤。</p>
<ul>
<li>创建 XMLHttpRequest 对象，也就是创建一个异步调用对象</li>
<li>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</li>
<li>设置响应 HTTP 请求状态变化的函数</li>
<li>发送 HTTP 请求</li>
<li>获取异步调用返回的数据</li>
<li>使用 JavaScript 和 DOM 实现局部刷新</li>
</ul>
<h2 id="并发（concurrency）和并行（parallelism）区别？"><a href="#并发（concurrency）和并行（parallelism）区别？" class="headerlink" title="并发（concurrency）和并行（parallelism）区别？"></a>并发（concurrency）和并行（parallelism）区别？</h2><p>并发是宏观概念，分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</p>
<p>并行是微观概念，假设 CPU 中存在两个核心，那么就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</p>
<h2 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h2><p>同步：执行完函数或方法后，一直等待系统返回值或消息。这时程序是阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  </p>
<p>异步：执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </p>
<h2 id="为什么要使用模块化开发？"><a href="#为什么要使用模块化开发？" class="headerlink" title="为什么要使用模块化开发？"></a>为什么要使用模块化开发？</h2><p>过程：</p>
<ul>
<li><p>一个模块是实现一个特定功能的一组方法。由于函数具有独立作用域的特点，最原始的写法是使用函数来作为模块，几个函数作为一个模块，但是这种方式容易造成全局变量的污染，并且模块间没有联系。</p>
</li>
<li><p>后面提出了对象写法，通过将函数作为一个对象的方法来实现，这样解决了直接使用函数作为模块的一些缺点，但是这种办法会暴露所有的模块成员，外部代码可以修改内部属性的值。</p>
</li>
<li><p>使用立即执行函数实现模块化是常见的手段，通过利用闭包来实现模块私有作用域的建立，解决了命名冲突、污染全局作用域的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">globalVariable</span>)</span>&#123;</span><br><span class="line">   globalVariable.test = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">   <span class="comment">// ... 声明各种变量、函数都不会污染全局作用域</span></span><br><span class="line">&#125;)(globalVariable)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用模块化好处：</p>
<ul>
<li>解决命名冲突</li>
<li>提供复用性</li>
<li>提高代码可维护性</li>
</ul>
<h2 id="js-的几种模块规范？"><a href="#js-的几种模块规范？" class="headerlink" title="js 的几种模块规范？"></a>js 的几种模块规范？</h2><p>js 中现在比较成熟的有四种模块加载方案。</p>
<ul>
<li><p>CommonJS 方案，它通过 require 来引入模块，通过 <code>module.exports</code> 定义模块的输出接口。这种模块加载方案是服务器端的解决方案，以同步的方式来引入模块，因为在服务端文件都存储在本地磁盘，所以读取非常快，以同步的方式加载没有问题。但如果是在浏览器端，由于模块的加载是使用网络请求，因此使用异步加载的方式更加合适。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>AMD 方案，这种方案采用异步加载的方式来加载模块，模块的加载不影响后面语句的执行，所有依赖这个模块的语句都定义在一个回调函数里，等到加载完成后再执行回调函数。require.js 实现了 AMD 规范。</p>
</li>
<li><p>CMD 方案，这种方案和 AMD 方案都是为了解决异步模块加载的问题，sea.js 实现了 CMD 规范。它和 require.js的区别在于模块定义时对依赖的处理不同和对依赖模块的执行时机的处理不同。</p>
</li>
<li><p> ES6 提出的方案，使用 import 和 export 的形式来导入导出模块。这种方案和上面三种方案都不同。</p>
</li>
</ul>
<h2 id="CommonJS-和-ES-Module-的区别？"><a href="#CommonJS-和-ES-Module-的区别？" class="headerlink" title="CommonJS 和 ES Module 的区别？"></a>CommonJS 和 ES Module 的区别？</h2><p>具体见 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6938581764432461854">聊聊什么是CommonJs和Es Module及它们的区别</a></p>
<ol>
<li><p>CommonJS 输出的是值的拷贝，ES Module 输出的是值的引用。</p>
</li>
<li><p>CommonJS 是运行时加载（动态，可以在语句中使用 require ），ES Module 是编译时输出接口（静态，只能在文件最顶部 import ）。</p>
</li>
<li><p>CommonJS 的 require（）是同步加载模块，ES Module 的 import 是异步加载模块，静态编译时加载，有独立的模块依赖解析。</p>
</li>
<li><p>CommonJS 模块的顶层 this 指向当前模块，ES6 模块中，顶层 this 指向 undefined。</p>
</li>
</ol>
<h2 id="AMD-和-CMD-规范的区别？"><a href="#AMD-和-CMD-规范的区别？" class="headerlink" title="* AMD 和 CMD 规范的区别？"></a>* AMD 和 CMD 规范的区别？</h2><p>它们之间的主要区别有两个方面。</p>
<p>（1）在模块定义时对依赖的处理不同。AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块。而 CMD 推崇就近依赖，只有在用到某个模块的时候再去 require 。</p>
<p>（2）对依赖模块的执行时机处理不同。首先 AMD 和 CMD 对于模块的加载方式都是异步加载，不过它们的区别在于 模块的执行时机，AMD 在依赖模块加载完成后就直接执行依赖模块，依赖模块的执行顺序和我们书写的顺序不一定一致。而 CMD 在依赖模块加载完成后并不执行，只是下载而已，等到所有的依赖模块都加载好后，进入回调函数逻辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序就和我们书写的顺序保持一致了。</p>
<h2 id="ES6-模块与-CommonJS-模块、AMD、CMD-的差异。"><a href="#ES6-模块与-CommonJS-模块、AMD、CMD-的差异。" class="headerlink" title="* ES6 模块与 CommonJS 模块、AMD、CMD 的差异。"></a>* ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</h2><ul>
<li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。CommonJS 模块就是对象，即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li>
</ul>
<h2 id="requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）"><a href="#requireJS-的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何-缓存的？）" class="headerlink" title="* requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）"></a>* requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</h2><p>require.js 的核心原理是通过动态创建 script 脚本来异步引入模块，然后对每个脚本的 load 事件进行监听，如果每个脚本都加载完成了，再调用回调函数。</p>
<h2 id="documen-write-和-innerHTML-的区别？"><a href="#documen-write-和-innerHTML-的区别？" class="headerlink" title="documen.write 和 innerHTML 的区别？"></a>documen.write 和 innerHTML 的区别？</h2><ul>
<li><p>document.write 的内容会代替整个文档内容，会重写整个页面。</p>
</li>
<li><p>innerHTML 的内容只是替代指定元素的内容，只会重写页面中的部分内容。</p>
</li>
</ul>
<h2 id="DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？"><a href="#DOM-操作——怎样添加、移除、移动、复制、创建和查找节点？" class="headerlink" title="DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？"></a>DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</h2><p>（1）创建新节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">createDocumentFragment(node);</span><br><span class="line">createElement(node);</span><br><span class="line">createTextNode(text);</span><br></pre></td></tr></table></figure>

<p>（2）添加、移除、替换、插入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">appendChild(node)</span><br><span class="line">removeChild(node)</span><br><span class="line">replaceChild(<span class="keyword">new</span>,old)</span><br><span class="line">insertBefore(<span class="keyword">new</span>,old)</span><br></pre></td></tr></table></figure>

<p>（3）查找</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getElementById();</span><br><span class="line">getElementsByName();</span><br><span class="line">getElementsByTagName();</span><br><span class="line">getElementsByClassName();</span><br><span class="line">querySelector();</span><br><span class="line">querySelectorAll();</span><br></pre></td></tr></table></figure>

<p>（4）属性操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getAttribute(key);</span><br><span class="line">setAttribute(key, value);</span><br><span class="line">hasAttribute(key);</span><br><span class="line">removeAttribute(key);</span><br></pre></td></tr></table></figure>

<h2 id="innerHTML-与-outerHTML-的区别？"><a href="#innerHTML-与-outerHTML-的区别？" class="headerlink" title="innerHTML 与 outerHTML 的区别？"></a>innerHTML 与 outerHTML 的区别？</h2><p>对于这样一个 HTML 元素：<code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code>。</p>
<p>innerHTML：内部 HTML，<code>content&lt;br/&gt;</code>；<br>outerHTML：外部 HTML，<code>&lt;div&gt;content&lt;br/&gt;&lt;/div&gt;</code>；<br>innerText：内部文本，<code>content</code> ；<br>outerText：内部文本，<code>content</code> ；</p>
<h2 id="JavaScript-类数组对象的定义？"><a href="#JavaScript-类数组对象的定义？" class="headerlink" title="JavaScript 类数组对象的定义？"></a>JavaScript 类数组对象的定义？</h2><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。</p>
<p>常见的类数组对象有 <strong>arguments</strong> 和 <strong>DOM 方法的返回结果</strong>，<strong>一个函数</strong>也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。常见的类数组转换为数组的方法有这样几种：</p>
<p>（1）通过 call 调用数组的 slice 方法来实现转换 <code>Array.prototype.slice.call(arrayLike);</code>。</p>
<p>（2）通过 call 调用数组的 splice 方法来实现转换 <code>Array.prototype.splice.call(arrayLike, 0);</code>。</p>
<p>（3）通过 apply 调用数组的 concat 方法来实现转换 <code>Array.prototype.concat.apply([], arrayLike);</code>。</p>
<p>（4）通过 Array.from 方法来实现转换 <code>Array.from(arrayLike);</code>。</p>
<h2 id="数组有哪些原生方法？"><a href="#数组有哪些原生方法？" class="headerlink" title="数组有哪些原生方法？"></a>数组有哪些原生方法？</h2><p><img src="https://i.loli.net/2021/07/21/vej1Ao59BbQqwTt.jpg" alt="Snipaste_2021-07-21_13-12-00.jpg"></p>
<h3 id="map-filter-reduce-各自有什么作用？"><a href="#map-filter-reduce-各自有什么作用？" class="headerlink" title="map, filter, reduce 各自有什么作用？"></a>map, filter, reduce 各自有什么作用？</h3><p><code>map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。</p>
<p><code>filter</code> 作用也是生成一个新数组，在遍历数组的时候将返回值为 <code>true</code> 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素。</p>
<p><code>reduce</code> 可以将数组中的元素通过回调函数最终转换为一个值，它接受两个参数，分别是回调函数和初始值。具体用法见 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904063729926152">25个你不得不知道的数组reduce高级用法</a>。</p>
<h2 id="的长度？"><a href="#的长度？" class="headerlink" title="[,,,] 的长度？"></a>[,,,] 的长度？</h2><p>尾后逗号 （有时叫做“终止逗号”）在向 JavaScript 代码添加元素、参数、属性时十分有用。如果想要添加新的属性，并且上一行已经使用了尾后逗号，你可以仅仅添加新的一行，而不需要修改上一行。这使得版本控制更加清晰，以及代码维护麻烦更少。</p>
<p>如果使用了多于一个尾后逗号，会产生间隙。 带有间隙的数组叫做稀疏数组（密致数组没有间隙），长度为<strong>逗号的数量</strong>。</p>
<h2 id="js-语句末尾分号是否可以省略？"><a href="#js-语句末尾分号是否可以省略？" class="headerlink" title="js 语句末尾分号是否可以省略？"></a>js 语句末尾分号是否可以省略？</h2><p>在 ECMAScript 规范中，语句结尾的分号并不是必需的。但是我们一般最好不要省略分号，因为加上分号一方面有利于我们代码的可维护性，另一方面也可以避免我们在对代码进行压缩时出现错误。</p>
<h2 id="如何编写高性能的-Javascript-？"><a href="#如何编写高性能的-Javascript-？" class="headerlink" title="如何编写高性能的 Javascript ？"></a>如何编写高性能的 Javascript ？</h2><ul>
<li>使用位运算代替一些简单的四则运算。</li>
<li>避免使用过深的嵌套循环。</li>
<li>不要使用未定义的变量。</li>
<li>当需要多次访问数组长度时，可以用变量保存起来，避免每次都会去进行属性查找。</li>
</ul>
<h2 id="escape，encodeURI，encodeURIComponent-有什么区别？"><a href="#escape，encodeURI，encodeURIComponent-有什么区别？" class="headerlink" title="*escape，encodeURI，encodeURIComponent 有什么区别？"></a>*escape，encodeURI，encodeURIComponent 有什么区别？</h2><p>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</p>
<p>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</p>
<p>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</p>
<h2 id="Unicode-和-UTF-8-之间的关系？"><a href="#Unicode-和-UTF-8-之间的关系？" class="headerlink" title="Unicode 和 UTF-8 之间的关系？"></a>Unicode 和 UTF-8 之间的关系？</h2><p>Unicode 是一种字符集合，现在可容纳 100 多万个字符。每个字符对应一个不同的 Unicode 编码，它只规定了符号的二进制代码，却没有规定这个二进制代码在计算机中如何编码传输。</p>
<p>UTF-8 是一种对 Unicode 的编码方式，它是一种变长的编码方式，可以用 1~4 个字节来表示一个字符。</p>
<h2 id="什么是执行栈？"><a href="#什么是执行栈？" class="headerlink" title="什么是执行栈？"></a>什么是执行栈？</h2><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。当开始执行 JS 代码时，首先会执行一个 <code>main</code> 函数，然后执行代码。根据先进后出的原则，后执行的函数会先弹出栈。</p>
<h2 id="js-的事件循环（Event-Loop）是什么？（高频）"><a href="#js-的事件循环（Event-Loop）是什么？（高频）" class="headerlink" title="js 的事件循环（Event Loop）是什么？（高频）"></a>js 的事件循环（Event Loop）是什么？（高频）</h2><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 <strong>微任务</strong>（microtask） 和 <strong>宏任务</strong>（macrotask）。在 ES6 规范中，microtask 称为 <code>jobs</code>，macrotask 称为 <code>task</code>。有关宏任务、微任务具体见<a target="_blank" rel="noopener" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">tasks-microtasks-queues-and-schedules</a>。</p>
<p> js 是单线程运行的，通过将不同函数的执行上下文压入执行栈来保证代码的有序执行。在执行同步代码的时候，如果遇到了<strong>异步</strong>事件，js 引擎并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务；当异步事件执行完毕后，再<strong>将异步事件对应的回调加入到与当前执行栈中不同的另一个任务队列中</strong>等待执行。</p>
<p>任务队列可以分为宏任务队列和微任务队列，当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再判断宏任务队列中的任务。</p>
<p><strong>微任务</strong>： <code>process.nextTick</code> ，<code>promise</code> 的回调，对 Dom 变化监听的<code>MutationObserver</code>，其中 <code>process.nextTick</code> 为 Node 独有。</p>
<p><strong>宏任务</strong>： <code>script</code> 脚本的执行、<code>setTimeout </code>，<code>setInterval</code> ，<code>setImmediate</code> 一类的定时事件，还有如 <code>I/O</code> 操作、<code>UI rendering</code>等。</p>
<p><img src="https://i.loli.net/2021/09/11/H3nSo9t6erYCmMA.png" alt="image.png"></p>
<p>Event Loop 执行顺序如下所示：</p>
<ul>
<li>首先执行同步代码，这属于宏任务</li>
<li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li>
<li>执行所有微任务</li>
<li>当执行完所有微任务后，如有必要会<strong>渲染页面</strong>。（为了能够使得<strong>JS引擎线程</strong>与<strong>GUI渲染线程</strong>有序切换）</li>
<li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 <code>setTimeout</code> 中的回调函数</li>
</ul>
<p>浏览器页面初次渲染完毕后，JS 引擎线程结合事件触发线程的工作流程如下：</p>
<ol>
<li>同步任务在 JS 引擎线程（主线程）上执行，形成执行栈。</li>
<li>主线程之外，事件触发线程管理着一个任务队列。只要异步任务有了运行结果，就在任务队列之中放置一个事件。</li>
<li>执行栈中的同步任务执行完毕，系统就会读取任务队列，如果有异步任务需要执行，将其加到主线程的执行栈并执行相应的异步任务。</li>
</ol>
<h2 id="Node-中的-Event-Loop-和浏览器中的有什么区别？"><a href="#Node-中的-Event-Loop-和浏览器中的有什么区别？" class="headerlink" title="Node 中的 Event Loop 和浏览器中的有什么区别？"></a>Node 中的 Event Loop 和浏览器中的有什么区别？</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903512845860872#heading-4">这一次，彻底弄懂 JavaScript 执行机制</a></p>
<p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><img src="https://i.loli.net/2021/09/11/cyIsZ8k7fXYT2eD.png" alt="image.png"></p>
<ul>
<li>timers 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code> 回调，并且是由 poll 阶段控制的。同样，在 Node 中定时器指定的时间也不是准确时间，只能是<strong>尽快</strong>执行。</li>
<li>I/O 阶段会处理一些上一轮循环中的<strong>少数未执行</strong>的 I/O 回调</li>
<li>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情<ul>
<li>回到 timer 阶段执行回调</li>
<li>执行 I/O 回调</li>
</ul>
</li>
<li>check 阶段执行 <code>setImmediate</code></li>
<li>close callbacks 阶段执行 close 事件</li>
</ul>
<h2 id="process-nextTick-执行顺序？"><a href="#process-nextTick-执行顺序？" class="headerlink" title="process.nextTick 执行顺序？"></a>process.nextTick 执行顺序？</h2><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p>
<h2 id="为什么-0-1-0-2-0-3？如何解决？"><a href="#为什么-0-1-0-2-0-3？如何解决？" class="headerlink" title="为什么 0.1 + 0.2 != 0.3？如何解决？"></a>为什么 0.1 + 0.2 != 0.3？如何解决？</h2><ul>
<li><p>计算机实际上计算的是这两个数字在计算机里所存储的二进制，0.1 和 0.2 在转换为二进制表示的时候会出现位数无限循环的情况。0.1 在二进制中表示为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (0011) 表示循环</span></span><br><span class="line"><span class="number">0.1</span> = <span class="number">2</span>^-<span class="number">4</span> * <span class="number">1.10011</span>(<span class="number">0011</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>JS 采用的浮点数标准会裁剪掉我们的数字：js 中是以 64 位双精度格式来存储数字的，只有 53 位的有效数字，超过这个长度的位数会被截取掉。IEEE 754 双精度版本（64位）将 64 位分为了三段</p>
<ul>
<li>第一位用来表示符号</li>
<li>接下去的 11 位用来表示指数</li>
<li>其他的位数用来表示有效位，也就是用二进制表示 0.1 中的 <code>10011(0011)</code></li>
</ul>
</li>
<li><p>那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 0.1 不再是 0.1 了，而是变成了 <code>0.100000000000000002</code>，同样的，0.2 在二进制也是无限循环的，被裁剪后也失去了精度变成了 <code>0.200000000000000002</code>。</p>
</li>
<li><p>所以这两者相加不等于 <code>0.3</code> 而是 <code>0.300000000000000004</code></p>
</li>
</ul>
<p>对于这样的情况，我们可以</p>
<ul>
<li>将其转换为整数后再进行运算，运算后再转换为对应的小数，从而解决这个问题。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将两个数相加的结果和右边相减，如果相减的结果小于一个极小数（JavaScript 提供的最小精度值），那么我们就可以认定结果是相等的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt;= <span class="built_in">Number</span>.EPSILON);</span><br></pre></td></tr></table></figure>



<h2 id="toPrecision-和-toFixed-和-Math-round-的区别？"><a href="#toPrecision-和-toFixed-和-Math-round-的区别？" class="headerlink" title="toPrecision 和 toFixed 和 Math.round 的区别？"></a>toPrecision 和 toFixed 和 Math.round 的区别？</h2><p>toPrecision 用于处理精度，精度是从左至右第一个不为 0 的数开始数起。<br>toFixed 是对小数点后指定位数取整，从小数点开始数起。<br>Math.round 是将一个数字四舍五入到一个整数。</p>
<h2 id="什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="*什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>*什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h2><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化我们的开发效率。</p>
<p>比如说我们实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对我们的项目开发和后期的项目维护是非常不利的。</p>
<p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p>
<p>MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p>
<h2 id="介绍-Object-defineProperty-？"><a href="#介绍-Object-defineProperty-？" class="headerlink" title="介绍 Object.defineProperty ？"></a>介绍 Object.defineProperty ？</h2><p>Object.defineProperty 函数一共有三个参数，第一个参数是需要定义属性的对象，第二个参数是需要定义的属性，第三个是该属性描述符。属性描述符的值如下：</p>
<ul>
<li>value：就是属性的值。</li>
<li>writable：决定属性能否被赋值。</li>
<li>enumerable：决定 for in 能否枚举该属性。</li>
<li>configurable：决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>我们可以通过 Object.defineProperty 函数改变属性的特征，或者定义访问器属性。</p>
<h3 id="使用-Object-defineProperty-来进行数据劫持的缺点？"><a href="#使用-Object-defineProperty-来进行数据劫持的缺点？" class="headerlink" title="使用 Object.defineProperty() 来进行数据劫持的缺点？"></a><strong>使用 Object.defineProperty() 来进行数据劫持的缺点？</strong></h3><ul>
<li><p>不能监听数组的变化（即如果对象上有新增的属性，需要对新增的属性再次进行</p>
</li>
<li><p>必须遍历对象的每个属性</p>
</li>
<li><p>如果属性是对象，还需要深层遍历。这也是为什么**Vue给对象新增属性需要通过<code>$set</code>**的原因，其原理也是通过<code>Object.defineProperty</code>对新增的属性再次进行劫持</p>
</li>
</ul>
<h2 id="什么是-Proxy-？"><a href="#什么是-Proxy-？" class="headerlink" title="什么是 Proxy ？"></a>什么是 Proxy ？</h2><p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。Proxy 可以理解成在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。</p>
<h3 id="Proxy-与-Object-defineProperty-有什么区别？"><a href="#Proxy-与-Object-defineProperty-有什么区别？" class="headerlink" title="Proxy 与 Object.defineProperty 有什么区别？"></a>Proxy 与 Object.defineProperty 有什么区别？</h3><ul>
<li>Proxy 针对整个对象，而 Object.defineProperty 针对单个属性，前者解决了 需要对对象进行深度递归（支持嵌套的复杂对象劫持）实现对每个属性劫持的问题。</li>
<li>Proxy 解决了 Object.defineProperty 无法劫持数组。</li>
<li>比 Object.defineProperty 有更多的拦截方法，对比一些新的浏览器，可能会对 Proxy 针正对性的优化，有助于性能提升。</li>
</ul>
<p>Proxy的缺点也很明显，作为新的内置对象，对老浏览器的兼容性就不那么友好了，所以在使用的时候得考虑这方面的兼容问题。</p>
<h2 id="谈谈你对-webpack-的看法"><a href="#谈谈你对-webpack-的看法" class="headerlink" title="*谈谈你对 webpack 的看法"></a>*谈谈你对 webpack 的看法</h2><p>我当时使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源数。</p>
<p>我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。</p>
<p>Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。</p>
<p>Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。</p>
<p>Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。</p>
<p>loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。</p>
<p>插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</p>
<p>使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。</p>
<h2 id="offsetWidth-offsetHeight，clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？"><a href="#offsetWidth-offsetHeight，clientWidth-clientHeight-与-scrollWidth-scrollHeight-的区别？" class="headerlink" title="offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？"></a>offsetWidth/offsetHeight，clientWidth/clientHeight 与 scrollWidth/scrollHeight 的区别？</h2><p>clientWidth/clientHeight 返回的是元素的内部宽度，它的值只包含 content + padding，如果有滚动条，不包含滚动条。<br>clientTop 返回上边框的宽度。<br>clientLeft 返回左边框的宽度。</p>
<p>offsetWidth/offsetHeight 返回的是元素的布局宽度，它的值包含 content + padding + border 包含了滚动条。<br>offsetTop 返回当前元素相对于其 offsetParent 元素的顶部距离。<br>offsetLeft 返回当前元素相对于其 offsetParent 元素的左部距离。</p>
<p>scrollWidth/scrollHeight 返回值包含 content + padding + 溢出内容的尺寸。<br>scrollTop 属性返回一个元素内容垂直滚动的像素数。<br>scrollLeft 属性返回元素滚动条到元素左边的距离。</p>
<h2 id="谈一谈你理解的函数式编程？"><a href="#谈一谈你理解的函数式编程？" class="headerlink" title="谈一谈你理解的函数式编程？"></a>谈一谈你理解的函数式编程？</h2><p>简单说，”函数式编程”是一种”编程范式”，也就是如何编写程序的方法论。它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”。</p>
<h2 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h2><p>回调函数的致命弱点。根本问题：</p>
<ol>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ol>
<p>还有不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p>
<h2 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h2><p>js 中的异步机制可以分为以下几种：</p>
<ul>
<li><p>回调函数。回调函数的<strong>优点</strong>是简单、容易理解和部署，<strong>缺点</strong>是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），流程会很混乱，不利于代码的可维护。而且每个任务只能指定一个回调函数，多个回调函数嵌套的时候会造成回调函数地狱。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定有两个函数f1和f2，后者等待前者的执行结果。</span></span><br><span class="line">f1();</span><br><span class="line">f2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">　　<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　<span class="comment">// f1的任务代码</span></span><br><span class="line">　　　　callback();</span><br><span class="line">　　&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行代码就变成下面这样：</span></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure></li>
<li><p>事件监听。采用事件驱动模式，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。<strong>优点</strong>是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。<strong>缺点</strong>是整个程序都要变成事件驱动型，运行流程会变得很不清晰。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，为f1绑定一个事件</span></span><br><span class="line">f1.on(<span class="string">&#x27;done&#x27;</span>, f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对f1进行改写，f1.trigger(&#x27;done&#x27;)表示执行完成后，立即触发done事件，从而开始执行f2。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　　　<span class="comment">// f1的任务代码</span></span><br><span class="line">　　　　f1.trigger(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">　　&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发布/订阅。上述”事件”，完全可以理解成”信号”：我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做“发布/订阅模式”，又称”观察者模式”。<strong>优点</strong>是可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先，f2向&quot;信号中心&quot;jQuery订阅&quot;done&quot;信号。</span></span><br><span class="line">jQuery.subscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后，f1进行如下改写：jQuery.publish(&quot;done&quot;)的意思是，f1执行完成后，向&quot;信号中心&quot;jQuery发布&quot;done&quot;信号，从而引发f2的执行。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// f1的任务代码</span></span><br><span class="line">		jQuery.publish(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">	&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外，f2完成执行后，也可以取消订阅。</span></span><br><span class="line">jQuery.unsubscribe(<span class="string">&quot;done&quot;</span>, f2);</span><br></pre></td></tr></table></figure></li>
<li><p>Promise 。使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	f1();</span><br><span class="line">    resolve();</span><br><span class="line"> &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    	f2();</span><br><span class="line"> 	&#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           f3();</span><br><span class="line">  		&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>generator 。生成器函数就是一个带星号（*）的函数，在内部碰到 yield 就可以实现暂停功能，使用 next 进行迭代。当我们遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕的时候我们再将执行权给转移回来，因此可以以同步的顺序来书写异步操作。使用这种方式我们需要考虑的问题是何时将函数的控制权转移回来，因此我们需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。详情见<a target="_blank" rel="noopener" href="https://blog.csdn.net/a18792627168/article/details/106154898%E3%80%82">https://blog.csdn.net/a18792627168/article/details/106154898。</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gen = g();</span><br><span class="line"></span><br><span class="line"><span class="comment">// g()并不会立即执行函数，而是返回迭代器Iterator对象，必须调用遍历器对象的next方法，使得指针移向下一个状态。</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next());   	<span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next());   	<span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next());	<span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(gen.next());	<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>async 。async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码的函数gen可以写成async函数，就是下面这样。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>Generator 函数是一个状态机，封装了多个内部状态。执行 Generator 函数会返回一个遍历器对象，可以依次遍历 Generator 函数内部的每一个状态，但是只有调用<code>next</code>方法才会遍历下一个内部状态，所以其实提供了一种<strong>可以暂停执行</strong>的函数。<code>yield</code>表达式就是暂停标志。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li>
<li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li>
<li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li>
<li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li>
</ul>
<p>Generator 函数被调用时并不会执行。每次调用遍历器对象的next方法，就会返回一个有着<code>value</code>和<code>done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</p>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h2><p><strong>以同步方式执行异步操作。</strong>ES7引入的async 是一个通过异步执行并隐式返回 Promise 作为结果的函数。async 就是将函数返回值使用 <code>Promise.resolve()</code> 包裹了下，<code>await</code> 就是 <code>generator</code> 加上 <code>Promise</code> 的语法糖，且内部实现了自动执行 <code>generator</code>。</p>
<p>考虑以下情景：接口一，请求到数据一，而数据一被当做请求二的参数去请求数据二，用Promise实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模拟第一次请求</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">5</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟第二次请求</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 拿第一次请求的数据去乘10，当做第二次请求的数据</span></span><br><span class="line">        resolve(res * <span class="number">10</span>)</span><br><span class="line">      &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">sres</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(sres)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">// 1 + 2 = 3 3秒后输出 50</span></span><br></pre></td></tr></table></figure>

<p>async/await 实现，注意以下几点：</p>
<ul>
<li>await 只能在 async 函数里使用</li>
<li>await 后面最好接 Promise，如果后面接的是普通函数则会直接执行</li>
<li>async 函数返回的是一个 Promise</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="number">5</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(data * <span class="number">10</span>)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">req</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 同步方式执行异步，像排队一样</span></span><br><span class="line">  <span class="keyword">const</span> data1 = <span class="keyword">await</span> fn1() <span class="comment">// 等待1秒后返回数据再往下执行</span></span><br><span class="line">  <span class="keyword">const</span> data2 = <span class="keyword">await</span> fn2(data1) <span class="comment">// 拿data1去请求2秒后，往下走</span></span><br><span class="line">  <span class="built_in">console</span>.log(data2) <span class="comment">// 总共3秒后 输出 50</span></span><br><span class="line">&#125;</span><br><span class="line">req()</span><br></pre></td></tr></table></figure>

<h2 id="async-await-与-Generator-的区别？"><a href="#async-await-与-Generator-的区别？" class="headerlink" title="async / await 与 Generator 的区别？"></a>async / await 与 Generator 的区别？</h2><p>async 函数对 Generator 函数的改进，体现在以下四点:</p>
<p>（1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器，无需手动执行 next() 方法。</p>
<p>（2）更好的语义。async 和 await ，比起 * 和 yield ，语义更清楚了。 async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p>
<p>（3）更广的适用性。co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
<p>（4）返回值是 Promise。async 函数的返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用。进一步说，async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部 then 命令的语法糖。</p>
<p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。有空可以看一看 <a target="_blank" rel="noopener" href="https://blog.csdn.net/a18792627168/article/details/106170485%E3%80%82%E6%88%96%E8%80%85https://juejin.cn/post/6844903988584775693%E3%80%82">https://blog.csdn.net/a18792627168/article/details/106170485。或者https://juejin.cn/post/6844903988584775693。</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">asyncPrint(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>




<h2 id="Js-动画与-CSS-动画区别及相应实现"><a href="#Js-动画与-CSS-动画区别及相应实现" class="headerlink" title="Js 动画与 CSS 动画区别及相应实现"></a>Js 动画与 CSS 动画区别及相应实现</h2><p>CSS3 的动画的<strong>优点</strong>：在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化。代码相对简单。</p>
<p><strong>缺点</strong>：在动画控制上不够灵活。兼容性不好。</p>
<p>JavaScript 的动画<strong>优点</strong>：控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。</p>
<p>对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧。</p>
<h2 id="get-请求传参长度的误区"><a href="#get-请求传参长度的误区" class="headerlink" title="get 请求传参长度的误区"></a>get 请求传参长度的误区</h2><p>误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。</p>
<p>实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源于浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:</p>
<ul>
<li>HTTP 协议未规定 GET 和 POST 的长度限制</li>
<li>GET 的最大长度显示是因为浏览器和 web 服务器限制了 URI 的长度</li>
<li>不同的浏览器和 WEB 服务器，限制的最大长度不一样</li>
<li>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li>
</ul>
<h2 id="URL-和-URI-的区别？"><a href="#URL-和-URI-的区别？" class="headerlink" title="URL 和 URI 的区别？"></a>URL 和 URI 的区别？</h2><p><strong>URI</strong>: Uniform Resource Identifier      <strong>统一资源标识符</strong>，用唯一的标识来确定一个资源，它是一种抽象的定义，也就是说不管使用什么方法来定义，只要能唯一的标识一个资源，就可以称为 URI。<br><strong>URL</strong>: Uniform Resource Location        <strong>统一资源定位符</strong>，URL 和 URN 是 URI 的子集，URL 可以理解为使用地址来标识资源。<br><strong>URN</strong>: Universal Resource Name          <strong>统一资源名称</strong>，URN 可以理解为使用名称来标识资源。</p>
<h2 id="src-和-href-的区别"><a href="#src-和-href-的区别" class="headerlink" title="src 和 href 的区别"></a>src 和 href 的区别</h2><p>href 表示超文本引用，在 link 和 a 等元素上使用。指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的连接，用于超链接。</p>
<p>src 表示来源地址，在 img、script、iframe 等元素（可替换的元素）上。指向外部资源的位置，指向的内容将会嵌入到文档中当前标签的所在位置，在请求src资源时会将其指向的资源下载并应用到文档內。</p>
<p><strong>src 的内容，是页面必不可少的一部分，是引入。href 的内容，是与该页面有关联，是引用。</strong></p>
<h2 id="get-和-post-请求在缓存方面的区别"><a href="#get-和-post-请求在缓存方面的区别" class="headerlink" title="get 和 post 请求在缓存方面的区别"></a>get 和 post 请求在缓存方面的区别</h2><p>get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</p>
<p>post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。</p>
<h2 id="mouseover-和-mouseenter-的区别？"><a href="#mouseover-和-mouseenter-的区别？" class="headerlink" title="mouseover 和 mouseenter 的区别？"></a>mouseover 和 mouseenter 的区别？</h2><p>当鼠标移动到元素上时就会触发 mouseenter 事件，类似 mouseover，它们两者之间的差别是 <strong>mouseenter 不会冒泡</strong>。</p>
<p>由于 mouseenter 不支持事件冒泡，导致在一个元素的子元素上进入或离开的时候会触发其 mouseover 和 mouseout 事件，但是却不会触发 mouseenter 和 mouseleave 事件。</p>
<h2 id="let-和-const-的注意点？"><a href="#let-和-const-的注意点？" class="headerlink" title="let 和 const 的注意点？"></a>let 和 const 的注意点？</h2><ul>
<li>声明的变量只在声明时的代码块内有效</li>
<li>不存在声明提升</li>
<li>存在暂时性死区，如果在变量声明前使用，会报错</li>
<li>不允许重复声明，重复声明会报错</li>
</ul>
<h2 id="什么是尾调用，有什么好处？"><a href="#什么是尾调用，有什么好处？" class="headerlink" title="什么是尾调用，有什么好处？"></a>什么是尾调用，有什么好处？</h2><p>尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。</p>
<p>使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以<strong>不必再保留当前的执行上下文，从而节省了内存</strong>，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<h2 id="Symbol-类型的注意点？"><a href="#Symbol-类型的注意点？" class="headerlink" title="Symbol 类型的注意点？"></a>Symbol 类型的注意点？</h2><ul>
<li>Symbol 函数前<strong>不能使用 new 命令</strong>，否则会报错。</li>
<li>Symbol 函数可以接受<strong>一个字符串作为参数</strong>，表示对 Symbol 实例的描述，主要是为了在控制台显示或者转为字符串时，比较容易区分。</li>
<li>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</li>
<li>Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</li>
<li>Symbol.for 接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有就返回这个 Symbol 值，否则新建并返回一个以该字符串为名称的 Symbol 值。</li>
<li>Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</li>
</ul>
<h2 id="set-和-map-区别？"><a href="#set-和-map-区别？" class="headerlink" title="set 和 map 区别？"></a>set 和 map 区别？</h2><p><strong>Set：</strong>（ES6新增，类似数组）</p>
<ul>
<li>成员唯一、无序且不重复。（因此可以去重 NaN ）</li>
<li>[value, value]，键值与键名是一致的（或者说只有键值，没有键名）。</li>
<li>可以遍历，方法有：add、delete、has。</li>
</ul>
<p><strong>WeakSet：</strong></p>
<ul>
<li><strong>成员只能是对象</strong>。</li>
<li>成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏。</li>
<li>不能遍历，方法有add、delete、has。</li>
</ul>
<p><strong>Map：</strong></p>
<ul>
<li>本质上是键值对的集合，类似集合。但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>可以遍历，方法很多可以跟各种数据格式转换。</li>
</ul>
<p><strong>WeakMap：</strong></p>
<ul>
<li><strong>只接受对象作为键名</strong>（null除外），不接受其他类型的值作为键名。</li>
<li>键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的。</li>
<li>不能遍历，方法有get、set、has、delete。</li>
</ul>
<h2 id="Reflect-对象创建目的？"><a href="#Reflect-对象创建目的？" class="headerlink" title="*Reflect 对象创建目的？"></a>*Reflect 对象创建目的？</h2><ul>
<li>将 Object 对象的一些明显属于语言内部的方法（比如 Object.defineProperty，放到 Reflect 对象上。</li>
<li>修改某些 Object 方法的返回结果，让其变得更合理。</li>
<li>让 Object 操作都变成函数行为。</li>
<li>Reflect 对象的方法与 Proxy 对象的方法一一对应，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法。这就让 Proxy 对象可以方便地调用对应的 Reflect 方法，完成默认行为，作为修改行为的基础。也就是说，不管 Proxy 怎么修改默认行为，你总可以在 Reflect 上获取默认行为。</li>
</ul>
<h2 id="require-模块引入的查找方式？"><a href="#require-模块引入的查找方式？" class="headerlink" title="*require 模块引入的查找方式？"></a>*require 模块引入的查找方式？</h2><p>当 Node 遇到 require(X) 时，按下面的顺序处理。</p>
<p>（1）如果 X 是内置模块（比如 require(‘http’)）<br>　　a. 返回该模块。<br>　　b. 不再继续执行。</p>
<p>（2）如果 X 以 “./“ 或者 “/“ 或者 “../“ 开头<br>　　a. 根据 X 所在的父模块，确定 X 的绝对路径。<br>　　b. 将 X 当成文件，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X<br>    X.js<br>    X.json<br>    X.node</p>
<p>　　c. 将 X 当成目录，依次查找下面文件，只要其中有一个存在，就返回该文件，不再继续执行。<br>    X/package.json（main字段）<br>    X/index.js<br>    X/index.json<br>    X/index.node</p>
<p>（3）如果 X 不带路径<br>　　a. 根据 X 所在的父模块，确定 X 可能的安装目录。<br>　　b. 依次在每个目录中，将 X 当成文件名或目录名加载。</p>
<p>（4）抛出 “not found”</p>
<h2 id="什么是-Promise-对象，什么是-Promises-A-规范？"><a href="#什么是-Promise-对象，什么是-Promises-A-规范？" class="headerlink" title="什么是 Promise 对象，什么是 Promises/A+ 规范？"></a>什么是 Promise 对象，什么是 Promises/A+ 规范？</h2><p>Promise 对象是异步编程的一种解决方案。Promises/A+ 规范是 JavaScript Promise 的标准，规定了一个 Promise 所必须具有的特性。</p>
<p>Promise 是一个构造函数（构造函数内部的代码是立即执行的），接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者 rejected 状态，并且状态一经改变，就无法再被改变。状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p>
<h2 id="图片懒加载和预加载"><a href="#图片懒加载和预加载" class="headerlink" title="图片懒加载和预加载"></a>图片懒加载和预加载</h2><p>懒加载定义：懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。</p>
<p>懒加载优点：</p>
<ul>
<li>能提升用户的体验</li>
<li>减少无效资源的加载</li>
<li>防止并发加载的资源过多会阻塞js的加载</li>
</ul>
<p>懒加载原理：首先将页面上的图片的 src 属性设为空字符串，而图片的真实路径则设置在data-original属性中， 当页面滚动的时候需要去监听scroll事件，在scroll事件的回调中，判断我们的懒加载的图片是否进入可视区域，如果图片在可视区内将图片的 src 属性设置为data-original 的值，这样就可以实现延迟加载。</p>
<p>懒加载实现可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903614138286094">https://juejin.cn/post/6844903614138286094</a></p>
<p>预加载定义：预加载简单来说就是将所有所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</p>
<p>预加载优点：提供给用户更好的体验，减少等待的时间。</p>
<p>预加载方法：</p>
<ul>
<li><p>使用HTML标签。<code>&lt;img src=&quot;xxx&quot; style=&quot;display:none&quot;/&gt;</code></p>
</li>
<li><p>使用Image对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;./myPreload.js&quot;</span>&gt;&lt;/script&gt;<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//myPreload.js文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">var image= new Image()</span></span><br><span class="line"><span class="string">image.src=&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>区别：<strong>一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力</strong>。</p>
<h2 id="JavaScript-设计模式"><a href="#JavaScript-设计模式" class="headerlink" title="*JavaScript 设计模式"></a>*JavaScript 设计模式</h2><h3 id="单例模式是什么？"><a href="#单例模式是什么？" class="headerlink" title="单例模式是什么？"></a>单例模式是什么？</h3><p>单例模式保证了全局只有一个实例来被访问。比如说常用的如弹框组件的实现和全局状态的实现。</p>
<h3 id="策略模式是什么？"><a href="#策略模式是什么？" class="headerlink" title="策略模式是什么？"></a>策略模式是什么？</h3><p>策略模式主要是用来将方法的实现和方法的调用分离开，外部通过不同的参数可以调用不同的策略。我主要在 MVP 模式解耦的时候用来将视图层的方法定义和方法调用分离。</p>
<h3 id="代理模式是什么？"><a href="#代理模式是什么？" class="headerlink" title="代理模式是什么？"></a>代理模式是什么？</h3><p> 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。比如说常见的事件代理。</p>
<h3 id="中介者模式是什么？"><a href="#中介者模式是什么？" class="headerlink" title="中介者模式是什么？"></a>中介者模式是什么？</h3><p>中介者模式指的是，多个对象通过一个中介者进行交流，而不是直接进行交流，这样能够将通信的各个对象解耦。</p>
<h3 id="适配器模式是什么？"><a href="#适配器模式是什么？" class="headerlink" title="适配器模式是什么？"></a>适配器模式是什么？</h3><p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。假如我们需要一种新的接口返回方式，但是老的接口由于在太多地方已经使用了，不能随意更改，这个时候就可以使用适配器模式。比如我们需要一种自定义的时间返回格式，但是我们又不能对 js 时间格式化的接口进行修改，这个时候就可以使用适配器模式。</p>
<h3 id="观察者模式和发布订阅模式有什么不同？"><a href="#观察者模式和发布订阅模式有什么不同？" class="headerlink" title="观察者模式和发布订阅模式有什么不同？"></a>观察者模式和发布订阅模式有什么不同？</h3><p>发布订阅模式其实属于广义上的观察者模式</p>
<p>在观察者模式中，观察者需要直接订阅目标事件。在目标发出内容改变的事件后，直接接收事件并作出响应。</p>
<p>而在发布订阅模式中，发布者和订阅者之间多了一个调度中心。调度中心一方面从发布者接收事件，另一方面向订阅者发布事件，订阅者需要在调度中心中订阅事件。通过调度中心实现了发布者和订阅者关系的解耦。使用发布订阅者模式更利于我们代码的可维护性。</p>
<h2 id="开发中常用的几种-Content-Type-？"><a href="#开发中常用的几种-Content-Type-？" class="headerlink" title="*开发中常用的几种 Content-Type ？"></a>*开发中常用的几种 Content-Type ？</h2><p>（1）application/x-www-form-urlencoded</p>
<p>浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。</p>
<p>（2）multipart/form-data</p>
<p>该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>
<p>（3）application/json</p>
<p>告诉服务器消息主体是序列化后的 JSON 字符串。</p>
<p>（4）text/xml</p>
<p>该种方式主要用来提交 XML 格式的数据。</p>
<h2 id="如何确定页面的可用性时间，什么是-Performance-API？"><a href="#如何确定页面的可用性时间，什么是-Performance-API？" class="headerlink" title="*如何确定页面的可用性时间，什么是 Performance API？"></a>*如何确定页面的可用性时间，什么是 Performance API？</h2><p>Performance API 用于精确度量、控制、增强浏览器的性能表现。这个 API 为测量网站性能，提供以前没有办法做到的精度。</p>
<p>使用 getTime 来计算脚本耗时的缺点，首先，getTime方法（以及 Date 对象的其他方法）都只能精确到毫秒级别（一秒的千分之一），想要得到更小的时间差别就无能为力了。其次，这种写法只能获取代码运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。</p>
<p>为了解决这两个不足之处，ECMAScript 5引入“高精度时间戳”这个 API，部署在 performance 对象上。它的精度可以达到1毫秒的千分之一（1秒的百万分之一）。</p>
<p>navigationStart：当前浏览器窗口的前一个网页关闭，发生 unload 事件时的 Unix 毫秒时间戳。如果没有前一个网页，则等于 fetchStart 属性。</p>
<p>loadEventEnd：返回当前网页 load 事件的回调函数运行结束时的 Unix 毫秒时间戳。如果该事件还没有发生，返回 0。</p>
<p>根据上面这些属性，可以计算出网页加载各个阶段的耗时。比如，网页加载整个过程的耗时的计算方法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t = performance.timing;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = t.loadEventEnd - t.navigationStart;</span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<h2 id="Math-ceil-和-Math-floor"><a href="#Math-ceil-和-Math-floor" class="headerlink" title="Math.ceil 和 Math.floor"></a>Math.ceil 和 Math.floor</h2><p>Math.ceil() === 向上取整，函数返回一个大于或等于给定数字的最小整数。</p>
<p>Math.floor() === 向下取整，函数返回一个小于或等于给定数字的最大整数。</p>
<h2 id="js-for-循环注意点"><a href="#js-for-循环注意点" class="headerlink" title="js for 循环注意点"></a>js for 循环注意点</h2><ul>
<li>当判断语句含有多个语句时，以最后一个判断语句的值为准，因此下面的代码会执行 10 次。</li>
<li>当判断语句为空时，循环会一直进行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>, j &lt; <span class="number">9</span>; i++, j++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个列表，假设有-100000-个数据，这个该怎么办？"><a href="#一个列表，假设有-100000-个数据，这个该怎么办？" class="headerlink" title="一个列表，假设有 100000 个数据，这个该怎么办？"></a>一个列表，假设有 100000 个数据，这个该怎么办？</h2><p>我们需要思考的问题：该处理是否必须同步完成？数据是否必须按顺序完成？</p>
<p>解决办法：</p>
<p>（1）将数据<strong>分页</strong>，利用分页的原理，每次服务器端只返回一定数目的数据，浏览器每次只对一部分进行加载。</p>
<p>（2）使用<strong>懒加载</strong>的方法，每次加载一部分数据，其余数据当需要使用时再去加载。</p>
<p>（3）使用<strong>数组分块技术</strong>，基本思路是为要处理的项目创建一个队列，然后设置定时器每过一段时间取出一部分数据，然后再使用定时器取出下一个要处理的项目进行处理，接着再设置另一个定时器。</p>
<h2 id="js-中倒计时的纠偏实现？"><a href="#js-中倒计时的纠偏实现？" class="headerlink" title="*js 中倒计时的纠偏实现？"></a>*js 中倒计时的纠偏实现？</h2><p>在前端实现中我们一般通过 setTimeout 和 setInterval 方法来实现一个倒计时效果。但是使用这些方法会存在时间偏差的问题，这是由于 js 的程序执行机制造成的，setTimeout 和 setInterval 的作用是隔一段时间将回调事件加入到事件队列中，因此事件并不是立即执行的，它会<strong>等到当前执行栈为空的时候再取出事件执行</strong>，因此事件等待执行的时间就是造成误差的原因。</p>
<p>一般解决倒计时中的误差的有这样两种办法：</p>
<p>（1）第一种是通过前端定时向服务器发送请求获取最新的时间差，以此来校准倒计时时间。</p>
<p>（2）第二种方法是前端根据偏差时间来自动调整间隔时间的方式来实现的。这一种方式首先是以 setTimeout 递归的方式来实现倒计时，然后通过一个变量来记录已经倒计时的秒数。每一次函数调用的时候，首先将变量加一，然后根据这个变量和每次的间隔时间，我们就可以计算出此时无偏差时应该显示的时间。然后将当前的真实时间与这个时间相减，这样我们就可以得到时间的偏差大小，因此我们在设置下一个定时器的间隔大小的时候，我们就从间隔时间中减去这个偏差大小，以此来实现由于程序执行所造成的时间误差的纠正。</p>
<h2 id="V8-下的垃圾回收机制是怎么样的？"><a href="#V8-下的垃圾回收机制是怎么样的？" class="headerlink" title="V8 下的垃圾回收机制是怎么样的？"></a>V8 下的垃圾回收机制是怎么样的？</h2><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>
<h3 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h3><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p>
<p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>
<h3 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h3><p>什么情况下对象会出现在老生代空间中：</p>
<ul>
<li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li>
<li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li>
</ul>
<p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是<strong>标记清除算法</strong>和<strong>标记压缩算法</strong>。在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>某一个空间没有分块的时候</li>
<li>空间中被对象超过一定限制</li>
<li>空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<h1 id="JavaScript-实现"><a href="#JavaScript-实现" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h1><h2 id="实现一个事件委托"><a href="#实现一个事件委托" class="headerlink" title="实现一个事件委托"></a>实现一个事件委托</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l1&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l2&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l3&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;l4&quot;</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>给li绑定事件，注意以上这种情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">element, eventType, selector, fn</span>) </span>&#123;</span><br><span class="line">  element.addEventListener(eventType, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> el = e.target</span><br><span class="line">      <span class="comment">// 如果元素被指定的选择器字符串选择，Element.matches()方法返回true</span></span><br><span class="line">      <span class="keyword">while</span> (!el.matches(selector)) &#123;</span><br><span class="line">          <span class="comment">// 遍历到最顶层，退出</span></span><br><span class="line">          <span class="keyword">if</span> (element === el) &#123;</span><br><span class="line">              el = <span class="literal">null</span></span><br><span class="line">              <span class="keyword">break</span></span><br><span class="line">          &#125;</span><br><span class="line">          el = el.parentNode</span><br><span class="line">      &#125;</span><br><span class="line">      el &amp;&amp; <span class="built_in">console</span>.log(<span class="string">&#x27;执行回调函数&#x27;</span>)</span><br><span class="line">  &#125;,<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">return</span> element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现一个可以拖拽的DIV"><a href="#实现一个可以拖拽的DIV" class="headerlink" title="实现一个可以拖拽的DIV"></a>实现一个可以拖拽的DIV</h2><p>一个元素的拖拽过程，我们可以分为三个步骤，第一步是鼠标按下目标元素，第二步是鼠标保持按下的状态移动鼠标，第三步是鼠标抬起，拖拽过程结束。三个鼠标事件：点击、移动、抬起。</p>
<p>如果是图片，加入<code>e.preventDefault();</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dv=<span class="built_in">document</span>.getElementById(<span class="string">&#x27;dv&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> isDrag=<span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> position=<span class="literal">null</span></span><br><span class="line">dv.addEventListener(<span class="string">&#x27;mousedown&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    isDrag=<span class="literal">true</span></span><br><span class="line">    position=[e.clientX,e.clientY]</span><br><span class="line">&#125;)</span><br><span class="line">dv.addEventListener(<span class="string">&#x27;mousemove&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isDrag) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">const</span> x=e.clientX</span><br><span class="line">    <span class="keyword">const</span> y=e.clientY</span><br><span class="line">    <span class="keyword">const</span> changeX=x-position[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> changeY=y-position[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> left=<span class="built_in">parseInt</span>(dv.style.left||<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> top=<span class="built_in">parseInt</span>(dv.style.top||<span class="number">0</span>)</span><br><span class="line">    dv.style.left=left+changeX+<span class="string">&#x27;px&#x27;</span></span><br><span class="line">    dv.style.top=top+changeY+<span class="string">&#x27;px&#x27;</span></span><br><span class="line">    position=[x,y]</span><br><span class="line">&#125;)</span><br><span class="line">dv.addEventListener(<span class="string">&#x27;mouseup&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    isDrag=<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="实现数组去重？"><a href="#实现数组去重？" class="headerlink" title="实现数组去重？"></a>实现数组去重？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,  <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;1&#x27;</span>), <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;1&#x27;</span>), <span class="regexp">/a/</span>, <span class="regexp">/a/</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Set</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unique_1 = <span class="function"><span class="params">arr</span> =&gt;</span> [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"><span class="comment">// 例子:</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Arr_new = [].concat.apply([],<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(Arr_new))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> demo1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], demo2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>], demo3 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(fn(demo1,demo2,demo3))<span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure></li>
<li><p>filter</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique_2</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = array.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> array.indexOf(item) === index;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>reduce</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unique_3 = <span class="function"><span class="params">arr</span> =&gt;</span> arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre.includes(cur) ? pre : [...pre, cur],[]);</span><br></pre></td></tr></table></figure></li>
<li><p>双重for循环</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique_4</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[i] === array[j]) &#123;</span><br><span class="line">        array.splice(j, <span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Object 键值对(效果最好)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique_5</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> array.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="实现函数柯里化"><a href="#实现函数柯里化" class="headerlink" title="实现函数柯里化"></a>实现函数柯里化</h2><p>柯里化就是把接受<strong>「多个参数」</strong>的函数变换成接受一个<strong>「单一参数」</strong>的函数，并且返回接受<strong>「余下参数」</strong>返回结果的一种应用。具体实现参考自<a target="_blank" rel="noopener" href="https://zh.javascript.info/currying-partials">该文章</a>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断参数的长度是否满足函数所需参数的长度</span></span><br><span class="line">    <span class="keyword">if</span> (args.length &gt;= func.length) &#123;</span><br><span class="line">      <span class="comment">// 满足则执行函数</span></span><br><span class="line">      <span class="keyword">return</span> func.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则递归返回柯里化的函数，等待下一个参数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> curried.apply(<span class="built_in">this</span>, args.concat(args2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">let</span> currying = <span class="function">(<span class="params">fn, ...args</span>) =&gt;</span></span><br><span class="line">            fn.length &gt; args.length ?</span><br><span class="line">            <span class="function">(<span class="params">...<span class="built_in">arguments</span></span>) =&gt;</span> currying(fn, ...args, ...arguments) :</span><br><span class="line">            fn(...args)</span><br></pre></td></tr></table></figure>

<h2 id="实现数组扁平化"><a href="#实现数组扁平化" class="headerlink" title="实现数组扁平化"></a>实现数组扁平化</h2><p>使用 reduce、concat 和递归展开无限多层嵌套的数组，详情见<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat#reduce_concat_isarray_recursivity">MDN reduce应用</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flat</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.flat(num)</span><br><span class="line"><span class="comment">//正经写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatDeep</span>(<span class="params">arr, d = <span class="number">1</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> d &gt; <span class="number">0</span> ? arr.reduce(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc.concat(<span class="built_in">Array</span>.isArray(val) ? flatDeep(val, d - <span class="number">1</span>) : val), []) : arr.slice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现拷贝"><a href="#实现拷贝" class="headerlink" title="实现拷贝"></a>实现拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>1、Object.assign()实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> initalObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br></pre></td></tr></table></figure>

<p>2、函数库lodash的_.clone方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = _.clone(obj1);</span><br></pre></td></tr></table></figure>

<p>3、展开运算符…</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2= &#123;...obj1&#125;</span><br></pre></td></tr></table></figure>

<p>4、Array.prototype.concat()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = arr.concat();    </span><br></pre></td></tr></table></figure>

<p>5、Array.prototype.slice()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = arr.slice();</span><br></pre></td></tr></table></figure>



<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>1、参考自<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020255831">如何写出一个惊艳面试官的深拷贝?</a>，讲的真的很详细！但是剩下的很多好没有实现。</p>
<ul>
<li>基本实现<ul>
<li><input checked="" disabled="" type="checkbox"> 递归能力</li>
</ul>
</li>
<li>循环引用<ul>
<li><input checked="" disabled="" type="checkbox"> 考虑问题的全面性</li>
<li><input checked="" disabled="" type="checkbox"> 理解weakmap的真正意义</li>
</ul>
</li>
<li>多种类型<ul>
<li><input disabled="" type="checkbox"> 考虑问题的严谨性</li>
<li><input disabled="" type="checkbox"> 创建各种引用类型的方法，JS API的熟练程度</li>
<li><input disabled="" type="checkbox"> 准确的判断数据类型，对数据类型的理解程度</li>
</ul>
</li>
<li>通用遍历：<ul>
<li><input disabled="" type="checkbox"> 写代码可以考虑性能优化</li>
<li><input disabled="" type="checkbox"> 了解集中遍历的效率</li>
<li><input disabled="" type="checkbox"> 代码抽象能力</li>
</ul>
</li>
<li>拷贝函数：<ul>
<li><input disabled="" type="checkbox"> 箭头函数和普通函数的区别</li>
<li><input disabled="" type="checkbox"> 正则表达式熟练程度</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (target === <span class="literal">null</span> || <span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">  <span class="comment">// 利用map解决循环引用问题 weakMap减少内存消耗</span></span><br><span class="line">  <span class="keyword">if</span> (map.has(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.get(target)</span><br><span class="line">  &#125;</span><br><span class="line">  map.set(target, cloneTarget)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">    cloneTarget[key] = clone(target[key],map)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、对象只有一层的话可以使用Object.assign()函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> initalObj = <span class="built_in">Object</span>.assign(&#123;&#125;, obj);</span><br></pre></td></tr></table></figure>

<p>3、用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。局限性：</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cloneObj = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str, newobj = obj.constructor === <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.JSON)&#123;</span><br><span class="line">        str = <span class="built_in">JSON</span>.stringify(obj), <span class="comment">//系列化对象</span></span><br><span class="line">        newobj = <span class="built_in">JSON</span>.parse(str); <span class="comment">//还原</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            newobj[i] = <span class="keyword">typeof</span> obj[i] === <span class="string">&#x27;object&#x27;</span> ? </span><br><span class="line">            cloneObj(obj[i]) : obj[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4、函数库lodash的_.cloneDeep方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = _.cloneDeep(obj1);</span><br></pre></td></tr></table></figure>

<h2 id="手写-call、apply-及-bind-函数"><a href="#手写-call、apply-及-bind-函数" class="headerlink" title="手写 call、apply 及 bind 函数"></a>手写 call、apply 及 bind 函数</h2><p>call 函数的实现步骤：</p>
<ul>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有传或传的值为空对象 context 指向 window</span></span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="comment">// fn 需要是一个唯一值</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>(context), result=<span class="literal">null</span></span><br><span class="line">  <span class="comment">// 给 context 添加一个方法 指向 this (this就是触发的函数)</span></span><br><span class="line">  context[fn] = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 处理参数 去除第一个参数this 其它传入fn函数</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 执行 fn</span></span><br><span class="line">  result = context[fn](...args)</span><br><span class="line">  <span class="comment">// 删除方法</span></span><br><span class="line">  <span class="keyword">delete</span> context[fn] </span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>apply 函数的实现步骤：</p>
<ul>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>(context), result=<span class="literal">null</span></span><br><span class="line">  context[fn] = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">let</span> arg = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  result = context[fn](arg)</span><br><span class="line">  <span class="keyword">delete</span> context[fn]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bind 函数的实现步骤：</p>
<ul>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...newArgs</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 由于支持柯里化形式传参, newArgs 保存第二次参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.call(context,...args, ...newArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new-操作符具体干了什么？如何实现？"><a href="#new-操作符具体干了什么？如何实现？" class="headerlink" title="new 操作符具体干了什么？如何实现？"></a>new 操作符具体干了什么？如何实现？</h2><p>在调用 <code>new</code> 的过程中会发生以下四件事情：</p>
<p>（1）首先创建一个新的空对象<br>（2）设置原型，将对象的原型设置为函数的 prototype 对象。<br>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）<br>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">// Constructor 是 arguments 中第一个元素, args 为剩余值 Constructor =&gt; [Function: fn]</span></span><br><span class="line">  <span class="keyword">let</span> [Constructor, ...args] = [...arguments];</span><br><span class="line">  <span class="comment">// 将 obj 的原型指向构造函数, 这样 obj 就可以访问到构造函数原型中的属性</span></span><br><span class="line">  obj.__proto__ = Constructor.prototype;</span><br><span class="line">  <span class="comment">// 使用 apply, 改变构造函数 this 的指向到新建的对象, 这样 obj 就可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">let</span> result = Constructor.apply(obj, args);</span><br><span class="line">  <span class="comment">// 判断函数的返回值类型, 如果是值类型, 返回创建的对象。如果是引用类型, 就返回这个引用类型的对象。</span></span><br><span class="line">  <span class="keyword">if</span> (result &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">&#x27;function&#x27;</span> || <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实现instanceof"><a href="#实现instanceof" class="headerlink" title="实现instanceof"></a>实现instanceof</h2><p>instanceof 运算符用于判断构造函数的 <code>prototype</code> 属性是否出现在对象的原型链 <code>__proto__</code> 中的任何位置。可参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903613584654344">浅谈 instanceof 和 typeof 的实现原理</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">leftValue, rightValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> leftVaule !== <span class="string">&#x27;object&#x27;</span> || leftVaule === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> leftproto = <span class="built_in">Object</span>.getPrototypeOf(leftValue), <span class="comment">// 获取左边对象的原型。getPrototypeOf 方法返回指定对象的原型，等同于 __proto__</span></span><br><span class="line">    prototype = rightValue.prototype; <span class="comment">// 获取右边构造函数的 prototype 对象</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 若 leftproto === null 退出查找</span></span><br><span class="line">    <span class="keyword">if</span> (!leftproto) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (leftproto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    leftproto = <span class="built_in">Object</span>.getPrototypeOf(leftproto);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数、原型、原型链之间的关系如下图：<img src="https://i.loli.net/2021/07/21/kfuqgFARIGJnPjM.jpg" alt="Snipaste_2021-07-21_11-00-06.jpg"></p>
<h2 id="实现sleep"><a href="#实现sleep" class="headerlink" title="实现sleep"></a>实现sleep</h2><p>某个时间后就去执行某个函数，使用Promise封装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(fn)</span><br><span class="line">    &#125;,time)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">autoPlay</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> sleep(fn(),<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">await</span> sleep(fn(),<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现数组reduce"><a href="#实现数组reduce" class="headerlink" title="实现数组reduce"></a>实现数组reduce</h2><p>更多的实现数组方法见<a target="_blank" rel="noopener" href="https://juejin.cn/post/6846687601806557192#comment">「数组方法」从详细操作js数组到浅析v8中array.js</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.myReduce = <span class="function"><span class="keyword">function</span> (<span class="params">fn, initValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initValue === <span class="literal">undefined</span> &amp;&amp; !<span class="built_in">this</span>.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;myReduce of empty array with no initial value&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// this 就是调用 myReduce 的数组</span></span><br><span class="line">  <span class="keyword">let</span> result = initValue ? initValue : <span class="built_in">this</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = initValue ? <span class="number">0</span> : <span class="number">1</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="comment">// acc cur index src</span></span><br><span class="line">    result = fn(result, <span class="built_in">this</span>[i], i, <span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="实现数组map"><a href="#实现数组map" class="headerlink" title="实现数组map"></a>实现数组map</h2><p>通过 <code>reduce</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> mapArray = arr.map(<span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> reduceArray = arr.reduce(<span class="function">(<span class="params">acc, current</span>) =&gt;</span> &#123;</span><br><span class="line">  acc.push(current * <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span> acc</span><br><span class="line">&#125;, [])</span><br><span class="line"><span class="built_in">console</span>.log(mapArray, reduceArray) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>



<h2 id="手写AJAX"><a href="#手写AJAX" class="headerlink" title="手写AJAX"></a>手写AJAX</h2><p>最简易版本</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    <span class="comment">// 2.创建http请求</span></span><br><span class="line">    request.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="comment">// 3.设置相应http请求状态变化的函数</span></span><br><span class="line">    request.onreadystatechange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt;<span class="number">300</span> || request.status == <span class="number">304</span>) &#123;</span><br><span class="line">                <span class="comment">// 5.获取异步调用返回的函数</span></span><br><span class="line">                <span class="keyword">let</span> string = request.responseText</span><br><span class="line">                <span class="keyword">let</span> object = <span class="built_in">JSON</span>.parse(string)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.发送http请求</span></span><br><span class="line">    request.send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用正则实现-trim"><a href="#用正则实现-trim" class="headerlink" title="用正则实现 trim()"></a>用正则实现 trim()</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trim = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ^开始, \s空格, +一或多个, |或, $结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">string</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> string.replace(<span class="regexp">/^\s+|\s+$/g</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现Object-create方法"><a href="#实现Object-create方法" class="headerlink" title="实现Object.create方法"></a>实现Object.create方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">proto</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 将原型挂在构造函数的prototype上</span></span><br><span class="line">    Fn.prototype = proto;</span><br><span class="line">    Fn.prototype.constructor = Fn;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/07/21/LaBIgJHGTkNV8QO.jpg" alt="Snipaste_2021-07-21_17-18-35.jpg"></p>
<h2 id="实现compose"><a href="#实现compose" class="headerlink" title="实现compose"></a>实现compose</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fn.length) <span class="keyword">return</span> <span class="function">(<span class="params">v</span>) =&gt;</span> v;</span><br><span class="line">  <span class="keyword">if</span> (fn.length === <span class="number">1</span>) <span class="keyword">return</span> fn[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> fn.reduce(</span><br><span class="line">    <span class="comment">// pre 第一个函数 cur 下一个函数</span></span><br><span class="line">    <span class="function">(<span class="params">pre, cur</span>) =&gt;</span></span><br><span class="line">      <span class="comment">// args 传入的参数 1-&gt;5-&gt;8-&gt;10-&gt;11</span></span><br><span class="line">      <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">        pre(cur(...args))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用法如下:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn3</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn4</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = compose(fn1, fn2, fn3, fn4);</span><br><span class="line"><span class="built_in">console</span>.log(a(<span class="number">1</span>)); <span class="comment">// 1+4+3+2+1=11</span></span><br></pre></td></tr></table></figure>



<h2 id="如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』"><a href="#如何将浮点数点左边的数每三位添加一个逗号，如-12000000-11-转化为『12-000-000-11』" class="headerlink" title="如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?"></a>如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</h2><ul>
<li><p>replace是字符串方法，需要先toString()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> number &amp;&amp; number.toString().replace(<span class="regexp">/(?!^)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">&quot;,&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>Intl</code> 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比。<code>Intl.NumberFormat</code>用于启用语言敏感数字格式的对象的构造函数。NumberFormat()为空就默认英美地区数字表达方式。</p>
</li>
<li><p>```js<br>function format1(number) {<br>  return Intl.NumberFormat().format(number)<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `toLocaleString()` 方法返回该对象的字符串，字符串格式因不同语言而不同。</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  function format2(number) &#123;</span><br><span class="line">    return number.toLocaleString(&#x27;en&#x27;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="如何实现数组的随机排序？"><a href="#如何实现数组的随机排序？" class="headerlink" title="如何实现数组的随机排序？"></a>如何实现数组的随机排序？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组 sort 方法对数组元素随机排序，让 Math.random() 出来的数与 0.5 比较，如果大于就返回 1 交换位置，如果小于就返回 -1，不交换位置。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  缺点：每个元素被派到新数组的位置不是随机的，原因是 sort() 方法是依次比较的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）随机从原数组抽取一个元素，加入到新数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">while</span> (arr.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * arr.length);</span><br><span class="line">    result.push(arr[randomIndex]);</span><br><span class="line">    arr.splice(randomIndex, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）随机交换数组内的元素（洗牌算法类似）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomSort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = array.length;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(array) || length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">    <span class="keyword">let</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (length - index)) + index;</span><br><span class="line">    [array[index], array[randomIndex]] = [array[randomIndex], array[index]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寄生式组合继承的实现？"><a href="#寄生式组合继承的实现？" class="headerlink" title="寄生式组合继承的实现？"></a>寄生式组合继承的实现？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;My name is &quot;</span> + <span class="built_in">this</span>.name + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = <span class="built_in">Object</span>.create(Person.prototype);</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">Student.prototype.sayMyGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;My grade is &quot;</span> + <span class="built_in">this</span>.grade + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="写一个通用的事件侦听器函数"><a href="#写一个通用的事件侦听器函数" class="headerlink" title="写一个通用的事件侦听器函数"></a>写一个通用的事件侦听器函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtils = &#123;</span><br><span class="line">  <span class="comment">// 视能力分别使用dom0||dom2||IE方式 来绑定事件</span></span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  <span class="attr">addEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">      element.attachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移除事件</span></span><br><span class="line">  <span class="attr">removeEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">      element.detachEvent(<span class="string">&quot;on&quot;</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">&quot;on&quot;</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取事件目标</span></span><br><span class="line">  <span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event.target || event.srcElement;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取 event 对象的引用，取到事件的所有信息，确保随时能使用 event</span></span><br><span class="line">  <span class="attr">getEvent</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> event || <span class="built_in">window</span>.event;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻止事件（主要是事件冒泡，因为 IE 不支持事件捕获）</span></span><br><span class="line">  <span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件的默认行为</span></span><br><span class="line">  <span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="实现-js-的节流与防抖（原理？）（高频）"><a href="#实现-js-的节流与防抖（原理？）（高频）" class="headerlink" title="实现 js 的节流与防抖（原理？）（高频）"></a>实现 js 的节流与防抖（原理？）（高频）</h2><ul>
<li><strong>函数防抖</strong>： 在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。完整版可以参考<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/22">JavaScript专题之跟着underscore学防抖</a>。</li>
<li><strong>函数节流</strong>： 规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。完整版可以参考<a target="_blank" rel="noopener" href="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着underscore学节流</a>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数防抖的实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">      timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置定时器，使事件间隔指定事件后执行</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现一（时间戳）;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">this</span>, args = <span class="built_in">arguments</span>, nowTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span></span><br><span class="line">    <span class="keyword">if</span> (nowTime - preTime &gt;= delay) &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">      preTime = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数节流的实现二（定时器）;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn,delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> valid=<span class="literal">true</span>, context = <span class="built_in">this</span>, args = <span class="built_in">arguments</span>, </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!valid)&#123;</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">        valid=<span class="literal">false</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            fn.apply(context,args)</span><br><span class="line">            valid=<span class="literal">true</span></span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么使用-setTimeout-实现-setInterval？怎么模拟？"><a href="#为什么使用-setTimeout-实现-setInterval？怎么模拟？" class="headerlink" title="为什么使用 setTimeout 实现 setInterval？怎么模拟？"></a>为什么使用 setTimeout 实现 setInterval？怎么模拟？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mySetInterval</span>(<span class="params">fn, timeout</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制器，控制定时器是否继续执行</span></span><br><span class="line">  <span class="keyword">var</span> timer = &#123;</span><br><span class="line">    <span class="attr">flag</span>: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置递归函数，模拟定时器执行。</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">interval</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer.flag) &#123;</span><br><span class="line">      fn();</span><br><span class="line">      <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动定时器</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(interval, timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回控制器</span></span><br><span class="line">  <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写一个-Promise"><a href="#手写一个-Promise" class="headerlink" title="手写一个 Promise"></a>手写一个 Promise</h2><p>参考了**<a href="https://link.zhihu.com/?target=https://github.com/xieranmaya/blog/issues/3">剖析 Promise 内部结构，一步一步实现一个完整的、能通过所有 Test case 的 Promise 类</a>**，其中<code>不同Promise的交互</code>问题仍为解决，有待后续补充。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  self.status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  self.data = <span class="literal">undefined</span>;</span><br><span class="line">  self.onResolvedCallback = [];</span><br><span class="line">  self.onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 异步执行所有的回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        self.status = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line">        self.data = value</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class="line">          self.onResolvedCallback[i](value)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 异步执行所有的回调函数</span></span><br><span class="line">      <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        self.status = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">        self.data = reason</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">          self.onRejectedCallback[i](reason)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> value &#125;;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123; <span class="keyword">return</span> reason &#125;;</span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 异步执行onResolved</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data);</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">          &#125; ibian</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 异步执行onRejected</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> x = onRejected(self.data);</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// resolve(x)</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 catch</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 finally</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里所有的then调用是一起的，但是这个then里调用fn又异步了一次，所以它总是最后调用的。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn)</span><br><span class="line">    <span class="keyword">throw</span> reason</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 all</span></span><br><span class="line"><span class="built_in">Promise</span>.myall = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> resolve([])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> res = [], count = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 同时也能处理arr数组中非Promise对象</span></span><br><span class="line">        <span class="keyword">if</span> (!(arr[i] <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">          res[i] = arr[i]</span><br><span class="line">          <span class="keyword">if</span> (++count === arr.length)</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          arr[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            res[i] = data</span><br><span class="line">            <span class="keyword">if</span> (++count === arr.length)</span><br><span class="line">              resolve(res)</span><br><span class="line">          &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">              reject(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 race</span></span><br><span class="line"><span class="built_in">Promise</span>.myrace = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(arr[i] <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.resolve(arr[i]).then(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        arr[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何封装一个-javascript-的类型判断函数？"><a href="#如何封装一个-javascript-的类型判断函数？" class="headerlink" title="如何封装一个 javascript 的类型判断函数？"></a>如何封装一个 javascript 的类型判断函数？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getType</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断数据是 null 的情况</span></span><br><span class="line">  <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">&quot;&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断数据是引用类型的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valueClass = <span class="built_in">Object</span>.prototype.toString.call(value),</span><br><span class="line">      type = valueClass.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>].split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    type.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> type.join(<span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 判断数据是基本数据类型的情况和函数的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写一个-jsonp"><a href="#手写一个-jsonp" class="headerlink" title="手写一个 jsonp"></a>手写一个 jsonp</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, params, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否含有参数</span></span><br><span class="line">  <span class="keyword">let</span> queryString = url.indexOf(<span class="string">&quot;?&quot;</span>) === -<span class="number">1</span> ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加参数</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.hasOwnProperty(k)) &#123;</span><br><span class="line">      queryString += k + <span class="string">&quot;=&quot;</span> + params[k] + <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理回调函数名</span></span><br><span class="line">  <span class="keyword">let</span> random = <span class="built_in">Math</span>.random()</span><br><span class="line">      .toString()</span><br><span class="line">      .replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">    callbackName = <span class="string">&quot;myJsonp&quot;</span> + random;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加回调函数</span></span><br><span class="line">  queryString += <span class="string">&quot;callback=&quot;</span> + callbackName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建请求</span></span><br><span class="line">  <span class="keyword">let</span> scriptNode = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  scriptNode.src = url + queryString;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>[callbackName] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用回调函数</span></span><br><span class="line">    callback(...arguments);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除这个引入的脚本</span></span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].removeChild(scriptNode);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起请求</span></span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(scriptNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写一个观察者模式？"><a href="#手写一个观察者模式？" class="headerlink" title="手写一个观察者模式？"></a>手写一个观察者模式？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> topics = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 注册监听函数</span></span><br><span class="line">    <span class="attr">subscribe</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      topics[topic].push(handler);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布事件，触发观察者回调事件</span></span><br><span class="line">    <span class="attr">publish</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, info</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">          handler(info);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的一个观察者的回调事件</span></span><br><span class="line">    <span class="attr">remove</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic, handler</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!topics.hasOwnProperty(topic)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> handlerIndex = -<span class="number">1</span>;</span><br><span class="line">      topics[topic].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (item === handler) &#123;</span><br><span class="line">          handlerIndex = index;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (handlerIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        topics[topic].splice(handlerIndex, <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除主题的所有观察者的回调事件</span></span><br><span class="line">    <span class="attr">removeAll</span>: <span class="function"><span class="keyword">function</span>(<span class="params">topic</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (topics.hasOwnProperty(topic)) &#123;</span><br><span class="line">        topics[topic] = [];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="EventEmitter-实现"><a href="#EventEmitter-实现" class="headerlink" title="EventEmitter 实现"></a>EventEmitter 实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">on</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event] || [];</span><br><span class="line">    callbacks.push(callback);</span><br><span class="line">    <span class="built_in">this</span>.events[event] = callbacks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">off</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event];</span><br><span class="line">    <span class="built_in">this</span>.events[event] = callbacks &amp;&amp; callbacks.filter(<span class="function"><span class="params">fn</span> =&gt;</span> fn !== callback);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">emit</span>(<span class="params">event, ...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> callbacks = <span class="built_in">this</span>.events[event];</span><br><span class="line">    callbacks.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">      fn(...args);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">once</span>(<span class="params">event, callback</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> wrapFun = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      callback(...args);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.off(event, wrapFun);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.on(event, wrapFun);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="JavaScript代码题"><a href="#JavaScript代码题" class="headerlink" title="JavaScript代码题"></a>JavaScript代码题</h1><h2 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h2><p>parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，其中 radix 表示要解析的数字的基数。（该值介于 2 ~ 36 之间，并且字符串中的数字不能大于 radix 才能正确返回数字结果值）。当参数 <code>radix</code> 的值为 <code>0</code>，或没有设置该参数时，<code>parseInt()</code> 会根据 <code>string</code> 来判断数字的基数。</p>
<p>此处 map 传了 3 个参数 (element, index, array)，默认第三个参数被忽略掉，因此三次传入的参数分别为 “1-0”, “2-1”, “3-2”</p>
<p>因为字符串的值不能大于基数，因此后面两次调用均失败，返回 NaN ，第一次基数为 0 ，按十进制解析返回 1。 [ 1, NaN, NaN ]</p>
<h2 id="forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？"><a href="#forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-能解释一下这段代码的意思吗？" class="headerlink" title="[].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？"></a><code>[].forEach.call($$(&quot;*&quot;),function(a)&#123;a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)&#125;)</code> 能解释一下这段代码的意思吗？</h2><p>（1）选取页面所有 DOM 元素。<br>在浏览器的控制台中可以使用$$()方法来获取页面中相应的元素，这是现代浏览器提供的一个命令行 API 相当于 document.querySelectorAll 方法。</p>
<p>（2）循环遍历 DOM 元素。</p>
<p>（3）给元素添加 outline 。<br>由于渲染的 outline 是不在 CSS 盒模型中的，所以为元素添加 outline 并不会影响元素的大小和页面的布局。</p>
<p>（4）生成随机颜色函数。<br>Math.random()*(1&lt;&lt;24) 可以得到 0~2^24 - 1 之间的随机数，因为得到的是一个浮点数，但我们只需要整数部分，使用取反操作符 ~ 连续两次取反获得整数部分，然后再用 toString(16) 的方式，转换为一个十六进制的字符串。</p>
<h2 id="下面这个JS程序的输出是什么？"><a href="#下面这个JS程序的输出是什么？" class="headerlink" title="下面这个JS程序的输出是什么？"></a>下面这个JS程序的输出是什么？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f1 = Foo(),</span><br><span class="line">    f2 = Foo();</span><br><span class="line">f1();</span><br><span class="line">f1();</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure>

<p>这道题考察<strong>闭包</strong>和<strong>引用类型对象</strong>的知识点：</p>
<ul>
<li>一般来说函数执行完后它的局部变量就会随着函数调用结束被销毁，但是 Foo() 返回了一个匿名函数的引用（即一个<strong>闭包</strong>），它可以访问到 Foo() 被调用产生的环境，而局部变量 i 一直处在这个环境中，只要一个环境有可能被访问到，它就不会被销毁，所以说<strong>闭包有延续变量作用域的功能</strong>。前两次输出 0 1。</li>
<li>Foo() 返回的是一个匿名函数，所以 f1，f2 相当于指向了两个不同的函数对象，最后输出 0。</li>
</ul>
<h2 id="下面代码的结果？"><a href="#下面代码的结果？" class="headerlink" title="下面代码的结果？"></a>下面代码的结果？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(([])?<span class="literal">true</span>:<span class="literal">false</span>); </span><br><span class="line"><span class="built_in">console</span>.log(([]==<span class="literal">false</span>?<span class="literal">true</span>:<span class="literal">false</span>)); </span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;==<span class="literal">false</span>)?<span class="literal">true</span>:<span class="literal">false</span>) </span><br></pre></td></tr></table></figure>

<p>题目的类型转换结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>([]); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Number</span>([]); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">Number</span>(&#123;&#125;); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<p>因此：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(([])?<span class="literal">true</span>:fasle);<span class="comment">// =&gt; console.log((true)?true:false);</span></span><br><span class="line"><span class="built_in">console</span>.log([]==<span class="literal">false</span>?<span class="literal">true</span>:<span class="literal">false</span>); <span class="comment">// =&gt; console.log(0==0?true:false);</span></span><br><span class="line"><span class="built_in">console</span>.log((&#123;&#125;==<span class="literal">false</span>)?<span class="literal">true</span>:<span class="literal">false</span>); <span class="comment">// =&gt; console.log((NaN==0)?true:false);</span></span><br></pre></td></tr></table></figure>

<h2 id="下面代码的结果？-1"><a href="#下面代码的结果？-1" class="headerlink" title="下面代码的结果？"></a>下面代码的结果？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line">  alert(<span class="string">&#x27;hi&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">Boolean</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (y) &#123;</span><br><span class="line">  alert(<span class="string">&#x27;hello&#x27;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>if(x) 这里期望 x 是一个布尔类型的原始值，而 x 是一个对象，<strong>任何对象转为布尔值，都为得到 true</strong>（切记！在 JS 中，只有 0，-0，NaN，””，null，undefined 这六个值转布尔值时，结果为 false）。</li>
</ul>
<h2 id="下面代码的结果？-2"><a href="#下面代码的结果？-2" class="headerlink" title="下面代码的结果？"></a>下面代码的结果？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);   <span class="comment">//2-&gt;2</span></span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);   <span class="comment">//6-&gt;6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);   <span class="comment">//5-&gt;3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);     <span class="comment">//1-&gt;1</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);   <span class="comment">//8-&gt;8</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);   <span class="comment">//3-&gt;4</span></span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);   <span class="comment">//7-&gt;7</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);   <span class="comment">//4-&gt;5</span></span><br></pre></td></tr></table></figure>

<p>执行 async1() 时会调用 async2() ，然后输出 async2，此时将会保留 async1 函数的上下文，然后跳出 async1 函数。</p>
<p>await将直接使用Promise.resolve()相同语义。</p>
<h2 id="‘1’-’2’-’3’-map-parseInt-的返回值？"><a href="#‘1’-’2’-’3’-map-parseInt-的返回值？" class="headerlink" title="[‘1’,’2’,’3’].map(parseInt)的返回值？"></a>[‘1’,’2’,’3’].map(parseInt)的返回值？</h2><p>[1, NaN, NaN]</p>
<p>map方法中接受一个函数 function，一共可以接收三个参数，其中第一个参数代表当前被处理的元素，第二个参数代表该元素的索引（默认有）。</p>
<p>parseInt是用来解析字符串，使字符串成为指定基数的整数 <code>parseInt(string, radix)</code> adix是一个介于2-36之间的整数，返回解析后的整数值。</p>
<ul>
<li>parseInt(‘1’, 0); // radix为0时，使用默认的10进制。</li>
<li>parseInt(‘2’, 1); // radix值在2-36，无法解析，返回NaN</li>
<li>parseInt(‘3’, 2); // 基数为2，2进制数表示的数中，最大值小于3，无法解析，返回NaN</li>
</ul>
<p>变成[1,2,3]：</p>
<ul>
<li>[“1”,”2”,”3”].map(Number)</li>
<li>[“1”,”2”,”3”].map(v =&gt; +v);</li>
</ul>
<h2 id="使用-JS-实现获取文件扩展名？"><a href="#使用-JS-实现获取文件扩展名？" class="headerlink" title="使用 JS 实现获取文件扩展名？"></a>使用 JS 实现获取文件扩展名？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String.lastIndexOf() 方法返回指定值（本例中的&#x27;.&#x27;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于 &#x27;filename&#x27; 和 &#x27;.hiddenfile&#x27; ，lastIndexOf 的返回值分别为 0 和 -1 无符号右移操作符(&gt;&gt;&gt;) 将 -1 转换为 4294967295 ，将 -2 转换为 4294967294 ，这个方法可以保证边缘情况时文件名不变。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFileExtension</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> filename.slice(((filename.lastIndexOf(<span class="string">&quot;.&quot;</span>) - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">0</span>) + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何判断一个对象是否为空对象？"><a href="#如何判断一个对象是否为空对象？" class="headerlink" title="如何判断一个对象是否为空对象？"></a>如何判断一个对象是否为空对象？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkNullObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span> &amp;&amp; <span class="built_in">Object</span>.getOwnPropertySymbols(obj).length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用闭包实现每隔一秒打印-1-2-3-4"><a href="#使用闭包实现每隔一秒打印-1-2-3-4" class="headerlink" title="使用闭包实现每隔一秒打印 1,2,3,4"></a>使用闭包实现每隔一秒打印 1,2,3,4</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用闭包实现</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 let 块级作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一道常被人轻视的前端-JS-面试题"><a href="#一道常被人轻视的前端-JS-面试题" class="headerlink" title="一道常被人轻视的前端 JS 面试题"></a>一道常被人轻视的前端 JS 面试题</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName(); <span class="comment">// 2</span></span><br><span class="line">getName(); <span class="comment">// 4</span></span><br><span class="line">Foo().getName(); <span class="comment">// 1</span></span><br><span class="line">getName(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h2 id="如何查找一篇英文文章中出现频率最高的单词？"><a href="#如何查找一篇英文文章中出现频率最高的单词？" class="headerlink" title="如何查找一篇英文文章中出现频率最高的单词？"></a>如何查找一篇英文文章中出现频率最高的单词？</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMostWord</span>(<span class="params">article</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 合法性判断</span></span><br><span class="line">  <span class="keyword">if</span> (!article) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数处理</span></span><br><span class="line">  article = article.trim().toLowerCase();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> wordList = article.match(<span class="regexp">/[a-z]+/g</span>),</span><br><span class="line">    visited = [],</span><br><span class="line">    maxNum = <span class="number">0</span>,</span><br><span class="line">    maxWord = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  article = <span class="string">&quot; &quot;</span> + wordList.join(<span class="string">&quot;  &quot;</span>) + <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历判断单词出现次数</span></span><br><span class="line">  wordList.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.indexOf(item) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加入 visited </span></span><br><span class="line">      visited.push(item);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> word = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot; &quot;</span> + item + <span class="string">&quot; &quot;</span>, <span class="string">&quot;g&quot;</span>),</span><br><span class="line">        num = article.match(word).length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num &gt; maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">        maxWord = item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxWord + <span class="string">&quot;  &quot;</span> + maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大数相加"><a href="#大数相加" class="headerlink" title="大数相加"></a>大数相加</h2><p>参考自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/72179476">JS 实现两个大数相加？</a>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/">https://asura1211.github.io/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/"><img class="prev-cover" src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【面试准备】— — Vue篇</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/"><img class="next-cover" src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【面试准备】— — 浏览器工作原理篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/06/06/【阅读笔记】— — pink老师js进阶/" title="【阅读笔记】— — pink老师js进阶"><img class="cover" src="https://i.loli.net/2021/06/07/3boUIdzwVjvaMu6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-06</div><div class="title">【阅读笔记】— — pink老师js进阶</div></div></a></div><div><a href="/2021/06/24/【阅读笔记】— — 你不知道的JavaScript（上）/" title="【阅读笔记】— — 你不知道的JavaScript（上）"><img class="cover" src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-25</div><div class="title">【阅读笔记】— — 你不知道的JavaScript（上）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">JavaScript 基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-number">2.1.</span> <span class="toc-text">js 中的命名规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">js 的基本数据类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E6%9C%89%E5%87%A0%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">JavaScript 有几种类型的值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7-Class-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">内部属性 [[Class]] 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">js 有哪些内置对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined-%E4%B8%8E-undeclared-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">undefined 与 undeclared 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">null 和 undefined 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-of-%E5%92%8C-for-in-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">for of 和 for in 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-%E5%92%8C-instanceof-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">typeof 和 instanceof 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let%EF%BC%8Cconst%EF%BC%8Cvar-%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.10.</span> <span class="toc-text">let，const，var 区别？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#document-ready-%E5%92%8C-onload-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">document.ready 和 onload 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AE%89%E5%85%A8%E7%9A%84-undefined-%E5%80%BC%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">如何获取安全的 undefined 值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E5%87%A0%E6%9D%A1%E5%86%99-JavaScript-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">说几条写 JavaScript 的基本规范？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.14.</span> <span class="toc-text">JavaScript 原型，原型链？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">JavaScript 中的作用域与变量声明提升？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">JavaScript 的作用域链？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-This-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.17.</span> <span class="toc-text">谈谈 This 对象的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84-this"><span class="toc-number">2.17.1.</span> <span class="toc-text">箭头函数的 this</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.18.</span> <span class="toc-text">箭头函数和普通函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">new 的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call-%E3%80%81apply-%E5%92%8C-bind-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.20.</span> <span class="toc-text">call() 、apply() 和 bind() 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E4%B8%AD%E6%95%B4%E6%95%B0%E7%9A%84%E5%AE%89%E5%85%A8%E8%8C%83%E5%9B%B4%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">2.21.</span> <span class="toc-text">js 中整数的安全范围是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E4%B8%AD%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.22.</span> <span class="toc-text">ES6 中有使用过什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-NaN-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">typeof NaN 的结果是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isNaN-%E5%92%8C-Number-isNaN-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.24.</span> <span class="toc-text">isNaN 和 Number.isNaN 函数的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">2.25.</span> <span class="toc-text">转换规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#To-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.25.1.</span> <span class="toc-text">To 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#To-%E6%95%B0%E5%AD%97%E5%80%BC"><span class="toc-number">2.25.2.</span> <span class="toc-text">To 数字值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#To-%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">2.25.3.</span> <span class="toc-text">To 布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%EF%BC%88%E6%8B%86%E7%AE%B1%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">2.25.4.</span> <span class="toc-text">对象转原始类型（拆箱转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.25.5.</span> <span class="toc-text">四则运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.25.6.</span> <span class="toc-text">比较运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84-valueOf-%E5%92%8C-toString-%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.26.</span> <span class="toc-text">{} 和 [] 的 valueOf 和 toString 的结果是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.27.</span> <span class="toc-text">~ 操作符的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eval-%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number">2.28.</span> <span class="toc-text">eval 是做什么的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-DOM-%E5%92%8C-BOM%EF%BC%9F"><span class="toc-number">2.29.</span> <span class="toc-text">什么是 DOM 和 BOM？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E5%92%8C%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.30.</span> <span class="toc-text">解析字符串中的数字和将字符串强制类型转换为数字之间的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E5%80%BC%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">2.31.</span> <span class="toc-text">布尔值的隐式强制类型转换？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-amp-amp-%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="toc-number">2.32.</span> <span class="toc-text">|| 和 &amp;&amp; 操作符的返回值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99%EF%BC%9F"><span class="toc-number">2.33.</span> <span class="toc-text">&#x3D;&#x3D; 操作符的强制类型转换规则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-is-%E4%B8%8E%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6-%E2%80%9C-%E2%80%9D%E3%80%81%E2%80%9C-%E2%80%9D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.34.</span> <span class="toc-text">Object.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.34.1.</span> <span class="toc-text">类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E5%AD%97%EF%BC%8C%E4%BE%8B%E5%A6%82-%E2%80%9812-3b%E2%80%99"><span class="toc-number">2.35.</span> <span class="toc-text">如何将字符串转化为数字，例如 ‘12.3b’?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.36.</span> <span class="toc-text">常用正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.37.</span> <span class="toc-text">javascript 创建对象的几种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.38.</span> <span class="toc-text">JavaScript 继承的几种实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%AE%9E%E7%8E%B0%E8%A7%81%E5%AE%9E%E7%8E%B0%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">2.39.</span> <span class="toc-text">事件委托是什么？（实现见实现部分）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E5%A6%82%E4%BD%95%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="toc-number">2.40.</span> <span class="toc-text">JavaScript 如何绑定事件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.41.</span> <span class="toc-text">什么是闭包？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9Cuse-strict%E2%80%9D-%E7%9B%AE%E7%9A%84-%E4%BD%BF%E7%94%A8%E5%AE%83%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.42.</span> <span class="toc-text">“use strict” 目的 ? 使用它区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript%E7%9A%84%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.43.</span> <span class="toc-text">JavaScript的全局函数有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.44.</span> <span class="toc-text">如何判断一个对象是否属于某个类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E-JSON-%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.45.</span> <span class="toc-text">对于 JSON 的了解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NOSCRIPT-%E6%A0%87%E7%AD%BE%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">2.46.</span> <span class="toc-text">NOSCRIPT 标签是做什么用的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.47.</span> <span class="toc-text">js 延迟加载的方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-Ajax%EF%BC%9F%EF%BC%88%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%AF%87%E6%89%8B%E5%86%99Ajax%EF%BC%89"><span class="toc-number">2.48.</span> <span class="toc-text">Ajax 是什么? 如何创建一个 Ajax？（见实现篇手写Ajax）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88concurrency%EF%BC%89%E5%92%8C%E5%B9%B6%E8%A1%8C%EF%BC%88parallelism%EF%BC%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.49.</span> <span class="toc-text">并发（concurrency）和并行（parallelism）区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.50.</span> <span class="toc-text">同步和异步的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%9F"><span class="toc-number">2.51.</span> <span class="toc-text">为什么要使用模块化开发？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9D%97%E8%A7%84%E8%8C%83%EF%BC%9F"><span class="toc-number">2.52.</span> <span class="toc-text">js 的几种模块规范？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CommonJS-%E5%92%8C-ES-Module-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.53.</span> <span class="toc-text">CommonJS 和 ES Module 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AMD-%E5%92%8C-CMD-%E8%A7%84%E8%8C%83%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.54.</span> <span class="toc-text">* AMD 和 CMD 规范的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES6-%E6%A8%A1%E5%9D%97%E4%B8%8E-CommonJS-%E6%A8%A1%E5%9D%97%E3%80%81AMD%E3%80%81CMD-%E7%9A%84%E5%B7%AE%E5%BC%82%E3%80%82"><span class="toc-number">2.55.</span> <span class="toc-text">* ES6 模块与 CommonJS 模块、AMD、CMD 的差异。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#requireJS-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E5%A6%82%E4%BD%95%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E6%AC%A1%E5%8A%A0%E8%BD%BD%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95-%E7%BC%93%E5%AD%98%E7%9A%84%EF%BC%9F%EF%BC%89"><span class="toc-number">2.56.</span> <span class="toc-text">* requireJS 的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何 缓存的？）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#documen-write-%E5%92%8C-innerHTML-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.57.</span> <span class="toc-text">documen.write 和 innerHTML 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-%E6%93%8D%E4%BD%9C%E2%80%94%E2%80%94%E6%80%8E%E6%A0%B7%E6%B7%BB%E5%8A%A0%E3%80%81%E7%A7%BB%E9%99%A4%E3%80%81%E7%A7%BB%E5%8A%A8%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E6%89%BE%E8%8A%82%E7%82%B9%EF%BC%9F"><span class="toc-number">2.58.</span> <span class="toc-text">DOM 操作——怎样添加、移除、移动、复制、创建和查找节点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#innerHTML-%E4%B8%8E-outerHTML-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.59.</span> <span class="toc-text">innerHTML 与 outerHTML 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E7%B1%BB%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">2.60.</span> <span class="toc-text">JavaScript 类数组对象的定义？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.61.</span> <span class="toc-text">数组有哪些原生方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-filter-reduce-%E5%90%84%E8%87%AA%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.61.1.</span> <span class="toc-text">map, filter, reduce 各自有什么作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%9F"><span class="toc-number">2.62.</span> <span class="toc-text">[,,,] 的长度？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E8%AF%AD%E5%8F%A5%E6%9C%AB%E5%B0%BE%E5%88%86%E5%8F%B7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5%EF%BC%9F"><span class="toc-number">2.63.</span> <span class="toc-text">js 语句末尾分号是否可以省略？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84-Javascript-%EF%BC%9F"><span class="toc-number">2.64.</span> <span class="toc-text">如何编写高性能的 Javascript ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#escape%EF%BC%8CencodeURI%EF%BC%8CencodeURIComponent-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.65.</span> <span class="toc-text">*escape，encodeURI，encodeURIComponent 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unicode-%E5%92%8C-UTF-8-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">2.66.</span> <span class="toc-text">Unicode 和 UTF-8 之间的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A7%E8%A1%8C%E6%A0%88%EF%BC%9F"><span class="toc-number">2.67.</span> <span class="toc-text">什么是执行栈？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%EF%BC%88Event-Loop%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">2.68.</span> <span class="toc-text">js 的事件循环（Event Loop）是什么？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Node-%E4%B8%AD%E7%9A%84-Event-Loop-%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.69.</span> <span class="toc-text">Node 中的 Event Loop 和浏览器中的有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#process-nextTick-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">2.70.</span> <span class="toc-text">process.nextTick 执行顺序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.71.</span> <span class="toc-text">为什么 0.1 + 0.2 !&#x3D; 0.3？如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toPrecision-%E5%92%8C-toFixed-%E5%92%8C-Math-round-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.72.</span> <span class="toc-text">toPrecision 和 toFixed 和 Math.round 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVVM%EF%BC%9F%E6%AF%94%E4%B9%8B-MVC-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF-MVP-%EF%BC%9F"><span class="toc-number">2.73.</span> <span class="toc-text">*什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-Object-defineProperty-%EF%BC%9F"><span class="toc-number">2.74.</span> <span class="toc-text">介绍 Object.defineProperty ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Object-defineProperty-%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">2.74.1.</span> <span class="toc-text">使用 Object.defineProperty() 来进行数据劫持的缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Proxy-%EF%BC%9F"><span class="toc-number">2.75.</span> <span class="toc-text">什么是 Proxy ？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Proxy-%E4%B8%8E-Object-defineProperty-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.75.1.</span> <span class="toc-text">Proxy 与 Object.defineProperty 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-webpack-%E7%9A%84%E7%9C%8B%E6%B3%95"><span class="toc-number">2.76.</span> <span class="toc-text">*谈谈你对 webpack 的看法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#offsetWidth-offsetHeight%EF%BC%8CclientWidth-clientHeight-%E4%B8%8E-scrollWidth-scrollHeight-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.77.</span> <span class="toc-text">offsetWidth&#x2F;offsetHeight，clientWidth&#x2F;clientHeight 与 scrollWidth&#x2F;scrollHeight 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88%E4%BD%A0%E7%90%86%E8%A7%A3%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.78.</span> <span class="toc-text">谈一谈你理解的函数式编程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">2.79.</span> <span class="toc-text">回调地狱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.80.</span> <span class="toc-text">异步编程的实现方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Generator"><span class="toc-number">2.81.</span> <span class="toc-text">Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await"><span class="toc-number">2.82.</span> <span class="toc-text">async &#x2F; await</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await-%E4%B8%8E-Generator-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.83.</span> <span class="toc-text">async &#x2F; await 与 Generator 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Js-%E5%8A%A8%E7%94%BB%E4%B8%8E-CSS-%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.84.</span> <span class="toc-text">Js 动画与 CSS 动画区别及相应实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-%E8%AF%B7%E6%B1%82%E4%BC%A0%E5%8F%82%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA"><span class="toc-number">2.85.</span> <span class="toc-text">get 请求传参长度的误区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#URL-%E5%92%8C-URI-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.86.</span> <span class="toc-text">URL 和 URI 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#src-%E5%92%8C-href-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.87.</span> <span class="toc-text">src 和 href 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get-%E5%92%8C-post-%E8%AF%B7%E6%B1%82%E5%9C%A8%E7%BC%93%E5%AD%98%E6%96%B9%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.88.</span> <span class="toc-text">get 和 post 请求在缓存方面的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mouseover-%E5%92%8C-mouseenter-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.89.</span> <span class="toc-text">mouseover 和 mouseenter 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let-%E5%92%8C-const-%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F"><span class="toc-number">2.90.</span> <span class="toc-text">let 和 const 的注意点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E8%B0%83%E7%94%A8%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">2.91.</span> <span class="toc-text">什么是尾调用，有什么好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9%EF%BC%9F"><span class="toc-number">2.92.</span> <span class="toc-text">Symbol 类型的注意点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set-%E5%92%8C-map-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.93.</span> <span class="toc-text">set 和 map 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reflect-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E7%9B%AE%E7%9A%84%EF%BC%9F"><span class="toc-number">2.94.</span> <span class="toc-text">*Reflect 对象创建目的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#require-%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E7%9A%84%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.95.</span> <span class="toc-text">*require 模块引入的查找方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Promise-%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF-Promises-A-%E8%A7%84%E8%8C%83%EF%BC%9F"><span class="toc-number">2.96.</span> <span class="toc-text">什么是 Promise 对象，什么是 Promises&#x2F;A+ 规范？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.97.</span> <span class="toc-text">图片懒加载和预加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.98.</span> <span class="toc-text">*JavaScript 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.98.1.</span> <span class="toc-text">单例模式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.98.2.</span> <span class="toc-text">策略模式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.98.3.</span> <span class="toc-text">代理模式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.98.4.</span> <span class="toc-text">中介者模式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.98.5.</span> <span class="toc-text">适配器模式是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">2.98.6.</span> <span class="toc-text">观察者模式和发布订阅模式有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%A0%E7%A7%8D-Content-Type-%EF%BC%9F"><span class="toc-number">2.99.</span> <span class="toc-text">*开发中常用的几种 Content-Type ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7%E6%97%B6%E9%97%B4%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF-Performance-API%EF%BC%9F"><span class="toc-number">2.100.</span> <span class="toc-text">*如何确定页面的可用性时间，什么是 Performance API？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-assign"><span class="toc-number">2.101.</span> <span class="toc-text">Object.assign()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Math-ceil-%E5%92%8C-Math-floor"><span class="toc-number">2.102.</span> <span class="toc-text">Math.ceil 和 Math.floor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-for-%E5%BE%AA%E7%8E%AF%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.103.</span> <span class="toc-text">js for 循环注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%88%97%E8%A1%A8%EF%BC%8C%E5%81%87%E8%AE%BE%E6%9C%89-100000-%E4%B8%AA%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%99%E4%B8%AA%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">2.104.</span> <span class="toc-text">一个列表，假设有 100000 个数据，这个该怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#js-%E4%B8%AD%E5%80%92%E8%AE%A1%E6%97%B6%E7%9A%84%E7%BA%A0%E5%81%8F%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">2.105.</span> <span class="toc-text">*js 中倒计时的纠偏实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V8-%E4%B8%8B%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">2.106.</span> <span class="toc-text">V8 下的垃圾回收机制是怎么样的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E7%AE%97%E6%B3%95"><span class="toc-number">2.106.1.</span> <span class="toc-text">新生代算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E7%94%9F%E4%BB%A3%E7%AE%97%E6%B3%95"><span class="toc-number">2.106.2.</span> <span class="toc-text">老生代算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.</span> <span class="toc-text">JavaScript 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">3.1.</span> <span class="toc-text">实现一个事件委托</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E6%8B%96%E6%8B%BD%E7%9A%84DIV"><span class="toc-number">3.2.</span> <span class="toc-text">实现一个可以拖拽的DIV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">实现数组去重？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">实现函数柯里化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8C%96"><span class="toc-number">3.5.</span> <span class="toc-text">实现数组扁平化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.6.</span> <span class="toc-text">实现拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.6.1.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">3.6.2.</span> <span class="toc-text">深拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99-call%E3%80%81apply-%E5%8F%8A-bind-%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">手写 call、apply 及 bind 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">new 操作符具体干了什么？如何实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0instanceof"><span class="toc-number">3.9.</span> <span class="toc-text">实现instanceof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0sleep"><span class="toc-number">3.10.</span> <span class="toc-text">实现sleep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84reduce"><span class="toc-number">3.11.</span> <span class="toc-text">实现数组reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84map"><span class="toc-number">3.12.</span> <span class="toc-text">实现数组map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99AJAX"><span class="toc-number">3.13.</span> <span class="toc-text">手写AJAX</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%AD%A3%E5%88%99%E5%AE%9E%E7%8E%B0-trim"><span class="toc-number">3.14.</span> <span class="toc-text">用正则实现 trim()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Object-create%E6%96%B9%E6%B3%95"><span class="toc-number">3.15.</span> <span class="toc-text">实现Object.create方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0compose"><span class="toc-number">3.16.</span> <span class="toc-text">实现compose</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E6%B5%AE%E7%82%B9%E6%95%B0%E7%82%B9%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%95%B0%E6%AF%8F%E4%B8%89%E4%BD%8D%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%97%E5%8F%B7%EF%BC%8C%E5%A6%82-12000000-11-%E8%BD%AC%E5%8C%96%E4%B8%BA%E3%80%8E12-000-000-11%E3%80%8F"><span class="toc-number">3.17.</span> <span class="toc-text">如何将浮点数点左边的数每三位添加一个逗号，如 12000000.11 转化为『12,000,000.11』?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="toc-number">3.18.</span> <span class="toc-text">如何实现数组的随机排序？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.19.</span> <span class="toc-text">寄生式组合继承的实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8%E5%87%BD%E6%95%B0"><span class="toc-number">3.20.</span> <span class="toc-text">写一个通用的事件侦听器函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-js-%E7%9A%84%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96%EF%BC%88%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%89%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.21.</span> <span class="toc-text">实现 js 的节流与防抖（原理？）（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-setTimeout-%E5%AE%9E%E7%8E%B0-setInterval%EF%BC%9F%E6%80%8E%E4%B9%88%E6%A8%A1%E6%8B%9F%EF%BC%9F"><span class="toc-number">3.22.</span> <span class="toc-text">为什么使用 setTimeout 实现 setInterval？怎么模拟？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-Promise"><span class="toc-number">3.23.</span> <span class="toc-text">手写一个 Promise</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA-javascript-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">3.24.</span> <span class="toc-text">如何封装一个 javascript 的类型判断函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA-jsonp"><span class="toc-number">3.25.</span> <span class="toc-text">手写一个 jsonp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">3.26.</span> <span class="toc-text">手写一个观察者模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EventEmitter-%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.27.</span> <span class="toc-text">EventEmitter 实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">JavaScript代码题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C1%E2%80%9D-%E2%80%9C2%E2%80%9D-%E2%80%9C3%E2%80%9D-map-parseInt-%E7%AD%94%E6%A1%88%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">[“1”, “2”, “3”].map(parseInt) 答案是多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forEach-call-quot-quot-function-a-a-style-outline-quot-1px-solid-quot-Math-random-1-lt-lt-24-toString-16-%E8%83%BD%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E6%80%9D%E5%90%97%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">[].forEach.call($$(&quot;*&quot;),function(a){a.style.outline&#x3D;&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E8%BF%99%E4%B8%AAJS%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">下面这个JS程序的输出是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">下面代码的结果？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F-1"><span class="toc-number">4.5.</span> <span class="toc-text">下面代码的结果？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%9F-2"><span class="toc-number">4.6.</span> <span class="toc-text">下面代码的结果？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%981%E2%80%99-%E2%80%992%E2%80%99-%E2%80%993%E2%80%99-map-parseInt-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">[‘1’,’2’,’3’].map(parseInt)的返回值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-JS-%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">使用 JS 实现获取文件扩展名？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">4.9.</span> <span class="toc-text">如何判断一个对象是否为空对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E4%B8%80%E7%A7%92%E6%89%93%E5%8D%B0-1-2-3-4"><span class="toc-number">4.10.</span> <span class="toc-text">使用闭包实现每隔一秒打印 1,2,3,4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E5%B8%B8%E8%A2%AB%E4%BA%BA%E8%BD%BB%E8%A7%86%E7%9A%84%E5%89%8D%E7%AB%AF-JS-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.11.</span> <span class="toc-text">一道常被人轻视的前端 JS 面试题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%B8%80%E7%AF%87%E8%8B%B1%E6%96%87%E6%96%87%E7%AB%A0%E4%B8%AD%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">如何查找一篇英文文章中出现频率最高的单词？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">4.13.</span> <span class="toc-text">大数相加</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 常见问题"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题">【面试准备】— — 常见问题</a><time datetime="2021-10-11T14:03:14.000Z" title="发表于 2021-10-11 22:03:14">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 前端综合篇"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇">【面试准备】— — 前端综合篇</a><time datetime="2021-10-11T12:53:49.000Z" title="发表于 2021-10-11 20:53:49">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/%E3%80%90%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E3%80%91%E2%80%94%20%E2%80%94%20git%20%E6%93%8D%E4%BD%9C/" title="【知识整理】— — git 操作"><img src="https://i.loli.net/2021/10/13/K1ZJbqocNyQfnws.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【知识整理】— — git 操作"/></a><div class="content"><a class="title" href="/2021/09/29/%E3%80%90%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E3%80%91%E2%80%94%20%E2%80%94%20git%20%E6%93%8D%E4%BD%9C/" title="【知识整理】— — git 操作">【知识整理】— — git 操作</a><time datetime="2021-09-29T15:12:34.000Z" title="发表于 2021-09-29 23:12:34">2021-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>