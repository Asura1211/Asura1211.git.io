<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【面试准备】— — Vue篇 | 青山の博客</title><meta name="keywords" content="Vue"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：CSS 面试知识点总结。侵权删。 Vue 双向数据绑定（响应式）原理？（高频）vue 通过使用双向数据绑定实现 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。 首先通过 Object.defineProperty() 对 Model 数据各个属性添加访问器属">
<meta property="og:type" content="article">
<meta property="og:title" content="【面试准备】— — Vue篇">
<meta property="og:url" content="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：CSS 面试知识点总结。侵权删。 Vue 双向数据绑定（响应式）原理？（高频）vue 通过使用双向数据绑定实现 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。 首先通过 Object.defineProperty() 对 Model 数据各个属性添加访问器属">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg">
<meta property="article:published_time" content="2021-07-10T14:02:20.000Z">
<meta property="article:modified_time" content="2021-11-20T08:40:25.968Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【面试准备】— — Vue篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-20 16:40:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【面试准备】— — Vue篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-10T14:02:20.000Z" title="发表于 2021-07-10 22:02:20">2021-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-20T08:40:25.968Z" title="更新于 2021-11-20 16:40:25">2021-11-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【面试准备】— — Vue篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：<a target="_blank" rel="noopener" href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/Css/Css.md">CSS 面试知识点总结</a>。侵权删。</p>
<h2 id="Vue-双向数据绑定（响应式）原理？（高频）"><a href="#Vue-双向数据绑定（响应式）原理？（高频）" class="headerlink" title="Vue 双向数据绑定（响应式）原理？（高频）"></a>Vue 双向数据绑定（响应式）原理？（高频）</h2><p>vue 通过使用双向数据绑定实现 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用<strong>数据劫持</strong>和<strong>发布订阅者模式</strong>来实现的。</p>
<p>首先通过 Object.defineProperty() 对 Model 数据各个属性添加访问器属性，以此实现数据的劫持，因此当 Model 中的数据发生变化的时候，可以通过配置的 setter 和 getter 方法实现对 View 层数据更新的通知。</p>
<p>流程大概如下：</p>
<ol>
<li>实现一个监听器 Observer，用来劫持并监听所有属性，如果发生变动，则通知订阅者。核心方法是<strong>利用 <code>Object.defineProperty()</code> 通过递归的方式对所有属性都添加 setter、getter 方法进行监听。</strong></li>
<li>实现一个订阅者 Watcher，当接到属性变化的通知时，执行对应的函数，然后渲染和更新视图。使用 Dep 来记录数据的更改由哪个 Watcher 更新。</li>
<li>实现一个解析器 Compile，用于扫描和解析节点的相关指令，并根据初始化模板初始化相应的订阅器。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/27/g9D4Bciwbz2O7Nr.png" alt="image.png"></p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039750996">Vue2.x 的双向绑定原理及实现</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/reactivity.html">https://cn.vuejs.org/v2/guide/reactivity.html</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016884795">https://segmentfault.com/a/1190000016884795</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573210285899789">https://juejin.cn/post/6854573210285899789</a></p>
<h3 id="v-model-是什么的语法糖（todo）"><a href="#v-model-是什么的语法糖（todo）" class="headerlink" title="*v-model 是什么的语法糖（todo）"></a>*v-model 是什么的语法糖（todo）</h3><p><strong>1.作用在普通表单元素上：</strong>动态绑定 input 的 value 指向 messgae 变量，并且在触发 input 事件时动态把 message 设置为目标值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">&gt;</span></span></span><br><span class="line"><span class="xml">//$event.target 指代当前触发的事件对象的dom;</span></span><br><span class="line"><span class="xml">//$event.target.value 当前dom的value值;</span></span><br><span class="line"><span class="xml">//在@input方法中，value =&gt; sth;</span></span><br><span class="line"><span class="xml">//在:value中,sth =&gt; value;</span></span><br></pre></td></tr></table></figure>

<p>**2.作用在组件上:**在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件</p>
<p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现</strong>。因此父组件<code>v-model</code>语法糖本质上可以修改为 <code>&#39;&#39;</code></p>
<p>在组件的实现中，可以通过 <strong>v-model属性</strong> 来配置子组件接收的prop名称，以及派发的事件名称。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;aa-input v-model=<span class="string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">aa-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onmessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">props:&#123;<span class="attr">value</span>:aa,&#125;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">onmessage</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        $emit(<span class="string">&#x27;input&#x27;</span>,e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event</p>
<p>但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。</p>
<p>js 监听input 输入框输入数据改变，用oninput ,数据改变以后就会立刻出发这个事件。</p>
<p>通过input事件把数据$emit 出去，在父组件接受。</p>
<p>父组件设置v-model的值为input$emit过来的值。</p>
<p>具体见<a target="_blank" rel="noopener" href="https://github.com/lgwebdream/FE-Interview/issues/914">https://github.com/lgwebdream/FE-Interview/issues/914</a></p>
<h2 id="什么是-Virtual-DOM？（高频）"><a href="#什么是-Virtual-DOM？（高频）" class="headerlink" title="什么是 Virtual DOM？（高频）"></a>什么是 Virtual DOM？（高频）</h2><p>对将要插入到文档中的 <strong>DOM 树结构进行分析</strong>，<strong>使用 js 对象表示</strong>。比如一个元素对象包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树保存下来，最后再将 DOM 片段插入到文档中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">  <span class="attr">tagName</span>: <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: &#123;</span><br><span class="line">    <span class="attr">tagName</span>: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对应的 DOM 就是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&#x27;list&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>当页面的状态发生改变，需要对 DOM 结构进行调整时，首先根据变更的状态，重新构建起一棵对象树</li>
<li>然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的差异</li>
<li>最后将记录有差异的地方应用到真正的 DOM 树，这样视图就更新了。判断差异的算法分为两步：<ul>
<li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步会给每个节点添加索引，便于最后渲染差异。（需要判断新旧节点的 <code>tagName</code> 是否相同，如果不相同的话就代表节点被替换。相同则判断是否有子元素，有就进行第二步）</li>
<li>一旦节点有子元素，就判断子元素是否有不同。（原列表是否有节点被移除、新列表是否有新节点加入、节点是否有移动）</li>
</ul>
</li>
</ol>
<h3 id="为什么-Virtual-DOM-比原生-DOM-快？"><a href="#为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="为什么 Virtual DOM 比原生 DOM 快？"></a><strong>为什么 Virtual DOM 比原生 DOM 快？</strong></h3><p>Virtual DOM 这种方法对于需要有大量 DOM 操作的时候，能够很好的提高操作效率，通过在操作前确定需要做的最小修改，从而<strong>尽可能减少 DOM 操作带来的重流和重绘影响</strong>。其实 Virtual DOM 并不一定比真实操作 DOM 快，这种方法是为了提高开发时的可维护性：在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</p>
<p><strong>Virtual DOM 最大的优势</strong>：</p>
<ol>
<li>将 Virtual DOM 作为一个兼容层，让还能对接非 Web 端的系统，实现跨端开发。</li>
<li>同样的，通过 Virtual DOM 可以渲染到其他的平台，比如实现 SSR、同构渲染等等。</li>
<li>实现组件的高度抽象化。</li>
</ol>
<h3 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h3><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，很少会跨层级的移动元素，所以只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p>
<p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p>
<p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以不能使用这个来对比。需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样才能够复用老的 DOM 树上的节点。</p>
<h2 id="Vue-中-diff-算法？-高频"><a href="#Vue-中-diff-算法？-高频" class="headerlink" title="Vue 中 diff 算法？(高频)"></a>Vue 中 diff 算法？(高频)</h2><p>部分参考自<a target="_blank" rel="noopener" href="https://juejin.cn/post/6994959998283907102">https://juejin.cn/post/6994959998283907102</a></p>
<p>Diff 算法是一种<strong>对比算法</strong>。对比旧虚拟 DOM 和新虚拟 DOM，找出发生更改的虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不更新其他节点，实现精准地更新真实 DOM，提高效率。</p>
<p><strong>原理</strong>：Diff 算法比较只会在同层级进行, 不会跨层级比较。diff 算法是深度优先算法，时间复杂度 O(n)</p>
<p><strong>对比流程</strong>：当数据改变时，会触发 setter，并且通过 Dep.notify 去通知所有订阅者 Watcher，订阅者们就会调用  patch 方法，给真实 DOM 打补丁，更新相应的视图。</p>
<p><img src="https://i.loli.net/2021/10/27/a63sB5EAdQIKhgD.png" alt="image.png"></p>
<ol>
<li><p>patch 方法：对比当前同层的虚拟节点是否为同一种类型的标签。</p>
<ul>
<li><p>是：继续执行 patchVnode 方法进行深层比对</p>
</li>
<li><p>否：没必要比对，直接整个节点替换成新虚拟节点</p>
</li>
</ul>
</li>
<li><p>sameVnode 方法：判断是否为同一类型节点</p>
</li>
<li><p>patchVnode 方法：</p>
<ul>
<li>找到对应的真实 DOM，称为 el</li>
<li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是（没有变化）直接<code>return</code></li>
<li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点</li>
<li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li>
<li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li>
<li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，<strong>这一步很重要</strong></li>
</ul>
</li>
<li><p>updateChildren 方法：新旧虚拟节点的子节点对比（首尾指针法）。新的子节点集合和旧的子节点集合，各有首尾两个指针。总共有五种比较情况：</p>
<ul>
<li><code>oldS 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li>
<li><code>oldS 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li>
<li><code>oldE 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li>
<li><code>oldE 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li>
<li>如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li>
</ul>
</li>
</ol>
<p><strong>节点的插入删除移动的具体流程</strong>见4！</p>
<h3 id="diff-中-key-值的作用？"><a href="#diff-中-key-值的作用？" class="headerlink" title="diff 中 key 值的作用？"></a>diff 中 key 值的作用？</h3><p>如果用 index 做为 key，插入一个新数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>                      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>林三心<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                              <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>                     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>理想结果：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;button @click=&quot;add&quot;&gt;增加&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">list: [</span><br><span class="line">    &#123; title: &quot;a&quot;, id: &quot;100&quot; &#125;,</span><br><span class="line">    &#123; title: &quot;b&quot;, id: &quot;101&quot; &#125;,</span><br><span class="line">    &#123; title: &quot;c&quot;, id: &quot;102&quot; &#125;,</span><br><span class="line">]</span><br><span class="line">      </span><br><span class="line">add() &#123;</span><br><span class="line">    this.list.unshift(&#123; title: &quot;林三心&quot;, id: &quot;99&quot; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是结果是<strong>所有 li 标签都更新了</strong>。原因：在进行子节点的 diff 算法过程中，会<strong>先进行旧首节点和新首节点的sameNode 对比</strong>，这一步命中逻辑，因为现在新旧两次首部节点的 key 都是 0。同理 key 为 1 和 2  的也命中逻辑，导致相同 key 节点会进行 patchVnode 更新文本，而原本就有的 c 节点，却因为之前没有 key 为 4 的节点，而被当做新节点。使用 index 做 key，<strong>前三个都进行patchVnode更新文本，最后一个进行了新增节点</strong>。</p>
<p>解决方案：使用一个独一无二的值来当做 key。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的话，a，b，c 节点的 key 永远不变，所以就算进行了 patchVnode，也不会执行更新操作，节省了性能。而新增节点，由于更新前没有它的 key 所对应的节点，所以被当做新的节点，增加到真实DOM。</p>
<h2 id="vue-中-key-值的作用？（高频）"><a href="#vue-中-key-值的作用？（高频）" class="headerlink" title="vue 中 key 值的作用？（高频）"></a>vue 中 key 值的作用？（高频）</h2><ol>
<li>v-if 中使用 key：由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此使用 v-if 实现元素切换时，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，显然不符合需求。因此通过使用 key 来<strong>唯一标识一个元素</strong>，这样使用 key 的元素不会被复用。</li>
<li><strong>v-for 中使用 key</strong>：用 v-for 更新已渲染过的元素列表时，默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，使 Vue 跟踪元素的身份，从而高效的实现复用。这时 key 的作用是<strong>为了高效的更新渲染虚拟 DOM。</strong></li>
</ol>
<p><strong>深入讲讲：</strong></p>
<p>Vue 在 patch 过程中判断两个节点是否是相同节点，key 是一个必要条件。渲染一组列表时，key 往往是唯一标识。由于 Vue 判断两个节点是否相同时，主要判断两者的 key 和元素类型，如果不设置 key，值就是 undefined，则可能永远认为这是两个相同的节点，这导致了频繁更新元素，使得整个 patch 过程比较低效，影响性能。</p>
<h2 id="Vue-和-React-之间的区别（高频）"><a href="#Vue-和-React-之间的区别（高频）" class="headerlink" title="Vue 和 React 之间的区别（高频）"></a>Vue 和 React 之间的区别（高频）</h2><p><strong>相同点：</strong>围绕着数据流和组件化以及 diff 策略来答</p>
<ul>
<li>使用Virtual DOM，用 js 模拟 DOM 结构，提高重绘性能</li>
<li>组件化开发，都支持 props 进行父子组件之间的数据通信</li>
<li>都支持数据驱动视图，不直接操作真实 dom</li>
<li>都支持服务器端的渲染</li>
<li>都支持 native 方案，React 的 react native，Vue 的 WEEX</li>
<li>都有状态管理，React 有 redux，Vue 有 Vuex</li>
</ul>
<p><strong>异同点：</strong>围绕着更新的触发方式，以及异步和同步的渲染过程来答</p>
<ul>
<li>Vue 的表单可以使用 v-model 支持<strong>双向绑定</strong>，而 React 的数据流动是<strong>单向</strong>的。当然 v-model 是语法糖，本质上和 React 写表单的方式没区别。</li>
<li><strong>改变数据方式</strong>不同，Vue 修改状态只需要通过 this 的某种方式去更新 state 中的数据，而 React 需要使用 <code>setState</code> 来改变状态。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优，但是 React 还是需要用户手动去优化这方面的问题。</li>
<li>React 需要使用 <strong>JSX</strong>，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加灵活。Vue 使用了<strong>模板语法</strong>，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 <code>render</code> 函数就能在浏览器中运行。</li>
<li>React 的思想很棒，各种抽象和模式使得代码更加美观。</li>
</ul>
<p>更多可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6847009771355127822#heading-46">你不知道的React 和 Vue 的20个区别</a>。</p>
<h3 id="diff-算法区别？（高频）"><a href="#diff-算法区别？（高频）" class="headerlink" title="diff 算法区别？（高频）"></a><strong>diff 算法区别？</strong>（高频）</h3><p>参考自 <a target="_blank" rel="noopener" href="https://cxyzjd.com/article/qq_45932447/110001564">https://cxyzjd.com/article/qq_45932447/110001564</a></p>
<p><strong><a target="_blank" rel="noopener" href="https://juejin.cn/post/6919376064833667080">=&gt;react、vue2、vue3 的 diff 算法区别（good！）</a></strong></p>
<p>vue 和 react 的 diff 算法，都是忽略跨级比较，只做同级比较，复杂度都为 O(n)。vue diff 时调动 patch 函数。react 的思路是递增法：通过对比新列表中的节点，在原本的列表中的位置是否递增，来判断当前节点是否需要移动。</p>
<ol>
<li>vue 列表比对，采用<strong>从两端到中间的比对方式</strong>，而 react 则采用<strong>从左到右依次比对的方式</strong>。当一个集合只是把最后一个节点移动到了第一个，react 会把前面的节点依次移动，而 vue 只会把最后一个节点移动到第一个。</li>
<li>vue 比对节点，当<strong>节点元素类型相同，但是 className 不同</strong>，认为是不同类型元素，删除重建；而 react 会认为是同类型节点，只是修改节点属性。</li>
</ol>
<p>总体上，vue 的对比方式更高效。</p>
<h3 id="jQuery-与-vue-区别"><a href="#jQuery-与-vue-区别" class="headerlink" title="jQuery 与 vue 区别"></a>jQuery 与 vue 区别</h3><ol>
<li>jQuery 使用选择器选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，和原生 HTML 区别只在于可以更方便的选取和操作 DOM 对象，数据和界面还是在一起的。比如需要获取 label 标签的内容：<code>(“lable”).val(); </code> 还是依赖DOM元素的值。</li>
<li>Vue 则是通过 Vue 对象将数据和 View 完全分离。对数据进行操作不再需要引用相应的 DOM 对象。</li>
</ol>
<h2 id="Vue-的生命周期是什么？"><a href="#Vue-的生命周期是什么？" class="headerlink" title="Vue 的生命周期是什么？"></a>Vue 的生命周期是什么？</h2><p>Vue 的生命周期指的是组件从创建到销毁的一系列的过程。</p>
<h3 id="各个生命阶段？（高频）"><a href="#各个生命阶段？（高频）" class="headerlink" title="各个生命阶段？（高频）"></a>各个生命阶段？（高频）</h3><p>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。<img src="https://i.loli.net/2021/10/17/8VDnJaCiH5A9vyZ.png" alt="12602393-5310c1449192165f.jpg"></p>
<p>（1）beforeCreate：在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中获取不到 props 或者 data 数据。</p>
<p>（2）created：在<strong>实例创建完成后</strong>触发，此时可以<strong>访问 data、methods 等属性</strong>。但组件还没有被挂载到页面中去，所以<strong>访问不到 $el 属性</strong>。一般可以在这个函数中<strong>进行一些页面初始化的工作</strong>，比如通过 ajax 请求数据来对页面进行初始化。</p>
<p>（3）beforeMount：在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</p>
<p>（4）mounted：在<strong>组件挂载到页面后</strong>触发。此时可以<strong>获取页面中的 DOM 元素</strong>。</p>
<p>（5）beforeUpdate：在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候可以对可能会被移除的元素做一些操作，比如移除事件监听器。</p>
<p>（6）updated：虚拟 DOM 重新渲染和打补丁之后调用。</p>
<p>（7）beforeDestroy：在实例销毁之前调用。在这一步可以销毁定时器、解绑全局事件等。</p>
<p>（8）destroyed：在实例销毁之后调用。调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<p>当使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。</p>
<h3 id="keep-alive-组件作用？"><a href="#keep-alive-组件作用？" class="headerlink" title="keep-alive 组件作用？"></a>keep-alive 组件作用？</h3><p>如果需要<strong>在组件切换的时候，保存一些组件的状态防止多次渲染</strong>，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<p>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</p>
<h2 id="Vue-组件间的参数传递方式？（高频）"><a href="#Vue-组件间的参数传递方式？（高频）" class="headerlink" title="Vue 组件间的参数传递方式？（高频）"></a>Vue 组件间的参数传递方式？（高频）</h2><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><ol>
<li>子组件通过 props 属性接受父组件数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。典型的<strong>单向数据流</strong>，子组件不能直接修改 props， 而是必须通过发送事件的方式告知父组件修改数据。</li>
</ol>
<p>  还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。</p>
<ol start="2">
<li><p>通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，实现通信。</p>
</li>
<li><p>使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 将变量注入到组件中。不论子组件有多深，只要调用 inject，就可以注入 provider 中的数据。</p>
</li>
<li><p>（Vue 2.3 及以上版本）<code>$listeners</code> 属性会将父组件中 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 自定义监听器。<code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信。</p>
</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync=&quot;value&quot; /&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;comp :value=&quot;value&quot; @update:value=&quot;v =&gt; value = v&quot;&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.$emit(&#x27;update:value&#x27;, 1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><ol>
<li><p>使用 eventBus 的方法，本质是通过<strong>创建一个空的 Vue 实例作为消息传递的对象</strong>，通信的组件引入这个实例，通过在实例上监听和触发事件实现消息的传递。</p>
</li>
<li><p>通过查找父组件中的子组件来获取到兄弟组件<code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p>
</li>
</ol>
<h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>Vue 2.2 新增的 API <code>provide / inject</code>：假设有父组件 A，然后有一个跨多层级的子组件 B</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;data&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.data) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><ul>
<li>Event Bus ，其实就是创建一个事件中心，用它来传递事件和接收事件。</li>
<li>Vuex。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面方法就不利于项目的维护。Vuex 的思想就是将公共数据抽离，作为全局的变量管理，然后其他组件就可以对公共数据进行读写操作，达到解耦目的。</li>
</ul>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样为了防止子组件意外改变父级组件的状态。</p>
<p>每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着不应该在一个子组件内部改变 prop。</p>
<p>简单的单向数据流是指用户访问 View，View 发出用户交互的 Action，在 Action 里对 state 进行相应更新。state 更新后会触发 View 更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测。</p>
<h2 id="computed-和-watch-的区别？（高频）"><a href="#computed-和-watch-的区别？（高频）" class="headerlink" title="computed 和 watch 的区别？（高频）"></a>computed 和 watch 的区别？（高频）</h2><p>（1）computed 是<strong>计算一个新的属性（但是依赖其他属性计算值），并将该属性挂载到 Vue 实例</strong>上，watch 是<strong>监听已经存在且已挂载到 Vue 实例上的数据</strong>，所以用 watch 同样可以监听 computed 计算属性的变化。（computed 能做的，watch 都能做，反之则不行）</p>
<p>（2）computed 本质是一个惰性求值的观察者，具有<strong>缓存性</strong>，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值（减少模板中计算逻辑）。而 watch 则是<strong>当数据发生变化便会调用执行函数</strong>，在回调中可以执行任何逻辑，如函数节流，Ajax 异步获取数据，甚至操作 DOM。</p>
<p>（3）使用场景：需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做复杂业务逻辑的情况可以使用 watch。</p>
<p>能用 computed 的尽量用 computed。</p>
<h2 id="什么是-MVVM？比之-MVC-有什么区别？什么是-MVP（高频）"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么是-MVP（高频）" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？什么是 MVP（高频）"></a>什么是 MVVM？比之 MVC 有什么区别？什么是 MVP（高频）</h2><p>View 和 Model：</p>
<ul>
<li>View 用户看到的视图</li>
<li>Model 本地数据和数据库中的数据</li>
</ul>
<p>MVC 架构通常是<strong>使用控制器更新模型，视图从模型中获取数据去渲染</strong>。View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作，通过调用 Model 层来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<p><img src="https://i.loli.net/2021/09/11/lahWzk4gVPcbs7U.png" alt="image.png"></p>
<p>但是 MVC 一个巨大的缺陷就是<strong>控制器承担的责任太大</strong>了，随着项目愈加复杂，控制器中的代码会越来越<strong>臃肿</strong>，导致出现不利于<strong>维护</strong>的情况。</p>
<p>**MVP **：与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦：MVC 中的 Controller 只知道 Model 的接口，因此没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter，因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。</p>
<p><strong>MVVM</strong>：与 MVP 思想相同，通<strong>过双向数据绑定将 View 和 Model 的同步更新给自动化</strong>了。<strong>ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据</strong>。这样还可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。以 Vue 框架来举例，<strong>ViewModel 就是组件的实例</strong>。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</p>
<p><img src="https://i.loli.net/2021/09/11/aFJGPc8H3E6pRrg.png" alt="image.png"></p>
<p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p>
<p><img src="https://i.loli.net/2021/09/11/UDACQIv2rqnBNhW.png" alt="image.png"></p>
<p>对于 MVVM 来说，最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是<strong>通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象</strong>。</p>
<h3 id="实现一个简单的-MVVM-框架（to-understand）"><a href="#实现一个简单的-MVVM-框架（to-understand）" class="headerlink" title="*实现一个简单的 MVVM 框架（to understand）"></a>*实现一个简单的 MVVM 框架（to understand）</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2436436c1863">https://www.jianshu.com/p/2436436c1863</a> 好难。。</p>
<h2 id="Vue-中的-nextTick-原理分析"><a href="#Vue-中的-nextTick-原理分析" class="headerlink" title="Vue 中的 nextTick 原理分析"></a>Vue 中的 nextTick 原理分析</h2><p>参考自<a target="_blank" rel="noopener" href="https://www.cxyzjd.com/article/qq_42072086/106987202">https://www.cxyzjd.com/article/qq_42072086/106987202</a></p>
<p>nextTick ：在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。变量：</p>
<ol>
<li>callbacks：用来存储所有需要执行的回调函数</li>
<li>pending：用来标志是否正在执行回调函数</li>
<li>timerFunc：用来触发执行回调函数</li>
</ol>
<p>当调用 nextTick 方法时会传入两个参数，回调函数和执行回调函数的上下文环境，如果没有提供回调函数，那么将返回 promise 对象。首先将拿到的回调函数存放到数组中，判断是否正在执行回调函数，如果当前没有，那么在 pending 的时候，就会执行 timeFunc（多次执行 nextTick 只会执行一次 timerFunc）。timeFunc 其实就是执行异步的方法，然后异步去执行 flushCallbacks 方法（将传递的函数依次执行）。</p>
<p>nextTick 多次调用会维持一个数组，之后会异步的把数组中的方法依次执行，这样用户就会在视图更新之后再获取到真实的dom元素。</p>
<p><img src="https://i.loli.net/2021/10/27/Vq4zSLbRHlCNoiu.png" alt="image.png"></p>
<h3 id="应用场景？"><a href="#应用场景？" class="headerlink" title="应用场景？"></a>应用场景？</h3><ul>
<li>在 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中。原因是在 created() 钩子函数执行时 DOM 并未进行任何渲染，此时进行 DOM 操作无异于徒劳。（mounted就不需要）</li>
<li>在数据变化之后要执行的某个操作，比如设置 <code>vm.someData = &#39;new value&#39;</code>，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始，执行更新时才会进行 DOM 更新。如果此时想要根据最新的 DOM 状态去做某些事情，就会出现问题。因此可以在数据变化之后使用 <code>Vue.nextTick(callback)</code> ，这样回调函数在 DOM 更新完成后就会调用。</li>
</ul>
<h3 id="Vue-data-某个属性值改变后，视图会立即同步执行渲染吗？"><a href="#Vue-data-某个属性值改变后，视图会立即同步执行渲染吗？" class="headerlink" title="Vue data 某个属性值改变后，视图会立即同步执行渲染吗？"></a>Vue data 某个属性值改变后，视图会立即同步执行渲染吗？</h3><p>不会。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</p>
<p><strong>Vue 在更新 DOM 时是异步执行的</strong>。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p>
<p>然后在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    vm.message = <span class="string">&#x27;new message&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 123,页面显示 new message</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="介绍一下-vue"><a href="#介绍一下-vue" class="headerlink" title="介绍一下 vue"></a>介绍一下 vue</h2><p>Vue 是一套用于构建用户界面的<strong>渐进式框架</strong>。Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<h2 id="vue-常用的修饰符？"><a href="#vue-常用的修饰符？" class="headerlink" title="vue 常用的修饰符？"></a>vue 常用的修饰符？</h2><ul>
<li>.prevent: 防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）</li>
<li>.stop: 阻止单击事件冒泡</li>
<li>.self: 只在当前元素自身触发处理函数</li>
<li>.once：事件只触发一次</li>
<li>.sync：props 值只能在父组件中更新并传递给子组件，在子组件内部是不允许改变传递进来的props值。但是如果需要在子组件内部改变 props 属性值并更新到父组件中，这时就用到 .sync 修饰符。<code>:name.sync</code> 是 <code>:name=&quot;name&quot; @update:name=&quot;name = $event&quot;</code> 的缩写。</li>
</ul>
<h2 id="vue-指令？"><a href="#vue-指令？" class="headerlink" title="vue 指令？"></a>vue 指令？</h2><p>参考自 <a target="_blank" rel="noopener" href="https://learnku.com/articles/38198">https://learnku.com/articles/38198</a></p>
<ol>
<li>v-text：v-text 与插值表达式<code>&#123;&#123;&#125;&#125;`相同的地方是，它也是将数据解析成纯文本（若解释 html 标签可能导致 xss 攻击）但区别是：使用 v-text 在页面加载时不会显示'message'，**解决了插值表达式闪烁问题**。
2. v-html：为了输出真正的 HTML，可以用 v-html 指令。它等同于 JS 的 innerHtml 属性，会将数据解析成 html 形式。
3. v-if：用于**条件性地渲染**一块内容。这块内容只会在指令的表达式返回 **truthy** 值的时候被渲染。
4. v-else：**必须和** `v-if` **连用**，否则会报错。
5. v-show：也是用来 **控制元素是否显示** 的，其功能与 `v-if` 指令相似。
6. v-for：循环
7. v-on：**绑定事件监听器** ，这样就可以进行交互。
8. v-bind：主要用于**绑定属性**，可以动态地绑定一个或多个属性，比如 class 属性、style 属性、value 属性、href 属性，只要是属性，就可以用 v-bind 进行绑定。
9. v-model：用于**在表单上创建双向数据绑定**，v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值，因为 v-model 选择 Vue 实例数据来作为具体的值。

10. v-pre：会**按原样输出**，标签中的内容是什么就输出什么，主要用来跳过这个元素以及它的子元素的编译过程，可以用来显示原始的 Mustache 标签。
11. v-once：关联的实例**只会渲染一次，执行一次性地插值**，当数据改变时，插值处的内容不会更新。若之后牵涉到重新渲染，那么 它关联的实例及其所有子节点会被视为静态内容而被跳过，这可以用来优化更新性能。

### v-show 与 v-if 区别

`v-show` 只是在 `display: none` 和 `display: block` 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以 `v-show` **在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。**

`v-if` ：当属性初始为 `false` 时，组件不会被渲染，直到条件为 `true`，并且切换条件时会触发销毁/挂载组件，所以**切换时开销更高，更适合不经常切换的场景。**

基于 `v-if` 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。

## vue 绑定事件？（to understand）

1.原生的事件绑定（见 JS 篇事件绑定），采用的是 addEventListener 实现。

2.组件的事件绑定，组件绑定事件采用的是 $on 方法 。在组件上是通过 @click.native 进行绑定

https://blog.csdn.net/qq_42072086/article/details/108063281

## data 什么时候为对象 || 函数？

**组件复用时**所有组件实例都会共享 `data`，如果 `data` 是对象，就会造成一个组件修改 `data` 以后，影响其他所有组件的后果，所以需要将 `data` 写成函数，每次用到就调用，获得新的数据。

**当使用 `new Vue()` 的方式**时，无论将 `data` 设置为对象还是函数都是可以的，因为 `new Vue()` 的方式是生成一个根组件，该组件不会复用，也就不存在共享 `data` 的情况。

## 什么是SPA？如何实现？

见 [彻底理清前端单页面应用（SPA）的实现原理 【精读源码】](https://segmentfault.com/a/1190000019936510)

### SPA 优缺点

优点：组件化

缺点：

- 不利于 SEO（搜索引擎）
- 首屏渲染时间长

服务端渲染SSR

预渲染Prerendering

### 单页面和多页面的区别是什么

![image.png](https://i.loli.net/2021/10/27/4mnTNfKZRr5tEo7.png)

## vue 注册组件的方式

**1、全局注册：**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-test&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="number">1212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div id=&quot;app&quot;&gt;&lt;my-test&gt;&lt;my-test/&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**组件的全局注册需要在全局实例化Vue前调用**，注册之后可以用在任何新创建的 Vue 实例中调用。

**2、局部注册：**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myTest = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="number">1212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: &#123;</span><br><span class="line">        myTest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

当只需要在某个局部用到某个组件时，可以使用局部注册的方式进行组件注册，此时局部注册的组件只能在注册该组件内部使用。

## vue 如何保存页面状态

1. keep-alive：缓存不活动的组件实例，而不是销毁它们。可以使用 keep-alive 包裹路由组件，去缓存页面状态。但是，这样并不能满足刷新页面依旧可以记住页面状态的需求。因为刷新浏览器页面的时候，等于是刷新了整个vue实例应用，所有vue缓存的数据都会丢失。

   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),</span><br><span class="line">    <span class="comment">// 在路由中添加meta字段</span></span><br><span class="line">    <span class="attr">meta</span>:&#123;</span><br><span class="line">     　　<span class="comment">// 添加keepAlive字段，值true则缓存当前页面，false则不缓存</span></span><br><span class="line">    　　<span class="attr">keepAlive</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]    </span><br><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">router-view</span>  <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-middle-content&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-view</span>  <span class="attr">v-if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-middle-content&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

2. 用 localStorage 做状态管理：使用 beforeunload 监听页面的刷新事件，然后在监听方法里将 Vuex 里的数据储存到 localStorage。

   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.vue 的 created 钩子函数:</span></span><br><span class="line"><span class="comment">// 在页面加载时读取localStorage里的状态信息</span></span><br><span class="line"><span class="built_in">localStorage</span>.getItem(<span class="string">&quot;userMsg&quot;</span>) &amp;&amp; <span class="built_in">this</span>.$store.replaceState(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;userMsg&quot;</span>)));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在页面刷新时将vuex里的信息保存到localStorage里</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;userMsg&quot;</span>,<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.$store.state))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

## 编译过程

Vue 会通过编译器将模板编译为 `render` 函数，然后通过执行 `render` 函数生成 Virtual DOM，最终映射为真实 DOM。编译过程分为三个阶段：

1. 将模板解析为 AST：最主要的事情是**通过各种各样的正则表达式去匹配模板中的内容**，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象。根据这个最基本的 AST 对象中的属性进一步扩展 AST。

   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    tag,</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="attr">attrsList</span>: attrs,</span><br><span class="line">    <span class="comment">// 属性映射</span></span><br><span class="line">    <span class="attr">attrsMap</span>: makeAttrsMap(attrs),</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    <span class="attr">children</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. 优化 AST：对节点进行静态内容提取，也就是将永远不会变动的节点提取出来，实现复用 Virtual DOM，跳过对比算法的功能。

3. 将 AST 转换为 `render` 函数

### *Vue 中 AST 抽象语法树的运用（to understand）

https://juejin.cn/post/6885146952877031432#heading-9

## *Vue 热重载？

"热重载"不是修改文件的时候简单重新加载页面。启用热重载后，当修改 `.vue` 文件时，所有该组件的实例会被替换，**并且不需要刷新页面**，它甚至保持应用程序和被替换组件的当前状态。

## *vue 中 mixin 和 mixins 区别？

mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。可以全局混入封装好的 ajax 或者一些工具函数等等。 

使用 mixin 混入时：

- mixin 的钩子函数会再自己组件的钩子函数之前触发
- 对于 methods、computed 这些配置项等，Vue 会进行合并
- 对于同名属性，Vue 会用组件里的来覆盖 mixin 的

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...逻辑</span></span><br><span class="line">        <span class="comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

mixins 是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mixinObj = &#123;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">mixinFunc</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">mixins</span>: [mixinObj],</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mixinFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。

## *Vue 中 slot 作用？

作为 `Web Components` 技术套件的一部分，是Web组件内的一个占位符。该占位符可以在后期使用自己的标记语言填充。https://github.com/febobo/web-interview/issues/16

# vue-router 

**解决的问题：**

- 监听 URL 的变化，并在变化前后执行相应的逻辑
- 不同的 URL 对应不同组件
- 提供多种方式改变 URL 的 API  ( URL 的改变不能导致浏览器刷新)

**使用方式：**

- 提供一个路由配置表，不同 URL 对应不同组件的配置
- 初始化路由实例 new VueRouter()
- 挂载到 Vue 实例上
- 提供一个路由占位，用来挂载 URL 匹配到的组件 

## Vue 路由跳转的方式？传参？

1. router-link：跳转前提是在 router.js 中配置了要跳转到的目的地（to）
2. this.$router.push()：函数里面调用，跳转到指定 url 路径，并在 history 栈中添加一个记录，点击后退会返回到上一个页面
   - 不传参数：`this.$router.push('/home');`
   - query 传参数：`this.$router.push(&#123;name:'home',query: &#123;id:'1'&#125;&#125;);</code> 取参数：<code>$route.query.id</code><ul>
<li>params 传参数：<code>this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;); </code> 取参数：<code>$route.params.id</code></li>
<li><strong>两者区别</strong>：<ul>
<li>query 类似 get, 跳转之后页面 url 会拼接参数，非重要性的可以这样传；刷新页面 id 还在。</li>
<li>params 类似 post, 跳转之后页面 url 不会拼接参数 , 可用来传密码等；刷新页面 id 消失。</li>
</ul>
</li>
</ul>
</li>
<li>this.$router.replace()：用法同 push，跳转到指定 url 路径，但是 history 栈中不会有记录，点击返回会跳转到上个页面，即直接替换了当前页面。</li>
<li>this.$router.go(n) ：向前或者向后跳转n个页面，n可为正整数或负整数。n 为 0 时强制刷新页面。</li>
</ol>
<h2 id="前端路由原理？"><a href="#前端路由原理？" class="headerlink" title="前端路由原理？"></a>前端路由原理？</h2><p>前端路由本质就是<strong>监听 URL 的变化</strong>，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式。<img src="https://i.loli.net/2021/09/18/3n8axwlMUWmpNKI.png" alt="image.png"></p>
<h3 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h3><p>使用 URL hash 值来作路由。支持所有浏览器，包括不支持HTML5 History Api的浏览器。</p>
<p>原理：URL 中 hash 值只是客户端的一种状态。当向服务器端发出请求时，<strong>hash 部分不会被发送</strong>。例如<code>www.test.com/#/</code> 就是 Hash URL。</p>
<ul>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录，因此能通过浏览器的回退、前进按钮控制 hash 的切换； </li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；</li>
<li>可以使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL的 hash 值；</li>
<li>使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... 具体逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>依赖 HTML5 History API 和服务器配置。history 路由模式的实现主要基于下面几个特性：</p>
<ul>
<li>history.pushState 和 history.repalceState 实现 URL 的变化 ；</li>
<li>使用 popState 事件来监听 url 的变化，从而对页面进行跳转；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popState 事件（即不引起页面刷新，只会更新浏览器的历史记录），这时需要手动触发页面跳转。</li>
</ul>
<h3 id="为什么history模式需要服务器支持？"><a href="#为什么history模式需要服务器支持？" class="headerlink" title="为什么history模式需要服务器支持？"></a>为什么history模式需要服务器支持？</h3><p>具体见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/shapeY/p/14708991.html">vue-router history模式 为什么需要服务端配置以及如何配置</a></p>
<p>假设应用地址为<code>abc.com</code>，服务端不加额外的配置。当通过<code>abc.com</code>访问时是没有问题的，之后通过 route-link 或者 router.api 来跳转也不会有问题，因为不会刷新页面请求 html，只是通过<code>history.pushState</code>或者<code>history.replaceState</code>来改变history记录，修改地址栏地址而已；</p>
<p>但是如果直接访问子路由 <code>abc.com/test</code> 时就会有问题，<code>/test</code>是子路由名，但是服务器中并不存在该目录，就无法索引到html文件，就会出现404，所以不管是访问什么路径，都应该加载根目录的html文件。</p>
<h3 id="两种模式的区别？"><a href="#两种模式的区别？" class="headerlink" title="两种模式的区别？"></a>两种模式的区别？</h3><ul>
<li>Hash 模式只可以更改 <code>#</code> 后面的内容；History 模式可以通过 API 设置任意的同源 URL。</li>
<li>Hash 模式只能更改哈希值，也就是字符串；History 模式可以通过 API 添加任意类型的数据到历史记录。</li>
<li>Hash 模式无需后端配置，并且兼容性好；History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 <code>index.html</code> 页面用于匹配不到静态资源的时候。</li>
<li>Hash 模式相对来说更简单，并且兼容性也更好。</li>
</ul>
<h3 id="前端路由优缺点？"><a href="#前端路由优缺点？" class="headerlink" title="前端路由优缺点？"></a>前端路由优缺点？</h3><p>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户。</p>
<p>缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置。</p>
<h2 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="headerlink" title="vue-router 中的导航钩子函数"></a>vue-router 中的导航钩子函数</h2><p>（1）全局的钩子函数 <code>router.beforeEach(to,from,next)</code> 和 <code>afterEach</code></p>
<p>beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</p>
<p>（2）单个路由独享的钩子函数 <code>beforeEnter(to, from, next)</code>，它是在路由配置上直接进行定义的。</p>
<p>（3）组件内的导航钩子主要有这三种：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code>。它们是直接在路由组件内部进行定义的。</p>
<h2 id="Vue-中-route-和-router-的区别？"><a href="#Vue-中-route-和-router-的区别？" class="headerlink" title="Vue 中 $route 和 $router 的区别？"></a>Vue 中 $route 和 $router 的区别？</h2><p>具体见<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022666268">vue中 $router 和 $route 的区别</a>。</p>
<ul>
<li>$route：当前激活路由的信息对象。每个对象都是局部的，可以获取当前路由的 path, name, params, query 等路由信息参数。</li>
<li>$router：全局的 router 实例。通过 vue 根实例中注入 router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。其中包含了很多属性和对象（比如 history 对象），任何页面也都可以调用其 push(), replace(), go() 等方法。</li>
</ul>
<h2 id="如何设置路由使不能匹配的url跳转到404页面"><a href="#如何设置路由使不能匹配的url跳转到404页面" class="headerlink" title="如何设置路由使不能匹配的url跳转到404页面"></a>如何设置路由使不能匹配的url跳转到404页面</h2><p>参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903608140431368">https://juejin.cn/post/6844903608140431368</a></p>
<p><strong>SPA的404路由配置：</strong></p>
<p>路由表固定时，只需要在路由表中添加一个路径为<code>404</code>的路由，同时<strong>在路由表的最底部</strong>配置一个路径为*的路由，重定向至404路由。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/404&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/notFound.vue&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>,    <span class="comment">// 此处需特别注意至于最底部</span></span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/404&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="什么是-Vuex？"><a href="#什么是-Vuex？" class="headerlink" title="什么是 Vuex？"></a>什么是 Vuex？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理插件，采用集中式存储管理应用的所有组件的状态，主要是为了多页面、多组件之间的通信。</p>
<p>更改状态的唯一方法是提交 mutation，例 <code>this.$store.commit(&#39;SET_VIDEO_PAUSE&#39;, video_pause)</code>，<code>SET_VIDEO_PAUSE</code> 为 mutations 属性中定义的方法 。</p>
<h2 id="Vuex-使用"><a href="#Vuex-使用" class="headerlink" title="Vuex 使用"></a>Vuex 使用</h2><p>参考自 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019077663">vuex 使用总结（详解）</a>。</p>
<p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的store 模式就足够了。但是如果需要构建一个中大型单页应用，Vuex 能够更好的帮助我们管理组件外部的状态，一般可以运用在购物车、登录状态、播放等场景中。</p>
<p>在 Vue 的单页面应用中使用时，需要使用<code>Vue.use(Vuex)</code>调用插件，并将其注入到Vue根实例中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getter</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state, payload) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">addCount</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 可以包含异步操作</span></span><br><span class="line">      <span class="comment">// context 是一个与 store 实例具有相同方法和属性的 context 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注入到根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后改变状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Vuex-核心概念-amp-底层原理"><a href="#Vuex-核心概念-amp-底层原理" class="headerlink" title="Vuex 核心概念&amp;底层原理"></a>Vuex 核心概念&amp;底层原理</h2><ul>
<li>State —— this.$store.state.xxx 取值。       包含了 store 中存储的各个状态</li>
<li>Getter —— this.$store.getters.xxx 取值。      借助 Vue 的计算属性 computed 来实现缓存</li>
<li>Mutation —— this.$store.commit( “xxx” )赋值。      更改 state 方法，<strong>只能是同步操作</strong></li>
<li>Action —— this.$store.dispatch( “xxx” )赋值。      触发 mutation 方法，<strong>可以包含异步操作</strong></li>
<li>Module。      Vue.set 动态添加 state 到响应式数据中</li>
</ul>
<p>由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter 暴露给 view 层的组件或者页面，页面监测到状态改变，于是更新页面。</p>
<h2 id="vuex-中如何组合使用多个-action"><a href="#vuex-中如何组合使用多个-action" class="headerlink" title="*vuex 中如何组合使用多个 action?"></a>*vuex 中如何组合使用多个 action?</h2><p>参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43974265/article/details/114138184">在vuex中组合使用多个action</a></p>
<p>业务逻辑场景：存在2个action，actionA和actionB，先执行完actionA才能执行actionB。</p>
<p>（<code>$store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>$store.dispatch</code> 仍旧返回 Promise）</p>
<ol>
<li><p>在组件里派发 action：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 派发其它的 action，编写其它逻辑代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>在另一个action中派发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">actionB</span>(<span class="params">&#123;dispatch, commit&#125;</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// then方法返回的是一个新的 Promise 实例，可以 return 出去，继续链式调用</span></span><br><span class="line">  <span class="keyword">return</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    commit(<span class="string">&#x27;someOtherMutation&#x27;</span>);  <span class="comment">// 在 actionA执行完成之后，再执行 actionB的代码</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>async/await</code> 的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;getData&#x27;</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">&#x27;getOtherData&#x27;</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="有使用过-vuex-的-module-吗？主要是在什么场景下使用？"><a href="#有使用过-vuex-的-module-吗？主要是在什么场景下使用？" class="headerlink" title="*有使用过 vuex 的 module 吗？主要是在什么场景下使用？"></a>*有使用过 vuex 的 module 吗？主要是在什么场景下使用？</h2><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>这时我们可以将 store 分割为<strong>模块（module）</strong>，每个模块拥有自己的 <code>state</code> 、 <code>getters</code> 、<code>mutations</code> 、<code>actions</code> 、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>
<h3 id="mutation-和-action-的区别？（to-understand）"><a href="#mutation-和-action-的区别？（to-understand）" class="headerlink" title="mutation 和 action 的区别？（to understand）"></a>mutation 和 action 的区别？（to understand）</h3><h3 id="为什么-action-提交-mutation-变更状态？（to-understand）"><a href="#为什么-action-提交-mutation-变更状态？（to-understand）" class="headerlink" title="为什么 action 提交 mutation 变更状态？（to understand）"></a>为什么 action 提交 mutation 变更状态？（to understand）</h3><h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><p>具体见 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6951262189168623623#heading-1">https://juejin.cn/post/6951262189168623623#heading-1</a></p>
<h2 id="Vue3-的特点？"><a href="#Vue3-的特点？" class="headerlink" title="Vue3 的特点？"></a>Vue3 的特点？</h2><ul>
<li>节点打 Tag，更新页面时直接定位到动态节点，会跳过静态的div，节省效率。</li>
<li>Tree Shaking 按需加载</li>
<li>Better TypeScript Support 更好的支持TypeScript语法</li>
<li>响应式 Proxy</li>
<li>增加 Composition api</li>
</ul>
<h2 id="Vue3-对响应式（数组）做了怎样的改进？（高频）"><a href="#Vue3-对响应式（数组）做了怎样的改进？（高频）" class="headerlink" title="Vue3 对响应式（数组）做了怎样的改进？（高频）"></a>Vue3 对响应式（数组）做了怎样的改进？（高频）</h2><p>vue2 在初始化的时候，通过 Object.defineProperty 对 data 的每个属性进行访问和修改的拦截，getter 进行依赖收集、setter 派发更新。Object.defineProperty 的几个缺点：</p>
<ul>
<li>初始化时需要<strong>遍历对象所有 key</strong>，如果嵌套对象，需要深层监听，造成性能问题</li>
<li>动态<strong>新增、删除</strong>对象属性无法拦截，只能用 set/delete api代替</li>
<li>无法监控到<strong>数组</strong>下标的变化(监听的性能代价太大)，所以需要对数组 api 方法进行重写</li>
<li>不支持新的Map、Set等数据结构</li>
</ul>
<p>vue3 用 proxy 全面代替 Object.defineProperty。proxy 拦截的是整个对象而不是对象的属性。proxy 的优势：</p>
<ul>
<li>可以监听多种操作方法，包括动态新增的属性和删除属性、has、apply等操作</li>
<li>可以监听数组的索引和 length 等属性</li>
<li>懒执行（在访问到对象属性的时候才会递归代理这个对象属性），不需要初始化的时候递归遍历</li>
<li>浏览器新标准，性能更好，并且有持续优化的可能</li>
</ul>
<p>更具体见 <a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue3/proxy.html">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</a></p>
<h2 id="vue3-与-vue2-区别？"><a href="#vue3-与-vue2-区别？" class="headerlink" title="vue3 与 vue2 区别？"></a>vue3 与 vue2 区别？</h2><p><strong>大的改动：</strong></p>
<ul>
<li>proxy 代替 Object.definePrototety 响应式系统</li>
<li>ts 代替 flow 类型检查</li>
<li>重构了目录结构，将代码主要分成三个独立的模块，更利于长期维护</li>
<li>重写 vdom，优化编译性能</li>
<li>支持 tree shaking</li>
<li>增加了 Composition API(setup)，让代码更易于维护</li>
</ul>
<p><strong>小的改动:</strong></p>
<ul>
<li>异步组件需要 defineAsyncComponent 方法来创建</li>
<li>v-model 用法</li>
<li>v-if 优先级高于 v-for</li>
<li>destroyed 生命周期选项被重命名为 unmounted</li>
<li>beforeDestroy 生命周期选项被重命名为 beforeUnmount</li>
<li>render函数默认参数createElement移除改为全局引入</li>
<li>组件事件现在需要在 emits 选项中声明</li>
</ul>
<p><strong>新特性：</strong></p>
<ul>
<li>组合式 API</li>
<li>Teleport</li>
<li>framents（组件支持多个根节点）</li>
<li>createRenderer（跨平台的自定义渲染器）</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/">https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/13/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E5%9F%BA%E4%BA%8Epannellum%E7%9A%84%E5%85%A8%E6%99%AF%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【项目复盘】— — 基于pannellum的全景H5页面实现</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/"><img class="next-cover" src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【面试准备】— — JavaScript篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Asura1211"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">Vue 双向数据绑定（响应式）原理？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#v-model-%E6%98%AF%E4%BB%80%E4%B9%88%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%EF%BC%88todo%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">*v-model 是什么的语法糖（todo）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Virtual-DOM%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">什么是 Virtual DOM？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Virtual-DOM-%E6%AF%94%E5%8E%9F%E7%94%9F-DOM-%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么 Virtual DOM 比原生 DOM 快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-DOM-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">如何比较两个 DOM 树的差异？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD-diff-%E7%AE%97%E6%B3%95%EF%BC%9F-%E9%AB%98%E9%A2%91"><span class="toc-number">1.3.</span> <span class="toc-text">Vue 中 diff 算法？(高频)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">diff 中 key 值的作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">vue 中 key 值的作用？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%92%8C-React-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">Vue 和 React 之间的区别（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">diff 算法区别？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery-%E4%B8%8E-vue-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.2.</span> <span class="toc-text">jQuery 与 vue 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">Vue 的生命周期是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">各个生命阶段？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive-%E7%BB%84%E4%BB%B6%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">keep-alive 组件作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">Vue 组件间的参数传递方式？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">父子通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">兄弟组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.3.</span> <span class="toc-text">跨多层次组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E7%BB%84%E4%BB%B6"><span class="toc-number">1.7.4.</span> <span class="toc-text">任意组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.7.5.</span> <span class="toc-text">单向数据流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">computed 和 watch 的区别？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVVM%EF%BC%9F%E6%AF%94%E4%B9%8B-MVC-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF-MVP%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">什么是 MVVM？比之 MVC 有什么区别？什么是 MVP（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-MVVM-%E6%A1%86%E6%9E%B6%EF%BC%88to-understand%EF%BC%89"><span class="toc-number">1.9.1.</span> <span class="toc-text">*实现一个简单的 MVVM 框架（to understand）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-nextTick-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.10.</span> <span class="toc-text">Vue 中的 nextTick 原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.10.1.</span> <span class="toc-text">应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-data-%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%80%BC%E6%94%B9%E5%8F%98%E5%90%8E%EF%BC%8C%E8%A7%86%E5%9B%BE%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%B8%B2%E6%9F%93%E5%90%97%EF%BC%9F"><span class="toc-number">1.10.2.</span> <span class="toc-text">Vue data 某个属性值改变后，视图会立即同步执行渲染吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-vue"><span class="toc-number">1.11.</span> <span class="toc-text">介绍一下 vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">vue 常用的修饰符？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">vue 指令？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">前端路由原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.14.1.</span> <span class="toc-text">Hash 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.14.2.</span> <span class="toc-text">History 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88history%E6%A8%A1%E5%BC%8F%E9%9C%80%E8%A6%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%AF%E6%8C%81%EF%BC%9F"><span class="toc-number">1.14.3.</span> <span class="toc-text">为什么history模式需要服务器支持？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.4.</span> <span class="toc-text">两种模式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.14.5.</span> <span class="toc-text">前端路由优缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.15.</span> <span class="toc-text">vue-router 中的导航钩子函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">Vue 中 $route 和 $router 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1%E4%BD%BF%E4%B8%8D%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9A%84url%E8%B7%B3%E8%BD%AC%E5%88%B0404%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.17.</span> <span class="toc-text">如何设置路由使不能匹配的url跳转到404页面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vuex"><span class="toc-number">2.</span> <span class="toc-text">Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Vuex%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是 Vuex？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">Vuex 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-amp-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">Vuex 核心概念&amp;底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex-%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-action"><span class="toc-number">2.4.</span> <span class="toc-text">*vuex 中如何组合使用多个 action?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87-vuex-%E7%9A%84-module-%E5%90%97%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">*有使用过 vuex 的 module 吗？主要是在什么场景下使用？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mutation-%E5%92%8C-action-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88to-understand%EF%BC%89"><span class="toc-number">2.5.1.</span> <span class="toc-text">mutation 和 action 的区别？（to understand）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-action-%E6%8F%90%E4%BA%A4-mutation-%E5%8F%98%E6%9B%B4%E7%8A%B6%E6%80%81%EF%BC%9F%EF%BC%88to-understand%EF%BC%89"><span class="toc-number">2.5.2.</span> <span class="toc-text">为什么 action 提交 mutation 变更状态？（to understand）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3"><span class="toc-number">3.</span> <span class="toc-text">Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">Vue3 的特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-%E5%AF%B9%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%E5%81%9A%E4%BA%86%E6%80%8E%E6%A0%B7%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">Vue3 对响应式（数组）做了怎样的改进？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3-%E4%B8%8E-vue2-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">vue3 与 vue2 区别？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%98%BF%E9%87%8C%E7%BB%83%E4%B9%A0%E7%94%9F/" title="【学习笔记】— — 阿里练习生"><img src="https://i.loli.net/2021/11/20/6kUmfsBR2yEIqnD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【学习笔记】— — 阿里练习生"/></a><div class="content"><a class="title" href="/2021/11/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%98%BF%E9%87%8C%E7%BB%83%E4%B9%A0%E7%94%9F/" title="【学习笔记】— — 阿里练习生">【学习笔记】— — 阿里练习生</a><time datetime="2021-11-14T19:07:06.000Z" title="发表于 2021-11-15 03:07:06">2021-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/14/%E3%80%90%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E3%80%91%E2%80%94%20%E2%80%94%20%E9%9D%A2%E7%BB%8F/" title="【面试记录】— — 面经"><img src="https://i.loli.net/2021/11/20/jROsEmxYHqpdNyV.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试记录】— — 面经"/></a><div class="content"><a class="title" href="/2021/11/14/%E3%80%90%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95%E3%80%91%E2%80%94%20%E2%80%94%20%E9%9D%A2%E7%BB%8F/" title="【面试记录】— — 面经">【面试记录】— — 面经</a><time datetime="2021-11-14T15:02:21.000Z" title="发表于 2021-11-14 23:02:21">2021-11-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家社区商城"/></a><div class="content"><a class="title" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城">【项目复盘】— — 贤得家社区商城</a><time datetime="2021-10-31T15:01:17.000Z" title="发表于 2021-10-31 23:01:17">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题"><img src="https://i.loli.net/2021/11/20/NIbleFaWKTwf6GO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 常见问题"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题">【面试准备】— — 常见问题</a><time datetime="2021-10-11T14:03:14.000Z" title="发表于 2021-10-11 22:03:14">2021-10-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>