<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【面试准备】— — Vue篇 | 青山の博客</title><meta name="keywords" content="Vue"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：CSS 面试知识点总结。侵权删。 Vue 原理参考自 https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6919373017218809864 当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内">
<meta property="og:type" content="article">
<meta property="og:title" content="【面试准备】— — Vue篇">
<meta property="og:url" content="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：CSS 面试知识点总结。侵权删。 Vue 原理参考自 https:&#x2F;&#x2F;juejin.cn&#x2F;post&#x2F;6919373017218809864 当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/26/i6csUxdw4EeS5mX.png">
<meta property="article:published_time" content="2021-07-10T14:02:20.000Z">
<meta property="article:modified_time" content="2021-12-07T05:55:56.678Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/11/26/i6csUxdw4EeS5mX.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【面试准备】— — Vue篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-07 13:55:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/11/26/i6csUxdw4EeS5mX.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【面试准备】— — Vue篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-10T14:02:20.000Z" title="发表于 2021-07-10 22:02:20">2021-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-07T05:55:56.678Z" title="更新于 2021-12-07 13:55:56">2021-12-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【面试准备】— — Vue篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：<a target="_blank" rel="noopener" href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/Css/Css.md">CSS 面试知识点总结</a>。侵权删。</p>
<h2 id="Vue-原理"><a href="#Vue-原理" class="headerlink" title="Vue 原理"></a>Vue 原理</h2><p>参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6919373017218809864">https://juejin.cn/post/6919373017218809864</a></p>
<p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
<h2 id="Vue-双向数据绑定（响应式）原理？（高频）"><a href="#Vue-双向数据绑定（响应式）原理？（高频）" class="headerlink" title="Vue 双向数据绑定（响应式）原理？（高频）"></a>Vue 双向数据绑定（响应式）原理？（高频）</h2><p>vue 的双向数据绑定主要是通过使用<strong>数据劫持</strong>和<strong>发布订阅者模式</strong>来实现 View 和 Model 的同步更新。首先通过 Object.defineProperty() 对 Model 数据各个属性添加访问器属性，以此实现数据的劫持，因此当 Model 中的数据发生变化的时候，可以通过配置的 setter 和 getter 方法实现对 View 层数据更新的通知。</p>
<p>流程大概如下：</p>
<ol>
<li>实现一个监听器 Observer，用来劫持并监听所有属性，如果发生变动，则拿到最新值并通知订阅者。核心方法是<strong>利用 <code>Object.defineProperty()</code> 通过递归的方式对所有属性添加 setter、getter 方法进行监听。</strong></li>
<li>实现一个解析器 Compile，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。</li>
<li>实现一个订阅者 Watcher，作为连接Observer和Compile的桥梁。<ul>
<li>在自身实例化时往属性订阅器(dep)里面添加自己 </li>
<li>自身必须有一个update()方法 </li>
<li>待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。</li>
</ul>
</li>
<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/27/g9D4Bciwbz2O7Nr.png" alt="image.png"></p>
<p>参考资料：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006599500">剖析Vue原理&amp;实现双向绑定MVVM</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/reactivity.html">https://cn.vuejs.org/v2/guide/reactivity.html</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016884795">https://segmentfault.com/a/1190000016884795</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6854573210285899789">https://juejin.cn/post/6854573210285899789</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6919373017218809864">https://juejin.cn/post/6919373017218809864</a></p>
<h3 id="Vue2-给-data-对象添加新属性"><a href="#Vue2-给-data-对象添加新属性" class="headerlink" title="Vue2 给 data 对象添加新属性"></a>Vue2 给 data 对象添加新属性</h3><p>使用Vue的全局 api **$set()**。相当于手动的把obj.b处理成一个响应式的属性，此时视图就会随之改变。</p>
<p>vm.<code>$set</code> 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 splice 方法触发响应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ul>
<h3 id="Vue3-对响应式（数组）做了怎样的改进？（高频）"><a href="#Vue3-对响应式（数组）做了怎样的改进？（高频）" class="headerlink" title="Vue3 对响应式（数组）做了怎样的改进？（高频）"></a>Vue3 对响应式（数组）做了怎样的改进？（高频）</h3><p>vue2 在初始化的时候，通过 Object.defineProperty 对 data 的每个属性进行访问和修改的拦截，getter 进行依赖收集、setter 派发更新。Object.defineProperty 的几个缺点：</p>
<ul>
<li><p>初始化时需要<strong>遍历对象所有 key</strong>，如果嵌套对象，需要深层监听，造成性能问题</p>
</li>
<li><p>动态<strong>新增、删除</strong>对象属性无法拦截，只能用 set/delete api代替</p>
</li>
<li><p>无法监控到<strong>数组下标的变化</strong>(监听的性能代价太大)，所以需要对数组 api 方法（”push”,  “pop”,  “shift”,  “unshift”,  “splice”,  “sort”,  “reverse”）进行重写。</p>
<p>首先获取到这个数组的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p>
</li>
<li><p>不支持新的Map、Set等数据结构</p>
</li>
</ul>
<p>vue3 用 proxy 全面代替 Object.defineProperty。proxy 拦截的是<strong>整个对象</strong>而不是对象的属性。proxy 的优势：</p>
<ul>
<li>可以监听多种操作方法，包括动态新增的属性和删除属性、has、apply等操作</li>
<li>可以监听数组的索引和 length 等属性<strong>（数组的变化）</strong></li>
<li><strong>懒执行</strong>（在访问到对象属性的时候才会递归代理这个对象属性），不需要初始化的时候递归遍历</li>
<li>支持 Map，Set，WeakMap 和 WeakSet。</li>
<li>浏览器新标准，性能更好，并且有持续优化的可能</li>
</ul>
<p>更具体见 <a target="_blank" rel="noopener" href="https://vue3js.cn/interview/vue3/proxy.html">Vue3.0里为什么要用 Proxy API 替代 defineProperty API ？</a></p>
<h2 id="什么是-Virtual-DOM？（高频）"><a href="#什么是-Virtual-DOM？（高频）" class="headerlink" title="什么是 Virtual DOM？（高频）"></a>什么是 Virtual DOM？（高频）</h2><p>对将要插入到文档中的 <strong>DOM 树结构进行分析</strong>，<strong>使用 js 对象表示</strong>。比如一个元素对象包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树保存下来，最后再将 DOM 片段插入到文档中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">  <span class="attr">tagName</span>: <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: &#123;</span><br><span class="line">    <span class="attr">tagName</span>: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对应的 DOM 就是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&#x27;list&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>当页面的状态发生改变，需要对 DOM 结构进行调整时，首先根据变更的状态，重新构建起一棵对象树</li>
<li>然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的差异</li>
<li>最后将记录有差异的地方应用到真正的 DOM 树，这样视图就更新了。判断差异的算法分为两步：<ul>
<li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步会给每个节点添加索引，便于最后渲染差异。（需要判断新旧节点的 <code>tagName</code> 是否相同，如果不相同的话就代表节点被替换。相同则判断是否有子元素，有就进行第二步）</li>
<li>一旦节点有子元素，就判断子元素是否有不同。（原列表是否有节点被移除、新列表是否有新节点加入、节点是否有移动）</li>
</ul>
</li>
</ol>
<h3 id="为什么-Virtual-DOM-比原生-DOM-快？"><a href="#为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="为什么 Virtual DOM 比原生 DOM 快？"></a><strong>为什么 Virtual DOM 比原生 DOM 快？</strong></h3><p>Virtual DOM 这种方法对于需要有大量 DOM 操作的时候，能够很好的提高操作效率，通过在操作前确定需要做的最小修改，从而<strong>尽可能减少 DOM 操作带来的回流和重绘影响</strong>。其实 Virtual DOM 并不一定比真实操作 DOM 快，这种方法是为了提高开发时的可维护性：在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</p>
<p><strong>Virtual DOM 最大的优势</strong>：</p>
<ol>
<li>将 Virtual DOM 作为一个兼容层，让还能对接非 Web 端的系统，实现跨端开发。</li>
<li>同样的，通过 Virtual DOM 可以渲染到其他的平台，比如实现 SSR、同构渲染等等。</li>
<li>实现组件的高度抽象化。</li>
</ol>
<h3 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h3><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，很少会跨层级的移动元素，所以只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p>
<p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p>
<p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以不能使用这个来对比。需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样才能够复用老的 DOM 树上的节点。</p>
<h2 id="Vue-中-diff-算法？-高频"><a href="#Vue-中-diff-算法？-高频" class="headerlink" title="Vue 中 diff 算法？(高频)"></a>Vue 中 diff 算法？(高频)</h2><p>部分参考自<a target="_blank" rel="noopener" href="https://juejin.cn/post/6994959998283907102">https://juejin.cn/post/6994959998283907102</a></p>
<p>Diff 算法是一种<strong>对比算法</strong>。对比旧虚拟 DOM 和新虚拟 DOM，找出发生更改的虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不更新其他节点，实现精准地更新真实 DOM，提高效率。</p>
<p><strong>原理</strong>：Diff 算法比较只会在同层级进行, 不会跨层级比较。diff 算法是深度优先算法，时间复杂度 O(n)</p>
<p><strong>对比流程</strong>：当数据改变时，会触发 setter，并且通过 Dep.notify 去通知所有订阅者 Watcher，订阅者们就会调用  patch 方法，给真实 DOM 打补丁，更新相应的视图。</p>
<p><img src="https://i.loli.net/2021/10/27/a63sB5EAdQIKhgD.png" alt="image.png"></p>
<ol>
<li><p>patch 方法：对比当前同层的虚拟节点是否为同一种类型的标签。</p>
<ul>
<li><p>是：继续执行 patchVnode 方法进行深层比对</p>
</li>
<li><p>否：没必要比对，直接整个节点替换成新虚拟节点</p>
</li>
</ul>
</li>
<li><p>sameVnode 方法：判断是否为同一类型节点</p>
</li>
<li><p>patchVnode 方法：</p>
<ul>
<li>找到对应的真实 DOM，称为 el</li>
<li>判断<code>newVnode</code>和<code>oldVnode</code>是否指向同一个对象，如果是（没有变化）直接<code>return</code></li>
<li>如果他们都有文本节点并且不相等，那么将<code>el</code>的文本节点设置为<code>newVnode</code>的文本节点</li>
<li>如果<code>oldVnode</code>有子节点而<code>newVnode</code>没有，则删除<code>el</code>的子节点</li>
<li>如果<code>oldVnode</code>没有子节点而<code>newVnode</code>有，则将<code>newVnode</code>的子节点真实化之后添加到<code>el</code></li>
<li>如果两者都有子节点，则执行<code>updateChildren</code>函数比较子节点，<strong>这一步很重要</strong></li>
</ul>
</li>
<li><p>updateChildren 方法：新旧虚拟节点的子节点对比（首尾指针法）。新的子节点集合和旧的子节点集合，各有首尾两个指针。总共有五种比较情况：</p>
<ul>
<li><code>oldS 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newS)</code></li>
<li><code>oldS 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldS, newE)</code></li>
<li><code>oldE 和 newS </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newS)</code></li>
<li><code>oldE 和 newE </code>使用<code>sameVnode方法</code>进行比较，<code>sameVnode(oldE, newE)</code></li>
<li>如果以上逻辑都匹配不到，再把所有旧子节点的 <code>key</code> 做一个映射到旧节点下标的 <code>key -&gt; index</code> 表，然后用新 <code>vnode</code> 的 <code>key</code> 去找出在旧节点中可以复用的位置。</li>
</ul>
</li>
</ol>
<p><strong>节点的插入删除移动的具体流程</strong>见4！</p>
<h3 id="diff-中-key-值的作用？"><a href="#diff-中-key-值的作用？" class="headerlink" title="diff 中 key 值的作用？"></a>diff 中 key 值的作用？</h3><p>如果用 index 做为 key，插入一个新数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>                      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;0&quot;</span>&gt;</span>林三心<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span>        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                              <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;3&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>                     <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>理想结果：只插入一个li标签新节点，其他都不动，确保操作DOM效率最高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">   &lt;li v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;button @click=&quot;add&quot;&gt;增加&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">list: [</span><br><span class="line">    &#123; title: &quot;a&quot;, id: &quot;100&quot; &#125;,</span><br><span class="line">    &#123; title: &quot;b&quot;, id: &quot;101&quot; &#125;,</span><br><span class="line">    &#123; title: &quot;c&quot;, id: &quot;102&quot; &#125;,</span><br><span class="line">]</span><br><span class="line">      </span><br><span class="line">add() &#123;</span><br><span class="line">    this.list.unshift(&#123; title: &quot;林三心&quot;, id: &quot;99&quot; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是结果是<strong>所有 li 标签都更新了</strong>。原因：在进行子节点的 diff 算法过程中，会<strong>先进行旧首节点和新首节点的sameNode 对比</strong>，这一步命中逻辑，因为现在新旧两次首部节点的 key 都是 0。同理 key 为 1 和 2  的也命中逻辑，导致相同 key 节点会进行 patchVnode 更新文本，而原本就有的 c 节点，却因为之前没有 key 为 4 的节点，而被当做新节点。使用 index 做 key，<strong>前三个都进行patchVnode更新文本，最后一个进行了新增节点</strong>。</p>
<p>解决方案：使用一个独一无二的值来当做 key。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.title &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样的话，a，b，c 节点的 key 永远不变，所以就算进行了 patchVnode，也不会执行更新操作，节省了性能。而新增节点，由于更新前没有它的 key 所对应的节点，所以被当做新的节点，增加到真实DOM。</p>
<h2 id="vue-中-key-值的作用？（高频）"><a href="#vue-中-key-值的作用？（高频）" class="headerlink" title="vue 中 key 值的作用？（高频）"></a>vue 中 key 值的作用？（高频）</h2><ol>
<li>v-if 中使用 key：由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此使用 v-if 实现元素切换时，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，显然不符合需求。因此通过使用 key 来<strong>唯一标识一个元素</strong>，这样使用 key 的元素不会被复用。</li>
<li><strong>v-for 中使用 key</strong>：用 v-for 更新已渲染过的元素列表时，默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，使 Vue 跟踪元素的身份，从而高效的实现复用。这时 key 的作用是<strong>为了高效的更新渲染虚拟 DOM。</strong></li>
</ol>
<p><strong>深入讲讲：</strong></p>
<p>Vue 在 patch 过程中判断两个节点是否是相同节点，key 是一个必要条件。渲染一组列表时，key 往往是唯一标识。由于 Vue 判断两个节点是否相同时，主要判断两者的 key 和元素类型，如果不设置 key，值就是 undefined，则可能永远认为这是两个相同的节点，这导致了频繁更新元素，使得整个 patch 过程比较低效，影响性能。</p>
<h2 id="Vue-和-React-之间的区别（高频）"><a href="#Vue-和-React-之间的区别（高频）" class="headerlink" title="Vue 和 React 之间的区别（高频）"></a>Vue 和 React 之间的区别（高频）</h2><p><strong>相同点：</strong>围绕着数据流和组件化以及 diff 策略来答</p>
<ul>
<li>使用Virtual DOM，用 js 模拟 DOM 结构，提高重绘性能。支持数据驱动视图，不直接操作真实 dom</li>
<li>组件化开发，都支持 props 进行父子组件之间的数据通信</li>
<li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库（redux， Vuex）。</li>
<li>都支持服务器端的渲染</li>
<li>都支持 native 方案，React 的 react native，Vue 的 WEEX</li>
</ul>
<p><strong>异同点：</strong>围绕着更新的触发方式，以及异步和同步的渲染过程来答</p>
<ul>
<li>Vue 的表单可以使用 v-model 支持<strong>双向绑定</strong>，而 React 的数据流动是<strong>单向</strong>的。当然 v-model 是语法糖，本质上和 React 写表单的方式没区别。</li>
<li><strong>改变数据方式</strong>不同，Vue 修改状态只需要通过 this 的某种方式去更新 state 中的数据，而 React 需要使用 <code>setState</code> 来改变状态。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优，但是 React 还是需要用户手动去优化这方面的问题。</li>
<li>React 需要使用 <strong>JSX</strong>（JSX 是使用 XML 语法编写 JavaScript 的一种语法糖），有一定上手成本，并且需要一整套工具链支持，但是完全可以通过 JS 来控制页面，更加灵活。Vue 使用了<strong>模板语法</strong>，相比于 JSX 来说没有那么灵活，但是可以脱离工具链，通过直接编写 <code>render</code> 函数就能在浏览器中运行。</li>
<li>React 的思想很棒，各种抽象和模式使得代码更加美观。</li>
</ul>
<p>更多可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6847009771355127822#heading-46">你不知道的React 和 Vue 的20个区别</a>。</p>
<h3 id="vue-和-react-的渲染差异？（todo）"><a href="#vue-和-react-的渲染差异？（todo）" class="headerlink" title="vue 和 react 的渲染差异？（todo）"></a>vue 和 react 的渲染差异？（todo）</h3><h3 id="diff-算法区别？（高频）"><a href="#diff-算法区别？（高频）" class="headerlink" title="diff 算法区别？（高频）"></a>diff 算法区别？（高频）</h3><p>参考自 <a target="_blank" rel="noopener" href="https://cxyzjd.com/article/qq_45932447/110001564">https://cxyzjd.com/article/qq_45932447/110001564</a></p>
<p><strong><a target="_blank" rel="noopener" href="https://juejin.cn/post/6919376064833667080">=&gt;react、vue2、vue3 的 diff 算法区别（good！）</a></strong></p>
<p>vue 和 react 的 diff 算法，都是忽略跨级比较，只做同级比较，复杂度都为 O(n)。vue diff 时调动 patch 函数。react 的思路是递增法：通过对比新列表中的节点，在原本的列表中的位置是否递增，来判断当前节点是否需要移动。</p>
<ol>
<li>vue 列表比对，采用<strong>从两端到中间的比对方式</strong>，而 react 则采用<strong>从左到右依次比对的方式</strong>。当一个集合只是把最后一个节点移动到了第一个，react 会把前面的节点依次移动，而 vue 只会把最后一个节点移动到第一个。</li>
<li>vue 比对节点，当<strong>节点元素类型相同，但是 className 不同</strong>，认为是不同类型元素，删除重建；而 react 会认为是同类型节点，只是修改节点属性。</li>
</ol>
<p>总体上，vue 的对比方式更高效。</p>
<h3 id="jQuery-与-vue-区别"><a href="#jQuery-与-vue-区别" class="headerlink" title="jQuery 与 vue 区别"></a>jQuery 与 vue 区别</h3><ol>
<li>jQuery 使用选择器选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，和原生 HTML 区别只在于可以更方便的选取和操作 DOM 对象，数据和界面还是在一起的。比如需要获取 label 标签的内容：<code>(“lable”).val(); </code> 还是依赖DOM元素的值。</li>
<li>Vue 则是通过 Vue 对象将数据和 View 完全分离。对数据进行操作不再需要引用相应的 DOM 对象。</li>
</ol>
<p>Vue 优点：</p>
<ul>
<li>数据的自动绑定</li>
<li>页面参数传递和页面状态管理。</li>
<li>模块化开发、无刷新保留场景参数更新</li>
<li>代码的可阅读性（模块化开发带来的）</li>
<li>基于强大的nodejs，拥有npm包管理器，可以很好滴管理包的版本</li>
<li>各子组件样式不冲突</li>
<li>视图,数据,结构分离</li>
<li>虚拟dom</li>
<li>各种指令;过滤器</li>
</ul>
<h2 id="Vue-的生命周期是什么？"><a href="#Vue-的生命周期是什么？" class="headerlink" title="Vue 的生命周期是什么？"></a>Vue 的生命周期是什么？</h2><p>Vue 的生命周期指的是组件从创建到销毁的一系列的过程。</p>
<h3 id="各个生命阶段？（高频）"><a href="#各个生命阶段？（高频）" class="headerlink" title="各个生命阶段？（高频）"></a>各个生命阶段？（高频）</h3><p>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。<img src="https://i.loli.net/2021/10/17/8VDnJaCiH5A9vyZ.png" alt="12602393-5310c1449192165f.jpg"></p>
<p>（1）beforeCreate：在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中获取不到 props 或者 data 数据。</p>
<p>（2）created：在<strong>实例创建完成后</strong>触发，此时可以<strong>访问 data、methods 等属性</strong>。但组件还没有被挂载到页面中去，所以<strong>访问不到 $el 属性</strong>。一般可以在这个函数中<strong>进行一些页面初始化的工作</strong>，比如通过 ajax 请求数据来对页面进行初始化。</p>
<p>（3）beforeMount：在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</p>
<p>（4）mounted：在<strong>组件挂载到页面后</strong>触发。此时可以<strong>获取页面中的 DOM 元素</strong>。</p>
<p>（5）beforeUpdate：在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候可以对可能会被移除的元素做一些操作，比如<strong>移除事件监听器</strong>。</p>
<p>（6）updated：虚拟 DOM 重新渲染和打补丁之后调用。</p>
<p>（7）beforeDestroy：在实例销毁之前调用。在这一步可以<strong>销毁定时器、解绑全局事件</strong>等。</p>
<p>（8）destroyed：在实例销毁之后调用。调用后，Vue 实例中的所有东西都会解除绑定，<strong>所有的事件监听器会被移除</strong>，所有的子实例也会被销毁。</p>
<p>当使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。</p>
<h3 id="keep-alive-组件作用？"><a href="#keep-alive-组件作用？" class="headerlink" title="keep-alive 组件作用？"></a>keep-alive 组件作用？</h3><p>如果需要<strong>在组件切换的时候，保存一些组件的状态防止多次渲染</strong>，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<p>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 keep-alive 包裹的组件在切换时不会进行销毁，当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p>
<p>keep-alive有以下三个属性：</p>
<ul>
<li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li>
<li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li>
<li>max 数字，最多可以缓存多少组件实例。</li>
</ul>
<h3 id="在哪个生命周期请求异步数据、绑定事件、取消事件？"><a href="#在哪个生命周期请求异步数据、绑定事件、取消事件？" class="headerlink" title="在哪个生命周期请求异步数据、绑定事件、取消事件？"></a>在哪个生命周期请求异步数据、绑定事件、取消事件？</h3><p>可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li>
<li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li>
</ul>
<h3 id="父子组件的生命周期顺序？"><a href="#父子组件的生命周期顺序？" class="headerlink" title="父子组件的生命周期顺序？"></a>父子组件的生命周期顺序？</h3><p>参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42072086/article/details/108385632">https://blog.csdn.net/qq_42072086/article/details/108385632</a></p>
<p>父子组件的<strong>加载渲染过程顺序</strong>为：（当dom渲染时，会创建元素，然后进行初始化，初始化组件的时候内部还有组件，会不停的去渲染，所以它的渲染顺序是先父后子，完成的顺序是先子后父。）</p>
<ul>
<li>父组件beforeCreated</li>
<li>父组件created </li>
<li>父组件beforeMounted </li>
<li>子组件beforeCreated </li>
<li>子组件created </li>
<li>子组件beforeMounted </li>
<li>子组件mounted </li>
<li><strong>父组件mounted</strong>（最后）</li>
</ul>
<p><strong>子组件更新过程</strong>：</p>
<ul>
<li>父beforeUpdate</li>
<li>子beforeUpdate</li>
<li>子updated</li>
<li>父updated</li>
</ul>
<p><strong>销毁过程</strong>：</p>
<ul>
<li>父beforeDestroy</li>
<li>子beforeDestroy</li>
<li>子destroyed</li>
<li>父destroyed</li>
</ul>
<h3 id="继承组件的生命周期顺序？"><a href="#继承组件的生命周期顺序？" class="headerlink" title="继承组件的生命周期顺序？"></a>继承组件的生命周期顺序？</h3><p>交替进行。</p>
<h2 id="Vue-组件间的参数传递方式？（高频）"><a href="#Vue-组件间的参数传递方式？（高频）" class="headerlink" title="Vue 组件间的参数传递方式？（高频）"></a>Vue 组件间的参数传递方式？（高频）</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><ol>
<li><p><strong>props / $emit</strong>：<code>props</code>只能是父组件向子组件进行传值，然后父组件在子组件上通过<code>v-on</code>注册监听事件，子组件通过 $emit 触发事件向父组件发送数据。这是典型的<strong>单向数据流</strong>，子组件不能直接修改 props， 而是必须通过发送事件的方式告知父组件修改数据。</p>
</li>
<li><p><strong>ref / $refs</strong>：通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，实现通信。（可以使用<code>$root</code>来访问根组件的实例）</p>
</li>
<li><p><strong>provider/inject</strong>：在父组件中通过 provider 提供变量，在子组件中通过 inject 将变量注入到组件中。不论子组件有多深，只要调用 inject，就可以注入 provider 中的数据。</p>
</li>
</ol>
<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><ol>
<li> eventBus 事件总线（<code>$emit / $on</code>）：，本质是通过<strong>创建一个空的 Vue 实例作为消息传递的对象</strong>，通信的组件引入这个实例，通过在实例上监听和触发事件实现消息的传递。<strong>缺点</strong>：如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</li>
</ol>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br><span class="line"><span class="comment">// 发送 firstComponent.vue</span></span><br><span class="line">EventBus.$emit(<span class="string">&#x27;addition&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">num</span>:<span class="built_in">this</span>.num++</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 接收 secondComponent.vue</span></span><br><span class="line">EventBus.$on(<span class="string">&#x27;addition&#x27;</span>, <span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.count = <span class="built_in">this</span>.count + param.num;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>$parent / $children</strong>：通过查找父组件中的子组件来获取到兄弟组件<code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。注意：拿到的是所有子组件的实例，是一个数组，并且是无序，访问的数据也不是响应式的。（在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组）</li>
</ol>
<h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><ol>
<li><p>Vue中的<strong>依赖注入</strong>（<code>provide / inject</code>）：注意，依赖注入所提供的属性是<strong>非响应式</strong>的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 爷组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 孙组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;data&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.data) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>**<code>$sttr / $listeners</code>**：</p>
<ul>
<li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li>
<li><code>$listeners</code>：是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li>
</ul>
</li>
</ol>
<h3 id="任意组件通信"><a href="#任意组件通信" class="headerlink" title="任意组件通信"></a>任意组件通信</h3><ul>
<li>Event Bus ，其实就是创建一个事件中心，用它来传递事件和接收事件。</li>
<li>Vuex。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面方法就不利于项目的维护。Vuex 的思想就是<strong>将公共数据抽离，作为全局的变量管理</strong>，然后其他组件就可以对公共数据进行读写操作，达到解耦目的。</li>
</ul>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样为了防止子组件意外改变父级组件的状态。</p>
<p>每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着不应该在一个子组件内部改变 prop。</p>
<p>简单的单向数据流是指用户访问 View，View 发出用户交互的 Action，在 Action 里对 state 进行相应更新。state 更新后会触发 View 更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测。</p>
<h2 id="computed-和-watch-的区别？（高频）"><a href="#computed-和-watch-的区别？（高频）" class="headerlink" title="computed 和 watch 的区别？（高频）"></a>computed 和 watch 的区别？（高频）</h2><p>参考自<a target="_blank" rel="noopener" href="https://www.codenong.com/cs105783438/">https://www.codenong.com/cs105783438/</a></p>
<p>（1）computed 是计算一个新的属性（但是<strong>依赖其他属性</strong>），并将该属性挂载到 Vue 实例上，watch 是<strong>监听已经存在且已挂载到 Vue 实例上的数据</strong>，所以用 watch 同样可以监听 computed 计算属性的变化。（computed &lt; watch）</p>
<p>（2）computed 具有<strong>缓存性</strong>，只有当依赖变化后，访问 computed 属性，才会计算新的值（减少模板中计算逻辑）。而 watch 则是<strong>当数据发生变化便会调用执行函数</strong>，在回调中可以执行任何逻辑，如函数节流，Ajax 异步获取数据，甚至操作 DOM。</p>
<p>（3）computed 不支持异步，当Computed中有异步操作时，无法监听数据的变化；watch 支持异步监听。</p>
<p>（4）使用场景：当需要进行数值计算，并且依赖于其它数据时使用 computed（利用缓存特性，避免重新计算），对于监听到值的变化需要做复杂业务逻辑的情况可以使用 watch。</p>
<p>能用 computed 的尽量用 computed。</p>
<h3 id="两者实现计算"><a href="#两者实现计算" class="headerlink" title="两者实现计算"></a>两者实现计算</h3><p>做一个加法运算，对输入 a，输入 b 执行加法，并显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add: function () &#123;</span><br><span class="line">      return this.a + this.b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  // computed 和 methods 其实类似，但是可以有 getter、setter</span><br><span class="line">  computed: &#123;</span><br><span class="line">    returnAdd: function () &#123;</span><br><span class="line">      // return this.a + this.b;</span><br><span class="line">	  // getter</span><br><span class="line">      get: function() &#123;</span><br><span class="line">          this.sumAB_getter = this.a + this.b;</span><br><span class="line">          return this.a + this.b;</span><br><span class="line">      &#125;,</span><br><span class="line">      // setter</span><br><span class="line">      set: function(newVal) &#123;</span><br><span class="line">          console.log(&#x27;returnAdd-setter:&#x27; + newVal);</span><br><span class="line">          this.sumAB_setter = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: function(n, o)&#123;</span><br><span class="line">        this.sumAB_watch = n + this.b;</span><br><span class="line">        console.log(&#x27;a-newValue:&#x27; + n, &#x27;a-oldValue:&#x27; + o, &#x27;sumAB_watch:&#x27; + this.sumAB_watch);</span><br><span class="line">    &#125;,</span><br><span class="line">    b: function(n, o)&#123;</span><br><span class="line">        this.sumAB_watch = this.a + n;</span><br><span class="line">        console.log(&#x27;b-newValue:&#x27; + n, &#x27;b-oldValue:&#x27; + o, &#x27;sumAB_watch:&#x27; + this.sumAB_watch);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="实现一个可复用的-tab-组件？"><a href="#实现一个可复用的-tab-组件？" class="headerlink" title="实现一个可复用的 tab 组件？"></a>实现一个可复用的 tab 组件？</h2><p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components?file=/index.html">https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-dynamic-components?file=/index.html</a> </p>
<h2 id="slot-与-scope-slot？"><a href="#slot-与-scope-slot？" class="headerlink" title="slot 与  scope-slot？"></a>slot 与  scope-slot？</h2><p>slot 又名插槽，是 Vue 的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，<strong>默认插槽（匿名插槽）</strong>，<strong>具名插槽</strong>和<strong>作用域插槽</strong>。</p>
<p>作用域插槽：不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</p>
<p><strong>实现原理</strong>：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>。当组件执行渲染函数遇到slot标签时，会使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>
<h2 id="纯函数和副作用"><a href="#纯函数和副作用" class="headerlink" title="纯函数和副作用"></a>纯函数和副作用</h2><p>参考自 <a target="_blank" rel="noopener" href="https://github.com/zachrey/zblog/issues/3">https://github.com/zachrey/zblog/issues/3</a></p>
<p><strong>函数副作用</strong>：当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量）或修改参数。</p>
<p><strong>无副作用 &amp; 纯函数：</strong></p>
<ol>
<li>函数与外界的只有唯一一个渠道进行沟通，通过传入参数和返回值进行沟通。</li>
<li>相同的传入参数永远只会有相同的返回值。</li>
</ol>
<p>最简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="什么是-MVVM？比之-MVC-有什么区别？什么是-MVP（高频）"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么是-MVP（高频）" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？什么是 MVP（高频）"></a>什么是 MVVM？比之 MVC 有什么区别？什么是 MVP（高频）</h2><p>View 和 Model：</p>
<ul>
<li>View 用户看到的视图</li>
<li>Model 本地数据和数据库中的数据</li>
</ul>
<p>MVC 架构通常是<strong>使用控制器更新模型，视图从模型中获取数据去渲染</strong>。View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作，通过调用 Model 层来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<p><img src="https://i.loli.net/2021/09/11/lahWzk4gVPcbs7U.png" alt="image.png"></p>
<p>但是 MVC 一个巨大的缺陷就是<strong>控制器承担的责任太大</strong>了，随着项目愈加复杂，控制器中的代码会越来越<strong>臃肿</strong>，导致出现不利于<strong>维护</strong>的情况。</p>
<p>**MVP **：与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦：MVC 中的 Controller 只知道 Model 的接口，因此没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter，因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。</p>
<p><strong>MVVM</strong>：与 MVP 思想相同，通<strong>过双向数据绑定将 View 和 Model 的同步更新给自动化</strong>了。<strong>ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据</strong>。这样还可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。以 Vue 框架来举例，<strong>ViewModel 就是组件的实例</strong>。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</p>
<p><img src="https://i.loli.net/2021/09/11/aFJGPc8H3E6pRrg.png" alt="image.png"></p>
<p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p>
<p><img src="https://i.loli.net/2021/09/11/UDACQIv2rqnBNhW.png" alt="image.png"></p>
<p>对于 MVVM 来说，最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是<strong>通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象</strong>。</p>
<h3 id="实现一个简单的-MVVM-框架（to-understand）"><a href="#实现一个简单的-MVVM-框架（to-understand）" class="headerlink" title="*实现一个简单的 MVVM 框架（to understand）"></a>*实现一个简单的 MVVM 框架（to understand）</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2436436c1863">https://www.jianshu.com/p/2436436c1863</a> 好难。。</p>
<h2 id="Vue-中的-nextTick-原理分析"><a href="#Vue-中的-nextTick-原理分析" class="headerlink" title="Vue 中的 nextTick 原理分析"></a>Vue 中的 nextTick 原理分析</h2><p>参考自<a target="_blank" rel="noopener" href="https://www.cxyzjd.com/article/qq_42072086/106987202">https://www.cxyzjd.com/article/qq_42072086/106987202</a></p>
<p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p>
<p>nextTick ：在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。变量：</p>
<ol>
<li>callbacks：用来存储所有需要执行的回调函数</li>
<li>pending：用来标志是否正在执行回调函数</li>
<li>timerFunc：用来触发执行回调函数</li>
</ol>
<p>当调用 nextTick 方法时会传入两个参数，回调函数和执行回调函数的上下文环境，如果没有提供回调函数，那么将返回 promise 对象。首先将拿到的回调函数存放到数组中，判断是否正在执行回调函数，如果当前没有，那么在 pending 的时候，就会执行 timeFunc（多次执行 nextTick 只会执行一次 timerFunc）。timeFunc 其实就是执行异步的方法，然后异步去执行 flushCallbacks 方法（将传递的函数依次执行）。</p>
<p>nextTick 多次调用会维持一个数组，之后会异步的把数组中的方法依次执行，这样用户就会在视图更新之后再获取到真实的dom元素。</p>
<p><img src="https://i.loli.net/2021/10/27/Vq4zSLbRHlCNoiu.png" alt="image.png"></p>
<h3 id="应用场景？"><a href="#应用场景？" class="headerlink" title="应用场景？"></a>应用场景？</h3><ul>
<li>在 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中。原因是在 created() 钩子函数执行时 DOM 并未进行任何渲染，此时进行 DOM 操作无异于徒劳。（mounted就不需要）</li>
<li>在数据变化之后要执行的某个操作，比如设置 <code>vm.someData = &#39;new value&#39;</code>，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始，执行更新时才会进行 DOM 更新。如果此时想要根据最新的 DOM 状态去做某些事情，就会出现问题。因此可以在数据变化之后使用 <code>Vue.nextTick(callback)</code> ，这样回调函数在 DOM 更新完成后就会调用。</li>
</ul>
<h3 id="Vue-data-某个属性值改变后，视图会立即同步执行渲染吗？（高频）"><a href="#Vue-data-某个属性值改变后，视图会立即同步执行渲染吗？（高频）" class="headerlink" title="Vue data 某个属性值改变后，视图会立即同步执行渲染吗？（高频）"></a>Vue data 某个属性值改变后，视图会立即同步执行渲染吗？（高频）</h3><p>不会。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。</p>
<p><strong>Vue 在更新 DOM 时是异步执行的</strong>。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p>
<p>然后在下一个的事件循环 “tick” 中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    vm.message = <span class="string">&#x27;new message&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 123,页面显示 new message</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="介绍一下-vue"><a href="#介绍一下-vue" class="headerlink" title="介绍一下 vue"></a>介绍一下 vue</h2><p>Vue 是一套用于构建用户界面的<strong>渐进式框架</strong>。Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<h2 id="vue-常用的修饰符？"><a href="#vue-常用的修饰符？" class="headerlink" title="vue 常用的修饰符？"></a>vue 常用的修饰符？</h2><ul>
<li>.prevent：防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播），等同于 JavaScript 中的 <code>event.preventDefault()</code></li>
<li>.stop：阻止事件冒泡，等同于 JavaScript 中的 <code>event.stopPropagation()</code></li>
<li>.self：只在当前元素自身触发处理函数，不包含子元素</li>
<li>.once：事件只触发一次</li>
<li>.sync：props 值只能在父组件中更新并传递给子组件，在子组件内部是不允许改变传递进来的props值。可以使用 .sync 修饰符实现在子组件内部改变 props 属性值并更新到父组件中。</li>
</ul>
<h3 id="sync-的作用？"><a href="#sync-的作用？" class="headerlink" title=".sync 的作用？"></a>.sync 的作用？</h3><p>.sync修饰符实际上是一个<strong>语法糖</strong>，可以实现子组件与父组件的双向绑定，并且可以实现子组件同步修改父组件的值。<code>:money.sync=&quot;dataApp&quot;</code> 是 <code>:money=&quot;dataApp&quot; v-on:update:money=&quot;dataApp = $event&quot;</code> 的缩写。</p>
<h2 id="vue-指令？"><a href="#vue-指令？" class="headerlink" title="vue 指令？"></a>vue 指令？</h2><p>参考自 <a target="_blank" rel="noopener" href="https://learnku.com/articles/38198">https://learnku.com/articles/38198</a></p>
<ol>
<li>v-text：v-text 与插值表达式<code>&#123;&#123;&#125;&#125;`相同的地方是，它也是将数据解析成纯文本（若解释 html 标签可能导致 xss 攻击）但区别是：使用 v-text 在页面加载时不会显示'message'，**解决了插值表达式闪烁问题**。
2. v-html：为了输出真正的 HTML，可以用 v-html 指令。它等同于 JS 的 innerHtml 属性，会将数据解析成 html 形式。
3. v-if：用于**条件性地渲染**一块内容。这块内容只会在指令的表达式返回 **truthy** 值的时候被渲染。
4. v-else：**必须和** `v-if` **连用**，否则会报错。
5. v-show：用来**控制元素是否显示**。
6. v-for：循环
7. v-on：**绑定事件监听器**。
8. v-bind：主要用于**绑定属性**，可以动态地绑定一个或多个属性，比如 class 属性、style 属性、value 属性、href 属性。
9. v-model：在表单上**创建双向数据绑定**，v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值，因为 v-model 选择 Vue 实例数据来作为具体的值。

10. v-pre：会**按原样输出**，标签中的内容是什么就输出什么，主要用来跳过这个元素以及它的子元素的编译过程，可以用来显示原始的 Mustache 标签。
11. v-once：关联的实例**只会渲染一次，执行一次性地插值**，当数据改变时，插值处的内容不会更新。若之后牵涉到重新渲染，那么它关联的实例及其所有子节点会被视为静态内容而被跳过，可以用来优化更新性能。

### v-show 与 v-if 区别（高频）

- **手段**：v-if 是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐（none、block）。

- **编译过程**：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；
- **编译条件**：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；
- **性能消耗**：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；
- **使用场景**：`v-show` 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景；`v-if` 切换时开销更高，更适合不经常切换的场景

基于 `v-if` 的惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。

### v-model 原理

v-model 是⽤来在表单控件或者组件上创建双向绑定的，可以看成是 value + input 方法的语法糖，默认为组件绑定名为 value 的 prop 和名为 input 的事件。

**1.作用在普通表单元素上：**动态绑定 input 的 value 指向 messgae 变量，并且在触发 input 事件时动态把 message 设置为目标值。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">&quot;sth&quot;</span> /&gt;</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-bind:value</span>=<span class="string">&quot;message&quot;</span> </span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">v-on:input</span>=<span class="string">&quot;message=$event.target.value&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">&gt;</span></span></span><br><span class="line"><span class="xml">//$event.target 指代当前触发的事件对象的dom;</span></span><br><span class="line"><span class="xml">//$event.target.value 当前dom的value值;</span></span><br><span class="line"><span class="xml">//在@input方法中，value =&gt; sth;</span></span><br><span class="line"><span class="xml">//在:value中,sth =&gt; value;</span></span><br></pre></td></tr></table></figure>

**2.作用在组件上:**在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件

**本质是一个父子组件通信的语法糖，通过prop和$.emit实现**。因此父组件`v-model`语法糖本质上可以修改为 `''`

在组件的实现中，可以通过 **v-model属性** 来配置子组件接收的prop名称，以及派发的事件名称。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;aa-input v-model=<span class="string">&quot;aa&quot;</span>&gt;&lt;/aa-input&gt;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">aa-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;aa=$event.target.value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件：</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;aa&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onmessage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aa-input</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">props:&#123;<span class="attr">value</span>:aa,&#125;</span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="function"><span class="title">onmessage</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">        $emit(<span class="string">&#x27;input&#x27;</span>,e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event

但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。

js 监听input 输入框输入数据改变，用oninput ,数据改变以后就会立刻出发这个事件。

通过input事件把数据$emit 出去，在父组件接受。

父组件设置v-model的值为input$emit过来的值。

具体见https://github.com/lgwebdream/FE-Interview/issues/914

## vue 绑定事件？（to understand）

1.原生的事件绑定（见 JS 篇事件绑定），采用的是 addEventListener 实现。

2.组件的事件绑定，组件绑定事件采用的是 $on 方法 。在组件上是通过 @click.native 进行绑定

https://blog.csdn.net/qq_42072086/article/details/108063281

## data 什么时候为对象 || 函数？（高频）

**组件复用时**所有组件实例都会共享 `data`，如果 `data` 是对象，就会造成一个组件修改 `data` 以后，影响其他所有组件的后果，所以需要将 `data` 写成函数，每次用到就调用，获得新的数据。

**当使用 `new Vue()` 的方式**时，无论将 `data` 设置为对象还是函数都是可以的，因为 `new Vue()` 的方式是生成一个根组件，该组件不会复用，也就不存在共享 `data` 的情况。

## 什么是SPA？

见 [彻底理清前端单页面应用（SPA）的实现原理 【精读源码】](https://segmentfault.com/a/1190000019936510)

SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。

MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。

### SPA 优缺点

优点：组件化

缺点：

- 不利于 SEO（搜索引擎）
- 首屏渲染时间长

服务端渲染SSR

预渲染Prerendering

### 单页面和多页面的区别是什么

![image.png](https://i.loli.net/2021/10/27/4mnTNfKZRr5tEo7.png)

## vue 注册组件的方式

**1、全局注册：**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-test&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="number">1212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div id=&quot;app&quot;&gt;&lt;my-test&gt;&lt;my-test/&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**组件的全局注册需要在全局实例化Vue前调用**，注册之后可以用在任何新创建的 Vue 实例中调用。

**2、局部注册：**

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myTest = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="number">1212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: &#123;</span><br><span class="line">        myTest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

当只需要在某个局部用到某个组件时，可以使用局部注册的方式进行组件注册，此时局部注册的组件只能在注册该组件内部使用。

## vue 如何保存页面状态（缓存页面）（高频）

参考自https://juejin.cn/post/6919373017218809864

会出现以下两种情况：

- 前组件会被卸载
- 前组件不会被卸载

### 组件会被卸载

**（1）将状态存储在 LocalStorage / SessionStorage**：在组件即将被销毁的生命周期中，通过 JSON.stringify() 把当前组件的 state 储存在 LocalStorage / SessionStorage。（或者使用 beforeunload 监听页面的刷新事件，然后在监听方法里将 Vuex 里的数据储存到 localStorage）

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created 钩子函数: 在页面加载时读取localStorage里的状态信息</span></span><br><span class="line"><span class="built_in">localStorage</span>.getItem(<span class="string">&quot;userMsg&quot;</span>) &amp;&amp; <span class="built_in">this</span>.$store.replaceState(<span class="built_in">JSON</span>.parse(<span class="built_in">localStorage</span>.getItem(<span class="string">&quot;userMsg&quot;</span>)));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//在页面刷新时将vuex里的信息保存到localStorage里</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;beforeunload&quot;</span>,<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">localStorage</span>.setItem(<span class="string">&quot;userMsg&quot;</span>, <span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.$store.state))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

**优点：**

- 兼容性好，不需要额外库或工具。
- 简单快捷，基本可以满足大部分需求。

**缺点：**

- 状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）会得到字符串而不是原来的值。

**（2）路由传值**：通过 vue-router 的 prop / to 可以实现路由间传递参数的效果。需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值。返回 A 组件时再次携带 state 达到路由状态保持的效果。

**优点：**

- 简单快捷，不会污染 LocalStorage / SessionStorage。
- 可以传递 Date、RegExp 等特殊对象

**缺点：**

- 如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。

### 组件不会被卸载

**（1）单页面渲染**：将要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。

**优点：**

- 代码量少
- 不需要考虑状态传递过程中的错误

**缺点：**

- 增加 A 组件维护成本
- 需要传入额外的 prop 到 B 组件
- 无法利用路由定位页面

**（2）keep-alive**：缓存页面状态。当组件在 keep-alive 内被切换时组件的 **activated、deactivated** 这两个生命周期钩子函数会被执行，被包裹在 keep-alive 中的组件状态将被保留。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// store/index.js</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/Home.vue&#x27;</span>),</span><br><span class="line">    <span class="comment">// 在路由中添加meta字段</span></span><br><span class="line">    <span class="attr">meta</span>:&#123;</span><br><span class="line">     　　<span class="comment">// 添加keepAlive字段，值true则缓存当前页面，false则不缓存</span></span><br><span class="line">    　　<span class="attr">keepAlive</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]    </span><br><span class="line"><span class="comment">// App.vue</span></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">router-view</span>  <span class="attr">v-if</span>=<span class="string">&quot;$route.meta.keepAlive&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-middle-content&quot;</span>/&gt;</span></span></span><br><span class="line">&lt;/keep-alive&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">router-view</span>  <span class="attr">v-if</span>=<span class="string">&quot;!$route.meta.keepAlive&quot;</span> <span class="attr">class</span>=<span class="string">&quot;app-middle-content&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>

**缺点：**

- 刷新浏览器页面时（等于刷新了整个vue实例应用），所有vue缓存的数据都会丢失。

## 编译过程

vue的模版编译过程主要如下：**template -> ast -> render函数**

Vue 会通过编译器将模板编译为 `render` 函数，然后通过执行 `render` 函数生成 Virtual DOM，最终映射为真实 DOM。编译过程分为三个阶段：

1. 调用 parse 方法将模板解析为 AST：最主要的事情是**通过各种各样的正则表达式去匹配模板中的内容**，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象。根据这个最基本的 AST 对象中的属性进一步扩展 AST。

   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    tag,</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="attr">attrsList</span>: attrs,</span><br><span class="line">    <span class="comment">// 属性映射</span></span><br><span class="line">    <span class="attr">attrsMap</span>: makeAttrsMap(attrs),</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    <span class="attr">children</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

2. 优化 AST：**对静态节点做优化**。对节点进行静态内容提取，也就是将永远不会变动的节点提取出来，实现复用 Virtual DOM，跳过对比算法的功能。

3. 将 AST 转换为 `render` 函数

### *Vue 中 AST 抽象语法树的运用（to understand）

https://juejin.cn/post/6885146952877031432#heading-9

## *Vue 热重载？

"热重载"不是修改文件的时候简单重新加载页面。启用热重载后，当修改 `.vue` 文件时，所有该组件的实例会被替换，**并且不需要刷新页面**，它甚至保持应用程序和被替换组件的当前状态。

## *vue 中 mixin 和 mixins 区别？

mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。可以全局混入封装好的 ajax 或者一些工具函数等等。 

使用 mixin 混入时：

- mixin 的钩子函数会再自己组件的钩子函数之前触发
- 对于 methods、computed 这些配置项等，Vue 会进行合并
- 对于同名属性，Vue 会用组件里的来覆盖 mixin 的

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...逻辑</span></span><br><span class="line">        <span class="comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

mixins 是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mixinObj = &#123;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">mixinFunc</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">mixins</span>: [mixinObj],</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mixinFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。

## *对SSR的理解

SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端。

SSR的优势：

- 更好的SEO
- 首屏加载速度更快

SSR的缺点：

- 开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；
- 当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；
- 更多的服务端负载。

# vue-router 

**解决的问题：**

- 监听 URL 的变化，并在变化前后执行相应的逻辑
- 不同的 URL 对应不同组件
- 提供多种方式改变 URL 的 API  ( URL 的改变不能导致浏览器刷新)

**使用方式：**

- 提供一个路由配置表，不同 URL 对应不同组件的配置
- 初始化路由实例 new VueRouter()
- 挂载到 Vue 实例上
- 提供一个路由占位，用来挂载 URL 匹配到的组件 

## Vue 路由跳转的方式？传参？

1. router-link：跳转前提是在 router.js 中配置了要跳转到的目的地（to）
2. this.$router.push()：函数里面调用，跳转到指定 url 路径，并在 history 栈中添加一个记录，点击后退会返回到上一个页面
   - 不传参数：`this.$router.push('/home');`
   - query 传参数：`this.$router.push(&#123;name:'home',query: &#123;id:'1'&#125;&#125;);</code> 取参数：<code>$route.query.id</code><ul>
<li>params 传参数：<code>this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;); </code> 取参数：<code>$route.params.id</code></li>
<li><strong>两者区别</strong>：<ul>
<li>query 类似 get, 跳转之后页面 url 会拼接参数，非重要性的可以这样传；刷新页面 id 还在。</li>
<li>params 类似 post, 跳转之后页面 url 不会拼接参数 , 可用来传密码等；刷新页面 id 消失。</li>
</ul>
</li>
</ul>
</li>
<li>this.$router.replace()：用法同 push，跳转到指定 url 路径，但是 history 栈中不会有记录，点击返回会跳转到上个页面，即直接替换了当前页面。</li>
<li>this.$router.go(n) ：向前或者向后跳转n个页面，n可为正整数或负整数。n 为 0 时强制刷新页面。</li>
</ol>
<h2 id="前端路由原理？"><a href="#前端路由原理？" class="headerlink" title="前端路由原理？"></a>前端路由原理？</h2><p>前端路由本质就是<strong>监听 URL 的变化</strong>，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式。<img src="https://i.loli.net/2021/09/18/3n8axwlMUWmpNKI.png" alt="image.png"></p>
<h3 id="Hash-模式（默认）"><a href="#Hash-模式（默认）" class="headerlink" title="Hash 模式（默认）"></a>Hash 模式（默认）</h3><p>使用 URL hash 值来作路由。支持所有浏览器，包括不支持HTML5 History Api的浏览器。</p>
<p>原理：URL 中 hash 值只是客户端的一种状态。当向服务器端发出请求时，<strong>hash 部分不会被发送</strong>。例如<code>www.test.com/#/</code> 就是 Hash URL。</p>
<ul>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录，因此能通过浏览器的回退、前进按钮控制 hash 的切换； </li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；</li>
<li>可以使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL的 hash 值；</li>
<li>使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... 具体逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>依赖 HTML5 History API 和服务器配置。history 路由模式的实现主要基于下面几个特性：</p>
<ul>
<li>history.pushState 和 history.repalceState 实现 URL 的变化 ；</li>
<li>使用 popState 事件来监听 url 的变化，从而对页面进行跳转；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popState 事件（即不引起页面刷新，只会更新浏览器的历史记录），这时需要手动触发页面跳转。</li>
</ul>
<h3 id="为什么history模式需要服务器支持？"><a href="#为什么history模式需要服务器支持？" class="headerlink" title="为什么history模式需要服务器支持？"></a>为什么history模式需要服务器支持？</h3><p>具体见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/shapeY/p/14708991.html">vue-router history模式 为什么需要服务端配置以及如何配置</a></p>
<p>假设应用地址为<code>abc.com</code>，服务端不加额外的配置。当通过<code>abc.com</code>访问时是没有问题的，之后通过 route-link 或者 router.api 来跳转也不会有问题，因为不会刷新页面请求 html，只是通过<code>history.pushState</code>或者<code>history.replaceState</code>来改变history记录，修改地址栏地址而已；</p>
<p>但是如果直接访问子路由 <code>abc.com/test</code> 时就会有问题，<code>/test</code>是子路由名，但是服务器中并不存在该目录，就无法索引到html文件，就会出现404，所以不管是访问什么路径，都应该加载根目录的html文件。</p>
<h3 id="两种模式的区别？"><a href="#两种模式的区别？" class="headerlink" title="两种模式的区别？"></a>两种模式的区别？</h3><ul>
<li>Hash 模式只可以更改 <code>#</code> 后面的内容；History 模式可以通过 API 设置任意的同源 URL。</li>
<li>Hash 模式只能更改哈希值，也就是字符串；History 模式可以通过 API 添加任意类型的数据到历史记录。</li>
<li>Hash 模式无需后端配置，并且兼容性好；History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 <code>index.html</code> 页面用于匹配不到静态资源的时候。</li>
<li>Hash 模式相对来说更简单，并且兼容性也更好。</li>
</ul>
<h3 id="前端路由优缺点？"><a href="#前端路由优缺点？" class="headerlink" title="前端路由优缺点？"></a>前端路由优缺点？</h3><p>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户。</p>
<p>缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置。</p>
<h2 id="Vue-Router-的懒加载如何实现"><a href="#Vue-Router-的懒加载如何实现" class="headerlink" title="Vue-Router 的懒加载如何实现"></a>Vue-Router 的懒加载如何实现</h2><p>参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6964779204462247950/#heading-2">https://juejin.cn/post/6964779204462247950/#heading-2</a></p>
<p>（1）方案一(常用)：使用箭头函数+import动态加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> List = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/components/list.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>, <span class="attr">component</span>: List &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>（2）方案二：使用箭头函数+require动态加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="attr">path</span>: <span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">     <span class="attr">component</span>: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">&#x27;@/components/list&#x27;</span>], resolve)</span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="headerlink" title="vue-router 中的导航钩子函数"></a>vue-router 中的导航钩子函数</h2><p>（1）全局钩子函数 <code>router.beforeEach(to,from,next)</code> 和 <code>afterEach</code></p>
<p>beforeEach 全局前置守卫，代表进入路由之前。有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。（用来判断是否登录了，没登录就跳转到登录页）</p>
<p>afterEach 全局后置钩子，代表进入路由之后。（用来跳转之后滚动条回到顶部）</p>
<p>（2）单个路由独享钩子函数 <code>beforeEnter(to, from, next)</code>，它是在路由配置上直接进行定义的。</p>
<p>（3）组件内导航钩子函数：<code>beforeRouteEnter</code>、<code>beforeRouteUpdate</code>、<code>beforeRouteLeave</code>。它们是直接在路由组件内部进行定义的，这三个钩子都有三个参数∶to、from、next</p>
<ul>
<li>beforeRouteEnter∶ 进入组件前触发</li>
<li>beforeRouteUpdate∶ 当前地址改变并且该组件被复用时触发。举例来说，带有动态参数的路径foo/∶id，在 /foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li>
<li>beforeRouteLeave∶ 离开组件被调用</li>
</ul>
<h3 id="触发钩子的完整顺序"><a href="#触发钩子的完整顺序" class="headerlink" title="触发钩子的完整顺序"></a>触发钩子的完整顺序</h3><p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p>
<ul>
<li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li>
<li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li>
<li>beforeEnter：路由独享守卫</li>
<li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li>
<li>beforeResolve：路由全局解析守卫</li>
<li>afterEach：路由全局后置钩子</li>
<li>beforeCreate：组件生命周期，不能访问tAis。</li>
<li>created;组件生命周期，可以访问tAis，不能访问dom。</li>
<li>beforeMount：组件生命周期</li>
<li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li>
<li>mounted：访问/操作dom。</li>
<li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li>
<li>执行beforeRouteEnter回调函数next。</li>
</ul>
<ol>
<li>导航行为被触发到导航完成的整个过程</li>
</ol>
<ul>
<li>导航行为被触发，此时导航未被确认。</li>
<li>在失活的组件里调用离开守卫 beforeRouteLeave。</li>
<li>调用全局的 beforeEach守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li>
<li>在路由配置里调用 beforeEnteY。</li>
<li>解析异步路由组件（如果有）。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li>
<li>导航完成</li>
</ul>
<h2 id="Vue-中-route-和-router-的区别？"><a href="#Vue-中-route-和-router-的区别？" class="headerlink" title="Vue 中 $route 和 $router 的区别？"></a>Vue 中 $route 和 $router 的区别？</h2><p>具体见<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022666268">vue中 $router 和 $route 的区别</a>。</p>
<ul>
<li>$route：当前激活路由的信息对象。每个对象都是局部的，可以获取当前路由的 path, name, params, query 等路由信息参数。</li>
<li>$router：全局的 router 实例。通过 vue 根实例中注入 router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。其中包含了很多属性和对象（比如 history 对象），任何页面也都可以调用其 push(), replace(), go() 等方法。</li>
</ul>
<h2 id="如何设置路由使不能匹配的url跳转到404页面"><a href="#如何设置路由使不能匹配的url跳转到404页面" class="headerlink" title="如何设置路由使不能匹配的url跳转到404页面"></a>如何设置路由使不能匹配的url跳转到404页面</h2><p>参考自 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903608140431368">https://juejin.cn/post/6844903608140431368</a></p>
<p><strong>SPA的404路由配置：</strong></p>
<p>路由表固定时，只需要在路由表中添加一个路径为<code>404</code>的路由，同时<strong>在路由表的最底部</strong>配置一个路径为*的路由，重定向至404路由。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span>,</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/404&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/notFound.vue&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>,    <span class="comment">// 此处需特别注意至于最底部</span></span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&#x27;/404&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>部分参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903993374670855">https://juejin.cn/post/6844903993374670855</a></p>
<h2 id="Vuex-原理"><a href="#Vuex-原理" class="headerlink" title="Vuex 原理"></a>Vuex 原理</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，采用集中式存储管理应用所有组件的状态，主要是为了多页面、多组件之间的通信。每一个 Vuex 应用的<strong>核心就是 store</strong>（仓库）。</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 mutation：<code>this.$store.commit(&#39;Function&#39;, video_pause)</code>，这样可以方便地跟踪每一个状态的变化。</li>
</ul>
<p><img src="https://i.loli.net/2021/11/22/nUyl5A1ruR7kZz8.png" alt="image.png"></p>
<ul>
<li>Vue Components 是 vue 组件，组件会<strong>触发（dispatch）</strong>一些事件或动作，也就是图中的 Actions;</li>
<li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作<strong>提交（Commit）</strong>到 Mutations 中;</li>
<li>然后 Mutations 就去<strong>改变（Mutate）</strong>State 中的数据;</li>
<li>当 State 中的数据被改变之后，就会重新<strong>渲染（Render）</strong>到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li>
</ul>
<h2 id="Vuex-核心概念"><a href="#Vuex-核心概念" class="headerlink" title="Vuex 核心概念"></a>Vuex 核心概念</h2><ul>
<li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li>
<li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li>
<li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li>
</ul>
<p><strong>Vuex 的五种属性？</strong></p>
<ul>
<li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含<strong>同步/异步</strong>操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。（像一个装饰器，包裹mutations，使之可以异步。）</li>
<li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错，该方法名只能全局唯一。（this.$store.commit( “xxx” )赋值， 更改 state 方法，只能是<strong>同步</strong>操作）</li>
<li><code>state</code>∶ <strong>页面状态管理容器对象</strong>。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。（this.$store.state.xxx 取值，包含了 store 中存储的各个状态）</li>
<li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。（this.$store.getters.xxx 取值）</li>
<li><code>Module</code>：模块化Vuex。通过Vue.set 动态添加 state 到响应式数据中</li>
</ul>
<p>由 view 层发起一个 Action 给 Mutation，在 Mutation 中修改状态，返回新的状态，通过 Getter 暴露给 view 层的组件或者页面，页面监测到状态改变，于是更新页面。</p>
<h3 id="action-和-mutation-的区别"><a href="#action-和-mutation-的区别" class="headerlink" title="action 和 mutation 的区别"></a>action 和 mutation 的区别</h3><ul>
<li>action 提交的是 mutation，而不直接变更状态。mutation可以直接变更状态。</li>
<li>action 可以包含任意异步操作。mutation只能是同步操作。</li>
<li>提交方式不同，action 是用<code>this.$store.dispatch(&#39;ACTION_NAME&#39;,data)</code>来提交。mutation是用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code>来提交。</li>
<li>Mutation 的参数是 state，包含 store 中的数据；store 的参数是 context，是 state 的父级，包含 state、getters。</li>
</ul>
<h3 id="为什么使用-action-提交-mutation-变更状态？"><a href="#为什么使用-action-提交-mutation-变更状态？" class="headerlink" title="为什么使用 action 提交 mutation 变更状态？"></a>为什么使用 action 提交 mutation 变更状态？</h3><p>可以把各个请求放到对应的 actions 文件下，返回数据处理，再提交 mutation。这样 页面处理逻辑相对干净。</p>
<p>action 支持 commit 和 dispatch 两个方法，根据需求选择同步或异步提交。</p>
<p>action 提交方便问题查找，每一步都可以输出错误，直接提交则不便于问题追踪。</p>
<h3 id="为什么-mutation-不能做异步操作？"><a href="#为什么-mutation-不能做异步操作？" class="headerlink" title="为什么 mutation 不能做异步操作？"></a>为什么 mutation 不能做异步操作？</h3><p>Vuex中所有的状态更新的唯一途径都是 mutation，异步操作通过 Action 来提交 mutation 实现。</p>
<p>每个mutation执行完成后都会对应到一个新的状态变更，这样vue-devtools就可以打个快照存下来，然后就可以实现 time-travel 。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</p>
<p>time-travel：由于所有的状态变更只能通过 <code>mutation</code> 状态，并且每次状态的改变都会生产一个全新的 <code>state</code> 对象。把每次变更的 <code>state</code> 对象事件都记录下来，展现出一个 <code>mutation</code> 列表，当想展现什么时间段的状态，只需要切换到那个时间段的 <code>state</code> 对象。</p>
<h3 id="如何组合使用多个-action"><a href="#如何组合使用多个-action" class="headerlink" title="如何组合使用多个 action?"></a>如何组合使用多个 action?</h3><p>参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43974265/article/details/114138184">在vuex中组合使用多个action</a></p>
<p>业务逻辑场景：存在2个action，actionA和actionB，先执行完 actionA 才能执行 actionB。</p>
<p>（<code>$store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>$store.dispatch</code> 仍旧返回 Promise）</p>
<ol>
<li><p>在组件里派发 action：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 派发其它的 action，编写其它逻辑代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>在另一个action中派发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">actionB</span>(<span class="params">&#123;dispatch, commit&#125;</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// then方法返回的是一个新的 Promise 实例，可以 return 出去，继续链式调用</span></span><br><span class="line">  <span class="keyword">return</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    commit(<span class="string">&#x27;someOtherMutation&#x27;</span>);  <span class="comment">// 在 actionA执行完成之后，再执行 actionB的代码</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>async/await</code> 的写法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;getData&#x27;</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">&#x27;getOtherData&#x27;</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="如何重复使用-mutation"><a href="#如何重复使用-mutation" class="headerlink" title="如何重复使用 mutation"></a>如何重复使用 mutation</h3><p>使用 mapMutations 辅助函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件中</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">        <span class="attr">setNumber</span>:<span class="string">&#x27;SET_NUMBER&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p>
<h2 id="Vuex-使用"><a href="#Vuex-使用" class="headerlink" title="Vuex 使用"></a>Vuex 使用</h2><p>参考自 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019077663">vuex 使用总结（详解）</a>。</p>
<p><strong>为什么使用？</strong></p>
<ul>
<li>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。因此经常采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。<strong>这些模式非常脆弱，通常会导致代码无法维护。</strong></li>
<li>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。同时代码将会变得更结构化且易维护。</li>
</ul>
<p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的store 模式就足够了。但是如果需要构建一个中大型单页应用，Vuex 能够更好的帮助我们管理组件外部的状态，一般可以运用在购物车、登录状态、播放等场景中。</p>
<p>在 Vue 的单页面应用中使用时，需要使用<code>Vue.use(Vuex)</code>调用插件，并将其注入到Vue根实例中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getter</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state, payload) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">addCount</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 可以包含异步操作</span></span><br><span class="line">      <span class="comment">// context 是一个与 store 实例具有相同方法和属性的 context 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 注入到根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;App/&gt;&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后改变状态：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Vuex-和-localStorage-的区别"><a href="#Vuex-和-localStorage-的区别" class="headerlink" title="Vuex 和 localStorage 的区别"></a>Vuex 和 localStorage 的区别</h2><p><strong>（1）最重要的区别</strong>：vuex 存储在内存中；localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON 的 stringify 和 parse 方法进行处理；读取内存比读取硬盘速度要快。</p>
<p><strong>（2）应用场景</strong>：Vuex 能做到数据的响应式，localstorage 不能。</p>
<p><strong>（3）永久性</strong>：刷新页面时 vuex 存储的值会丢失，localstorage不会。</p>
<p><strong>注意：</strong> 对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到</p>
<h2 id="有使用过-vuex-的-module-吗？主要是在什么场景下使用？"><a href="#有使用过-vuex-的-module-吗？主要是在什么场景下使用？" class="headerlink" title="有使用过 vuex 的 module 吗？主要是在什么场景下使用？"></a>有使用过 vuex 的 module 吗？主要是在什么场景下使用？</h2><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>这时我们可以将 store 分割为<strong>模块（module）</strong>，每个模块拥有自己的 <code>state</code> 、 <code>getters</code> 、<code>mutations</code> 、<code>actions</code> 、甚至是嵌套子模块——从上至下进行同样方式的分割。</p>
<h2 id="Vuex-严格模式"><a href="#Vuex-严格模式" class="headerlink" title="Vuex 严格模式"></a>Vuex 严格模式</h2><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
<p>在Vuex.Store 构造器选项中开启,如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="attr">strict</span>:<span class="literal">true</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><p>具体见 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6951262189168623623#heading-1">https://juejin.cn/post/6951262189168623623#heading-1</a></p>
<h2 id="Vue3-的特点？"><a href="#Vue3-的特点？" class="headerlink" title="Vue3 的特点？"></a>Vue3 的特点？</h2><ul>
<li><p>节点打 Tag，更新页面时直接定位到动态节点，会跳过静态的div，节省效率。</p>
</li>
<li><p>Tree Shaking：按需加载</p>
</li>
<li><p>Better TypeScript Support：更好的支持TypeScript语法</p>
</li>
<li><p>响应式 Proxy</p>
</li>
<li><p>增加 Composition API：将组件属性暴露为函数，使得 Vue3 的开发风格更接近于原生 JavaScript，也使得 Vue3 更适合于 TypeScript 结合，带给开发者更多地灵活性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span><br><span class="line">import &#123; ref, computed, onMounted &#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">    	// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span><br><span class="line">    	const count = ref(0)</span><br><span class="line">    	// Vue2中需要在methods option中声明的函数，现在直接声明</span><br><span class="line">    	function increment() &#123;</span><br><span class="line">      		count.value++</span><br><span class="line">    	&#125;</span><br><span class="line">    	// 对应于Vue2中的mounted声明周期</span><br><span class="line">    	onMounted(() =&gt; console.log(&#x27;component mounted!&#x27;))</span><br><span class="line">    	return &#123; count, increment &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="解释-tree-shaking？"><a href="#解释-tree-shaking？" class="headerlink" title="解释 tree-shaking？"></a>解释 tree-shaking？</h3><p>Tree shaking 是一种通过清除多余代码方式来优化项目打包体积的技术，只能在静态 modules 下工作。</p>
<p>ECMAScript 6 模块加载是静态的，因此整个依赖树可以被静态地推导出解析语法树，判断哪些模块和变量未被使用，从而删除对应代码。所以在 ES6 中使用 tree shaking 是非常容易的。</p>
<h2 id="vue3-与-vue2-区别？（高频）"><a href="#vue3-与-vue2-区别？（高频）" class="headerlink" title="vue3 与 vue2 区别？（高频）"></a>vue3 与 vue2 区别？（高频）</h2><p><strong>大的改动：</strong></p>
<ul>
<li>proxy 代替 Object.definePrototety 响应式系统</li>
<li>ts 代替 flow 类型检查</li>
<li>重构了目录结构，将代码主要分成三个独立的模块，更利于长期维护</li>
<li>重写 vdom，优化编译性能</li>
<li>支持 tree shaking</li>
<li>增加了 Composition API(setup)，让代码更易于维护</li>
</ul>
<p><strong>小的改动:</strong></p>
<ul>
<li>异步组件需要 defineAsyncComponent 方法来创建</li>
<li>v-model 用法</li>
<li>v-if 优先级高于 v-for</li>
<li>destroyed 生命周期选项被重命名为 unmounted</li>
<li>beforeDestroy 生命周期选项被重命名为 beforeUnmount</li>
<li>render函数默认参数createElement移除改为全局引入</li>
<li>组件事件现在需要在 emits 选项中声明</li>
</ul>
<p><strong>新特性：</strong></p>
<ul>
<li>组合式 API</li>
<li>Teleport</li>
<li>framents（组件支持多个根节点）</li>
<li>createRenderer（跨平台的自定义渲染器）</li>
</ul>
<h2 id="vue3-的-Composition-API"><a href="#vue3-的-Composition-API" class="headerlink" title="vue3 的 Composition API"></a>vue3 的 Composition API</h2><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）。</p>
<p><img src="https://i.loli.net/2021/11/25/4D3PGhpcRVBme8T.png" alt="image.png"></p>
<p>与 Vue2 Options API 区别：</p>
<ul>
<li>在逻辑组织和逻辑复用方面，<code>Composition API</code>优于<code>Options API</code>，因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li>
<li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li>
<li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li>
<li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/">https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/11/26/i6csUxdw4EeS5mX.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/13/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E5%9F%BA%E4%BA%8Epannellum%E7%9A%84%E5%85%A8%E6%99%AF%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【项目复盘】— — 基于pannellum的全景H5页面实现</div></div></a></div><div class="next-post pull-right"><a href="/2021/07/03/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20JavaScript%E7%AF%87/"><img class="next-cover" src="https://i.loli.net/2021/11/26/IjNHoiM76eEFcsB.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【面试准备】— — JavaScript篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Asura1211"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">Vue 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Vue 双向数据绑定（响应式）原理？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue2-%E7%BB%99-data-%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">Vue2 给 data 对象添加新属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue3-%E5%AF%B9%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%88%E6%95%B0%E7%BB%84%EF%BC%89%E5%81%9A%E4%BA%86%E6%80%8E%E6%A0%B7%E7%9A%84%E6%94%B9%E8%BF%9B%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">Vue3 对响应式（数组）做了怎样的改进？（高频）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Virtual-DOM%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">什么是 Virtual DOM？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Virtual-DOM-%E6%AF%94%E5%8E%9F%E7%94%9F-DOM-%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">为什么 Virtual DOM 比原生 DOM 快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-DOM-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">如何比较两个 DOM 树的差异？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD-diff-%E7%AE%97%E6%B3%95%EF%BC%9F-%E9%AB%98%E9%A2%91"><span class="toc-number">1.4.</span> <span class="toc-text">Vue 中 diff 算法？(高频)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">diff 中 key 值的作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">vue 中 key 值的作用？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%92%8C-React-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">Vue 和 React 之间的区别（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%92%8C-react-%E7%9A%84%E6%B8%B2%E6%9F%93%E5%B7%AE%E5%BC%82%EF%BC%9F%EF%BC%88todo%EF%BC%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">vue 和 react 的渲染差异？（todo）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">diff 算法区别？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery-%E4%B8%8E-vue-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.3.</span> <span class="toc-text">jQuery 与 vue 区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">Vue 的生命周期是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.7.1.</span> <span class="toc-text">各个生命阶段？（高频）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive-%E7%BB%84%E4%BB%B6%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.7.2.</span> <span class="toc-text">keep-alive 组件作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%B7%E6%B1%82%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E3%80%81%E7%BB%91%E5%AE%9A%E4%BA%8B%E4%BB%B6%E3%80%81%E5%8F%96%E6%B6%88%E4%BA%8B%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.7.3.</span> <span class="toc-text">在哪个生命周期请求异步数据、绑定事件、取消事件？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">1.7.4.</span> <span class="toc-text">父子组件的生命周期顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">1.7.5.</span> <span class="toc-text">继承组件的生命周期顺序？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.8.</span> <span class="toc-text">Vue 组件间的参数传递方式？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.8.1.</span> <span class="toc-text">父子组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.8.2.</span> <span class="toc-text">兄弟组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.8.3.</span> <span class="toc-text">跨多层次组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.8.4.</span> <span class="toc-text">任意组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.8.5.</span> <span class="toc-text">单向数据流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.9.</span> <span class="toc-text">computed 和 watch 的区别？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97"><span class="toc-number">1.9.1.</span> <span class="toc-text">两者实现计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84-tab-%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">实现一个可复用的 tab 组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slot-%E4%B8%8E-scope-slot%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">slot 与  scope-slot？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0%E5%92%8C%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">1.12.</span> <span class="toc-text">纯函数和副作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVVM%EF%BC%9F%E6%AF%94%E4%B9%8B-MVC-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF-MVP%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">什么是 MVVM？比之 MVC 有什么区别？什么是 MVP（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-MVVM-%E6%A1%86%E6%9E%B6%EF%BC%88to-understand%EF%BC%89"><span class="toc-number">1.13.1.</span> <span class="toc-text">*实现一个简单的 MVVM 框架（to understand）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-nextTick-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90"><span class="toc-number">1.14.</span> <span class="toc-text">Vue 中的 nextTick 原理分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.14.1.</span> <span class="toc-text">应用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-data-%E6%9F%90%E4%B8%AA%E5%B1%9E%E6%80%A7%E5%80%BC%E6%94%B9%E5%8F%98%E5%90%8E%EF%BC%8C%E8%A7%86%E5%9B%BE%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%90%8C%E6%AD%A5%E6%89%A7%E8%A1%8C%E6%B8%B2%E6%9F%93%E5%90%97%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.14.2.</span> <span class="toc-text">Vue data 某个属性值改变后，视图会立即同步执行渲染吗？（高频）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-vue"><span class="toc-number">1.15.</span> <span class="toc-text">介绍一下 vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">vue 常用的修饰符？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sync-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.16.1.</span> <span class="toc-text">.sync 的作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E6%8C%87%E4%BB%A4%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">vue 指令？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">前端路由原理？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-%E6%A8%A1%E5%BC%8F%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-number">1.18.1.</span> <span class="toc-text">Hash 模式（默认）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.18.2.</span> <span class="toc-text">History 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88history%E6%A8%A1%E5%BC%8F%E9%9C%80%E8%A6%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%AF%E6%8C%81%EF%BC%9F"><span class="toc-number">1.18.3.</span> <span class="toc-text">为什么history模式需要服务器支持？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.18.4.</span> <span class="toc-text">两种模式的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.18.5.</span> <span class="toc-text">前端路由优缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-Router-%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.19.</span> <span class="toc-text">Vue-Router 的懒加载如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">vue-router 中的导航钩子函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E9%92%A9%E5%AD%90%E7%9A%84%E5%AE%8C%E6%95%B4%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.20.1.</span> <span class="toc-text">触发钩子的完整顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">Vue 中 $route 和 $router 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E8%B7%AF%E7%94%B1%E4%BD%BF%E4%B8%8D%E8%83%BD%E5%8C%B9%E9%85%8D%E7%9A%84url%E8%B7%B3%E8%BD%AC%E5%88%B0404%E9%A1%B5%E9%9D%A2"><span class="toc-number">1.22.</span> <span class="toc-text">如何设置路由使不能匹配的url跳转到404页面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vuex"><span class="toc-number">2.</span> <span class="toc-text">Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">Vuex 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">2.2.</span> <span class="toc-text">Vuex 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#action-%E5%92%8C-mutation-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.1.</span> <span class="toc-text">action 和 mutation 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-action-%E6%8F%90%E4%BA%A4-mutation-%E5%8F%98%E6%9B%B4%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">为什么使用 action 提交 mutation 变更状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-mutation-%E4%B8%8D%E8%83%BD%E5%81%9A%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">为什么 mutation 不能做异步操作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-action"><span class="toc-number">2.2.4.</span> <span class="toc-text">如何组合使用多个 action?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8-mutation"><span class="toc-number">2.2.5.</span> <span class="toc-text">如何重复使用 mutation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">Vuex 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E5%92%8C-localStorage-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">Vuex 和 localStorage 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87-vuex-%E7%9A%84-module-%E5%90%97%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">有使用过 vuex 的 module 吗？主要是在什么场景下使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text">Vuex 严格模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue3"><span class="toc-number">3.</span> <span class="toc-text">Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue3-%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">Vue3 的特点？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-tree-shaking%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">解释 tree-shaking？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3-%E4%B8%8E-vue2-%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">vue3 与 vue2 区别？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3-%E7%9A%84-Composition-API"><span class="toc-number">3.3.</span> <span class="toc-text">vue3 的 Composition API</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家社区商城"/></a><div class="content"><a class="title" href="/2021/10/31/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E7%A4%BE%E5%8C%BA%E5%95%86%E5%9F%8E/" title="【项目复盘】— — 贤得家社区商城">【项目复盘】— — 贤得家社区商城</a><time datetime="2021-10-31T15:01:17.000Z" title="发表于 2021-10-31 23:01:17">2021-10-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/11/26/c8CoiAjKTyGNS4a.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://i.loli.net/2021/10/13/UAFPpZByEcjaWOw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" title="【学习笔记】— — 字节青训营"><img src="https://i.loli.net/2021/11/20/6kUmfsBR2yEIqnD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【学习笔记】— — 字节青训营"/></a><div class="content"><a class="title" href="/2021/08/14/%E3%80%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" title="【学习笔记】— — 字节青训营">【学习笔记】— — 字节青训营</a><time datetime="2021-08-14T15:04:54.000Z" title="发表于 2021-08-14 23:04:54">2021-08-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/07/16/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E5%A0%82%E6%A8%A1%E5%9D%97/" title="【项目复盘】— — 贤得家e社区学堂管理系统"><img src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【项目复盘】— — 贤得家e社区学堂管理系统"/></a><div class="content"><a class="title" href="/2021/07/16/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E8%B4%A4%E5%BE%97%E5%AE%B6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%AD%A6%E5%A0%82%E6%A8%A1%E5%9D%97/" title="【项目复盘】— — 贤得家e社区学堂管理系统">【项目复盘】— — 贤得家e社区学堂管理系统</a><time datetime="2021-07-16T19:55:25.000Z" title="发表于 2021-07-17 03:55:25">2021-07-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>