<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【面试准备】— — Vue篇 | 青山の博客</title><meta name="keywords" content="Vue"><meta name="author" content="青山,lvchangjing_hit@163.com"><meta name="copyright" content="青山"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：CSS 面试知识点总结。侵权删。 Vue 双向数据绑定（响应式）原理？（高频）vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。 首先通过 Object.defineProperty() 方法来对 Model 数据各个属性">
<meta property="og:type" content="article">
<meta property="og:title" content="【面试准备】— — Vue篇">
<meta property="og:url" content="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/index.html">
<meta property="og:site_name" content="青山の博客">
<meta property="og:description" content="前言本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：CSS 面试知识点总结。侵权删。 Vue 双向数据绑定（响应式）原理？（高频）vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过使用数据劫持和发布订阅者模式来实现的。 首先通过 Object.defineProperty() 方法来对 Model 数据各个属性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg">
<meta property="article:published_time" content="2021-07-10T14:02:20.000Z">
<meta property="article:modified_time" content="2021-10-21T13:16:58.008Z">
<meta property="article:author" content="青山">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【面试准备】— — Vue篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-10-21 21:16:58'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="青山の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青山の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【面试准备】— — Vue篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-10T14:02:20.000Z" title="发表于 2021-07-10 22:02:20">2021-07-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-21T13:16:58.008Z" title="更新于 2021-10-21 21:16:58">2021-10-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">面试准备</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【面试准备】— — Vue篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我在复习Vue，准备实习面试时整理的笔记，参考自一些已经整理好的博客：<a target="_blank" rel="noopener" href="https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/Css/Css.md">CSS 面试知识点总结</a>。侵权删。</p>
<h2 id="Vue-双向数据绑定（响应式）原理？（高频）"><a href="#Vue-双向数据绑定（响应式）原理？（高频）" class="headerlink" title="Vue 双向数据绑定（响应式）原理？（高频）"></a>Vue 双向数据绑定（响应式）原理？（高频）</h2><p>vue 通过使用双向数据绑定，来实现了 View 和 Model 的同步更新。vue 的双向数据绑定主要是通过<strong>使用数据劫持</strong>和<strong>发布订阅者模式</strong>来实现的。</p>
<p>首先通过 Object.defineProperty() 方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，可以通过配置的 setter 和 getter 方法来实现对 View 层数据更新的通知。</p>
<p>数据在 html 模板中一共有两种绑定情况，一种是使用 v-model 来对 value 值进行绑定，一种是作为文本绑定，在对模板引擎进行解析的过程中：</p>
<ul>
<li>如果遇到元素节点，并且属性值包含 v-model 的话，就从 Model 中获取 v-model 所对应的属性值，并赋值给元素的 value 。然后给这个元素设置一个监听事件，当 View 中元素的数据发生变化的时候触发该事件，通知 Model 中的对应的属性的值进行更新。</li>
<li>如果遇到了绑定的文本节点，使用 Model 中对应的属性的值来替换这个文本。对于文本节点的更新，使用了发布订阅者模式，属性作为一个主题，为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。</li>
</ul>
<p>实现：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039750996">Vue2.x 的双向绑定原理及实现</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016884795">https://segmentfault.com/a/1190000016884795</a></p>
<h2 id="Vue-中-diff-算法？-todo高频-节点的插入删除移动的具体流程"><a href="#Vue-中-diff-算法？-todo高频-节点的插入删除移动的具体流程" class="headerlink" title="Vue 中 diff 算法？(todo高频) 节点的插入删除移动的具体流程"></a>Vue 中 diff 算法？(todo高频) 节点的插入删除移动的具体流程</h2><p><strong>Diff 算法是一种对比算法</strong>。对比旧虚拟 DOM 和新虚拟 DOM，找出发生更改的虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不更新其他节点，实现精准地更新真实 DOM，进而提高效率。</p>
<p>Diff 算法比较只会在同层级进行, 不会跨层级比较。<strong>（深度优先算法，O(n)）</strong></p>
<h3 id="diff-中-key-值的作用？"><a href="#diff-中-key-值的作用？" class="headerlink" title="diff 中 key 值的作用？"></a>diff 中 key 值的作用？</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6994959998283907102">https://juejin.cn/post/6994959998283907102</a></p>
<h2 id="Vue-和-React-之间的区别（高频）"><a href="#Vue-和-React-之间的区别（高频）" class="headerlink" title="Vue 和 React 之间的区别（高频）"></a>Vue 和 React 之间的区别（高频）</h2><p><strong>相同点：</strong>围绕着数据流和组件化以及diff策略来答</p>
<ul>
<li>使用Virtual DOM，用 js 模拟 DOM 结构，提高重绘性能</li>
<li>组件化开发，都支持 props 进行父子组件之间的数据通信</li>
<li>都支持数据驱动视图，不直接操作真实 dom</li>
<li>都支持服务器端的渲染</li>
<li>都支持 native 方案，React 的 react native，Vue 的 WEEX</li>
<li>都有管理状态，React有redux,Vue有自己的Vuex（自适应vue，量身定做）</li>
</ul>
<p><strong>异同点：</strong>围绕着更新的触发方式，以及异步和同步的渲染过程来答</p>
<ul>
<li>Vue 的表单可以使用 <code>v-model</code> 支持双向绑定，而 React 的数据流动是单向的。当然 <code>v-model</code> 其实是个语法糖，本质上和 React 写表单的方式没什么区别。</li>
<li>改变数据方式不同，Vue 修改状态只需要通过this的某种方式去更新state中的数据，而 React 需要使用 <code>setState</code> 来改变状态。并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题。</li>
<li>React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 <code>render</code> 函数就能在浏览器中运行。</li>
<li>React 的思想很棒，各种抽象和模式使得代码更加美观。</li>
</ul>
<p>更多可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6847009771355127822#heading-46">你不知道的React 和 Vue 的20个区别</a>。</p>
<h3 id="diff-算法区别？（高频）"><a href="#diff-算法区别？（高频）" class="headerlink" title="diff 算法区别？（高频）"></a><strong>diff 算法区别？</strong>（高频）</h3><p>参考自 <a target="_blank" rel="noopener" href="https://cxyzjd.com/article/qq_45932447/110001564">https://cxyzjd.com/article/qq_45932447/110001564</a></p>
<p>vue 和 react 的 diff 算法，都是忽略跨级比较，只做同级比较，复杂度都为 O(n)。vue diff 时调动 patch 函数，参数是 vnode 和oldVnode，分别代表新旧节点。</p>
<ol>
<li><p>vue 比对节点，当<strong>节点元素类型相同，但是 className 不同</strong>，认为是不同类型元素，删除重建；而 react 会认为是同类型节点，只是修改节点属性</p>
</li>
<li><p>vue 列表比对，采用<strong>从两端到中间的比对方式</strong>，而 react 则采用<strong>从左到右依次比对的方式</strong>。当一个集合只是把最后一个节点移动到了第一个，react 会把前面的节点依次移动，而 vue 只会把最后一个节点移动到第一个。</p>
<p>总体上，vue 的对比方式更高效。</p>
</li>
</ol>
<h2 id="Vue-的生命周期是什么？"><a href="#Vue-的生命周期是什么？" class="headerlink" title="Vue 的生命周期是什么？"></a>Vue 的生命周期是什么？</h2><p>Vue 的生命周期指的是组件从创建到销毁的一系列的过程，被称为 Vue 的生命周期。通过提供的 Vue 在生命周期各个阶段的钩子函数，可以很好的在 Vue 的各个生命阶段实现一些操作。</p>
<h3 id="各个生命阶段？（高频）"><a href="#各个生命阶段？（高频）" class="headerlink" title="各个生命阶段？（高频）"></a>各个生命阶段？（高频）</h3><p>Vue 一共有8个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁前和销毁后，每个阶段对应了一个生命周期的钩子函数。<img src="https://i.loli.net/2021/10/17/8VDnJaCiH5A9vyZ.png" alt="12602393-5310c1449192165f.jpg"></p>
<p>（1）beforeCreate：在实例初始化之后，在数据监听和事件配置之前触发。因此在这个事件中是获取不到 props 或者 data 数据的。</p>
<p>（2）created：在<strong>实例创建完成后</strong>触发，此时可以<strong>访问 data、methods 等属性</strong>。但这个时候组件还没有被挂载到页面中去，所以这个时候<strong>访问不到 $el 属性</strong>。一般可以在这个函数中<strong>进行一些页面初始化的工作</strong>，比如通过 ajax 请求数据来对页面进行初始化。</p>
<p>（3）beforeMount：在组件被挂载到页面之前触发。在 beforeMount 之前，会找到对应的 template，并编译成 render 函数。</p>
<p>（4）mounted：在<strong>组件挂载到页面后</strong>触发。此时可以通过 DOM API <strong>获取到页面中的 DOM 元素</strong>。</p>
<p>（5）beforeUpdate：在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前，这个时候可以对可能会被移除的元素做一些操作，比如移除事件监听器。</p>
<p>（6）updated：虚拟 DOM 重新渲染和打补丁之后调用。</p>
<p>（7）beforeDestroy：在实例销毁之前调用。一般在这一步可以销毁定时器、解绑全局事件等。</p>
<p>（8）destroyed：在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<p>当使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</p>
<h2 id="什么是-Virtual-DOM？（高频）"><a href="#什么是-Virtual-DOM？（高频）" class="headerlink" title="什么是 Virtual DOM？（高频）"></a>什么是 Virtual DOM？（高频）</h2><p>对将要插入到文档中的 <strong>DOM 树结构进行分析</strong>，<strong>使用 js 对象表示</strong>。比如一个元素对象包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="string">&#x27;list&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">children</span>: &#123;</span><br><span class="line">    <span class="attr">tag</span>: <span class="string">&#x27;li&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码对应的 DOM 就是</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&#x27;list&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>当页面的状态发生改变，需要对 DOM 结构进行调整时，首先根据变更的状态，重新构建起一棵对象树</li>
<li>然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的差异</li>
<li>最后将记录有差异的地方应用到真正的 DOM 树，这样视图就更新了。判断差异的算法分为两步：<ul>
<li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步会给每个节点添加索引，便于最后渲染差异。（需要判断新旧节点的 <code>tagName</code> 是否相同，如果不相同的话就代表节点被替换。相同则判断是否有子元素，有就进行第二步）</li>
<li>一旦节点有子元素，就判断子元素是否有不同。（原列表是否有节点被移除、新列表是否有新节点加入、节点是否有移动）</li>
</ul>
</li>
</ol>
<h3 id="为什么-Virtual-DOM-比原生-DOM-快？"><a href="#为什么-Virtual-DOM-比原生-DOM-快？" class="headerlink" title="为什么 Virtual DOM 比原生 DOM 快？"></a><strong>为什么 Virtual DOM 比原生 DOM 快？</strong></h3><p>Virtual DOM 这种方法对于需要有大量 DOM 操作的时候，能够很好的提高操作效率，通过在操作前确定需要做的最小修改，从而<strong>尽可能减少 DOM 操作带来的重流和重绘影响</strong>。其实 Virtual DOM 并不一定比真实操作 DOM 快，这种方法是为了提高开发时的可维护性：在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</p>
<p><strong>Virtual DOM 最大的优势</strong>：</p>
<ol>
<li>将 Virtual DOM 作为一个兼容层，让还能对接非 Web 端的系统，实现跨端开发。</li>
<li>同样的，通过 Virtual DOM 可以渲染到其他的平台，比如实现 SSR、同构渲染等等。</li>
<li>实现组件的高度抽象化。</li>
</ol>
<h3 id="如何比较两个-DOM-树的差异？"><a href="#如何比较两个-DOM-树的差异？" class="headerlink" title="如何比较两个 DOM 树的差异？"></a>如何比较两个 DOM 树的差异？</h3><p>两个树的完全 diff 算法的时间复杂度为 O(n^3) ，但是在前端中，很少会跨层级的移动元素，所以只需要比较同一层级的元素进行比较，这样就可以将算法的时间复杂度降低为 O(n)。</p>
<p>算法首先会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个序号。在深度遍历的时候，每遍历到一个节点，就将这个节点和新的树中的节点进行比较，如果有差异，则将这个差异记录到一个对象中。</p>
<p>在对列表元素进行对比的时候，由于 TagName 是重复的，所以不能使用这个来对比。需要给每一个子节点加上一个 key，列表对比的时候使用 key 来进行比较，这样才能够复用老的 DOM 树上的节点。</p>
<h2 id="Vue-中的-nextTick-原理分析（todo）"><a href="#Vue-中的-nextTick-原理分析（todo）" class="headerlink" title="Vue 中的 nextTick 原理分析（todo）"></a>Vue 中的 nextTick 原理分析（todo）</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/46c9d777cab1">https://www.jianshu.com/p/46c9d777cab1</a></p>
<p>nextTick ：在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。</p>
<h3 id="应用场景？"><a href="#应用场景？" class="headerlink" title="应用场景？"></a>应用场景？</h3><p>在数据变化之后要执行的某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放进 Vue.nextTick() 的回调函数中</p>
<h2 id="Vue-组件间的参数传递方式？（高频）"><a href="#Vue-组件间的参数传递方式？（高频）" class="headerlink" title="Vue 组件间的参数传递方式？（高频）"></a>Vue 组件间的参数传递方式？（高频）</h2><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><ul>
<li><p>第一种方法是子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。典型的单向数据流，子组件不能直接修改 props， 而是必须通过发送事件的方式告知父组件修改数据。</p>
<p>这还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 UI 控件上</p>
</li>
<li><p>第二种是通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。</p>
</li>
<li><p>第三种是使用 provider/inject，在父组件中通过 provider 提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provider 中的数据。</p>
</li>
<li><p>第四种（Vue 2.3 及以上版本）<code>$listeners</code> 属性会将父组件中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 来自定义监听器。<code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--父组件中--&gt;</span><br><span class="line">&lt;input :value.sync=&quot;value&quot; /&gt;</span><br><span class="line">&lt;!--以上写法等同于--&gt;</span><br><span class="line">&lt;input :value=&quot;value&quot; @update:value=&quot;v =&gt; value = v&quot;&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  this.$emit(&#x27;update:value&#x27;, 1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><ul>
<li><p>第一种是使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</p>
</li>
<li><p>第二种是通过通过查找父组件中的子组件来获取到兄弟组件<code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p>
</li>
</ul>
<h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>Vue 2.2 新增的 API <code>provide / inject</code>：假设有父组件 A，然后有一个跨多层级的子组件 B</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">provide</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">inject</span>: [<span class="string">&#x27;data&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.data) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h3><ul>
<li>Event Bus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li>
<li>Vuex。如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。Vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</li>
</ul>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的 <code>prop</code> 都使得其父子 <code>prop</code> 之间形成了一个单向下行绑定：父级 <code>prop</code> 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p>
<p>额外的，每次父级组件发生更新时，子组件中所有的 <code>prop</code> 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 <code>prop</code>。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>简单的单向数据流（unidirectional data flow）是指用户访问View，View发出用户交互的Action，在Action里对state进行相应更新。state更新后会触发View更新页面的过程。这样数据总是清晰的单向进行流动，便于维护并且可以预测。</p>
<h2 id="computed-和-watch-的区别？"><a href="#computed-和-watch-的区别？" class="headerlink" title="computed 和 watch 的区别？"></a>computed 和 watch 的区别？</h2><p>（1）computed 是<strong>计算一个新的属性（但是依赖其他属性计算值），并将该属性挂载到 Vue 实例</strong>上，而 watch 是<strong>监听已经存在且已挂载到 Vue 实例上的数据</strong>，所以用 watch 同样可以监听 computed 计算属性的变化。（computed 能做的，watch 都能做，反之则不行）</p>
<p>（2）computed 本质是一个惰性求值的观察者，具有<strong>缓存性</strong>，只有当依赖变化后，第一次访问 computed 属性，才会计算新的值（减少模板中计算逻辑）。而 watch 则是<strong>当数据发生变化便会调用执行函数</strong>，在回调中可以执行任何逻辑，如函数节流，Ajax 异步获取数据，甚至操作 DOM。</p>
<p>（3）使用场景：需要依赖别的属性来动态获得值的时候可以使用 computed，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 watch。</p>
<p>能用 computed 的尽量用 computed。</p>
<h2 id="v-show-与-v-if-区别"><a href="#v-show-与-v-if-区别" class="headerlink" title="v-show 与 v-if 区别"></a>v-show 与 v-if 区别</h2><p><code>v-show</code> 只是在 <code>display: none</code> 和 <code>display: block</code> 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留着的。所以总的来说 <code>v-show</code> <strong>在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</strong></p>
<p><code>v-if</code> 的话就得说到 Vue 底层的编译了。当属性初始为 <code>false</code> 时，组件就不会被渲染，直到条件为 <code>true</code>，并且切换条件时会触发销毁/挂载组件，所以总的来说<strong>在切换时开销更高，更适合不经常切换的场景。</strong></p>
<p>并且基于 <code>v-if</code> 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p>
<h2 id="介绍一下-vue"><a href="#介绍一下-vue" class="headerlink" title="介绍一下 vue"></a>介绍一下 vue</h2><h2 id="vue-常用的修饰符？"><a href="#vue-常用的修饰符？" class="headerlink" title="vue 常用的修饰符？"></a>vue 常用的修饰符？</h2><ul>
<li>.prevent: 提交事件不再重载页面</li>
<li>.stop: 阻止单击事件冒泡</li>
<li>.self: 当事件发生在该元素本身而不是子元素的时候会触发；</li>
</ul>
<h2 id="vue-中-key-值的作用？（高频）"><a href="#vue-中-key-值的作用？（高频）" class="headerlink" title="vue 中 key 值的作用？（高频）"></a>vue 中 key 值的作用？（高频）</h2><p>vue 中 key 值的作用可以分为两种情况来考虑。</p>
<p>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用，如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来<strong>唯一标识一个元素</strong>，这样使用 key 的元素不会被复用。</p>
<p>第二种情况是 <strong>v-for 中使用 key</strong>。用 v-for 更新已渲染过的元素列表时，默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，使 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是<strong>为了高效的更新渲染虚拟 DOM。</strong></p>
<p><strong>深入讲讲：</strong></p>
<p>Vue 在 patch 过程中判断两个节点是否是相同节点，key是一个必要条件，渲染一组列表时，key 往往是唯一标识，所以如果不定义 key 的话，Vue 只能认为比较的两个节点是同一个，哪怕它们实际上不是。这导致了频繁更新元素，使得整个 patch 过程比较低效，影响性能。</p>
<p>从源码中可以知道，Vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key,它的值就是 undefined，则可能永 远认为这是两个相同的节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的</p>
<h3 id="为什么-vue-数组里要设置-key？"><a href="#为什么-vue-数组里要设置-key？" class="headerlink" title="为什么 vue 数组里要设置 key？"></a>为什么 vue 数组里要设置 key？</h3><p>[=&gt;](###diff 中 key 值的作用？)</p>
<h2 id="keep-alive-组件有什么作用？"><a href="#keep-alive-组件有什么作用？" class="headerlink" title="keep-alive 组件有什么作用？"></a>keep-alive 组件有什么作用？</h2><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<p>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</p>
<h2 id="vue-中-mixin-和-mixins-区别？"><a href="#vue-中-mixin-和-mixins-区别？" class="headerlink" title="vue 中 mixin 和 mixins 区别？"></a>vue 中 mixin 和 mixins 区别？</h2><p>mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。可以全局混入封装好的 ajax 或者一些工具函数等等。 </p>
<p>使用 mixin 混入时：</p>
<ul>
<li>mixin 的钩子函数会再自己组件的钩子函数之前触发</li>
<li>对于 methods、computed 这些配置项等，Vue 会进行合并</li>
<li>对于同名属性，Vue 会用组件里的来覆盖 mixin 的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...逻辑</span></span><br><span class="line">        <span class="comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>mixins 是最常使用的扩展组件的方式。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mixinObj = &#123;</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">mixinFunc</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">mixins</span>: [mixinObj],</span><br><span class="line">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mixinFunc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外需要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p>
<h2 id="Vue-中-slot-作用？"><a href="#Vue-中-slot-作用？" class="headerlink" title="Vue 中 slot 作用？"></a>Vue 中 slot 作用？</h2><p>作为 <code>Web Components</code> 技术套件的一部分，是Web组件内的一个占位符。该占位符可以在后期使用自己的标记语言填充。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview/issues/16">https://github.com/febobo/web-interview/issues/16</a></p>
<h2 id="data-什么时候为对象-函数？"><a href="#data-什么时候为对象-函数？" class="headerlink" title="data 什么时候为对象 || 函数？"></a>data 什么时候为对象 || 函数？</h2><p><strong>组件复用时</strong>所有组件实例都会共享 <code>data</code>，如果 <code>data</code> 是对象的话，就会造成一个组件修改 <code>data</code> 以后会影响到其他所有组件，所以需要将 <code>data</code> 写成函数，每次用到就调用一次函数获得新的数据。</p>
<p>当使用 <code>new Vue()</code> 的方式时，无论将 <code>data</code> 设置为对象还是函数都是可以的，因为 <code>new Vue()</code> 的方式是生成一个根组件，该组件不会复用，也就不存在共享 <code>data</code> 的情况了。</p>
<h2 id="单页面如何实现？"><a href="#单页面如何实现？" class="headerlink" title="单页面如何实现？"></a>单页面如何实现？</h2><p>见 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019936510">彻底理清前端单页面应用（SPA）的实现原理 【精读源码】</a></p>
<h3 id="SPA-优缺点"><a href="#SPA-优缺点" class="headerlink" title="SPA 优缺点"></a>SPA 优缺点</h3><p>优点：组件化</p>
<p>缺点：</p>
<ul>
<li>不利于 SEO（搜索引擎）</li>
<li>首屏渲染时间长</li>
</ul>
<p>服务端渲染SSR</p>
<p>预渲染Prerendering</p>
<h2 id="什么是-MVVM？比之-MVC-有什么区别？（高频）"><a href="#什么是-MVVM？比之-MVC-有什么区别？（高频）" class="headerlink" title="什么是 MVVM？比之 MVC 有什么区别？（高频）"></a>什么是 MVVM？比之 MVC 有什么区别？（高频）</h2><p>View 和 Model：</p>
<ul>
<li>View 用户看到的视图</li>
<li>Model 本地数据和数据库中的数据</li>
</ul>
<p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新。</p>
<p><img src="https://i.loli.net/2021/09/11/lahWzk4gVPcbs7U.png" alt="image.png"></p>
<p>但是 MVC 有一个巨大的缺陷就是<strong>控制器承担的责任太大</strong>了，随着项目愈加复杂，控制器中的代码会越来越<strong>臃肿</strong>，导致出现不利于<strong>维护</strong>的情况。</p>
<p>在 MVVM 架构中，引入了 <strong>ViewModel</strong> 的概念。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。</p>
<p><img src="https://i.loli.net/2021/09/11/aFJGPc8H3E6pRrg.png" alt="image.png"></p>
<p>以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。</p>
<p>除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。这个<strong>隐式</strong>的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。</p>
<p><img src="https://i.loli.net/2021/09/11/UDACQIv2rqnBNhW.png" alt="image.png"></p>
<p>对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，<strong>而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓</strong>。</p>
<h3 id="什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？"><a href="#什么是-MVVM？比之-MVC-有什么区别？什么又是-MVP-？" class="headerlink" title="*什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？"></a>*什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化的开发效率。</p>
<p>比如说实验室在以前项目开发的时候，使用单页应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，当时一旦项目变得复杂，那么整个文件就会变得冗长，混乱，这样对的项目开发和后期的项目维护是非常不利的。</p>
<p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p>
<p>MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新；ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来实现的这一功能。</p>
<h3 id="实现一个简单的-MVVM-框架"><a href="#实现一个简单的-MVVM-框架" class="headerlink" title="实现一个简单的 MVVM 框架"></a>实现一个简单的 MVVM 框架</h3><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2436436c1863">https://www.jianshu.com/p/2436436c1863</a> 好难。。</p>
<h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>Vue 会通过编译器将模板通过几个阶段最终编译为 <code>render</code> 函数，然后通过执行 <code>render</code> 函数生成 Virtual DOM 最终映射为真实 DOM。编译的过程分为三个阶段：</p>
<ol>
<li>将模板解析为 AST</li>
<li>优化 AST</li>
<li>将 AST 转换为 <code>render</code> 函数</li>
</ol>
<p>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象。然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="attr">type</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    tag,</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="attr">attrsList</span>: attrs,</span><br><span class="line">    <span class="comment">// 属性映射</span></span><br><span class="line">    <span class="attr">attrsMap</span>: makeAttrsMap(attrs),</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    <span class="attr">children</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个阶段：对节点进行静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。</p>
<p>最后一个阶段：通过 AST 生成 <code>render</code> 函数</p>
<h3 id="Vue-中-AST-抽象语法树的运用"><a href="#Vue-中-AST-抽象语法树的运用" class="headerlink" title="Vue 中 AST 抽象语法树的运用"></a>Vue 中 AST 抽象语法树的运用</h3><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6885146952877031432#heading-9">https://juejin.cn/post/6885146952877031432#heading-9</a></p>
<h2 id="Vue-热重载？"><a href="#Vue-热重载？" class="headerlink" title="Vue 热重载？"></a>Vue 热重载？</h2><p>“热重载”不是修改文件的时候简单重新加载页面。启用热重载后，当修改 <code>.vue</code> 文件时，所有该组件的实例会被替换，<strong>并且不需要刷新页面</strong>，它甚至保持应用程序和被替换组件的当前状态。</p>
<h2 id="jQuery与vue区别"><a href="#jQuery与vue区别" class="headerlink" title="jQuery与vue区别"></a>jQuery与vue区别</h2><ol>
<li>vue和jQuery对比jQuery是使用选择器()选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的</li>
<li>比如需要获取label标签的内容：)选取DOM对象，对其进行赋值、取值、事件绑定等操作，其实和原生的HTML的区别只在于可以更方便的选取和操作DOM对象，而数据和界面是在一起的。</li>
<li>比如需要获取label标签的内容：(“lable”).val();,它还是依赖DOM元素的值。Vue则是通过Vue对象将数据和View完全分离开来了</li>
<li>对数据进行操作不再需要引用相应的DOM对象，可以说数据和View是分离的，他们通过Vue对象这个vm实现相互的绑定，这就是MVVM。</li>
</ol>
<h2 id="为什么会出现vue，react这些框架，对比原生有什么优势？（todo）"><a href="#为什么会出现vue，react这些框架，对比原生有什么优势？（todo）" class="headerlink" title="为什么会出现vue，react这些框架，对比原生有什么优势？（todo）"></a>为什么会出现vue，react这些框架，对比原生有什么优势？（todo）</h2><h2 id="vue-注册组件的方式"><a href="#vue-注册组件的方式" class="headerlink" title="vue 注册组件的方式"></a>vue 注册组件的方式</h2><p>注册的方式有两种，全局注册和局部注册。</p>
<p><strong>1、全局注册：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-test&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="number">1212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div id=&quot;app&quot;&gt;&lt;my-test&gt;&lt;my-test/&gt;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>组件的全局注册需要在全局实例化Vue前调用</strong>，注册之后可以用在任何新创建的 Vue 实例中调用。</p>
<p><strong>2、局部注册：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myTest = &#123;</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="number">1212</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: &#123;</span><br><span class="line">        myTest</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当只需要在某个局部用到某个组件时，可以使用局部注册的方式进行组件注册，此时局部注册的组件只能在注册该组件内部使用。</p>
<h2 id="vue-输出"><a href="#vue-输出" class="headerlink" title="vue 输出"></a>vue 输出</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">message</span>: <span class="string">&#x27;123&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    vm.message = <span class="string">&#x27;new message&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 123,页面显示 new message</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p><strong>解决的问题：</strong></p>
<ul>
<li>监听 URL 的变化，并在变化前后执行相应的逻辑</li>
<li>不同的 URL 对应不同的不同的组件</li>
<li>提供多种方式改变 URL 的 API  ( URL 的改变不能导致浏览器刷新)</li>
</ul>
<p><strong>使用方式：</strong></p>
<ul>
<li>提供一个路由配置表，不同 URL 对应不同组件的配置</li>
<li>初始化路由实例 new VueRouter()</li>
<li>挂载到 Vue 实例上</li>
<li>提供一个路由占位，用来挂载 URL 匹配到的组件 </li>
</ul>
<h2 id="Vue-路由跳转的方式"><a href="#Vue-路由跳转的方式" class="headerlink" title="Vue 路由跳转的方式"></a>Vue 路由跳转的方式</h2><ol>
<li>router-link：跳转前提是在 router.js 中配置了要跳转到的目的地， to ）</li>
<li>this.$router.push()：函数里面调用，跳转到指定 url 路径，并在 history 栈中添加一个记录，点击后退会返回到上一个页面<ul>
<li>不传参数：<code>this.$router.push(&#39;/home&#39;);</code></li>
<li>query 传参数：<code>this.$router.push(&#123;name:&#39;home&#39;,query: &#123;id:&#39;1&#39;&#125;&#125;);</code> 取参数：<code>$route.query.id</code></li>
<li>params 传参数：<code>this.$router.push(&#123;name:&#39;home&#39;,params: &#123;id:&#39;1&#39;&#125;&#125;); </code> 取参数：<code>$route.params.id</code></li>
<li>两者区别：<ul>
<li>query类似 get, 跳转之后页面 url 后面会拼接参数，非重要性的可以这样传；刷新页面id还在</li>
<li>params类似 post, 跳转之后页面 url 后面不会拼接参数 , 但是刷新页面 id 会消失。（密码等）</li>
</ul>
</li>
</ul>
</li>
<li>this.$router.replace()：用法同push，跳转到指定url路径，但是history栈中不会有记录，点击返回会跳转到上个页面，即直接替换了当前页面</li>
<li>this.$router.go(n) ：向前或者向后跳转n个页面，n可为正整数或负整数。当n为0时强制刷新页面</li>
</ol>
<h2 id="vue-router-传参？"><a href="#vue-router-传参？" class="headerlink" title="vue-router 传参？"></a>vue-router 传参？</h2><h2 id="前端路由原理？两种实现方式有什么区别？"><a href="#前端路由原理？两种实现方式有什么区别？" class="headerlink" title="前端路由原理？两种实现方式有什么区别？"></a>前端路由原理？两种实现方式有什么区别？</h2><p>前端路由本质就是<strong>监听 URL 的变化</strong>，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式。<img src="https://i.loli.net/2021/09/18/3n8axwlMUWmpNKI.png" alt="image.png"></p>
<h3 id="Hash-模式"><a href="#Hash-模式" class="headerlink" title="Hash 模式"></a>Hash 模式</h3><p><code>www.test.com/#/</code> 就是 Hash URL，当 <code>#</code> 后面的哈希值发生变化时，可以通过 <code>hashchange</code> 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 <code>www.test.com</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... 具体逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p>History 模式是 HTML5 新推出的功能，主要使用 <code>history.pushState</code> 和 <code>history.replaceState</code> 改变 URL。通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。</p>
<p>当用户做出浏览器动作时，比如点击后退按钮时会触发 <code>popState</code> 事件</p>
<h3 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h3><ul>
<li>Hash 模式只可以更改 <code>#</code> 后面的内容，History 模式可以通过 API 设置任意的同源 URL</li>
<li>History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li>
<li>Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 <code>index.html</code> 页面用于匹配不到静态资源的时候</li>
<li>Hash 模式相对来说更简单，并且兼容性也更好。</li>
</ul>
<h3 id="前端路由优缺点？"><a href="#前端路由优缺点？" class="headerlink" title="前端路由优缺点？"></a>前端路由优缺点？</h3><p>优点：用户体验好，不需要每次都从服务器全部获取，快速展现给用户</p>
<p>缺点：单页面无法记住之前滚动的位置，无法在前进，后退的时候记住滚动的位置</p>
<h2 id="vue-router-的路由管理模式？"><a href="#vue-router-的路由管理模式？" class="headerlink" title="vue-router 的路由管理模式？"></a>vue-router 的路由管理模式？</h2><p>vue-router 有 3 种路由模式：hash、history、abstract</p>
<ol>
<li><p><strong>hash</strong>：使用 URL hash 值来作路由。支持所有浏览器，包括不支持HTML5 History Api的浏览器。</p>
<p>原理：URL 中 hash 值只是客户端的一种状态。当向服务器端发出请求时，hash 部分不会被发送。</p>
<ul>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录，因此能通过浏览器的回退、前进按钮控制 hash 的切换； </li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；</li>
<li>或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 UR L的 hash 值；</li>
<li>还可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转。</li>
</ul>
</li>
<li><p><strong>history</strong> : 依赖 HTML5 History API 和服务器配置。history 路由模式的实现主要基于下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 实现 URL 的变化 ；</li>
<li>使用 popState 事件来监听 url 的变化，从而对页面进行跳转；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popState 事件，这时需要手动触发页面跳转。</li>
</ul>
</li>
<li><p><strong>abstract</strong> : 支持所有JavaScript运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p>
</li>
</ol>
<h2 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" class="headerlink" title="vue-router 中的导航钩子函数"></a>vue-router 中的导航钩子函数</h2><p>（1）全局的钩子函数 beforeEach 和 afterEach</p>
<p>beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错误的监听函数。</p>
<p>（2）单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。</p>
<p>（3）组件内的导航钩子主要有这三种：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的。</p>
<h2 id="Vue-中-route-和-router-的区别？"><a href="#Vue-中-route-和-router-的区别？" class="headerlink" title="Vue 中 $route 和 $router 的区别？"></a>Vue 中 $route 和 $router 的区别？</h2><p>具体见<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022666268">vue中 $router 和 $route 的区别</a>。</p>
<ul>
<li>$route：当前激活的路由的信息对象。每个对象都是局部的，可以获取当前路由的 path, name, params, query 等属性。</li>
<li>$router：全局的 router 实例。通过 vue 根实例中注入 router 实例，然后再注入到每个子组件，从而让整个应用都有路由功能。其中包含了很多属性和对象（比如 history 对象），任何页面也都可以调用其 push(), replace(), go() 等方法。</li>
</ul>
<h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="什么是-Vuex？"><a href="#什么是-Vuex？" class="headerlink" title="什么是 Vuex？"></a>什么是 Vuex？</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理插件。它采用集中式存储管理应用的所有组件的状态，而更改状态的唯一方法是提交 mutation，例<code>this.$store.commit(&#39;SET_VIDEO_PAUSE&#39;, video_pause)</code>，<code>SET_VIDEO_PAUSE</code> 为mutations属性中定义的方法 。</p>
<h2 id="Vuex-使用"><a href="#Vuex-使用" class="headerlink" title="Vuex 使用"></a>Vuex 使用</h2><p>如果不打算开发大型单页应用，应用够简单，最好不要使用 Vuex。一个简单的store 模式就足够了。但是如果需要构建一个中大型单页应用，就要考虑如何更好地在组件外部管理状态，Vuex 是不错的选择。</p>
<p>具体见<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019077663">vuex 使用总结（详解）</a>。</p>
<h2 id="Vuex-核心概念-amp-底层原理"><a href="#Vuex-核心概念-amp-底层原理" class="headerlink" title="Vuex 核心概念&amp;底层原理"></a>Vuex 核心概念&amp;底层原理</h2><ul>
<li>State —— this.$store.state.xxx 取值。       提供一个响应式数据</li>
<li>Getter —— this.$store.getters.xxx 取值。      借助 Vue 的计算属性 computed 来实现缓存</li>
<li>Mutation —— this.$store.commit( “xxx” )赋值。      更改 state 方法，只能是同步操作</li>
<li>Action —— this.$store.dispatch( “xxx” )赋值。      触发 mutation 方法，可以包含异步操作</li>
<li>Module。      Vue.set 动态添加 state 到响应式数据中</li>
</ul>
<h2 id="vuex-中如何组合使用多个-action"><a href="#vuex-中如何组合使用多个-action" class="headerlink" title="vuex 中如何组合使用多个 action?"></a>vuex 中如何组合使用多个 action?</h2><p>参考自 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43974265/article/details/114138184">在vuex中组合使用多个action</a></p>
<p>业务逻辑场景：存在2个action，actionA和actionB，先执行完actionA才能执行actionB。</p>
<p>（<code>$store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>$store.dispatch</code> 仍旧返回 Promise）</p>
<ol>
<li><p>在组件里派发 action：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 派发其它的 action，编写其它逻辑代码</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>在另一个action中派发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">actionB</span>(<span class="params">&#123;dispatch, commit&#125;</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// then方法返回的是一个新的 Promise 实例，可以 return 出去，继续链式调用</span></span><br><span class="line">  <span class="keyword">return</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    commit(<span class="string">&#x27;someOtherMutation&#x27;</span>);  <span class="comment">// 在 actionA执行完成之后，再执行 actionB的代码</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>async/await</code> 的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">&#x27;getData&#x27;</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">&#x27;actionA&#x27;</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">&#x27;getOtherData&#x27;</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="有使用过vuex的module吗？主要是在什么场景下使用？"><a href="#有使用过vuex的module吗？主要是在什么场景下使用？" class="headerlink" title="有使用过vuex的module吗？主要是在什么场景下使用？"></a>有使用过vuex的module吗？主要是在什么场景下使用？</h2><p>把状态全部集中在状态树上，非常难以维护。按模块分成多个module，状态树延伸多个分支，模块的状态内聚，主枝干放全局共享状态</p>
<h1 id="Vue-3"><a href="#Vue-3" class="headerlink" title="Vue 3"></a>Vue 3</h1><p>具体见 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6951262189168623623#heading-1">https://juejin.cn/post/6951262189168623623#heading-1</a></p>
<h2 id="vue3-与-vue2-区别？"><a href="#vue3-与-vue2-区别？" class="headerlink" title="vue3 与 vue2 区别？"></a>vue3 与 vue2 区别？</h2><p><strong>大的改动：</strong></p>
<ul>
<li>proxy代替Object.definePrototety响应式系统</li>
<li>ts代替flow类型检查</li>
<li>重构了目录结构，将代码主要分成三个独立的模块，更利于长期维护</li>
<li>重写vdom，优化编译性能</li>
<li>支持tree shaking</li>
<li>增加了composition api(setup)，让代码更易于维护</li>
</ul>
<p><strong>小的改动:</strong></p>
<ul>
<li>异步组件需要 defineAsyncComponent 方法来创建</li>
<li>v-model 用法</li>
<li><code>v-if优先级高于v-for</code></li>
<li>destroyed 生命周期选项被重命名为 unmounted</li>
<li>beforeDestroy 生命周期选项被重命名为 beforeUnmount</li>
<li>render函数默认参数createElement移除改为全局引入</li>
<li>组件事件现在需要在 emits 选项中声明</li>
</ul>
<p><strong>新特性：</strong></p>
<ul>
<li>组合式 API</li>
<li>Teleport</li>
<li>framents（组件支持多个根节点）</li>
<li>createRenderer（跨平台的自定义渲染器）</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:lvchangjing_hit@163.com">青山</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/">https://asura1211.github.io/2021/07/10/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20Vue%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Asura1211.github.io" target="_blank">青山の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/13/%E3%80%90%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98%E3%80%91%E2%80%94%20%E2%80%94%20%E5%9F%BA%E4%BA%8Epannellum%E7%9A%84%E5%85%A8%E6%99%AF%E5%AE%9E%E7%8E%B0/"><img class="prev-cover" src="https://i.loli.net/2021/10/13/e1m9lTZkGhDBf2s.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【项目复盘】— — 基于pannellum的全景实现</div></div></a></div><div class="next-post pull-right"><a href="/2021/06/30/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E7%AF%87/"><img class="next-cover" src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【面试准备】— — 浏览器工作原理篇</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://i.loli.net/2021/06/07/Zpg5K4k9MJcLmI8.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">青山</div><div class="author-info__description">Stay hungry, stay foolish.</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%88%E5%93%8D%E5%BA%94%E5%BC%8F%EF%BC%89%E5%8E%9F%E7%90%86%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">Vue 双向数据绑定（响应式）原理？（高频）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD-diff-%E7%AE%97%E6%B3%95%EF%BC%9F-todo%E9%AB%98%E9%A2%91-%E8%8A%82%E7%82%B9%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">Vue 中 diff 算法？(todo高频) 节点的插入删除移动的具体流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">diff 中 key 值的作用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E5%92%8C-React-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">Vue 和 React 之间的区别（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">diff 算法区别？（高频）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">Vue 的生命周期是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E7%94%9F%E5%91%BD%E9%98%B6%E6%AE%B5%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">各个生命阶段？（高频）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Virtual-DOM%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">什么是 Virtual DOM？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Virtual-DOM-%E6%AF%94%E5%8E%9F%E7%94%9F-DOM-%E5%BF%AB%EF%BC%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">为什么 Virtual DOM 比原生 DOM 快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA-DOM-%E6%A0%91%E7%9A%84%E5%B7%AE%E5%BC%82%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">如何比较两个 DOM 树的差异？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-nextTick-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%88todo%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">Vue 中的 nextTick 原理分析（todo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">应用场景？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">Vue 组件间的参数传递方式？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">父子通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.2.</span> <span class="toc-text">兄弟组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%A4%9A%E5%B1%82%E6%AC%A1%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">1.7.3.</span> <span class="toc-text">跨多层次组件通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E7%BB%84%E4%BB%B6"><span class="toc-number">1.7.4.</span> <span class="toc-text">任意组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.7.5.</span> <span class="toc-text">单向数据流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">computed 和 watch 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v-show-%E4%B8%8E-v-if-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">v-show 与 v-if 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-vue"><span class="toc-number">1.10.</span> <span class="toc-text">介绍一下 vue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">vue 常用的修饰符？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.12.</span> <span class="toc-text">vue 中 key 值的作用？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-vue-%E6%95%B0%E7%BB%84%E9%87%8C%E8%A6%81%E8%AE%BE%E7%BD%AE-key%EF%BC%9F"><span class="toc-number">1.12.1.</span> <span class="toc-text">为什么 vue 数组里要设置 key？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive-%E7%BB%84%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">keep-alive 组件有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E4%B8%AD-mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">vue 中 mixin 和 mixins 区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD-slot-%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">Vue 中 slot 作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#data-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%BA%E5%AF%B9%E8%B1%A1-%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">data 什么时候为对象 || 函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">单页面如何实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SPA-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.17.1.</span> <span class="toc-text">SPA 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVVM%EF%BC%9F%E6%AF%94%E4%B9%8B-MVC-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%EF%BC%88%E9%AB%98%E9%A2%91%EF%BC%89"><span class="toc-number">1.18.</span> <span class="toc-text">什么是 MVVM？比之 MVC 有什么区别？（高频）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVVM%EF%BC%9F%E6%AF%94%E4%B9%8B-MVC-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BB%80%E4%B9%88%E5%8F%88%E6%98%AF-MVP-%EF%BC%9F"><span class="toc-number">1.18.1.</span> <span class="toc-text">*什么是 MVVM？比之 MVC 有什么区别？什么又是 MVP ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-MVVM-%E6%A1%86%E6%9E%B6"><span class="toc-number">1.18.2.</span> <span class="toc-text">实现一个简单的 MVVM 框架</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="toc-number">1.19.</span> <span class="toc-text">编译过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%AD-AST-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-number">1.19.1.</span> <span class="toc-text">Vue 中 AST 抽象语法树的运用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%83%AD%E9%87%8D%E8%BD%BD%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">Vue 热重载？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jQuery%E4%B8%8Evue%E5%8C%BA%E5%88%AB"><span class="toc-number">1.21.</span> <span class="toc-text">jQuery与vue区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0vue%EF%BC%8Creact%E8%BF%99%E4%BA%9B%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%AF%B9%E6%AF%94%E5%8E%9F%E7%94%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F%EF%BC%88todo%EF%BC%89"><span class="toc-number">1.22.</span> <span class="toc-text">为什么会出现vue，react这些框架，对比原生有什么优势？（todo）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E6%B3%A8%E5%86%8C%E7%BB%84%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.23.</span> <span class="toc-text">vue 注册组件的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-%E8%BE%93%E5%87%BA"><span class="toc-number">1.24.</span> <span class="toc-text">vue 输出</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#vue-router"><span class="toc-number">2.</span> <span class="toc-text">vue-router</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">Vue 路由跳转的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E4%BC%A0%E5%8F%82%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">vue-router 传参？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%A4%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">前端路由原理？两种实现方式有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">Hash 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History-%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.2.</span> <span class="toc-text">History 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">2.3.3.</span> <span class="toc-text">两种模式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">2.3.4.</span> <span class="toc-text">前端路由优缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E7%9A%84%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">vue-router 的路由管理模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue-router-%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">vue-router 中的导航钩子函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E4%B8%AD-route-%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">Vue 中 $route 和 $router 的区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vuex"><span class="toc-number">3.</span> <span class="toc-text">Vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Vuex%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">什么是 Vuex？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">Vuex 使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vuex-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5-amp-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">Vuex 核心概念&amp;底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex-%E4%B8%AD%E5%A6%82%E4%BD%95%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA-action"><span class="toc-number">3.4.</span> <span class="toc-text">vuex 中如何组合使用多个 action?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87vuex%E7%9A%84module%E5%90%97%EF%BC%9F%E4%B8%BB%E8%A6%81%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">有使用过vuex的module吗？主要是在什么场景下使用？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Vue-3"><span class="toc-number">4.</span> <span class="toc-text">Vue 3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue3-%E4%B8%8E-vue2-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">vue3 与 vue2 区别？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 计算机网络"/></a><div class="content"><a class="title" href="/2021/10/13/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="【面试准备】— — 计算机网络">【面试准备】— — 计算机网络</a><time datetime="2021-10-13T14:28:02.000Z" title="发表于 2021-10-13 22:28:02">2021-10-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 常见问题"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="【面试准备】— — 常见问题">【面试准备】— — 常见问题</a><time datetime="2021-10-11T14:03:14.000Z" title="发表于 2021-10-11 22:03:14">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇"><img src="https://i.loli.net/2021/10/13/TzfF5RQVrDNdm76.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【面试准备】— — 前端综合篇"/></a><div class="content"><a class="title" href="/2021/10/11/%E3%80%90%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87%E3%80%91%E2%80%94%20%E2%80%94%20%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AF%87/" title="【面试准备】— — 前端综合篇">【面试准备】— — 前端综合篇</a><time datetime="2021-10-11T12:53:49.000Z" title="发表于 2021-10-11 20:53:49">2021-10-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【阅读笔记】— — 重学前端（极客时间）"/></a><div class="content"><a class="title" href="/2021/10/06/%E3%80%90%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91%E2%80%94%20%E2%80%94%20%E9%87%8D%E5%AD%A6%E5%89%8D%E7%AB%AF%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/" title="【阅读笔记】— — 重学前端（极客时间）">【阅读笔记】— — 重学前端（极客时间）</a><time datetime="2021-10-06T20:49:27.000Z" title="发表于 2021-10-07 04:49:27">2021-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/09/29/%E3%80%90%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E3%80%91%E2%80%94%20%E2%80%94%20git%20%E6%93%8D%E4%BD%9C/" title="【知识整理】— — git 操作"><img src="https://i.loli.net/2021/10/13/K1ZJbqocNyQfnws.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【知识整理】— — git 操作"/></a><div class="content"><a class="title" href="/2021/09/29/%E3%80%90%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E3%80%91%E2%80%94%20%E2%80%94%20git%20%E6%93%8D%E4%BD%9C/" title="【知识整理】— — git 操作">【知识整理】— — git 操作</a><time datetime="2021-09-29T15:12:34.000Z" title="发表于 2021-09-29 23:12:34">2021-09-29</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 青山</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>